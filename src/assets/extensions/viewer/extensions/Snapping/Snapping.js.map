{"version":3,"file":"Snapping/Snapping.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/SnapMath.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/Snapper.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/SnapperIndicator.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/index.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/Snapping/index.js\");\n","\n// Collection of static math functions used for snapping implementation\n\n// Find closest point to p on a circular arc. \n//  @param {Vector2} center\n//  @param {number} radius\n//  @param {number} startAngle, endAngle - ccw angles in radians. 0 means direction x+\n//  @param {Vector2} [outPoint]\n//  @param {Vector2}\nexport var nearestPointOnCircularArc = function nearestPointOnCircularArc(p, center, radius, startAngle, endAngle, outPoint) {\n\n  outPoint = outPoint || new THREE.Vector2();\n\n  // get normalized direction from circle center to p.\n  // dir = (p-center).normalized()\n  var dir = outPoint.copy(p).sub(center).normalize();\n\n  // If the point is within the arc, we are done\n  var angle = Math.atan2(dir.y, dir.x);\n  var insideArc = Autodesk.Extensions.CompGeom.angleInsideArc(angle, startAngle, endAngle);\n  if (insideArc) {\n    // The ray from center towards p intersects the circle arc.\n    // So, we obtain the closest point by projecting p onto the circle.\n    //\n    // Since dir is the normalized direction from center to p, we obtain the circle projection by:\n    //  onCircleArc = center + dir * radius\n    return dir.multiplyScalar(radius).add(center);\n  }\n\n  // The closest point on the circle is not on the arc.\n  // Then the closest point must be one of the arc ends. Note that this conclusion\n  // can only be made for circles, but not for ellipses with different radii.\n  var pStart = Autodesk.Extensions.CompGeom.getEllipsePoint(startAngle, center.x, center.y, radius, radius);\n  var pEnd = Autodesk.Extensions.CompGeom.getEllipsePoint(endAngle, center.x, center.y, radius, radius);\n\n  var d2Start = pStart.distanceToSquared(p);\n  var d2End = pEnd.distanceToSquared(p);\n  var startIsCloser = d2Start <= d2End;\n\n  outPoint.copy(startIsCloser ? pStart : pEnd);\n  return outPoint;\n};\n\n// Compute intersection of two line segments\n// based on http://www.paulbourke.net/geometry/pointlineplane/\n//  @param {Vector2} p1, p2               - First line segment\n//  @param {Vector2} p3, p4               - Second line segment\n//  @param {bool}    [checkInsideSegment] - If true, we reject line intersections outside the segment ranges\n//  @param {Vector2} [outPoint]           - Optional target vector\n//  @param {number}  [epsilon]            - Nearly-zero threshold used to determine \"nearly-parallel\" resp. \"nearly-zero-length line\"\n//  @param {Vector2|null}\nexport var intersectLines = function intersectLines(p1, p2, p3, p4, checkInsideSegment, outPoint) {var epsilon = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.00001;\n\n  var denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n\n  // Reject if lines are parallel or one of them has zero-length\n  if (Math.abs(denom) < epsilon) {\n    return null;\n  }\n\n  // ua denotes where to find the intersection point p along segment (p1, p2):\n  //   For ua = 0, we have p = p1\n  //   For ua = 1, we have p = p2\n  var ua = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);\n  ua /= denom;\n\n  // Apply segment check\n  if (checkInsideSegment) {\n\n    // ub denotes where to find the intersection point p along segment (p3, p4)\n    var ub = (p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x);\n    ub /= denom;\n\n    // Intersection is within the segments if ua and ub are both in [0,1]\n    if (ua < 0.0 || ua > 1.0 ||\n    ub < 0.0 || ub > 1.0) {\n      return null;\n    }\n  }\n\n  outPoint = outPoint || new THREE.Vector2();\n\n  outPoint.x = p1.x + ua * (p2.x - p1.x);\n  outPoint.y = p1.y + ua * (p2.y - p1.y);\n  return outPoint;\n};","function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport { SnapperIndicator } from \"./SnapperIndicator.js\";\nimport { nearestPointOnCircularArc, intersectLines } from \"./SnapMath.js\";\n\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon;\nvar EPSILON = MeasureCommon.EPSILON;\nvar SnapType = MeasureCommon.SnapType;\nvar SnapResult = MeasureCommon.SnapResult;\n\nvar SNAP_PRECISION = 0.001;\n\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\nvar VertexBufferReader = avp.VertexBufferReader;\n\n/**\n                                                  * @param {number} a - First value to compare\n                                                  * @param {number} b - Second value to compare\n                                                  * @private\n                                                  */\nfunction isEqualWithPrecision(a, b) {\n  return Math.abs(a - b) <= SNAP_PRECISION;\n}\n\n/**\n   * Are the vectors equal within SNAP_PRECISION?\n   * @param {THREE.Vector3} v1 - vector\n   * @param {THREE.Vector3} v2 - vector\n   * @returns {boolean} - true when they are equal\n   * @private\n   */\nfunction isEqualVectorsWithPrecision(v1, v2) {\n  return Math.abs(v1.x - v2.x) <= SNAP_PRECISION &&\n  Math.abs(v1.y - v2.y) <= SNAP_PRECISION &&\n  Math.abs(v1.z - v2.z) <= SNAP_PRECISION;\n}\n\n/**\n   * Are the vectors inverse of each other within SNAP_PRECISION?\n   * @param {THREE.Vector3} v1 - vector\n   * @param {THREE.Vector3} v2 - vector\n   * @returns {boolean} - true when they are inverse of each other\n   * @private\n   */\nfunction isInverseVectorsWithPrecision(v1, v2) {\n  return Math.abs(v1.x + v2.x) <= SNAP_PRECISION &&\n  Math.abs(v1.y + v2.y) <= SNAP_PRECISION &&\n  Math.abs(v1.z + v2.z) <= SNAP_PRECISION;\n}\n\n/**\n   * @param {THREE.Vector3} point - Point \n   * @param {THREE.Vector3} lineStart - Start of the line\n   * @param {THREE.Vector3} lineEnd - End of the line\n   * @returns {number} - distance from point to the line\n   * @private\n   */\nfunction distancePointToLine(point, lineStart, lineEnd) {\n\n  if (lineStart.equals(lineEnd)) {// Degenerate line\n    return point.distanceTo(lineStart);\n  }\n\n  var X0 = new THREE.Vector3();\n  var X1 = new THREE.Vector3();\n  var distance;\n  var param;\n\n  X0.subVectors(lineStart, point);\n  X1.subVectors(lineEnd, lineStart);\n  param = X0.dot(X1);\n  X0.subVectors(lineEnd, lineStart);\n  param = -param / X0.dot(X0);\n\n  if (param < 0) {\n    distance = point.distanceTo(lineStart);\n  } else if (param > 1) {\n    distance = point.distanceTo(lineEnd);\n  } else {\n    X0.subVectors(point, lineStart);\n    X1.subVectors(point, lineEnd);\n    X0.cross(X1);\n    X1.subVectors(lineEnd, lineStart);\n\n    distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));\n  }\n\n  return distance;\n}\n\nvar SnapCandidateType = {\n  Unknown: 0,\n  Line: 1,\n  CircularArc: 2,\n  EllipticalArc: 3 };\n\n\n// A SnapCandidate references a single segment (line or arc) that we could snap to.\nvar SnapCandidate = /*#__PURE__*/function () {\n  function SnapCandidate(viewportId, distance) {_classCallCheck(this, SnapCandidate);\n\n    this.type = SnapCandidateType.Unknown;\n    this.viewportId = viewportId;\n\n    // 2d distance between original (unsnapped) position and the geometry of this candidate.\n    this.distance = 0;\n\n    // {Vector2} Start/Endpoint - only for line segments\n    this.lineStart = null;\n    this.lineEnd = null;\n\n    // Fixed radius - only for CircularArcs\n    this.radius = 0;\n\n    // Separate radii - only for ellipse arcs\n    this.radiusX = 0; // = major radius - by convention\n    this.radiusY = 0;\n\n    // Center point as Vector2 (for arcs)\n    this.center = null;\n\n    // Start/end angle for arcs: Ccw angle in radians. Angle 0 corresponds to direction x+.\n    this.startAngle = 0;\n    this.endAngle = 0;\n  }_createClass(SnapCandidate, [{ key: \"fromLine\", value: function fromLine(\n\n    p1, p2) {\n      this.type = SnapCandidateType.Line;\n      this.lineStart = p1.clone();\n      this.lineEnd = p2.clone();\n      return this;\n    } }, { key: \"fromCircularArc\", value: function fromCircularArc(\n\n    center, radius, start, end) {\n      this.type = SnapCandidateType.CircularArc;\n      this.center = center.clone();\n      this.radius = radius;\n      this.start = start;\n      this.end = end;\n      return this;\n    } }, { key: \"fromEllipticalArc\", value: function fromEllipticalArc(\n\n    center, radiusX, radiusY, start, end) {\n      this.type = SnapCandidateType.EllipticalArc;\n      this.center = center.clone();\n      this.radiusX = radiusX;\n      this.radiusY = radiusY;\n      this.start = start;\n      this.end = end;\n      return this;\n    } }, { key: \"isLine\", value: function isLine()\n\n    {return this.type === SnapCandidateType.Line;} }, { key: \"isCircularArc\", value: function isCircularArc()\n    {return this.type === SnapCandidateType.CirularArc;} }, { key: \"isEllipticalArc\", value: function isEllipticalArc()\n    {return this.type === SnapCandidateType.EllipticalArc;}\n\n    // Checks if the snapGeometry of this candidate intersects with another one.\n    //  @param {SnapCandidate} other\n    //  @param {Vector2} [optionalTarget]\n    //  @returns {THREE.Vector2|null} Returns intersection point if there is one.\n  }, { key: \"getIntersection\", value: function getIntersection(other, optionalTarget) {\n\n      if (this.isLine() && other.isLine()) {\n        // Note: We do the intersections on the whole line - not just the intersections.\n        // Reason is:\n        //  a) Otherwise, it would not snap if you are slightly outline of one line segment\n        //  b) By definition, we get only very close segment candidates anyway\n        return intersectLines(this.lineStart, this.lineEnd, other.lineStart, other.lineEnd, false, optionalTarget);\n      }\n\n      // TODO: Currently, we only support snapping to line-line intersections\n    } }]);return SnapCandidate;}();\n;\n\n// Checks if we can snap to an intersection of two close segments (each can be a line or arcs).\n//  @param {SnapCandidate[]} candidates     - Snap candidate geometries collected in GeometryCallback. Assumed to be within snapRadius.\n//  @param {TREE.Vector3}    intersectPoint - Unsnapped original position\n//  @param {number}          snapRadius\n//  @returns {Object|null} If an intersection snap is found, the result contains:\n//                    {\n//                        viewportId  // number\n//                        snapPoint   // (THREE.Vector3)\n//                    }\nvar findIntersectionSnap = function findIntersectionSnap(candidates, intersectPoint, snapRadius) {\n\n  // Sort snapping candidates by increasing distance\n  // Strictly speaking, we just need the best two ones. But the number of candidates within the snapping\n  // distance is generally small anyway - and working with a sorted array is more flexible to incrementally\n  // make the snapping smarter later.\n  var byDistance = function byDistance(ca, cb) {return ca.distance - cb.distance;};\n  candidates.sort(byDistance);\n\n  // Stop here if we don't have enough candidates for an intersection\n  if (candidates.length < 2) {\n    return null;\n  }\n\n  // Init result object\n  var result = {\n    // Just use the one of the first candidate. There is no unique viewportId when using an intersection.\n    viewportId: candidates[0].viewportId,\n\n    // Snapping happens in 2d - so we set z in advance and just keep the original value.\n    // Note: Snapper generally needs some revision if we use it for planes that are not perpendicular to the viewing direction.\n    snapPoint: new THREE.Vector3(0, 0, intersectPoint.z) };\n\n\n  // Check for any candidate that intersects with the closest one we found\n  var first = candidates[0];\n  for (var i = 1; i < candidates.length; i++) {\n    var second = candidates[i];\n\n    // Do intersection test. If found, write it to result.snapPoint\n    var found = first.getIntersection(second, result.snapPoint);\n    if (!found) {\n      continue;\n    }\n\n    // We found an intersection. Although we assume all candidates to be within\n    // snap radius already, the intersection may still be somewhere else.\n    // => Check if intersection is still within the snapRadius.\n    var dist = THREE.Vector2.prototype.distanceTo.call(result.snapPoint, intersectPoint);\n    if (dist < snapRadius) {\n      // We found a valid intersection snap\n      return result;\n    }\n  }\n  return null;\n};\n\n\n/**\n    * A tool that lets users attach pointer events to vertices and edges. It supports 2D and 3D models.\n    *\n    * @param {Viewer3D} viewer - Viewer instance\n    * @param {object} options - Configurations for the extension\n    * @memberof Autodesk.Viewing.Extensions.Snapping\n    * @alias Autodesk.Viewing.Extensions.Snapping.Snapper\n    * @class\n    */\nexport function Snapper(viewer, options) {\n\n  var _snapResult = new SnapResult();\n\n  var _viewer = viewer;\n  this.setGlobalManager(viewer.globalManager);\n\n  var _options = options || {};\n  var _names;\n\n  if (_options.markupMode) {\n    _names = [\"snapper-markup\"];\n  } else if (_options.toolName) {\n    // Allow tools to use their own snapper\n    _names = [_options.toolName];\n  } else {\n    _names = [\"snapper\"];\n  }\n\n  var _priority = 60;\n\n  var _active = false;\n\n  var _distanceToEdge = Number.MAX_VALUE;\n  var _distanceToVertex = null;\n\n  var _isDragging = false;\n  var _isPressing = false;\n  var _isSnapped = false;\n\n  var _forcedVpId = null; // the viewport index of the first selection for 2D\n\n  var _snapToPixel = false;\n\n  this.indicator = new SnapperIndicator(viewer, this);\n\n  this.markupMode = _options.markupMode;\n  this.renderSnappedGeometry = _options.renderSnappedGeometry;\n  this.renderSnappedTopology = _options.renderSnappedTopology;\n\n  //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of\n  //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.\n  this.detectRadiusInPixels = av.isMobileDevice() ? 50 : 10;\n\n  /**\n                                                              * @returns {boolean} true when the tool is active\n                                                              *\n                                                              * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isActive\n                                                              */\n  this.isActive = function () {\n    return _active;\n  };\n\n  this.getNames = function () {\n    return _names;\n  };\n\n  this.getName = function () {\n    return _names[0];\n  };\n\n  this.getPriority = function () {\n    return _priority;\n  };\n\n  /**\n      * Starts intercepting pointer events.\n      * Invoked automatically by the {@link ToolController}.\n      *\n      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#activate\n      */\n  this.activate = function () {\n    _active = true;\n\n    if (!this.indicator) {\n      this.indicator = new SnapperIndicator(viewer, this);\n    }\n  };\n\n\n  /**\n      * Stops intercepting pointer events.\n      * Invoked automatically by the {@link ToolController}.\n      *\n      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#deactivate\n      */\n  this.deactivate = function () {\n    _active = false;\n\n    if (this.indicator) {\n      this.indicator.destroy();\n      this.indicator = null;\n    }\n  };\n\n  this.copyResults = function (destiny) {\n    _snapResult.copyTo(destiny);\n  };\n\n  this.getEdge = function () {\n    return _snapResult.geomEdge;\n  };\n\n  this.getVertex = function () {\n    return _snapResult.geomVertex;\n  };\n\n  this.getGeometry = function () {\n    return _snapResult.getGeometry();\n  };\n\n  this.getGeometryType = function () {\n    return _snapResult.geomType;\n  };\n\n  this.getIntersectPoint = function () {\n    return _snapResult.intersectPoint;\n  };\n\n\n  /**\n      * @returns {SnapResult} The snapping status of the last pointer event performed.\n      *\n      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#getSnapResult\n      */\n  this.getSnapResult = function () {\n    return _snapResult;\n  };\n\n  /**\n      * Checks whether the tool's last update resulted on a snap.\n      *\n      * @returns {boolean} true when the last pointer event got snapped.\n      *\n      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isSnapped\n      */\n  this.isSnapped = function () {\n    return _isSnapped;\n  };\n\n  this.clearSnapped = function () {\n    _snapResult.clear();\n    _isSnapped = false;\n  };\n\n  this.setViewportId = function (vpId) {\n    _forcedVpId = vpId;\n  };\n\n  this.setSnapToPixel = function (enable) {\n    _snapToPixel = enable;\n  };\n\n  this.getSnapToPixel = function () {\n    return _snapToPixel;\n  };\n\n  this.setSnapToArc = function (enable) {\n    _snapResult.snapToArc = enable;\n  };\n\n  this.getSnapToArc = function () {\n    return _snapResult.snapToArc;\n  };\n\n  this.setArc = function (isArc) {\n    _snapResult.isArc = isArc;\n  };\n\n  this.getArc = function () {\n    return _snapResult.isArc;\n  };\n\n  /**\n      * 3D Snapping\n      *\n      * @param result -Result of Hit Test.\n      */\n  this.snapping3D = function (result) {\n\n    _snapResult.snapNode = result.dbId;\n    _snapResult.intersectPoint = result.intersectPoint;\n    _snapResult.modelId = result.model ? result.model.id : null;\n\n    // Avoid crash if the hit test does not belong to a model. This may happen, if a 3D overlay was hit (see Viewer3DImpl.rayIntersect).\n    if (!result.model) {\n      return;\n    }\n\n    var face = result.face;\n    var fragIds;\n\n    if (!result.fragId || result.fragId.length === undefined) {\n      fragIds = [result.fragId];\n    } else {\n      fragIds = result.fragId;\n    }\n\n    // This is for Fusion model with topology data\n    _snapResult.hasTopology = result.model.hasTopology();\n    if (_snapResult.hasTopology) {\n      this.snapping3DwithTopology(face, fragIds, result.model);\n    } else {\n      this.snapping3DtoMesh(face, fragIds, result.model);\n    }\n  };\n\n  /**\n      * Snapping order is: 1st vertices, 2nd edges, 3rd and final faces.\n      *\n      * @param face\n      * @param fragIds\n      * @param model\n      * @private\n      */\n  this.snapping3DwithTopology = function (face, fragIds, model) {\n\n    // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.\n    if (_snapResult.snapNode) {\n      fragIds = [];\n\n      model.getData().instanceTree.enumNodeFragments(_snapResult.snapNode, function (fragId) {\n        fragIds.push(fragId);\n      }, true);\n    }\n\n    _snapResult.geomFace = _snapResult.geomEdge = _snapResult.geomVertex = null;\n    _distanceToEdge = Number.MAX_VALUE;\n\n    for (var fi = 0; fi < fragIds.length; ++fi) {\n\n      var fragId = fragIds[fi];\n      var mesh = _viewer.impl.getRenderProxy(model, fragId);\n      var geometry = mesh.geometry;\n\n      var topoIndex = model.getTopoIndex(fragId);\n      var topology = model.getTopology(topoIndex);\n      var facesTopology = topology.faces;\n      var edgesTopology = topology.edges;\n\n      if (!_snapResult.geomFace) {\n        _snapResult.geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, mesh);\n\n        if (_snapResult.geomFace) {\n          _snapResult.geomFace.fragId = fragId;\n        }\n\n        var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n        _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      // Need to iterate all frags with same dbId, because when meshes are attached with each other, \n      // edge-topology data will only be on one mesh.\n      this.edgeSnappingWithTopology(_snapResult.intersectPoint, geometry, edgesTopology, mesh);\n\n    }\n\n    _snapResult.geomVertex = this.vertexSnappingWithTopology(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n    if (_snapResult.geomFace) {\n\n      // Determine which one should be drawn: face , edge or vertex\n      _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n      if ((_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) && _snapResult.geomVertex) {\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if ((_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) && _snapResult.geomEdge) {\n\n        var center = this.edgeIsCircle(_snapResult.geomEdge);\n        if (center) {\n          _snapResult.circularArcCenter = center;\n          _snapResult.circularArcRadius = center.distanceTo(_snapResult.geomEdge.vertices[0]);\n          _snapResult.geomEdge.center = _snapResult.circularArcCenter;\n          _snapResult.geomEdge.radius = _snapResult.circularArcRadius;\n          _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n        } else\n        if (this.edgeIsCurved(_snapResult.geomEdge)) {\n          _snapResult.geomType = SnapType.SNAP_CURVEDEDGE;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n\n      } else\n      {\n\n        if (this.faceIsCurved(_snapResult.geomFace)) {\n          _snapResult.geomType = SnapType.SNAP_CURVEDFACE;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_FACE;\n        }\n\n      }\n\n      _isSnapped = true;\n    }\n  };\n\n  this.snapping3DtoMesh = function (face, fragIds, model) {\n    for (var fi = 0; fi < fragIds.length; ++fi) {\n\n      var fragId = fragIds[fi];\n      var mesh = _viewer.impl.getRenderProxy(model, fragId);\n      var geometry = mesh.geometry;\n\n      // Handle 3D line geometry\n      var isLine = mesh.isLine || mesh.isWideLine;\n      if (isLine && face) {\n\n        // For line meshes, face is a line {a, b} instead of a Face3 instance (see lineRayCast(..) in VBIntersector.js,\n        // where a, b are vertex indices into the line mesh vertex array.\n        //\n        // Note: Unlike edge intersection for faces, we just use the line segment itself and don't search for topology\n        //       of connected line segments to identify polylines as one item. If we need this, we have to add the corresponding code first.\n        _snapResult.geomEdge = this.extractLineGeometry(face, geometry);\n        _snapResult.geomEdge.applyMatrix(mesh.matrixWorld);\n\n        _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n        _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n        // Determine which one should be drawn: edge or vertex\n        if (_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) {\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        {\n          // Note: Since we got the edge as hit result, we can already assume the intersection to be close to the line.\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n\n        _isSnapped = true;\n        break;\n      }\n\n      // Note that face may also be a line {a, b} (see lineRayCast(..) in VBIntersector.js\n      if (face instanceof THREE.Face3) {\n        _snapResult.geomFace = this.faceSnapping(face, geometry);\n      }\n\n      if (!_snapResult.geomFace)\n      continue;\n\n      _snapResult.geomFace.applyMatrix(mesh.matrixWorld);\n      _snapResult.geomEdge = this.edgeSnapping(_snapResult.geomFace, _snapResult.intersectPoint);\n      _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n      var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n      _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n\n      _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n      // Determine which one should be drawn: face, edge or vertex\n      if (_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) {\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if (_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) {\n        _snapResult.geomType = SnapType.SNAP_EDGE;\n      } else\n      {\n        _snapResult.geomType = SnapType.SNAP_FACE;\n      }\n\n      _isSnapped = true;\n      break;\n    }\n  };\n\n  this.faceSnappingWithTopology = function (face, geometry, facesTopology, mesh) {\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n    var vC = new THREE.Vector3();\n\n    var geom = new THREE.Geometry();\n\n    var attributes = geometry.attributes;\n\n    if (attributes.index !== undefined) {\n\n      var positions = geometry.vb ? geometry.vb : attributes.position.array;\n      var stride = geometry.vb ? geometry.vbstride : 3;\n\n      // Find the index of face topology list which includes the intersect face(triangle)\n      for (var i = 0; i < facesTopology.length; i++) {\n\n        var indexList = facesTopology[i].indexList;\n        var faceId = facesTopology[i].id;\n        for (var j = 0; j < indexList.length; j += 3) {\n\n          if (face.a === indexList[j]) {\n            if (face.b === indexList[j + 1] && face.c === indexList[j + 2] || face.b === indexList[j + 2] && face.c === indexList[j + 1]) {\n              break;\n            }\n          } else\n          if (face.a === indexList[j + 1]) {\n            if (face.b === indexList[j] && face.c === indexList[j + 2] || face.b === indexList[j + 2] && face.c === indexList[j]) {\n              break;\n            }\n          } else\n          if (face.a === indexList[j + 2]) {\n            if (face.b === indexList[j] && face.c === indexList[j + 1] || face.b === indexList[j + 1] && face.c === indexList[j]) {\n              break;\n            }\n          }\n        }\n\n        if (j < indexList.length) {\n          break;\n        }\n      }\n\n      if (i < facesTopology.length) {\n\n        for (var j = 0; j < indexList.length; j += 3) {\n          vA.set(\n          positions[indexList[j] * stride],\n          positions[indexList[j] * stride + 1],\n          positions[indexList[j] * stride + 2]);\n\n          vB.set(\n          positions[indexList[j + 1] * stride],\n          positions[indexList[j + 1] * stride + 1],\n          positions[indexList[j + 1] * stride + 2]);\n\n          vC.set(\n          positions[indexList[j + 2] * stride],\n          positions[indexList[j + 2] * stride + 1],\n          positions[indexList[j + 2] * stride + 2]);\n\n\n          var vIndex = geom.vertices.length;\n\n          geom.vertices.push(vA.clone());\n          geom.vertices.push(vB.clone());\n          geom.vertices.push(vC.clone());\n\n          geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n        }\n      }\n    }\n\n    //console.log(face);\n\n    if (geom.vertices.length > 0) {\n\n      geom.faceId = faceId;\n      geom.applyMatrix(mesh.matrixWorld);\n      return geom;\n    } else\n    {\n\n      return null;\n    }\n\n  };\n\n  /**\n      * Find the closest face next to the cast ray\n      *\n      * @param {THREE.Face3} face - the intersect triangle of Hit Test.\n      * @param geometry - the geometry of mesh\n      *\n      * @private\n      */\n  this.faceSnapping = function (face, geometry) {\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n    var vC = new THREE.Vector3();\n\n    var geom = new THREE.Geometry(); //Geometry which includes all the triangles on the same plane.\n\n\n\n    var attributes = geometry.attributes;\n\n    var indices = attributes.index && (attributes.index.array || geometry.ib);\n    var positions = geometry.vb ? geometry.vb : attributes.position.array;\n    var stride = geometry.vb ? geometry.vbstride : 3;\n    var offsets = geometry.offsets;\n\n    if (!offsets || offsets.length === 0) {\n\n      offsets = [{ start: 0, count: indices ? indices.length : positions.length, index: 0 }];\n\n    }\n\n    for (var oi = 0; oi < offsets.length; ++oi) {\n\n      var start = offsets[oi].start;\n      var count = offsets[oi].count;\n      var index = offsets[oi].index;\n\n      for (var i = start; i < start + count; i += 3) {\n\n        var a = index + (indices ? indices[i] : i);\n        var b = index + (indices ? indices[i + 1] : i + 1);\n        var c = index + (indices ? indices[i + 2] : i + 2);\n\n        vA.set(\n        positions[a * stride],\n        positions[a * stride + 1],\n        positions[a * stride + 2]);\n\n        vB.set(\n        positions[b * stride],\n        positions[b * stride + 1],\n        positions[b * stride + 2]);\n\n        vC.set(\n        positions[c * stride],\n        positions[c * stride + 1],\n        positions[c * stride + 2]);\n\n\n        var faceNormal = THREE.Triangle.normal(vA, vB, vC);\n\n        var va = new THREE.Vector3();\n        va.set(\n        positions[face.a * stride],\n        positions[face.a * stride + 1],\n        positions[face.a * stride + 2]);\n\n\n        if (isEqualVectorsWithPrecision(faceNormal, face.normal) && isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))\n        {\n\n          var vIndex = geom.vertices.length;\n\n          geom.vertices.push(vA.clone());\n          geom.vertices.push(vB.clone());\n          geom.vertices.push(vC.clone());\n\n          geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n\n        }\n      }\n    }\n\n    if (geom.vertices.length > 0) {\n\n      return this.getTrianglesOnSameFace(geom, face, positions, stride);\n    } else\n    {\n\n      return null;\n    }\n  };\n\n  /**\n      * Find triangles on the same face with the triangle intersected with the cast ray\n      *\n      * @param geom -Geometry which includes all the triangles on the same plane.\n      * @param face -Triangle which intersects with the cast ray.\n      * @param positions -Positions of all vertices.\n      * @param stride -Stride for the interleaved buffer.\n      *\n      * @private\n      */\n  this.getTrianglesOnSameFace = function (geom, face, positions, stride) {\n\n    var isIncludeFace = false; // Check if the intersect face is in the mesh\n    var vertexIndices = geom.vertices.slice();\n\n    var va = new THREE.Vector3();\n    va.set(\n    positions[face.a * stride],\n    positions[face.a * stride + 1],\n    positions[face.a * stride + 2]);\n\n    var vb = new THREE.Vector3();\n    vb.set(\n    positions[face.b * stride],\n    positions[face.b * stride + 1],\n    positions[face.b * stride + 2]);\n\n    var vc = new THREE.Vector3();\n    vc.set(\n    positions[face.c * stride],\n    positions[face.c * stride + 1],\n    positions[face.c * stride + 2]);\n\n    var intersectFace = new THREE.Geometry();\n    intersectFace.vertices.push(va);\n    intersectFace.vertices.push(vb);\n    intersectFace.vertices.push(vc);\n    intersectFace.faces.push(new THREE.Face3(0, 1, 2));\n\n    var vCount = [];\n\n    do {\n\n      vCount = [];\n\n      for (var j = 0; j < vertexIndices.length; j += 3) {\n\n        // The triangle which is intersected with the ray\n        if (vertexIndices[j].equals(va) && vertexIndices[j + 1].equals(vb) && vertexIndices[j + 2].equals(vc)) {\n\n          isIncludeFace = true;\n          vCount.push(j);\n          continue;\n        }\n\n        for (var k = 0; k < intersectFace.vertices.length; k += 3) {\n\n          // The triangles which are on the same face with the intersected triangle\n          if (this.trianglesSharedEdge(vertexIndices[j], vertexIndices[j + 1], vertexIndices[j + 2],\n          intersectFace.vertices[k], intersectFace.vertices[k + 1], intersectFace.vertices[k + 2])) {\n\n            var vIndex = intersectFace.vertices.length;\n            intersectFace.vertices.push(vertexIndices[j].clone());\n            intersectFace.vertices.push(vertexIndices[j + 1].clone());\n            intersectFace.vertices.push(vertexIndices[j + 2].clone());\n            intersectFace.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n\n            vCount.push(j);\n            break;\n          }\n        }\n      }\n\n      for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n        vertexIndices.splice(vCount[ci], 3);\n\n      }\n\n    } while (vCount.length > 0);\n\n    if (isIncludeFace) {\n      return intersectFace;\n    } else\n    {\n      return null;\n    }\n\n  };\n\n  /**\n      * Check if the two triangle share edge, the inputs are their vertices\n      *\n      * @param a1\n      * @param a2\n      * @param a3\n      * @param b1\n      * @param b2\n      * @param b3\n      * @private\n      */\n  this.trianglesSharedEdge = function (a1, a2, a3, b1, b2, b3) {\n\n    var c1 = false;\n    var c2 = false;\n    var c3 = false;\n\n    if (a1.equals(b1) || a1.equals(b2) || a1.equals(b3)) {\n      c1 = true;\n    }\n    if (a2.equals(b1) || a2.equals(b2) || a2.equals(b3)) {\n      c2 = true;\n    }\n    if (a3.equals(b1) || a3.equals(b2) || a3.equals(b3)) {\n      c3 = true;\n    }\n\n    if (c1 & c2 || c1 & c3 || c2 & c3) {\n      return true;\n    }\n\n    return false;\n  };\n\n  this.edgeSnappingWithTopology = function (intersectPoint, geometry, edgesTopology, mesh) {\n\n    var edgeGeom = new THREE.Geometry();\n    var minDistTopoIndex;\n    var minDist = Number.MAX_VALUE;\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n\n    var attributes = geometry.attributes;\n\n    if (attributes.index !== undefined && edgesTopology != undefined) {\n\n      var positions = geometry.vb ? geometry.vb : attributes.position.array;\n      var stride = geometry.vb ? geometry.vbstride : 3;\n\n      // Find the index of edge topology list which includes the nearest edge segment to the intersect point\n      for (var i = 0; i < edgesTopology.length; i++) {\n\n        var indexList = edgesTopology[i].indexList;\n        // In edges topology index list the type is LineStrip\n        for (var j = 0; j < indexList.length - 1; j++) {\n          vA.set(\n          positions[indexList[j] * stride],\n          positions[indexList[j] * stride + 1],\n          positions[indexList[j] * stride + 2]);\n\n          vB.set(\n          positions[indexList[j + 1] * stride],\n          positions[indexList[j + 1] * stride + 1],\n          positions[indexList[j + 1] * stride + 2]);\n\n\n          vA.applyMatrix4(mesh.matrixWorld);\n          vB.applyMatrix4(mesh.matrixWorld);\n\n          var dist = distancePointToLine(intersectPoint, vA, vB);\n          if (dist < minDist) {\n            minDist = dist;\n            minDistTopoIndex = i;\n          }\n        }\n      }\n\n      if (minDistTopoIndex) {\n        indexList = edgesTopology[minDistTopoIndex].indexList;\n        for (var k = 0; k < indexList.length - 1; k++) {\n          edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k] * stride], positions[indexList[k] * stride + 1], positions[indexList[k] * stride + 2]));\n          // To make the line's type to LinePieces which is used by drawLine function\n          edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k + 1] * stride], positions[indexList[k + 1] * stride + 1], positions[indexList[k + 1] * stride + 2]));\n        }\n      }\n    }\n\n    if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {\n\n      _distanceToEdge = minDist;\n      edgeGeom.applyMatrix(mesh.matrixWorld);\n      _snapResult.geomEdge = edgeGeom;\n    }\n  };\n\n  /**\n      * Get Edge geometry for the case that the hittest result contained a 3D lines. For this case, we have no Face3, so\n      * that faceSnapping and edgeSnapping don't work.\n      * \n      *  @param {Object}         edge     - {a, b} with vertex indices a,b of lineStart/lineEnd vertex\n      *  @param {GeometryBuffer} geometry\n      *  @returns {EdgeGeometry} Geometry with simple line\n      */\n  this.extractLineGeometry = function (edge, geometry) {\n\n    var va = new THREE.Vector3();\n    var vb = new THREE.Vector3();\n\n    var attributes = geometry.attributes;\n    var positions = geometry.vb ? geometry.vb : attributes.position.array;\n    var stride = geometry.vb ? geometry.vbstride : 3;\n\n    va.set(\n    positions[edge.a * stride],\n    positions[edge.a * stride + 1],\n    positions[edge.a * stride + 2]);\n\n    vb.set(\n    positions[edge.b * stride],\n    positions[edge.b * stride + 1],\n    positions[edge.b * stride + 2]);\n\n\n    var edgeGeom = new THREE.Geometry();\n    edgeGeom.vertices.push(va, vb);\n    return edgeGeom;\n  };\n\n  /**\n      * Find the closest edge next to the intersect point\n      *\n      * @param face -Face which is found by faceSnapping.\n      * @param intersectPoint -IntersectPoint between cast ray and face.\n      *\n      * @private\n      */\n  this.edgeSnapping = function (face, intersectPoint) {\n\n    var lineGeom = new THREE.Geometry();\n    var isEdge_12 = true;\n    var isEdge_13 = true;\n    var isEdge_23 = true;\n\n    for (var i = 0; i < face.vertices.length; i += 3) {\n\n      for (var j = 0; j < face.vertices.length; j += 3) {\n\n        if (i !== j) {\n          // Check edge 12\n          if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1]) ||\n          face.vertices[i].equals(face.vertices[j + 2])) && (\n          face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1]) ||\n          face.vertices[i + 1].equals(face.vertices[j + 2]))) {\n\n            isEdge_12 = false;\n\n          }\n          // Check edge 13\n          if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1]) ||\n          face.vertices[i].equals(face.vertices[j + 2])) && (\n          face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1]) ||\n          face.vertices[i + 2].equals(face.vertices[j + 2]))) {\n\n            isEdge_13 = false;\n\n          }\n          // Check edge 23\n          if ((face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1]) ||\n          face.vertices[i + 1].equals(face.vertices[j + 2])) && (\n          face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1]) ||\n          face.vertices[i + 2].equals(face.vertices[j + 2]))) {\n\n            isEdge_23 = false;\n\n          }\n        }\n      }\n\n      if (isEdge_12) {\n\n        lineGeom.vertices.push(face.vertices[i].clone());\n        lineGeom.vertices.push(face.vertices[i + 1].clone());\n\n      }\n      if (isEdge_13) {\n\n        lineGeom.vertices.push(face.vertices[i].clone());\n        lineGeom.vertices.push(face.vertices[i + 2].clone());\n\n      }\n      if (isEdge_23) {\n\n        lineGeom.vertices.push(face.vertices[i + 1].clone());\n        lineGeom.vertices.push(face.vertices[i + 2].clone());\n\n      }\n\n      isEdge_12 = true;\n      isEdge_13 = true;\n      isEdge_23 = true;\n\n    }\n\n    //return lineGeom;\n\n    var edgeGeom = new THREE.Geometry();\n    var minDistIndex;\n    var minDist = Number.MAX_VALUE;\n\n    for (var k = 0; k < lineGeom.vertices.length; k += 2) {\n\n      var dist = distancePointToLine(intersectPoint, lineGeom.vertices[k], lineGeom.vertices[k + 1]);\n\n      if (dist < minDist) {\n        minDist = dist;\n        minDistIndex = k;\n      }\n\n    }\n\n    edgeGeom.vertices.push(lineGeom.vertices[minDistIndex].clone());\n    edgeGeom.vertices.push(lineGeom.vertices[minDistIndex + 1].clone());\n\n    edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeGeom.vertices);\n\n    _distanceToEdge = minDist;\n\n    return edgeGeom;\n\n  };\n\n  this.getConnectedLineSegmentsOnSameLine = function (lineGeom, edgeVertices) {\n\n    var vertices = lineGeom.vertices.slice();\n    var va = edgeVertices[0];\n    var vb = edgeVertices[1];\n\n    var vCount = [];\n\n    do {\n\n      vCount = [];\n\n      for (var j = 0; j < vertices.length; j += 2) {\n\n        // The line which has min distance to intersection point\n        if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {\n\n          continue;\n        }\n\n        for (var k = 0; k < edgeVertices.length; k += 2) {\n\n          // The line segments which are connected on the same line\n          if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||\n          vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {\n\n            var V0 = new THREE.Vector3();\n            var V1 = new THREE.Vector3();\n\n            V0.subVectors(edgeVertices[k], edgeVertices[k + 1]);\n            V0.normalize();\n            V1.subVectors(vertices[j], vertices[j + 1]);\n            V1.normalize();\n\n            //if (V0.equals(V1) || V0.equals(V1.negate())) {\n            if (isEqualVectorsWithPrecision(V0, V1) || isInverseVectorsWithPrecision(V0, V1))\n            {\n\n              vCount.push(j);\n              break;\n\n            }\n          }\n        }\n      }\n\n      for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n        edgeVertices.push(vertices[vCount[ci]]);\n        edgeVertices.push(vertices[vCount[ci] + 1]);\n        vertices.splice(vCount[ci], 2);\n\n      }\n\n    } while (vCount.length > 0);\n\n    return edgeVertices;\n\n  };\n\n  this.vertexSnappingWithTopology = function (edge, intersectPoint) {\n\n    var minDist = Number.MAX_VALUE;\n    var point = new THREE.Vector3();\n\n    if (edge && edge.vertices.length > 1) {\n      var dist1 = intersectPoint.distanceTo(edge.vertices[0]);\n      var dist2 = intersectPoint.distanceTo(edge.vertices[edge.vertices.length - 1]);\n\n      if (dist1 <= dist2) {\n        minDist = dist1;\n        point = edge.vertices[0].clone();\n      } else\n      {\n        minDist = dist2;\n        point = edge.vertices[edge.vertices.length - 1].clone();\n      }\n    }\n\n    _distanceToVertex = minDist;\n\n    return point;\n  };\n\n  /**\n      * Find the closest vertex next to the intersect point\n      *\n      * @param edge -Edge which is found by edgeSnapping.\n      * @param intersectPoint -IntersectPoint between cast ray and face.\n      *\n      * @private\n      */\n  this.vertexSnapping = function (edge, intersectPoint) {\n\n    var minDist = Number.MAX_VALUE;\n    var point = new THREE.Vector3();\n\n    for (var i = 0; i < edge.vertices.length; ++i) {\n\n      var dist = intersectPoint.distanceTo(edge.vertices[i]);\n\n      if (dist < minDist - SNAP_PRECISION) {\n\n        minDist = dist;\n        point = edge.vertices[i].clone();\n\n      }\n    }\n\n    _distanceToVertex = minDist;\n\n    return point;\n  };\n\n  // This is only a workaround to detect if an edge is circle\n  this.edgeIsCircle = function (edge) {\n\n    var vertices = edge.vertices;\n\n    // Exclude squares and regular polygons\n    if (vertices.length < 8) {\n      return false;\n    }\n\n    if (vertices[0].equals(vertices[vertices.length - 1])) {\n\n      var center = new THREE.Vector3(0, 0, 0);\n      for (var i = 0; i < vertices.length; i += 2) {\n        center.add(vertices[i]);\n      }\n      center.divideScalar(vertices.length / 2.0);\n\n      var radius = center.distanceTo(vertices[0]);\n      for (var i = 0; i < vertices.length; i += 2) {\n        if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {\n          continue;\n        } else\n        {\n          return false;\n        }\n      }\n      return center;\n    } else\n    {\n      return false;\n    }\n  };\n\n  this.edgeIsCurved = function (edge) {\n\n    var vertices = edge.vertices;\n\n    if (vertices.length <= 2) {\n      return false;\n    } else\n    if (vertices[0].equals(vertices[vertices.length - 1])) {\n      return true;\n    } else\n    {\n      var V1 = new THREE.Vector3();\n      V1.subVectors(vertices[0], vertices[1]);\n\n      var V2 = new THREE.Vector3();\n      for (var i = 2; i < vertices.length; i += 2) {\n        V2.subVectors(vertices[i], vertices[i + 1]);\n        if (!isEqualVectorsWithPrecision(V1, V2)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  };\n\n  this.faceIsCurved = function (face) {\n\n    var vertices = face.vertices;\n    var faces = face.faces;\n\n    if (faces.length <= 1) {\n      return false;\n    } else\n    {\n      var fN1 = THREE.Triangle.normal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c]);\n      var vA1 = vertices[faces[0].a];\n\n      for (var i = 1; i < faces.length; i++) {\n        var fN2 = THREE.Triangle.normal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c]);\n        var vA2 = vertices[faces[i].a];\n\n        if (!isEqualVectorsWithPrecision(fN1, fN2) || !isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  };\n\n  this.angleVector2 = function (vector) {\n\n    if (vector.x > 0 && vector.y >= 0) {\n      return Math.atan(vector.y / vector.x);\n    } else\n    if (vector.x >= 0 && vector.y < 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI * 2;\n    } else\n    if (vector.x < 0 && vector.y <= 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI;\n    } else\n    if (vector.x <= 0 && vector.y > 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI;\n    } else\n    {// x = 0, y = 0\n      return null;\n    }\n  };\n\n  // Creates a THREE.Geometry that represents an approximation of a given elliptical arc in {z=0} plane.\n  // Points are obtained by by uniform sampling of a given elliptical arc.\n  //  @param {number} numPoints - The length number of points that the output geometry will contain. segments in which we subdivide the arc. Resulting point count is numSegments+1.\n  // See getEllipseArcPoint() for param details.\n  var createEllipticalArcGeometry = function createEllipticalArcGeometry(cx, cy, rx, ry, startAngle, endAngle, numPoints) {\n    var geometry = new THREE.Geometry();\n    for (var i = 0; i < numPoints; i++) {\n      var p = new THREE.Vector3(0, 0, 0);\n      var t = i / (numPoints - 1);\n      Autodesk.Extensions.CompGeom.getEllipseArcPoint(t, cx, cy, rx, ry, startAngle, endAngle, 0.0, p);\n      geometry.vertices.push(p);\n    }\n    return geometry;\n  };\n\n  /**\n      * @param {Viewer3D} viewer - Viewer instance\n      * @param snapper\n      * @param aDetectRadius\n      * @private\n      */\n  function GeometryCallback(viewer, snapper, aDetectRadius) {\n    this.viewer = viewer;\n    this.snapper = snapper;\n\n    this.lineGeom = new THREE.Geometry();\n    this.circularArc = null;\n    this.circularArcCenter;\n    this.circularArcRadius;\n    this.ellipticalArc = null;\n    this.ellipticalArcCenter;\n\n    this.minDist = Number.MAX_VALUE;\n\n    this.matrix = new THREE.Matrix4();\n\n    this.vpIdLine = null;\n    this.vpIdCircular = null;\n    this.vpIdElliptical = null;\n\n    this.detectRadius = aDetectRadius;\n\n    // Collects candidate segments that we can snap to.\n    // This is used to allow snapping to segment intersections.\n    this.snapCandidates = []; // {SnappingCandidate[]}\n  }\n\n  GeometryCallback.prototype.onLineSegment = function (x1, y1, x2, y2, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var vertices = this.lineGeom.vertices;\n    var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);\n    var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);\n\n    // LMV-5515: Apply the supplied matrix to the line vector's\n    if (this.matrix) {\n      v1.applyMatrix4(this.matrix);\n      v2.applyMatrix4(this.matrix);\n    }\n\n    // Skip segments outside detectRadius\n    var dist = distancePointToLine(intersectPoint, v1, v2);\n    if (dist > this.detectRadius) {\n      return;\n    }\n\n    // Collect snap candidate\n    this.snapCandidates.push(new SnapCandidate(vpId, dist).fromLine(v1, v2));\n\n    // Track minDist and lineGeometry for best hit so far\n    if (dist < this.minDist) {\n\n      vertices.splice(0, 2, v1, v2);\n      this.minDist = dist;\n\n      this.vpIdLine = vpId;\n    }\n  };\n\n  GeometryCallback.prototype.onCircularArc = function (cx, cy, start, end, radius, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n    var center = new THREE.Vector2(cx, cy);\n    point.sub(center);\n\n    // Compute closest point on arc\n    var pointOnArc = nearestPointOnCircularArc(intersectPoint, center, radius, start, end);\n    var dist = pointOnArc.distanceTo(intersectPoint); // 2D distance\n\n    // Collect snap candidate\n    this.snapCandidates.push(new SnapCandidate(vpId, dist).fromCircularArc(center, radius, start, end));\n\n    // Skip arcs outside detectRadius\n    if (dist > this.detectRadius) {\n      return;\n    }\n\n    // TODO: get rid of the CircleGeometry stuff below, because we computed the snapPoint above already.\n    //       But this needs some refactoring, because the Geometry is passed around outside of snapper.\n\n    var angle = this.snapper.angleVector2(point);\n\n    if (end > start && angle >= start && angle <= end) {\n      var arc = new THREE.CircleGeometry(radius, 100, start, end - start);\n    } else\n    if (end < start && (angle >= start || angle <= end)) {\n      var arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);\n    } else\n    {\n      return;\n    }\n    arc.vertices.splice(0, 1);\n    arc.applyMatrix(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));\n    this.circularArc = arc;\n    this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n    this.circularArcRadius = radius;\n\n    this.snapPoint = new THREE.Vector3(pointOnArc.x, pointOnArc.y, intersectPoint.z);\n\n    this.vpIdCircular = vpId;\n  };\n\n  GeometryCallback.prototype.onEllipticalArc = function (cx, cy, start, end, major, minor, tilt, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n    var major1 = major - this.detectRadius;\n    var minor1 = minor - this.detectRadius;\n    var major2 = major + this.detectRadius;\n    var minor2 = minor + this.detectRadius;\n\n    var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);\n    var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);\n\n    var center = new THREE.Vector2(cx, cy);\n    point.sub(center);\n    point.x *= minor;\n    point.y *= major;\n    var angle = this.snapper.angleVector2(point);\n\n    if (end > Math.PI * 2) {\n      end = Math.PI * 2;\n    }\n\n    if (equation1 >= 1 && equation2 <= 1) {\n\n      if (end > start && angle >= start && angle <= end || end < start && (angle >= start || angle <= end)) {\n        var arc = createEllipticalArcGeometry(cx, cy, major, minor, start, end, 50);\n        if (!isEqualWithPrecision(end - start, Math.PI * 2))\n        {\n          arc.vertices.pop();\n        }\n        arc.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));\n\n        // Compute distance between geometry and snapped point. \n        // We use the same way here as in getSnapResultPosition(). This will be replaced later by a more accurate solution.\n        var nearestPoint = nearestVertexInVertexToEdge(intersectPoint, arc);\n        var dist = THREE.Vector2.prototype.distanceTo.call(nearestPoint, intersectPoint); // only in x/y\n\n        // Collect snap candidate\n        var _center = new THREE.Vector2(cx, cy);\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).makeEllipticalArc(_center, major, minor, start, end));\n\n        // Todo: Unlike for line-segments, arcs are currently collected by \"last one wins\" rule by the code for single-snapping. \n        //       We should consider the distance here as well.\n        this.ellipticalArc = arc;\n        this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n\n        this.vpIdElliptical = vpId;\n      }\n    }\n  };\n\n  /**\n      * This method sets the matrix to identity if matrix is not supplied;\n      *\n      * @param {THREE.Matrix4} matrix - Matrix to set\n      */\n  GeometryCallback.prototype.setMatrix = function (matrix) {\n    this.matrix = matrix || new THREE.Matrix4();\n  };\n\n  /**\n      * Snap to a 2D model.\n      * \n      * @param {object}      hitResult - a result of a ray intersection.\n      * @param {object}      [options] - Options object.\n      * @param {Function}    [options.enumSegments] - Enumerates all segments within a given bbox in model-space.\n      *\n      */\n  this.snapping2D = function (hitResult) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!hitResult) {\n      return;\n    }\n\n    // hitResult is a result of a ray intersection. it may contain the following:\n    var\n    dbId =\n\n\n\n    hitResult.dbId,fragId = hitResult.fragId,intersectPoint = hitResult.intersectPoint,_hitResult$model = hitResult.model,model = _hitResult$model === void 0 ? _viewer.model : _hitResult$model;\n\n    if (model.is3d()) {\n      return;\n    }\n    _snapResult.modelId = hitResult.model ? hitResult.model.id : null;\n    _snapResult.hasTopology = false;\n    _snapResult.intersectPoint = intersectPoint;\n\n    var tr,scale = 1;\n\n    // The model that we are trying to snap is 2D, but the viewer is 3D. It means that we are in hypermodeling scenario!\n    // For that, we'll need to apply the inversed transform of the 2D model to the intersect point first, in order to get it in local model coords.\n    if (!_viewer.impl.is2d) {\n      tr = model.getModelToViewerTransform();\n      // If there's a transform, move point to original location in sheet (will be restored at the end)\n      if (tr) {\n        scale = tr.getMaxScaleOnAxis();\n        _snapResult.intersectPoint = intersectPoint.clone();\n        _snapResult.intersectPoint.applyMatrix4(model.getInverseModelToViewerTransform());\n      }\n    }\n\n    // Determine which one should be drawn: line, circular arc or elliptical arc\n    // Use the un-transformed point, but scale down the radius because we are comparing with the unscaled geometry\n    _snapResult.radius = this.setDetectRadius(intersectPoint) / scale;\n\n    // Geometry snapping is only possible if a fragment list is available to obtain geometry per fragment.\n    var supportsGeomSnapping = model.getFragmentList() != null;\n    if (!supportsGeomSnapping) {\n\n      // If no snapping is available, just accept the hitpoint as a vertex hit. This allows to measure\n      // distances between arbitrary points in rasters.\n      _isSnapped = true;\n      _snapResult.geomType = SnapType.SNAP_VERTEX;\n      _snapResult.geomVertex = intersectPoint; // Use the un-transformed point\n      tr && _snapResult.intersectPoint.applyMatrix4(tr); // Restore to original location\n      return;\n    }\n\n\n    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n    // Performs 2D snapping to segments based on an enumSegments() callback, which enumerates all segments\n    // within in a given bbox in model-space.\n    if (options.enumSegments) {\n      // enum all segments within the snapRadius around intersectPoint\n      var minx = _snapResult.intersectPoint.x - _snapResult.radius;\n      var miny = _snapResult.intersectPoint.y - _snapResult.radius;\n      var maxx = _snapResult.intersectPoint.x + _snapResult.radius;\n      var maxy = _snapResult.intersectPoint.y + _snapResult.radius;\n\n      options.enumSegments(minx, miny, maxx, maxy, gc);\n    } else {\n      // Regular snapping - snap to the 2D model's geometry.\n      var fragIds = fragId;\n\n      if (typeof fragIds === \"undefined\") {\n        return;\n      } else if (!Array.isArray(fragIds)) {\n        fragIds = [fragIds];\n      }\n\n      for (var fi = 0; fi < fragIds.length; ++fi) {\n        var mesh = _viewer.impl.getRenderProxy(model, fragIds[fi]);\n\n        if (mesh && mesh.geometry) {\n          gc.setMatrix(mesh.matrix);\n          var vbr = new VertexBufferReader(mesh.geometry);\n          vbr.enumGeomsForObject(model.reverseMapDbId(dbId), gc);\n          // Set the matrix back to identity after processing a mesh\n          gc.setMatrix();\n        }\n      }\n    }\n\n    // _snapResult.intersectPoint contains the possibly transformed point\n    this.finishSnapping2D(gc, _snapResult.intersectPoint);\n\n    // Snap the unsnapped point only if the snapping fails\n    if (!_isSnapped && _snapToPixel) {\n      _isSnapped = true;\n      _snapResult.geomType = SnapType.RASTER_PIXEL;\n      _snapResult.geomVertex = _snapResult.intersectPoint;\n    }\n\n    // Now apply the transform matrix on the results, so we'll get the results in their final transformed position.\n    if (tr) {var _snapResult$geomEdge, _snapResult$geomEdge2;\n      var results = [_snapResult.snapPoint, _snapResult.geomVertex, _snapResult.intersectPoint, _snapResult.circularArcCenter, (_snapResult$geomEdge =\n      _snapResult.geomEdge) === null || _snapResult$geomEdge === void 0 ? void 0 : _snapResult$geomEdge.vertices[0], (_snapResult$geomEdge2 = _snapResult.geomEdge) === null || _snapResult$geomEdge2 === void 0 ? void 0 : _snapResult$geomEdge2.vertices[1]];\n      // Remove undefined and possibly shared vectors\n      results = _toConsumableArray(new Set(results.filter(function (n) {return n;})));\n      results.forEach(function (res) {return res.applyMatrix4(tr);});\n      if (_snapResult.circularArcRadius) {\n        _snapResult.circularArcRadius *= scale;\n      }\n      _snapResult.radius *= scale;\n    }\n  };\n\n  // By default, snapper only considers model geometry that is written to ID buffer.\n  // This function performs the 2D snapping on a set of given 2D meshes instead. It works similar to snapping2D() but \n  // enumerates the given meshes instead of getting them from the fragment list.\n  //\n  //  @param {THREE.Vector3}                 intersectPoint - click position in world-coords\n  //  @param {function(dbId, layerId, vpId)} filter - Defines subset of primitives to be considered.\n  //  @param {THREE.Mesh[]}                  meshes - The triangulated 2D shapes to be checked for snapping\n  //  @param {number}                        [detectRadius] - Same coordinate system as the given geometry. Required if geometry is not in world-coords.\n\n  this.snapping2DOverlay = function (intersectPoint, meshes, filter, detectRadius) {\n    _snapResult.hasTopology = false;\n    _snapResult.intersectPoint = intersectPoint;\n    _snapResult.radius = detectRadius || this.setDetectRadius(intersectPoint);\n\n    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n      var vbr = new VertexBufferReader(mesh.geometry);\n      vbr.enumGeoms(filter, gc);\n    }\n\n    this.finishSnapping2D(gc, intersectPoint);\n  };\n\n  // Finish 2D snapping operation - assuming that all candidate geometry for snapping has been processed by the geometryCallback gc already.\n  this.finishSnapping2D = function (gc, intersectPoint) {\n\n    // When restricting to a single viewport, exclude candidates of all other viewports\n    if (_forcedVpId !== null) {\n      var isSameViewport = function isSameViewport(c) {return c.viewportId === _forcedVpId;};\n      gc.snapCandidates = gc.snapCandidates.filter(isSameViewport);\n    }\n\n    // Check if we can snap to an intersection of two close segments\n    var intersectSnap = findIntersectionSnap(gc.snapCandidates, intersectPoint, gc.detectRadius);\n    if (intersectSnap) {\n      _snapResult.viewportIndex2d = intersectSnap.viewportId;\n      _snapResult.snapPoint = intersectSnap.snapPoint;\n      _snapResult.geomType = SnapType.SNAP_INTERSECTION;\n      _snapResult.geomVertex = intersectSnap.snapPoint;\n      _isSnapped = true;\n      return;\n    }\n\n    if (gc.circularArc) {\n\n      _snapResult.viewportIndex2d = gc.vpIdCircular;\n\n      _snapResult.snapPoint = gc.snapPoint;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      if (intersectPoint.distanceTo(gc.circularArc.vertices[0]) < _snapResult.radius) {\n\n        _snapResult.geomVertex = gc.circularArc.vertices[0];\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if (intersectPoint.distanceTo(gc.circularArc.vertices[gc.circularArc.vertices.length - 1]) < _snapResult.radius) {\n\n        _snapResult.geomVertex = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      {\n\n        this.lineStripToPieces(gc.circularArc);\n        _snapResult.geomEdge = gc.circularArc;\n        _snapResult.circularArcCenter = gc.circularArcCenter;\n        _snapResult.circularArcRadius = gc.circularArcRadius;\n        _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n      }\n\n      _isSnapped = true;\n\n\n    } else\n    if (gc.ellipticalArc) {\n\n      _snapResult.viewportIndex2d = gc.vpIdElliptical;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[0]) < _snapResult.radius) {\n\n        _snapResult.geomVertex = gc.ellipticalArc.vertices[0];\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1]) < _snapResult.radius) {\n\n        _snapResult.geomVertex = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      {\n\n        this.lineStripToPieces(gc.ellipticalArc);\n        _snapResult.geomEdge = gc.ellipticalArc;\n        // Before we have measure design for elliptical arc, measure the center for now\n        _snapResult.circularArcCenter = gc.ellipticalArcCenter;\n        _snapResult.circularArcRadius = null;\n        _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n      }\n\n      _isSnapped = true;\n\n    } else\n    if (gc.lineGeom.vertices.length) {\n\n      _snapResult.viewportIndex2d = gc.vpIdLine;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      // Always expose edge segment - no matter whether we snap to the edge or one of its vertices.\n      // This allows us to combine it with other snap constraints later - as done by Edit2D.\n      _snapResult.geomEdge = gc.lineGeom;\n\n      if (this.markupMode) {// Markup mode\n        var start = gc.lineGeom.vertices[0];\n        var end = gc.lineGeom.vertices[1];\n        var mid = new THREE.Vector3();\n        mid.addVectors(start, end);\n        mid.divideScalar(2);\n        var md = intersectPoint.distanceTo(mid);\n        var sd = intersectPoint.distanceTo(start);\n        var ed = intersectPoint.distanceTo(end);\n\n        // Store it for snapping to parallel/perpendicular of underlying vectors\n        _snapResult.geomEdge = gc.lineGeom;\n\n        if (md < _snapResult.radius) {\n          _snapResult.geomVertex = mid;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        if (sd < _snapResult.radius) {\n          _snapResult.geomVertex = start;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        if (ed < _snapResult.radius) {\n          _snapResult.geomVertex = end;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n\n        // Circle center\n        if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {\n          _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n        }\n      } else\n      {// Measure mode\n        if (intersectPoint.distanceTo(gc.lineGeom.vertices[0]) < _snapResult.radius) {\n\n          if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {\n            _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n          } else {\n            _snapResult.geomType = SnapType.SNAP_VERTEX;\n          }\n\n          _snapResult.geomVertex = gc.lineGeom.vertices[0];\n        } else\n        if (_options.forceSnapVertices || intersectPoint.distanceTo(gc.lineGeom.vertices[1]) < _snapResult.radius) {\n\n          _snapResult.geomVertex = gc.lineGeom.vertices[1];\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n      }\n\n      _isSnapped = true;\n    }\n  };\n\n  this.snappingRasterPixel = function (result) {\n    if (!result) {\n      return;\n    }\n\n    var intersectPoint = result.intersectPoint;\n    _snapResult.intersectPoint = intersectPoint;\n    _snapResult.hasTopology = false;\n\n    // Determine which one should be drawn: line, circular arc or elliptical arc\n    _snapResult.radius = this.setDetectRadius(intersectPoint);\n    _snapResult.geomType = SnapType.RASTER_PIXEL;\n    _snapResult.geomVertex = intersectPoint;\n    _isSnapped = true;\n  };\n\n  this.snapMidpoint = function () {\n    _snapResult.isMidpoint = false;\n\n    // Snap midpoint for edge\n    if (_isSnapped) {\n      if (_snapResult.geomType === SnapType.SNAP_EDGE) {\n        var edge = _snapResult.geomEdge;\n        var p1 = edge.vertices[0];\n        var p2 = edge.vertices[1];\n\n        var midpoint = new THREE.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);\n\n        if (_snapResult.intersectPoint.distanceTo(midpoint) < 2 * _snapResult.radius) {\n          _snapResult.geomVertex = midpoint;\n          _snapResult.geomType = SnapType.SNAP_MIDPOINT;\n        }\n      }\n    }\n  };\n\n  this.setPerpendicular = function (isPerpendicular) {\n    _snapResult.isPerpendicular = isPerpendicular;\n  };\n\n  this.lineStripToPieces = function (geom) {\n\n    var vertices = geom.vertices;\n    for (var i = vertices.length - 2; i > 0; i--) {\n      vertices.splice(i, 0, vertices[i]);\n    }\n  };\n\n  this.setDetectRadius = function (point) {\n\n    var navapi = _viewer.navigation;\n    var camera = navapi.getCamera();\n    var position = navapi.getPosition();\n\n    var p = point.clone();\n\n    var distance = camera.isPerspective ? p.sub(position).length() :\n    navapi.getEyeVector().length();\n\n    var fov = navapi.getVerticalFov();\n    var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n    var viewport = navapi.getScreenViewport();\n    var _window = this.getWindow();\n    var devicePixelRatio = _window.devicePixelRatio || 1;\n    var radius = this.detectRadiusInPixels * worldHeight / (viewport.height * devicePixelRatio);\n\n    return radius;\n  };\n\n  this.handleButtonDown = function (event, button) {\n    _isDragging = true;\n    return false;\n  };\n\n  this.handleButtonUp = function (event, button) {\n    _isDragging = false;\n    return false;\n  };\n\n  this.handleMouseMove = function (event) {\n\n    if (_isDragging)\n    return false;\n\n    this.onMouseMove({\n      x: event.canvasX,\n      y: event.canvasY });\n\n\n    return false;\n  };\n\n  this.handleSingleTap = function (event) {\n\n    return this.handleMouseMove(event);\n  };\n\n  this.handlePressHold = function (event) {\n\n    if (av.isMobileDevice()) {\n      switch (event.type) {\n\n        case \"press\":\n          _isPressing = true;\n          this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n          break;\n\n        case \"pressup\":\n          this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n          _isPressing = false;\n          break;}\n\n    }\n    return false;\n\n  };\n\n  this.handleGesture = function (event)\n  {\n    if (av.isMobileDevice()) {\n      if (_isPressing) {\n        switch (event.type) {\n\n          case \"dragstart\":\n            this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n            break;\n\n          case \"dragmove\":\n            this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n            break;\n\n          case \"dragend\":\n            this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n            _isPressing = false;\n            break;\n\n          case \"pinchstart\":\n\n            break;\n\n          case \"pinchmove\":\n            break;\n\n          case \"pinchend\":\n            break;}\n\n      }\n    }\n\n    return false;\n  };\n\n  /**\n      * Handler to mouse move events, used to snap in markup edit mode.\n      *\n      * @param mousePosition\n      * @private\n      */\n  this.onMouseDown = function (mousePosition) {\n    return this.onMouseMove(mousePosition);\n  };\n\n  /**\n      * Handler to mouse move events, used to snap in markup edit mode.\n      *\n      * @param mousePosition\n      * @private\n      */\n  this.onMouseMove = function (mousePosition) {var _result$model, _viewer$model;\n\n    this.clearSnapped();\n\n    var result = _viewer.impl.snappingHitTest(mousePosition.x, mousePosition.y, false);\n\n    if (!result && _snapToPixel) {\n      var vpVec = _viewer.impl.clientToViewport(mousePosition.x, mousePosition.y);\n      var point = _viewer.impl.intersectGroundViewport(vpVec);\n      result = { intersectPoint: point };\n    }\n\n    if (!result || !result.intersectPoint)\n    return false;\n\n    var isLeaflet = ((_result$model = result.model) === null || _result$model === void 0 ? void 0 : _result$model.isLeaflet()) || _viewer.impl.is2d && ((_viewer$model = _viewer.model) === null || _viewer$model === void 0 ? void 0 : _viewer$model.isLeaflet());\n    // 3D Snapping\n    if (result.face) {\n      this.snapping3D(result);\n    }\n    // 2D Snapping\n    else if ((result.dbId || result.dbId === 0) && !isLeaflet) {\n        this.snapping2D(result);\n      }\n      // Pixel Snapping\n      else {\n          var isPixelSnap = _snapToPixel || isLeaflet;\n          if (isPixelSnap) {\n            this.snappingRasterPixel(result);\n          }\n        }\n\n    this.snapMidpoint();\n\n    return true;\n  };\n};\n\nav.GlobalManagerMixin.call(Snapper.prototype);","var MeasureCommon = Autodesk.Viewing.MeasureCommon;\nvar isEqualVectors = MeasureCommon.isEqualVectors;\nvar EPSILON = MeasureCommon.EPSILON;\nvar SnapType = MeasureCommon.SnapType;\n\nvar NO_OVERLAY = 0;\nvar FACE_OVERLAY = 1;\nvar EDGE_OVERLAY = 2;\nvar POINT_OVERLAY = 3;\n\nvar GEOMETRIES_OVERLAY = 'MeasureTool-snapper-geometries';\nvar INDICATOR_OVERLAY = 'MeasureTool-snapper-indicator';\n\nvar _geometryLineWidth = 0.3;\nvar _indicatorLineWidth = 0.2;\nvar _indicatorSize = 1.2;\nvar _point = null;\n\nvar _indicatorColor = 0xff7700;\nvar _geometryColor = 0x00CC00;\n\n// /** @constructor */\nexport function SnapperIndicator(viewer, snapper)\n{\n  this.viewer = viewer;\n  this.snapper = snapper;\n  this.overlayType = NO_OVERLAY;\n  this.previewsIntersectPoint = null;\n\n  this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n  this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n  this.geometryMaterial = new THREE.MeshPhongMaterial({\n    color: _geometryColor,\n    ambient: _geometryColor,\n    opacity: 0.5,\n    transparent: true,\n    depthTest: false,\n    depthWrite: false,\n    side: THREE.DoubleSide });\n\n\n  this.indicatorMaterial = new THREE.MeshBasicMaterial({\n    color: _indicatorColor,\n    ambient: _indicatorColor,\n    opacity: 1,\n    transparent: false,\n    depthTest: false,\n    depthWrite: false,\n    side: THREE.DoubleSide });\n\n}\n\nSnapperIndicator.prototype.constructor = SnapperIndicator;\nvar proto = SnapperIndicator.prototype;\n\n\nproto.render = function () {\n\n  var snapResult = this.snapper.getSnapResult();\n\n  if (!isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n    this.clearOverlay(GEOMETRIES_OVERLAY);\n  }\n\n  this.clearOverlay(INDICATOR_OVERLAY);\n\n  if (snapResult.isEmpty())\n  return;\n\n  if (this.snapper.renderSnappedGeometry ||\n  snapResult.hasTopology && this.snapper.renderSnappedTopology) {\n    this.renderGeometry(snapResult);\n  }\n  this.renderIndicator(snapResult);\n\n  this.previewsIntersectPoint = snapResult.intersectPoint.clone();\n};\n\nproto.removeOverlay = function (overlayName) {\n\n  this.viewer.impl.clearOverlay(overlayName);\n  this.viewer.impl.removeOverlayScene(overlayName);\n\n};\n\nproto.clearOverlay = function (overlayName) {\n\n  this.removeOverlay(overlayName);\n  this.viewer.impl.createOverlayScene(overlayName);\n\n};\n\nproto.clearOverlays = function () {\n\n  this.removeOverlay(GEOMETRIES_OVERLAY);\n  this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n\n  this.removeOverlay(INDICATOR_OVERLAY);\n  this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n  this.previewsIntersectPoint = null;\n\n};\n\nproto.addOverlay = function (overlayName, mesh) {\n\n  this.viewer.impl.addOverlay(overlayName, mesh);\n\n};\n\n/**\n    * Draw the planar face\n    * @param geom -Geometry which needs to be draw.\n    * @param mesh -Mesh which is loaded.\n    */\nproto.drawFace = function (geom, material, overlayName) {\n\n  var snapperPlane = new THREE.Mesh(geom, material, true);\n\n  if (overlayName === GEOMETRIES_OVERLAY) {\n    this.overlayType = FACE_OVERLAY;\n  }\n\n  this.addOverlay(overlayName, snapperPlane);\n\n};\n\nproto.cylinderMesh = function (pointX, pointY, material, width) {\n\n  var direction = new THREE.Vector3().subVectors(pointY, pointX);\n  var orientation = new THREE.Matrix4();\n  orientation.lookAt(pointX, pointY, new THREE.Object3D().up);\n  orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,\n  0, 0, 1, 0,\n  0, -direction.length(), 0, 0,\n  0, 0, 0, 1));\n\n  width = width || 0.5;\n  var cylinder = new THREE.CylinderGeometry(width, width, 1.0, 8, 1, true);\n  var edge = new THREE.Mesh(cylinder, material);\n  cylinder = null;\n\n  edge.applyMatrix(orientation);\n  edge.position.x = (pointY.x + pointX.x) / 2;\n  edge.position.y = (pointY.y + pointX.y) / 2;\n  edge.position.z = (pointY.z + pointX.z) / 2;\n  return edge;\n\n};\n\nproto.renderGeometry = function (snapResult) {\n\n  if (isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n    return;\n  }\n\n  switch (snapResult.geomType) {\n    case SnapType.SNAP_VERTEX:\n      SnapType.RASTER_PIXEL;\n      this.drawPoint(snapResult.geomVertex, this.geometryMaterial, GEOMETRIES_OVERLAY);\n      break;\n\n    case SnapType.SNAP_EDGE:\n    case SnapType.SNAP_CURVEDEDGE:\n    case SnapType.SNAP_CIRCULARARC:\n    case SnapType.SNAP_MIDPOINT:\n      this.drawLine(snapResult.geomEdge, this.geometryMaterial, _geometryLineWidth, GEOMETRIES_OVERLAY);\n      break;\n\n    case SnapType.SNAP_FACE:\n    case SnapType.SNAP_CURVEDFACE:\n      this.drawFace(snapResult.geomFace, this.geometryMaterial, GEOMETRIES_OVERLAY);\n      break;}\n\n};\n\n/**\n    * Renders a square around the given snap result.\n    * Is used when youre snapping on a vertex, intersection, circular\n    * arc on a F2D sheet, and the curved face.\n    * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n    */\nproto.renderVertexIndicator = function (snapResult) {\n\n  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n  var scale = this.setScale(pos);\n  var length = _indicatorSize * scale;\n\n  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n  var geom = new THREE.Geometry();\n  var p = new THREE.Vector3();\n\n  // Upper line\n  p.addVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Bottom line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Left line\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Right line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.addVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n};\n\n/**\n    * Renders a triangle around the given snap result\n    * on a midpoint\n    * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n    */\nproto.renderMidpointIndicator = function (snapResult) {\n\n  var pos = snapResult.geomVertex;\n  var scale = this.setScale(pos);\n  var length = _indicatorSize * scale;\n\n  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n  var geom = new THREE.Geometry();\n  var p = new THREE.Vector3();\n\n  // Bottom line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Left line\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.addVectors(pos, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Right line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.addVectors(pos, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n};\n\n/**\n    * Renders an upside-down Y around the given snap result\n    * on an edge or a curved edge..\n    * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n    */\nproto.renderEdgeIndicator = function (snapResult) {\n\n  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n  var scale = this.setScale(pos);\n  var length = _indicatorSize * scale;\n\n  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n  var geom = new THREE.Geometry();\n  var p = new THREE.Vector3();\n\n  // Bottom line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Left line\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Right line\n  p.addVectors(pos, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n};\n\n/**\n    * Renders an circle on a center of a circle\n    * and circular arc for other than F2D sheets.\n    * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n    */\nproto.renderCircleIndicator = function (snapResult) {\n\n  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n  this.drawCircle(pos, this.indicatorMaterial, INDICATOR_OVERLAY);\n\n};\n\n/**\n    * Renders an right-angle ( |_ ) indicator around the given snap result\n    * when the result is perpendicular.\n    * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n    */\nproto.renderPerpendicular = function (snapResult) {\n\n  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n  var scale = this.setScale(pos);\n  var length = _indicatorSize * scale;\n\n  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n  var geom = new THREE.Geometry();\n  var p = new THREE.Vector3();\n\n  // Upper line\n  geom.vertices[0] = pos.clone();\n  p.subVectors(pos, rightVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Bottom line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Left line\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Right line\n  geom.vertices[0] = pos.clone();\n  p.subVectors(pos, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n};\n\n/**\n    * Renders an X around the given snap result.\n    * Usually shown when using \"Free Measure\" mode is enabled.\n    * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n    */\nproto.renderPixelIndicator = function (snapResult) {\n\n  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n  var scale = this.setScale(pos);\n  var length = _indicatorSize * scale;\n\n  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n  var geom = new THREE.Geometry();\n  var p = new THREE.Vector3();\n\n  // Top-left line\n  p.subVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Top-right line\n  p.addVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Bottom-right line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Bottom-left line\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n\n};\n\nproto.renderIndicator = function (snapResult) {\n\n  if (snapResult.isPerpendicular) {\n    this.renderPerpendicular(snapResult);\n    return;\n  }\n\n  if (snapResult.snapToArc) {\n    if (snapResult.isArc && snapResult.geomType === SnapType.SNAP_CIRCULARARC && this.viewer.model.is2d() && !this.viewer.model.isPdf()) {\n      this.renderVertexIndicator(snapResult);\n    }\n    return;\n  }\n\n\n  switch (snapResult.geomType) {\n    case SnapType.SNAP_VERTEX:\n    case SnapType.SNAP_INTERSECTION:\n      this.renderVertexIndicator(snapResult);\n      break;\n\n    case SnapType.SNAP_MIDPOINT:\n      this.renderMidpointIndicator(snapResult);\n      break;\n\n    case SnapType.SNAP_CIRCLE_CENTER:\n      this.renderCircleIndicator(snapResult);\n      break;\n\n    case SnapType.SNAP_EDGE:\n    case SnapType.SNAP_CURVEDEDGE:\n      this.renderEdgeIndicator(snapResult);\n      break;\n\n    case SnapType.SNAP_CIRCULARARC:\n      if (this.viewer.model.is2d()) {\n        this.renderVertexIndicator(snapResult);\n      } else {\n        this.renderCircleIndicator(snapResult);\n      }\n      break;\n\n    case SnapType.SNAP_FACE:\n    case SnapType.SNAP_CURVEDFACE:\n      this.renderVertexIndicator(snapResult);\n      break;\n\n    case SnapType.RASTER_PIXEL:\n      this.renderPixelIndicator(snapResult);\n      break;}\n\n};\n\nproto.drawLine = function (geom, material, width, overlayName) {\n\n  // Line Pieces\n  if (overlayName === GEOMETRIES_OVERLAY) {\n    this.overlayType = EDGE_OVERLAY;\n  }\n\n  for (var i = 0; i < geom.vertices.length; i += 2) {\n    var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, width);\n    this.setEdgeScale(cylinder);\n    this.addOverlay(overlayName, cylinder);\n  }\n};\n\nproto.drawPoint = function (point, material, overlayName) {\n\n  // Because every point is snappable in PDFs, don't display the green dot for PDFs.\n  if (this.viewer.model.isLeaflet()) {\n    return;\n  }\n\n  if (!_point)\n  _point = new THREE.SphereGeometry(1.0);\n\n  var pointMesh = new THREE.Mesh(_point, material);\n  pointMesh.position.set(point.x, point.y, point.z);\n\n  this.setPointScale(pointMesh);\n\n  if (overlayName === GEOMETRIES_OVERLAY) {\n    this.overlayType = POINT_OVERLAY;\n  }\n\n  this.addOverlay(overlayName, pointMesh);\n\n};\n\nproto.drawCircle = function (point, material, overlayName) {\n\n  var torus = new THREE.TorusGeometry(_indicatorSize, _indicatorLineWidth, 2, 20);\n  var torusMesh = new THREE.Mesh(torus, material);\n  torusMesh.lookAt(this.viewer.navigation.getEyeVector().normalize());\n  torus = null;\n\n  torusMesh.position.set(point.x, point.y, point.z);\n\n  this.setCircleScale(torusMesh);\n\n  this.addOverlay(overlayName, torusMesh);\n\n};\n\nproto.setScale = function (point) {\n\n  var pixelSize = 5;\n\n  var navapi = this.viewer.navigation;\n  var camera = navapi.getCamera();\n  var position = navapi.getPosition();\n\n  var p = point.clone();\n\n  var distance = camera.isPerspective ? p.sub(position).length() :\n  navapi.getEyeVector().length();\n\n  var fov = navapi.getVerticalFov();\n  var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n  var viewport = navapi.getScreenViewport();\n  var scale = pixelSize * worldHeight / viewport.height;\n\n  return scale;\n\n};\n\nproto.setPointScale = function (pointMesh) {\n\n  var scale = this.setScale(pointMesh.position);\n  pointMesh.scale.x = scale;\n  pointMesh.scale.y = scale;\n  pointMesh.scale.z = scale;\n\n};\n\nproto.setCircleScale = function (torusMesh) {\n\n  var scale = this.setScale(torusMesh.position);\n  torusMesh.scale.x = scale;\n  torusMesh.scale.y = scale;\n};\n\nproto.setEdgeScale = function (cylinderMesh) {\n\n  var scale = this.setScale(cylinderMesh.position);\n  cylinderMesh.scale.x = scale;\n  cylinderMesh.scale.z = scale;\n};\n\nproto.updatePointScale = function (overlayName) {\n\n  if (this.overlayType != POINT_OVERLAY)\n  return;\n\n  var overlay = this.viewer.impl.overlayScenes[overlayName];\n  if (overlay) {\n    var scene = overlay.scene;\n\n    for (var i = 0; i < scene.children.length; i++) {\n      var pointMesh = scene.children[i];\n      if (pointMesh) {\n\n        this.setPointScale(pointMesh);\n      }\n    }\n  }\n};\n\nproto.updateEdgeScale = function (overlayName) {\n\n  if (this.overlayType != EDGE_OVERLAY)\n  return;\n\n  var overlay = this.viewer.impl.overlayScenes[overlayName];\n  if (overlay) {\n    var scene = overlay.scene;\n\n    for (var i = 0; i < scene.children.length; i++) {\n      var cylinderMesh = scene.children[i];\n      if (cylinderMesh) {\n\n        this.setEdgeScale(cylinderMesh);\n      }\n    }\n  }\n};\n\nproto.onCameraChange = function () {\n\n  this.updatePointScale(GEOMETRIES_OVERLAY);\n  this.updateEdgeScale(GEOMETRIES_OVERLAY);\n\n  // if (!this.snapper.markupMode) {\n  this.render();\n  // }\n};\n\nproto.destroy = function () {\n\n  this.removeOverlay(GEOMETRIES_OVERLAY);\n  this.removeOverlay(INDICATOR_OVERLAY);\n\n  if (_point) {\n    _point.dispose();\n    _point = null;\n  }\n};","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nvar av = Autodesk.Viewing;\n\n/**\n                            * @namespace Autodesk.Viewing.Extensions.Snapping\n                            */\nvar namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Snapping');\n\n/**\n                                                                            * @param m\n                                                                            * @param ns\n                                                                            * @private\n                                                                            */\nfunction _export(m, ns) {\n  for (var prop in m) {\n    if (m.hasOwnProperty(prop)) {\n      //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)\n      module.exports[prop] = m[prop];\n\n      //Export into the desired viewer namespace\n      ns[prop] = m[prop];\n    }\n  }\n}\n\n_export(require(\"./SnapMath.js\"), namespace);\n_export(require(\"./Snapper.js\"), namespace);\n_export(require(\"./SnapperIndicator.js\"), namespace);\n\n\n/**\n                                                       * Utility extension that provides access to the {@link Autodesk.Viewing.Extensions.Snapping.Snapper} tool.\n                                                       * \n                                                       * The extension id is: `Autodesk.Snapping`\n                                                       * \n                                                       * @example\n                                                       *   viewer.loadExtension('Autodesk.Snapping')\n                                                       *  \n                                                       * @memberof Autodesk.Viewing.Extensions\n                                                       * @alias Autodesk.Viewing.Extensions.SnappingExtension\n                                                       * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                                                       * @class\n                                                       */var\nSnappingExtension = /*#__PURE__*/function (_av$Extension) {\"use strict\";_inherits(SnappingExtension, _av$Extension);var _super = _createSuper(SnappingExtension);\n\n  /**\n                                                                                                                                                                   * @param {Viewer3D} viewer - Viewer instance\n                                                                                                                                                                   * @param {object} options - Configurations for the extension\n                                                                                                                                                                   * @alias Autodesk.Viewing.Extensions.SnappingExtension\n                                                                                                                                                                   * @class\n                                                                                                                                                                   */\n  function SnappingExtension(viewer, options) {_classCallCheck(this, SnappingExtension);return _super.call(this,\n    viewer, options);\n  }\n\n  /**\n     * Load the extension.\n     *\n     * @returns {Promise} that resolves when dependent extension finishes loading.\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#load\n     */_createClass(SnappingExtension, [{ key: \"load\", value: function load()\n    {\n      // Load the required dependency (and return the pending load as the load completion Promise)\n      return this.viewer.loadExtension('Autodesk.CompGeom');\n    }\n\n    /**\n       * Unloads the extension.\n       * It does not unload dependent extensions.\n       *\n       * @returns {boolean} Always returns true\n       * \n       * @alias Autodesk.Viewing.Extensions.SnappingExtension#unload\n       */ }, { key: \"unload\", value: function unload()\n    {return true;}\n\n\n    /**\n                    * Unused method.\n                    *\n                    * @returns {boolean} Always returns true\n                    * \n                    * @alias Autodesk.Viewing.Extensions.SnappingExtension#activate\n                    */ }, { key: \"activate\", value: function activate()\n    {return true;}\n\n    /**\n                    * Unused method.\n                    *\n                    * @returns {boolean} Always returns false\n                    * \n                    * @alias Autodesk.Viewing.Extensions.SnappingExtension#deactivate\n                    */ }, { key: \"deactivate\", value: function deactivate()\n    {return false;} }]);return SnappingExtension;}(av.Extension);\n\n\n// The ExtensionManager requires an extension to be registered.\nav.theExtensionManager.registerExtension('Autodesk.Snapping', SnappingExtension);"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACp+DA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACznBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}