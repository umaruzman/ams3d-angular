{"version":3,"file":"AEC/AEC.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Avatar/Avatar.scss?1ae1","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Avatar/AvatarEvents.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Avatar/AvatarExtension.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Avatar/AvatarTool.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Avatar/AvatarWidget.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/CanvasBookmark/CanvasBookmark.css?60fd","webpack://Autodesk.Extensions.[name]/./extensions/AEC/CanvasBookmark/CanvasBookmark.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/CanvasBookmark/CanvasBookmarkIcons.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/CanvasBookmark/CreateFrustumShape.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/CanvasBookmark/HCluster.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/DropMe/DropMe.css?a6a8","webpack://Autodesk.Extensions.[name]/./extensions/AEC/DropMe/DropMe.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/DropMe/DropMeTool.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/DropMe/ViewObjectIn3D.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/DropMe/ViewPortOverlay.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Hypermodeling/Hypermodeling.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/LibraryExports.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Locations/LocationsCommon.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Locations/LocationsService.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Locations/index.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/Minimap3D.css?21aa","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/Minimap3D.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/Minimap3DLayout.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/Minimap3DLocales.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/MinimapDropdown.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/MinimapExpandButton.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/MinimapMath.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/MinimapSideBySideButton.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/SheetMap.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/SheetThumbnail.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/adjustButtonStyle.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/resources/Icons.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/SheetSync/NearFarOverlay.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/SheetSync/SheetSyncConstants.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/SheetSync/SheetSyncExtension.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/SheetSync/SheetTransforms.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/SheetSync/SheetVisibilityManager.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/SheetSync/ThumbnailsOverlay.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/SheetSync/TopViewRenderer.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Viewports/Providers/AecModelDataViewportProvider.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Viewports/Providers/AlignmentServiceViewportProvider.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Viewports/Providers/ViewportProviderInterface.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Viewports/ViewportTypes/AecModelDataViewport.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Viewports/ViewportTypes/AlignmentServiceViewport.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Viewports/ViewportTypes/ViewportInterface.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Viewports/ViewportsExtension.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Viewports/ViewportsLocales.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/common/AecModelData.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/hyperlinks/HyperlinkExtension.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/hyperlinks/HyperlinkTracker.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/levels/FloorSelector.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/levels/FloorSelectorFilter.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/levels/Level.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/levels/LevelUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/levels/LevelsExtension.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/ui/ListPanel.css?7477","webpack://Autodesk.Extensions.[name]/./extensions/AEC/ui/ListPanel.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/bezier.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/EditShapes.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/LoopContainment.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Math2D.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/SolidDefConvert.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Svg.js","webpack://Autodesk.Extensions.[name]/./node_modules/@adsk/solid-definition/dist/solid-definition.min.js","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Avatar/Avatar.scss","webpack://Autodesk.Extensions.[name]/./extensions/AEC/CanvasBookmark/CanvasBookmark.css","webpack://Autodesk.Extensions.[name]/./extensions/AEC/DropMe/DropMe.css","webpack://Autodesk.Extensions.[name]/./extensions/AEC/Minimap3D/Minimap3D.css","webpack://Autodesk.Extensions.[name]/./extensions/AEC/ui/ListPanel.css","webpack://Autodesk.Extensions.[name]/./node_modules/css-loader/lib/css-base.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/addStyles.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/urls.js","webpack://Autodesk.Extensions.[name]/./thirdparty/mouse-event-polyfill/MouseEventPolyfill.js","webpack://Autodesk.Extensions.[name]/./thirdparty/resize-observer-polyfill/ResizeObserver.min.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/AEC/LibraryExports.js\");\n","\nvar content = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Avatar.scss\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Avatar.scss\", function() {\n\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Avatar.scss\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","export var AvatarEvents = {\n  DRAG_START_EVENT: 'dragStart',\n  DRAG_MOVE_EVENT: 'dragMove',\n  DRAG_END_EVENT: 'dragEnd',\n  ROTATE_START_EVENT: 'rotateStart',\n  ROTATE_MOVE_EVENT: 'rotateMove',\n  ROTATE_END_EVENT: 'rotateEnd' };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import AvatarWidget from './AvatarWidget';\nimport { worldToMapPixels as _worldToMapPixels, mapPixelsToWorld as _mapPixelsToWorld, mapPixelsToWidget as _mapPixelsToWidget, widgetToMapPixels as _widgetToMapPixels, getCameraRotationAngle as _getCameraRotationAngle } from '../SheetSync/SheetTransforms';\nimport { FADE_DURATION, SheetSyncEvents } from \"../SheetSync/SheetSyncConstants\";\n\nvar av = Autodesk.Viewing;\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar myExtensionName = 'Autodesk.AEC.AvatarExtension';\n\nvar FOCUS_DURATION = 2.0;\n\n/**\n                          // AvatarExtension - A viewer extension that displays an avatar on a 2D sheet, based on a targetViewer's 3D camera.\n                          // @param {Viewer3D} [viewer]                            - viewer instance\n                          // @param {Object} [options]                             - Configuration options for AvatarExtension\n                          */var\nAvatarExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(AvatarExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(AvatarExtension);\n  function AvatarExtension(viewer, options) {var _this;_classCallCheck(this, AvatarExtension);\n    _this = _super.call(this, viewer, options);\n\n    _this.options = _this.options.avatarOptions || _this.options;\n\n    // Auto focus camera on avatar.\n    _this.autoFocus = _this.options.autoFocus === undefined ? true : _this.options.autoFocus;\n\n    // Indicates if the avatar is currently out of focus.\n    _this.outOfFocus = true;\n\n    // Time to focus the camera on avatar.\n    _this.focusDuration = FOCUS_DURATION;\n\n    // Last 3D camera position.\n    _this.last3dCameraPos = new THREE.Vector3();\n\n    _this.update = _this.update.bind(_assertThisInitialized(_this));\n    _this.onMainMapChanged = _this.onMainMapChanged.bind(_assertThisInitialized(_this));\n    _this.on3dCameraChanged = _this.on3dCameraChanged.bind(_assertThisInitialized(_this));\n    _this.onSheetCameraChanged = _this.onSheetCameraChanged.bind(_assertThisInitialized(_this));\n    _this.onDragStart = _this.onDragStart.bind(_assertThisInitialized(_this));\n    _this.onDragEnd = _this.onDragEnd.bind(_assertThisInitialized(_this));return _this;\n  }_createClass(AvatarExtension, [{ key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this2 = this;var transforms, targetPos;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n\n\n                  this.viewer.loadExtension('Autodesk.AEC.SheetSyncExtension', this.viewer.config));case 2:this.sheetSyncExt = _context.sent;\n\n                this.targetViewer = this.sheetSyncExt.targetViewer;\n\n                transforms = {\n                  mapPixelsToWorld: this.mapPixelsToWorld.bind(this),\n                  worldToMapPixels: this.worldToMapPixels.bind(this),\n                  mapPixelsToWidget: this.mapPixelsToWidget.bind(this),\n                  widgetToMapPixels: this.widgetToMapPixels.bind(this),\n                  getMapRotationAngle: this.getCameraRotationAngle.bind(this) };\n\n\n                this.avatarWidget = new AvatarWidget(this.viewer.container, this.targetViewer, this.globalManager, transforms, this.options.trackUsage, this.viewer.canvasWrap);\n\n                this.visible = true;\n\n                if (this.autoFocus) {\n                  // Set initial center & zoom level according to model bounds.\n                  targetPos = this.getFuzzyBoundsCenter();\n\n                  // If fuzzyBounds not ready yet - it means that there are no models ready yet in the target viewer.\n                  // in that case, wait for the first loaded model, and them set the initial zoom.\n                  if (targetPos) {\n                    this.setCameraPosition(targetPos, true);\n                  } else {\n                    this.targetViewer.addEventListener(av.GEOMETRY_LOADED_EVENT, function () {\n                      _this2.focusOnModel();\n                    }, { once: true });\n                  }\n                }\n\n                this.addListeners();\n                this.activateTool();case 10:case \"end\":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"unload\", value: function unload()\n\n\n    {\n      this.sheetSyncExt = null;\n\n      this.removeListeners();\n      this.deactivateTool();\n\n      this.avatarWidget.destroy();\n      this.avatarWidget = null;\n\n      if (this.focusAnim) {\n        this.focusAnim.stop();\n        this.focusAnim = null;\n      }\n\n      return true;\n    } }, { key: \"activateTool\", value: function activateTool()\n\n    {\n      if (this.toolActive) {\n        return;\n      }\n\n      this.toolActive = true;\n\n      this.viewer.toolController.registerTool(this.avatarWidget.tool);\n      this.viewer.toolController.activateTool(this.avatarWidget.tool.getName());\n\n      this.avatarWidget.addEventListener(Autodesk.AEC.AvatarEvents.DRAG_START_EVENT, this.onDragStart);\n      this.avatarWidget.addEventListener(Autodesk.AEC.AvatarEvents.DRAG_END_EVENT, this.onDragEnd);\n\n      this.updateFocus();\n    } }, { key: \"deactivateTool\", value: function deactivateTool()\n\n    {\n      if (!this.toolActive) {\n        return;\n      }\n\n      this.toolActive = false;\n\n      this.viewer.toolController.deactivateTool(this.avatarWidget.tool.getName());\n      this.viewer.toolController.deregisterTool(this.avatarWidget.tool);\n\n      this.avatarWidget.removeEventListener(Autodesk.AEC.AvatarEvents.DRAG_START_EVENT, this.onDragStart);\n      this.avatarWidget.removeEventListener(Autodesk.AEC.AvatarEvents.DRAG_END_EVENT, this.onDragEnd);\n    } }, { key: \"addListeners\", value: function addListeners()\n\n    {\n      this.targetViewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);\n      this.targetViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update); // Whenever a model has changed in this 3D viewer, update the widget accordingly.\n      this.targetViewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update); // Whenever a model has changed in this 3D viewer, update the widget accordingly.\n      this.targetViewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.on3dCameraChanged); // Whenever the 3D camera moved, update the widget accordingly.\n      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.update); // Whenever a model has changed in this 2D viewer, update the widget accordingly.\n      this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update); // Whenever a model has changed in this 2D viewer, update the widget accordingly.\n      this.viewer.addEventListener(av.RENDER_PRESENTED_EVENT, this.update); //  Whenever the 2D camera moved, update the widget accordingly (no viewport change).\n      this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this.update); //  Whenever the screen size has been changed.\n      this.viewer.addEventListener(SheetSyncEvents.MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);\n      this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.onSheetCameraChanged); // Whenever the 2d camera moved.\n    } }, { key: \"removeListeners\", value: function removeListeners()\n\n    {\n      this.targetViewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);\n      this.targetViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);\n      this.targetViewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);\n      this.targetViewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.on3dCameraChanged);\n      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);\n      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);\n      this.viewer.removeEventListener(av.RENDER_PRESENTED_EVENT, this.update);\n      this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.update);\n      this.viewer.removeEventListener(SheetSyncEvents.MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);\n      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.onSheetCameraChanged); // Whenever the 2d camera moved.\n    } }, { key: \"onDragStart\", value: function onDragStart()\n\n    {\n      if (this.focusAnim) {\n        this.focusAnim.stop();\n        this.focusAnim = null;\n      }\n    } }, { key: \"onDragEnd\", value: function onDragEnd()\n\n    {\n      this.outOfFocus = true;\n      this.updateFocus();\n    } }, { key: \"isEnabled\", value: function isEnabled()\n\n    {\n      return this.sheetSyncExt.isEnabled();\n    } }, { key: \"onMainMapChanged\", value: function onMainMapChanged(_ref)\n\n    {var sheetMap = _ref.sheetMap;\n      if (sheetMap) {\n        this.update();\n      }\n    } }, { key: \"update\", value: function update()\n\n    {\n      if (!this.viewer.impl || !this.viewer.model || !this.avatarWidget || !this.sheetSyncExt) {\n        return;\n      }\n\n      var promise;\n\n      if (this.sheetSyncExt.sheetMap && this.isEnabled() && this.visible) {\n        promise = this.avatarWidget.show();\n        this.activateTool();\n      } else {\n        promise = this.avatarWidget.hide();\n        this.deactivateTool();\n      }\n\n      // Update only if a sheetMap is loaded, otherwise, there won't be any transforms available.\n      if (this.sheetSyncExt.sheetMap) {\n        this.avatarWidget.update();\n      }\n\n      return promise;\n    } }, { key: \"show\", value: function show()\n\n    {\n      if (this.visible) {\n        return;\n      }\n\n      this.visible = true;\n\n      // Returns a promise that should be resolved after the fading animation is over.\n      return this.update();\n    } }, { key: \"hide\", value: function hide()\n\n    {\n      if (!this.visible) {\n        return;\n      }\n\n      this.visible = false;\n\n      // Returns a promise that should be resolved after the fading animation is over.\n      return this.update();\n    } }, { key: \"setCameraPosition\", value: function setCameraPosition(\n\n    pos, changeZoom) {\n      var camera = this.viewer.getCamera();\n\n      // Change x & y values, but keep the same camera distance if changeZoom is off.\n      camera.position.set(pos.x, pos.y, changeZoom ? pos.z : camera.position.z);\n      camera.target.set(pos.x, pos.y, camera.target.z);\n\n      camera.dirty = true;\n    }\n\n    // Map angle is determined according to the viewer's camera rotation.\n  }, { key: \"getCameraRotationAngle\", value: function getCameraRotationAngle() {\n      return _getCameraRotationAngle(this.viewer);\n    }\n\n    // Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.\n  }, { key: \"worldToMapPixels\", value: function worldToMapPixels(pos3D) {\n      return _worldToMapPixels(this.sheetSyncExt.sheetMap, pos3D);\n    }\n\n    // Convert minimap pixel coords (+ world-z) to 3D world position. Minimap pixels are absolute, i.e. not affected by scrolling.\n  }, { key: \"mapPixelsToWorld\", value: function mapPixelsToWorld(posX, posY, zWorld) {\n      return _mapPixelsToWorld(this.sheetSyncExt.sheetMap, posX, posY, zWorld);\n    } }, { key: \"mapPixelsToWidget\", value: function mapPixelsToWidget(\n\n    p) {\n      return _mapPixelsToWidget(this.sheetSyncExt.sheetMap, this.viewer, p);\n    }\n\n    // @param {Vector2} p - transformed in-place from widget pixels to map image pixels\n    //                      widget pixel origin is at top-left, i.e., y-axis points down (compatible to mouse events)\n    // @param {boolean} clamp - In case the resulting position is outside of the map, clamp the value to fit the maps' border.\n  }, { key: \"widgetToMapPixels\", value: function widgetToMapPixels(p, clamp) {\n      clamp = clamp && !this.sheetSyncExt.options.cropToViewport;\n      return _widgetToMapPixels(this.sheetSyncExt.sheetMap, this.viewer, p, clamp);\n    } }, { key: \"world3DtoWorld2D\", value: function world3DtoWorld2D(\n\n    point) {\n      var pos = this.worldToMapPixels(point);\n      this.mapPixelsToWidget(pos);\n      var worldPos = this.viewer.clientToWorld(pos.x, pos.y, undefined, true).point;\n\n      return worldPos;\n    }\n\n    // Find avatar position according to current 3D camera location.\n  }, { key: \"getAvatarPositionOn2DSheet\", value: function getAvatarPositionOn2DSheet() {\n      return this.world3DtoWorld2D(this.targetViewer.getCamera().position);\n    } }, { key: \"on3dCameraChanged\", value: function on3dCameraChanged()\n\n    {\n      this.updateFocus();\n      this.update();\n    } }, { key: \"onSheetCameraChanged\", value: function onSheetCameraChanged()\n\n    {\n      var navTool = this.viewer.toolController.getTool('pan');\n      var isPanning = navTool.isInteractionActive();\n\n      if (isPanning) {\n        this.outOfFocus = true;\n\n        // If panning has been made during animation - cancel the animation.\n        if (this.focusAnim) {\n          this.focusAnim.stop();\n          this.focusAnim = null;\n        }\n      }\n    }\n\n    // Zoom 2D camera to avatar position.\n  }, { key: \"focusOnAvatar\", value: function focusOnAvatar() {var _this3 = this;\n      this.animateFocus(false, function () {\n        _this3.outOfFocus = false;\n      });\n    }\n\n    // Zoom 2D camera to model bounds.\n  }, { key: \"focusOnModel\", value: function focusOnModel() {var _this4 = this;\n      this.animateFocus(true, function () {\n        _this4.outOfFocus = true;\n      });\n    } }, { key: \"updateFocus\", value: function updateFocus()\n\n    {\n      if (!this.sheetSyncExt || !this.sheetSyncExt.sheetMap || !this.autoFocus || this.avatarWidget.tool.isDragging) {\n        this.outOfFocus = true;\n        return;\n      }\n\n      var camera3d = this.targetViewer.getCamera();\n\n      // Focus the 2D camera only if the 3D camera really moved.\n      // Really moved <==> changed x or y position (We ignore z by purpose).\n      if (this.last3dCameraPos.x === camera3d.position.x && this.last3dCameraPos.y === camera3d.position.y) {\n        return;\n      }\n\n      if (!this.isAvatarInsideBounds()) {\n        this.focusOnModel();\n      } else if (this.outOfFocus) {\n        // Animate the transition if we are after:\n        // - Panning\n        // - Manually dragging the avatar\n        // - Double clicked to fly to location\n        // - Was outside of the model's visible bounds and now got back in\n        this.focusOnAvatar();\n      } else {\n        // Otherwise, the avatar is already focused, and just need to be updated to the last camera movement.\n        var pos = this.getAvatarPositionOn2DSheet();\n        this.setCameraPosition(pos);\n      }\n\n      this.last3dCameraPos = camera3d.position.clone();\n    } }, { key: \"getFuzzyBoundsCenter\", value: function getFuzzyBoundsCenter()\n\n    {\n      var bounds3D = this.sheetSyncExt.getFuzzyBox();\n\n      if (bounds3D.empty()) {\n        return null;\n      }\n\n      var min = this.world3DtoWorld2D(bounds3D.min);\n      var max = this.world3DtoWorld2D(bounds3D.max);\n      var bounds2D = new THREE.Box3().setFromPoints([min, max]);\n\n      var camera = this.viewer.getCamera();\n      var fit = this.viewer.navigation.computeFit(camera.position, camera.target, camera.fov, bounds2D, camera.aspect);\n\n      return fit.position;\n    } }, { key: \"isAvatarInsideBounds\", value: function isAvatarInsideBounds()\n\n    {\n      var bounds = this.sheetSyncExt.getFuzzyBox();\n\n      if (bounds.empty()) {\n        return false;\n      }\n\n      // Ignore height when checking these bounds. We care only about x & y here.\n      bounds.min.z = -Infinity;\n      bounds.max.z = Infinity;\n\n      var pos = this.targetViewer.getCamera().position;\n      return bounds.containsPoint(pos);\n    } }, { key: \"animateFocus\", value: function animateFocus(\n\n    isOutside, onDone) {var _this5 = this;\n      if (this.focusAnim) {\n        return;\n      }\n\n      var camera = this.viewer.getCamera();\n\n      var startPos = camera.position;\n\n      var onTimer = function onTimer(t) {\n        if (!_this5.toolActive) {\n          return;\n        }\n\n        var targetPos = isOutside ? _this5.getFuzzyBoundsCenter() : _this5.getAvatarPositionOn2DSheet();\n\n        if (targetPos) {\n          t = Autodesk.Viewing.Private.smootherStep(t);\n          var pos = startPos.clone().lerp(targetPos, t);\n          _this5.setCameraPosition(pos, isOutside);\n        }\n      };\n\n      var onFadeEnd = function onFadeEnd() {\n        _this5.focusAnim = null;\n        onDone && onDone();\n      };\n\n      this.focusAnim = Autodesk.Viewing.Private.fadeValue(0, 1, this.focusDuration, onTimer, onFadeEnd);\n    } }, { key: \"getAutoFocus\", value: function getAutoFocus()\n\n    {\n      return this.autoFocus;\n    } }, { key: \"setAutoFocus\", value: function setAutoFocus(\n\n    enable) {\n      this.autoFocus = enable;\n      this.updateFocus();\n    } }]);return AvatarExtension;}(Autodesk.Viewing.Extension);export { AvatarExtension as default };\n\n\nnamespace.AvatarExtension = AvatarExtension;\nav.theExtensionManager.registerExtension(myExtensionName, AvatarExtension);","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import '../../../thirdparty/mouse-event-polyfill/MouseEventPolyfill';\nimport { computeAngle } from '../Minimap3D/MinimapMath';\n\nvar GlobalManagerMixin = Autodesk.Viewing.GlobalManagerMixin;\nvar zAxis = new THREE.Vector3(0, 0, 1);\nvar FLY_TO_TIME = 0.5; // same as teleportDuration in BimWalk\nvar\nAvatarTool = /*#__PURE__*/function () {\n  function AvatarTool(avatarWidget) {_classCallCheck(this, AvatarTool);\n    this.avatarWidget = avatarWidget;\n    this.targetViewer = avatarWidget.targetViewer;\n    this.transforms = avatarWidget.transforms;\n\n    this.setGlobalManager(avatarWidget.globalManager);\n\n    this.dragDirectionStart = this.dragDirectionStart.bind(this);\n    this.dragDirectionMove = this.dragDirectionMove.bind(this);\n    this.dragDirectionEnd = this.dragDirectionEnd.bind(this);\n\n    this.dragPositionStart = this.dragPositionStart.bind(this);\n    this.dragPositionMove = this.dragPositionMove.bind(this);\n    this.dragPositionEnd = this.dragPositionEnd.bind(this);\n\n    this.onMouseWheel = this.onMouseWheel.bind(this);\n\n    // when dragging view direction, we lastAngle stores the angle between +y and the line from playerPos to last mouse position.\n    this.lastAngle = undefined;\n\n    // Is avatar being dragged.\n    this.isDragging = false;\n\n    // Is avatar being rotated.\n    this.isRotating = false;\n\n    // Is tool active.\n    this.active = false;\n\n    // Tool name.\n    this.names = ['avatar-tool'];\n  }_createClass(AvatarTool, [{ key: \"getNames\", value: function getNames()\n\n    {\n      return this.names;\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return this.names[0];\n    } }, { key: \"isActive\", value: function isActive()\n\n    {\n      return this.active;\n    } }, { key: \"activate\", value: function activate()\n\n    {\n      if (this.isActive()) {\n        return;\n      }\n\n      this.active = true;\n\n      this.avatarWidget.widgetUI.hitArea.addEventListener('mousedown', this.dragPositionStart);\n      this.avatarWidget.widgetUI.hitArea.addEventListener('touchstart', this.dragPositionStart);\n      this.avatarWidget.widgetUI.addEventListener('mousedown', this.dragDirectionStart);\n      this.avatarWidget.widgetUI.addEventListener('touchstart', this.dragDirectionStart);\n\n      if (this.avatarWidget.canvasWrap) {\n        this.avatarWidget.widgetUI.hitArea.addEventListener('mousewheel', this.onMouseWheel);\n        this.avatarWidget.widgetUI.hitArea.addEventListener('DOMMouseScroll', this.onMouseWheel); // Firefox\n        this.avatarWidget.widgetUI.addEventListener('mousewheel', this.onMouseWheel);\n        this.avatarWidget.widgetUI.addEventListener('DOMMouseScroll', this.onMouseWheel); // Firefox\n      }\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      if (!this.isActive()) {\n        return;\n      }\n\n      this.active = false;\n\n      this.avatarWidget.widgetUI.hitArea.removeEventListener('mousedown', this.dragPositionStart);\n      this.avatarWidget.widgetUI.hitArea.removeEventListener('touchstart', this.dragPositionStart);\n      this.avatarWidget.widgetUI.removeEventListener('mousedown', this.dragDirectionStart);\n      this.avatarWidget.widgetUI.removeEventListener('touchstart', this.dragDirectionStart);\n\n      if (this.avatarWidget.canvasWrap) {\n        this.avatarWidget.widgetUI.hitArea.removeEventListener('mousewheel', this.onMouseWheel);\n        this.avatarWidget.widgetUI.hitArea.removeEventListener('DOMMouseScroll', this.onMouseWheel); // Firefox\n        this.avatarWidget.widgetUI.removeEventListener('mousewheel', this.onMouseWheel);\n        this.avatarWidget.widgetUI.removeEventListener('DOMMouseScroll', this.onMouseWheel); // Firefox\n      }\n\n      this.dragPositionEnd();\n      this.dragDirectionEnd();\n    } }, { key: \"onMouseWheel\", value: function onMouseWheel(\n\n    e) {\n      var newEvent = new MouseEvent(e.type, e);\n\n      newEvent.wheelDelta = e.wheelDelta;\n      newEvent.deltaY = e.deltaY;\n\n      this.avatarWidget.canvasWrap.dispatchEvent(newEvent);\n\n      if (newEvent.defaultPrevented) {\n        e.preventDefault();\n      }\n    } }, { key: \"screenToMap\",\n\n    // Convert event client coords to absolute (=zoom and scroll-independent) pixel-coords on the map.\n    value: function screenToMap(e, clamp) {\n      if (e.type.indexOf('touch') >= 0) {\n        e.clientX = e.touches[0].pageX;\n        e.clientY = e.touches[0].pageY;\n      }\n\n      // get minimap pixel coords\n      var clientRect = this.avatarWidget.container.getBoundingClientRect();\n\n      // get position within map widget\n      var p = new THREE.Vector2(e.clientX - clientRect.left, e.clientY - clientRect.top);\n\n      // transform point to mapImage pixels\n      this.transforms.widgetToMapPixels(p, clamp);\n\n      return p;\n    } }, { key: \"dragPositionStart\", value: function dragPositionStart(\n\n    e) {\n      this.addWindowEventListener('mousemove', this.dragPositionMove);\n      this.addWindowEventListener('mouseup', this.dragPositionEnd);\n      this.addWindowEventListener('touchmove', this.dragPositionMove);\n      this.addWindowEventListener('touchend', this.dragPositionEnd);\n\n      e.stopPropagation();\n      e.preventDefault();\n\n      // Make sure that map doesn't scroll/follow while we are moving the avatar\n      this.isDragging = true;\n      this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.DRAG_START_EVENT });\n    } }, { key: \"dragPositionMove\", value: function dragPositionMove(\n\n    e) {\n      // get minimap pixel coords. Clamp x/y to map extent => avoid dragging out of the map\n      var _this$screenToMap = this.screenToMap(e, true),x = _this$screenToMap.x,y = _this$screenToMap.y;\n\n      var camera = this.targetViewer.impl.camera;\n\n      // keep z the same as before\n      var zWorld = camera.position.z;\n\n      // save current pos\n      var oldPosition = camera.position.clone();\n\n      var pos3D = this.transforms.mapPixelsToWorld(x, y, zWorld);\n\n      // move camera to new 3D position\n      camera.position.copy(pos3D);\n\n      // apply delta to the target vector\n      var delta = camera.position.clone().sub(oldPosition);\n\n      camera.target.add(delta);\n      camera.target.z = zWorld;\n\n      this.targetViewer.impl.invalidate(true, true, true);\n      this.targetViewer.dispatchEvent({ type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: camera });\n\n      e.stopPropagation();\n\n      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.DRAG_MOVE_EVENT, camera: camera });\n    } }, { key: \"dragPositionEnd\", value: function dragPositionEnd(\n\n    e) {\n      this.removeWindowEventListener('mousemove', this.dragPositionMove);\n      this.removeWindowEventListener('mouseup', this.dragPositionEnd);\n      this.removeWindowEventListener('touchmove', this.dragPositionMove);\n      this.removeWindowEventListener('touchend', this.dragPositionEnd);\n\n      e && e.stopPropagation();\n\n      this.isDragging = false;\n\n      // TODO: use LMV generic analytics infrastructure instead.\n      if (!this.avatarInteractionTracked) {\n        this.avatarInteractionTracked = true;\n\n        if (this.avatarWidget && this.avatarWidget.trackUsage) {\n          this.avatarWidget.trackUsage({\n            avatar_interaction_tracked: true });\n\n        }\n      }\n\n      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.DRAG_END_EVENT });\n    }\n\n    // Get targetViewer's camera position on map coordinates.\n  }, { key: \"getCameraPositionOnMap\", value: function getCameraPositionOnMap() {\n      var pos3D = this.targetViewer.impl.camera.position;\n      var p = this.transforms.worldToMapPixels(pos3D);\n      return p;\n    } }, { key: \"dragDirectionStart\", value: function dragDirectionStart(\n\n    e) {\n      // remember angle between north and (playerPos, mousePos) at dragStart\n      var p1 = this.getCameraPositionOnMap();\n      var p2 = this.screenToMap(e);\n      this.lastAngle = computeAngle(p1, p2);\n\n      this.addWindowEventListener('mousemove', this.dragDirectionMove);\n      this.addWindowEventListener('mouseup', this.dragDirectionEnd);\n      this.addWindowEventListener('touchmove', this.dragDirectionMove);\n      this.addWindowEventListener('touchend', this.dragDirectionEnd);\n\n      e.stopPropagation();\n      e.preventDefault();\n\n      this.isRotating = true;\n      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.ROTATE_START_EVENT, angle: this.lastAngle });\n    } }, { key: \"dragDirectionMove\", value: function dragDirectionMove(\n\n    e) {\n      // compute current angle\n      var p1 = this.getCameraPositionOnMap();\n      var p2 = this.screenToMap(e);\n      var newAngle = computeAngle(p1, p2);\n      var delta = this.lastAngle - newAngle;\n\n      // apply delta to view direction\n      var camera = this.targetViewer.impl.camera;\n      var viewVec = camera.target.clone().sub(camera.position);\n      viewVec.applyAxisAngle(zAxis, delta);\n      viewVec.add(camera.position);\n      camera.target.copy(viewVec);\n\n      // Rotate up-vector as well.\n      camera.up.applyAxisAngle(zAxis, delta);\n\n      this.targetViewer.impl.syncCamera();\n      this.targetViewer.dispatchEvent({ type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: camera });\n\n      this.lastAngle = newAngle;\n\n      e.stopPropagation();\n\n      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.ROTATE_MOVE_EVENT, angle: this.lastAngle });\n    } }, { key: \"dragDirectionEnd\", value: function dragDirectionEnd(\n\n    e) {\n      this.removeWindowEventListener('mousemove', this.dragDirectionMove);\n      this.removeWindowEventListener('mouseup', this.dragDirectionEnd);\n      this.removeWindowEventListener('touchmove', this.dragDirectionMove);\n      this.removeWindowEventListener('touch', this.dragDirectionEnd);\n\n      e && e.stopPropagation();\n\n      this.isRotating = false;\n      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.ROTATE_END_EVENT, angle: this.lastAngle });\n    } }, { key: \"convertEventHammerToMouse\", value: function convertEventHammerToMouse(\n\n    event) {\n      if (event.pointers) {\n        event.clientX = event.pointers[0].clientX;\n        event.clientY = event.pointers[0].clientY;\n      }\n    } }, { key: \"getCurrentLevel\", value: function getCurrentLevel()\n\n    {\n      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');\n      if (!levelExt) {\n        return;\n      }\n\n      return levelExt.getCurrentLevel();\n    } }, { key: \"handleDoubleClick\", value: function handleDoubleClick(\n\n    e) {var _this = this;\n      this.convertEventHammerToMouse(e);\n\n      // get minimap pixel coords\n      var _this$screenToMap2 = this.screenToMap(e),x = _this$screenToMap2.x,y = _this$screenToMap2.y;\n\n      // preserve camera-direction\n      var camera = this.targetViewer.impl.camera;\n      var dir = camera.getWorldDirection();\n\n      // when coming from an overview perspective, we don't want to just see the ground afterwards\n      dir.z = Math.max(dir.z, 0.0);\n\n      var zWorld = camera.position.z;\n\n      // choose z based on current level\n      var level = this.getCurrentLevel();\n\n      if (level) {\n        // Floor plus eye height (Should be 1.80m).\n        var height = level.zMin + 1.8 / this.targetViewer.model.getUnitScale();\n\n        // In case the ceiling is lower than 1.80m, we don't want to jump accidentally to the next level,\n        // So in that case, just set the camera in the middle of the floor.\n        if (height >= level.zMax) {\n          height = (level.zMin + level.zMax) / 2;\n        }\n\n        if (isFinite(height)) {\n          zWorld = height;\n        }\n      }\n\n      // Compute new camera position\n      var pos3D = this.transforms.mapPixelsToWorld(x, y, zWorld);\n      var target = pos3D.clone().add(dir);\n      var dstView = {\n        position: pos3D,\n        target: target,\n        up: camera.up };\n\n\n      this.isDragging = true;\n\n      Autodesk.Viewing.Private.flyToView(this.targetViewer, dstView, FLY_TO_TIME, function () {\n        _this.isDragging = false;\n      });\n\n      e.stopPropagation();\n      e.preventDefault();\n\n      return true;\n    } }, { key: \"handleDoubleTap\", value: function handleDoubleTap(\n\n    e) {\n      return this.handleDoubleClick(e);\n    } }]);return AvatarTool;}();export { AvatarTool as default };\n\n\nGlobalManagerMixin.call(AvatarTool.prototype);","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import AvatarTool from './AvatarTool';\nimport { AvatarEvents } from './AvatarEvents';\nimport { computeAngle } from '../Minimap3D/MinimapMath';\nimport CSS from './Avatar.scss'; // IMPORTANT!!\n\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar GlobalManagerMixin = Autodesk.Viewing.GlobalManagerMixin;\nvar av = Autodesk.Viewing;var\n\nAvatarWidget = /*#__PURE__*/function (_Autodesk$Viewing$Eve) {_inherits(AvatarWidget, _Autodesk$Viewing$Eve);var _super = _createSuper(AvatarWidget);\n  /**\n                                                                                                                                                       * \n                                                                                                                                                       * @param {HTMLElement} container - Div element where the avatar should be located.\n                                                                                                                                                       * @param {Viewer3D} targetViewer - Target viewer with a 3D model.\n                                                                                                                                                       * @param {GlobalManager} globalManager - Global manager.\n                                                                                                                                                       * @param {object} transforms - MUST contain these callbacks:\n                                                                                                                                                       *                                      mapPixelsToWorld\n                                                                                                                                                       *                                      worldToMapPixels\n                                                                                                                                                       *                                      mapPixelsToWidget\n                                                                                                                                                       *                                      widgetToMapPixels\n                                                                                                                                                       *                                      getMapRotationAngle\n                                                                                                                                                       * @param {HTMLElement} canvasWrap - Optional DOM element to catch events that are not consumed by the widget.\n                                                                                                                                                       * \n                                                                                                                                                       */\n  function AvatarWidget(container, targetViewer, globalManager, transforms, trackUsage, canvasWrap) {var _this;_classCallCheck(this, AvatarWidget);\n    _this = _super.call(this);\n    _this.container = container;\n    _this.targetViewer = targetViewer;\n    _this.transforms = transforms;\n    _this.trackUsage = trackUsage;\n    _this.canvasWrap = canvasWrap;\n    _this.setGlobalManager(globalManager);\n\n    _this.widgetUI = _this.createUI();\n\n    _this.tool = new AvatarTool(_assertThisInitialized(_this));\n    _this.tool.activate();return _this;\n  }_createClass(AvatarWidget, [{ key: \"createUI\", value: function createUI()\n\n    {\n      var _document = this.getDocument();\n\n      var widget = _document.createElement('div');\n      widget.className = 'avatar-widget';\n\n      this.container.appendChild(widget);\n\n      // Sub-widget to represent view direction\n      var frustumWidget = _document.createElement('div');\n      frustumWidget.className = 'avatar-frustum';\n      widget.appendChild(frustumWidget);\n      widget.frustumWidget = frustumWidget;\n\n      // By default, setting left/top to posX/posY would move the top-left corner of the frustum\n      // widget to that position. We want to have the tip of the camera there.\n      // Note that the offset may change depending on the border sizes in avatar-frustum css class.\n      widget.anchorX = 20; // =.avatar-frustum.border-left\n      widget.anchorY = 40; // =.avatar-frustum.border-top\n\n      // Filled circle at camera position\n      var filledCircle = _document.createElement('div');\n      filledCircle.className = 'avatar-position-fill';\n      widget.appendChild(filledCircle);\n      widget.posCircle = filledCircle;\n\n      // Hit area of the avatar position.\n      var hitArea = _document.createElement('div');\n      hitArea.className = 'avatar-position-hitarea';\n      widget.posCircle.appendChild(hitArea);\n      widget.hitArea = hitArea;\n\n      if (av.isTouchDevice()) {\n        hitArea.classList.add('touch');\n        frustumWidget.classList.add('touch');\n        widget.posCircle.classList.add('touch');\n        widget.anchorX = 40; // =.avatar-frustum.border-left\n        widget.anchorY = 80; // =.avatar-frustum.border-top\n      }\n\n      return widget;\n    } }, { key: \"destroy\", value: function destroy()\n\n    {\n      this.tool.deactivate();\n      this.tool = null;\n\n      this.container.removeChild(this.widgetUI);\n      this.widgetUI = null;\n    }\n\n    // Show avatar - resolve after animation ends.\n  }, { key: \"show\", value: function show() {\n      return this.changeVisibility(true);\n    }\n\n    // Hide avatar - resolve after animation ends.\n  }, { key: \"hide\", value: function hide() {\n      return this.changeVisibility(false);\n    }\n\n    // Change avatar visibility if needed - resolve after animation ends.\n  }, { key: \"changeVisibility\", value: function changeVisibility(show) {var _this2 = this;\n      return new Promise(function (resolve) {\n        if (show ^ _this2.widgetUI.classList.contains('visible')) {\n          show ? _this2.widgetUI.classList.add(\"visible\") : _this2.widgetUI.classList.remove(\"visible\");\n\n          var onTransitionEnd = function onTransitionEnd() {\n            _this2.widgetUI.removeEventListener('transitionend', onTransitionEnd);\n            resolve();\n          };\n\n          _this2.widgetUI.addEventListener('transitionend', onTransitionEnd);\n        } else {\n          resolve();\n        }\n      });\n    }\n\n    // get camera position in map pixel coords\n  }, { key: \"getPosition2D\", value: function getPosition2D() {\n      var pos3D = this.targetViewer.impl.camera.position;\n      return this.transforms.worldToMapPixels(pos3D);\n    }\n\n    // get camera target in map pixel coords\n  }, { key: \"getTarget2D\", value: function getTarget2D() {\n      var target3D = this.targetViewer.impl.camera.target;\n      return this.transforms.worldToMapPixels(target3D);\n    }\n\n    // Update the avatar position and rotation, according to the targetViewer's camera.\n  }, { key: \"update\", value: function update() {\n      // get position and target in pixels within the map\n      var pos2D = this.getPosition2D();\n      var target2D = this.getTarget2D();\n\n      var playerAngle = computeAngle(pos2D, target2D);\n\n      // rotate frustum shape (+ consider map rotation)\n      var mapRotationAngle = this.transforms.getMapRotationAngle();\n      this.widgetUI.frustumWidget.style.transform = \"rotate(\".concat(playerAngle + mapRotationAngle, \"rad)\");\n\n      this.transforms.mapPixelsToWidget(pos2D);\n\n      this.widgetUI.style.transform = \"translate(\".concat(pos2D.x - this.widgetUI.anchorX, \"px, \").concat(pos2D.y - this.widgetUI.anchorY, \"px)\");\n    } }, { key: \"isDragging\", value: function isDragging()\n\n    {\n      return this.tool.isDragging;\n    } }, { key: \"isRotating\", value: function isRotating()\n\n    {\n      return this.tool.isRotating;\n    } }]);return AvatarWidget;}(Autodesk.Viewing.EventDispatcher);export { AvatarWidget as default };\n\n\nGlobalManagerMixin.call(AvatarWidget.prototype);\nObject.assign(namespace, { AvatarEvents: AvatarEvents });","\nvar content = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./CanvasBookmark.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./CanvasBookmark.css\", function() {\n\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./CanvasBookmark.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nvar av = Autodesk.Viewing,avp = av.Private,avu = Autodesk.Viewing.UI;\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar myExtensionName = 'Autodesk.AEC.CanvasBookmarkExtension';\n\nvar LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';\n\nimport { createCameraIcon, createClusteredCameraIcon } from './CanvasBookmarkIcons.js';\nimport { createFrustumShape } from './CreateFrustumShape.js';\nimport HCluster from './HCluster.js';\n\nvar VISIBILITY_PROP = 'canvasBookmarks';\n\n// Name of the overlay scene that we use graphics overlays (frustum shapes)\nvar OverlayName = 'CanvasBookmark_Extension_Overlay';\nvar CutPlaneSetName = 'CanvasBookmark_CutPlanes';\n\n// Interpolate between two given Matrix4 transforms. Note that this requires the transforms\n// to be invertible combinations of pos/rotate/scale.\nvar lerpTransforms = function () {\n  var startPos = new THREE.Vector3();\n  var endPos = new THREE.Vector3();\n  var startScale = new THREE.Vector3();\n  var endScale = new THREE.Vector3();\n  var startRotate = new THREE.Quaternion();\n  var endRotate = new THREE.Quaternion();\n\n  var pos = new THREE.Vector3();\n  var scale = new THREE.Vector3();\n  var rotate = new THREE.Quaternion();\n\n  return function (startMatrix, endMatrix, t, dstTransform) {\n    startMatrix.decompose(startPos, startRotate, startScale);\n    endMatrix.decompose(endPos, endRotate, endScale);\n\n    pos.lerpVectors(startPos, endPos, t);\n    scale.lerpVectors(startScale, endScale, t);\n    THREE.Quaternion.slerp(startRotate, endRotate, rotate, t);\n\n    dstTransform.compose(pos, rotate, scale);\n\n    return dstTransform;\n  };\n}();\n\n// Interpolates between two bboxes. t is in [0,1]\nvar lerpBoxes = function lerpBoxes(startBox, endBox, t, dstBox) {\n  dstBox.min.lerpVectors(startBox.min, endBox.min, t);\n  dstBox.max.lerpVectors(startBox.max, endBox.max, t);\n  lerpTransforms(startBox.transform, endBox.transform, t, dstBox.transform);\n};\n\n// Clone Box3 with attached transform\nvar cloneBox = function cloneBox(srcBox) {\n  var box = srcBox.clone();\n  box.transform = srcBox.transform ? srcBox.transform.clone() : new THREE.Matrix4();\n  return box;\n};\n\nvar setButtonVisible = function setButtonVisible(button, value) {\n\n  // Make it detectable if this button is going to change on next anim frame.\n  button.visiblityChangePending = true;\n\n  // Delay class change to next anim frame - otherwise css transitions don't work sometimes.\n  requestAnimationFrame(function () {\n    if (value) {\n      button.container.classList.add('visible');\n    } else\n    {\n      button.container.classList.remove('visible');\n    }\n    button.visiblityChangePending = false;\n  });\n};var\n\n\nCanvasBookmarkExtension = /*#__PURE__*/function (_av$Extension) {_inherits(CanvasBookmarkExtension, _av$Extension);var _super = _createSuper(CanvasBookmarkExtension);\n  function CanvasBookmarkExtension(viewer, options) {var _this;_classCallCheck(this, CanvasBookmarkExtension);\n    _this = _super.call(this, viewer, options);\n\n    _this.viewer = viewer;\n\n    _this.bookmarks = [];\n    _this.clusteredBookmarks = [];\n\n    _this.camera = _this.viewer.navigation.getCamera();\n    _this.cameraMovedCB = _this.onCameraMoved.bind(_assertThisInitialized(_this));\n    _this.onModelTransformChanged = _this.onModelTransformChanged.bind(_assertThisInitialized(_this));\n    _this.onVisibilityChangedCB = _this.onVisibilityChanged.bind(_assertThisInitialized(_this));\n\n    // SectionBox animations\n    _this.sectionBox = null; // SectionBox as defined by currently hovered bookmark (not changed during anims)\n    _this.activeSectionBox = null; // Latest applied SectionBox\n    _this.animStartSectionBox = null; // Used only during cutplane animations\n    _this.animEndSectionBox = null; // Usually equal to this.sectionBox, but this.sectionBox may be null while animEndSectionBox is always valid during an animation\n    _this.sectionBoxAnim = null; // AnimControl - only existing during animations\n\n    // bookmarks visibility logic\n    _this.changeBookmarksVisibility = _this.changeBookmarksVisibility.bind(_assertThisInitialized(_this));\n    _this.changeBookmarksVisibilityTimeout = null;\n\n    _this._clusteringEnabled = _this.options.clusterfck !== undefined;\n    _this._clusteringThreshold = _this.options.clusteringThreshold || 110; // threshold is (icon_width * 5), depends on \"THREE.Vector3.distanceTo()\"\n\n    // bookmarks clustering\n    if (_this._clusteringEnabled) {\n      _this.hcluster = new HCluster(\n      _this.options.clusterfck,\n      function (b1, b2) {\n        var _b1 = new THREE.Vector2(b1.currentPosProjected.x, b1.currentPosProjected.y);\n        var _b2 = new THREE.Vector2(b2.currentPosProjected.x, b2.currentPosProjected.y);\n        return _b2.distanceTo(_b1);\n      },\n      _this._clusteringThreshold);\n\n    }\n\n    _this._filterOutInvisibleBookmark = _this._filterOutInvisibleBookmark.bind(_assertThisInitialized(_this));\n\n    _this.levelChangedCB = _this.onLevelChanged.bind(_assertThisInitialized(_this));\n\n    _this.extensionLoadedCB = _this.onExtensionLoaded.bind(_assertThisInitialized(_this));\n\n    // Indicates if any frustumShape is currently fading for hover effects.\n    _this.isFrustumFading = false;\n\n    // For testing: Callbacks that will be notified once as soon as Minimap has reached stable state\n    _this.waitingCallbacks = [];return _this;\n  }_createClass(CanvasBookmarkExtension, [{ key: \"setBookmarksVisible\", value: function setBookmarksVisible(\n\n    visible) {\n      this.bookmarks.forEach(function (b) {return setButtonVisible(b.marker, visible);});\n      this.clusteredBookmarks.forEach(function (b) {return setButtonVisible(b.marker, visible);});\n      if (!visible) {\n        this.stopGhosting();\n      }\n    } }, { key: \"onVisibilityChanged\", value: function onVisibilityChanged(\n\n    visible) {\n      if (this.viewer.prefs) {\n        this.viewer.prefs.set(VISIBILITY_PROP, visible);\n      }\n\n      this.setBookmarksVisible(visible);\n\n      if (visible) {\n        this.updateBookmarkPositions();\n      }\n    } }, { key: \"isVisible\", value: function isVisible()\n\n    {\n      return this.viewer.prefs && this.viewer.prefs.get(VISIBILITY_PROP);\n    } }, { key: \"onCameraMoved\", value: function onCameraMoved()\n\n    {\n      this.setBookmarksVisible(false);\n      this.debounceBookmarksVisibility();\n    } }, { key: \"createTooltip\", value: function createTooltip(\n\n    button, geomNode) {\n      button.setToolTip(geomNode.name());\n      button._toolTipElement.innerHTML = \"<b>\".concat(geomNode.name(), \"</b>\");\n    } }, { key: \"flyToBookmark\", value: function flyToBookmark(\n\n    bookmark) {\n      var dstView = {\n        position: bookmark.pos,\n        target: bookmark.target,\n        up: bookmark.up };\n\n      this.anim = avp.flyToView(this.viewer, dstView, 1.0);\n    } }, { key: \"getRelatedModelTransform\", value: function getRelatedModelTransform(\n\n    geomNode) {\n      var root = geomNode.getRootNode();\n\n      // Find the current visible model that share the same root node with the bookmark's node.\n      var relatedModel = this.viewer.getVisibleModels().find(\n      function (model) {return model.getDocumentNode().getRootNode() === root;});\n\n\n      var modelTransform = relatedModel === null || relatedModel === void 0 ? void 0 : relatedModel.getModelToViewerTransform();\n\n      return modelTransform;\n    }\n\n    // geomNode is a BubbleNode of type GEOMETRY_NODE\n  }, { key: \"createBookmark\", value: function createBookmark(geomNode) {var _this2 = this;\n\n      // extract camera data (TODO: Add generic utility function to BubbleNode to read camera)\n      var camera = geomNode.extractCamera();\n      if (!camera) {\n        return;\n      }\n\n      var pos = camera.position;\n      var target = camera.target;\n\n      var modelTransform = this.getRelatedModelTransform(geomNode);\n\n      // Transform pos & target according to the modelToViewerTransform of the related model.\n      if (modelTransform) {\n        pos.applyMatrix4(modelTransform);\n        target.applyMatrix4(modelTransform);\n      }\n\n      var dir = new THREE.Vector3(target.x - pos.x, target.y - pos.y, target.z - pos.z).normalize();\n      var up = new THREE.Vector3(0, 0, 1);\n\n      // IDs cannot start with numbers and have whitespaces\n      var button = new Autodesk.Viewing.UI.Button(\"b-\".concat(geomNode.name().replace(/\\s/g, '')));\n\n      // Configure style (TODO: Should move to css class or specified by client app)\n      button.container.classList.add('canvas-bookmark');\n      button.container.innerHTML = createCameraIcon();\n      setButtonVisible(button, this.isVisible());\n\n      this.createTooltip(button, geomNode);\n\n      this.viewer.container.appendChild(button.container);\n\n      var buttonSize = button.getDimensions();\n\n      var sectionBox = this.findSectionBox(geomNode, geomNode.name());\n      var sectionBoxCenter = sectionBox ? sectionBox.center().applyMatrix4(sectionBox.transform) : null;\n\n      var bookmark = {\n        marker: button,\n        pos: sectionBox ? sectionBoxCenter : pos,\n        cameraPos: pos,\n        dir: dir,\n        up: up,\n        target: target,\n        name: geomNode.name(),\n\n        // position within the marker that should be centered\n        anchorX: buttonSize.width / 2,\n        anchorY: buttonSize.height / 2,\n\n        fadeValue: 0.0,\n        hovered: false,\n        bubbleNode: geomNode,\n\n        clustered: false };\n\n\n      button.container.addEventListener('mouseenter', function () {_this2.onBookmarkMouseEnter(bookmark);});\n      button.container.addEventListener('mouseleave', function () {_this2.onBookmarkMouseLeave(bookmark);});\n\n      button.addEventListener(avu.Button.Event.CLICK, function () {\n        // pass to custom handler\n        if (_this2.options && _this2.options.onBookmark) {\n          _this2.options.onBookmark(bookmark.bubbleNode, camera);\n        }\n      });\n\n      return bookmark;\n    } }, { key: \"createClusteredBookmark\", value: function createClusteredBookmark(\n\n    flattenCluster, id, visible) {var _this3 = this;\n      var button = new Autodesk.Viewing.UI.Button(id);\n\n      button.container.classList.add('clustered-canvas-bookmark');\n      button.container.innerHTML = createClusteredCameraIcon();\n\n      setButtonVisible(button, this.isVisible() && visible);\n\n      this.viewer.container.appendChild(button.container);\n\n      var res = HCluster.ComputeMeanValueForFlattenCluster(flattenCluster);\n\n      var bookmark = {\n        marker: button,\n        name: id,\n\n        pos: res.center3D,\n        currentPosProjected: res.center2D,\n\n        cluster: flattenCluster,\n\n        fadeValue: 0.0,\n        hovered: false,\n\n        folded: true };\n\n\n      button.container.addEventListener('mouseenter', function () {_this3.onClusteredBookmarkMouseEnter(bookmark);});\n      button.container.addEventListener('mouseleave', function () {_this3.onClusteredBookmarkMouseLeave(bookmark);});\n      button.addEventListener(avu.Button.Event.CLICK, function () {_this3.onClusteredBookmarkClicked(bookmark);});\n\n      bookmark.marker.container.style.transform = \"translate(\".concat(res.center2D.x, \"px, \").concat(res.center2D.y, \"px)\");\n      this.clusteredBookmarks.push(bookmark);\n    } }, { key: \"deleteBookmark\", value: function deleteBookmark(\n\n    bookmark) {\n      this.viewer.container.removeChild(bookmark.marker.container);\n      this.hideFrustumShape(bookmark);\n    } }, { key: \"clearBookmarks\", value: function clearBookmarks()\n\n    {var _this4 = this;\n      // Cancel any outdated anims or cutplanes\n      this.stopSectionBoxAnim();\n      this.applySectionBox();\n\n      this.bookmarks.forEach(function (bm) {\n        _this4.deleteBookmark(bm);\n      });\n      this.bookmarks = [];\n\n      this.clusteredBookmarks.forEach(function (bm) {\n        _this4.deleteBookmark(bm);\n      });\n      this.clusteredBookmarks = [];\n    } }, { key: \"resetBookmarks\", value: function resetBookmarks(\n\n    geomNodes) {var _this5 = this;\n\n      this.clearBookmarks();\n      if (!geomNodes) {\n        return;\n      }\n\n      //The bookmarks make use of AECModelData, so we have to make sure we have that loaded.\n      av.Document.getAecModelData(geomNodes).then(function () {\n\n        for (var i = 0; i < geomNodes.length; i++) {\n          var geomNode = geomNodes[i];\n          var bookmark = _this5.createBookmark(geomNode);\n          if (bookmark) {\n            _this5.bookmarks.push(bookmark);\n          }\n        }\n\n        _this5.bookmarkData = geomNodes;\n\n        _this5.updateBookmarkPositions();\n      });\n    }\n\n    // Create bookmarks with correct positions for the current geoOffset\n  }, { key: \"resetGlobalOffset\", value: function resetGlobalOffset(globalOffset) {\n      this.options.globalOffset = globalOffset;\n      this.resetBookmarks(this.bookmarkData);\n    } }, { key: \"showFrustumShape\", value: function showFrustumShape(\n\n    bookmark) {\n      if (bookmark.frustumShape) {\n        return;\n      }\n\n      bookmark.frustumShape = createFrustumShape(bookmark.cameraPos, bookmark.dir);\n      this.viewer.impl.addOverlay(OverlayName, bookmark.frustumShape);\n\n      bookmark.frustumShape.name = bookmark.bubbleNode.name();\n\n      // Make LMV recompute near/far plane, so that the frustum shape is considered\n      // TODO: It would be easier if LMV would do that automatically, but it\n      //       updates the camera only when rendering the scene.\n      //       => Clarify if we can generally change that.\n      this.viewer.impl.updateCameraMatrices();\n    } }, { key: \"hideFrustumShape\", value: function hideFrustumShape(\n\n    bookmark) {\n      if (!bookmark.frustumShape) {\n        return;\n      }\n\n      this.viewer.impl.removeOverlay(OverlayName, bookmark.frustumShape);\n      bookmark.frustumShape = null;\n    }\n\n    // Controls the frustum fading. fadeValue is in [0,1]\n  }, { key: \"setFrustumFadeValue\", value: function setFrustumFadeValue(bookmark, fadeValue) {\n      bookmark.fadeValue = fadeValue;\n      if (bookmark.frustumShape) {\n        bookmark.frustumShape.setFadeValue(fadeValue);\n      }\n    }\n\n    // Update fading of the frustum shape based on elpased time in ms.\n  }, { key: \"updateFrustumShapeFading\", value: function updateFrustumShapeFading(bookmark, elapsed) {\n      var FadeInDurationMs = 500;\n      var FadeOutDurationMs = 500;\n\n      var fadingIn = bookmark.hovered && bookmark.fadeValue < 1.0;\n      var fadingOut = !bookmark.hovered && bookmark.fadeValue > 0.0;\n\n      if (!fadingIn && !fadingOut) {\n        return false;\n      }\n\n      // compute amount of fading change (1.0 = full fade)\n      var fadeInDelta = elapsed / FadeInDurationMs;\n      var fadeOutDelta = elapsed / FadeOutDurationMs;\n      var newValue = bookmark.fadeValue + (fadingIn ? fadeInDelta : -fadeOutDelta);\n\n      newValue = THREE.Math.clamp(newValue, 0, 1);\n      this.setFrustumFadeValue(bookmark, newValue);\n\n      // HACK: Use css fade instead\n      if (bookmark.marker && bookmark.marker._toolTipElement) {\n        bookmark.marker._toolTipElement.style.opacity = Math.min(1, 3 * newValue);\n      }\n\n      // remove frustums if not used anymore\n      if (!bookmark.hovered && bookmark.fadeValue === 0) {\n        this.hideFrustumShape(bookmark);\n      }\n\n      this.viewer.impl.invalidate(false, false, true);\n\n      return true;\n    } }, { key: \"requestTimer\", value: function requestTimer()\n\n    {var _this6 = this;\n      var _window = this.getWindow();\n      this.timerId = _window.requestAnimationFrame(function () {return _this6.onTimer();});\n    } }, { key: \"onTimer\", value: function onTimer()\n\n    {var _this7 = this;\n      // get elapsed time in ms\n      var curTime = performance.now();\n      var elapsed = curTime - this.lastTime;\n      this.lastTime = curTime;\n\n      // Track whether any frustum-shape fading is going on\n      this.isFrustumFading = false;\n\n      this.bookmarks.forEach(function (bookmark) {\n        var fading = _this7.updateFrustumShapeFading(bookmark, elapsed);\n        _this7.isFrustumFading = _this7.isFrustumFading || fading;\n      });\n\n      // Trigger notification if fading stuff is finished\n      if (this.isAllDone()) {\n        this.waitingCallbacks.forEach(function (p) {return p();});\n        this.waitingCallbacks.length = 0;\n      }\n\n      this.requestTimer();\n    }\n\n    // Returns an oriented box (THREE.Box3() + attached Matrix4 box.transform)\n  }, { key: \"findSectionBox\", value: function findSectionBox(bubbleNode, name) {\n      var viewNode = bubbleNode.search({ type: 'view' });\n\n      if (!viewNode.length || viewNode[0].data.name !== name)\n      return null;\n\n      var sb = viewNode[0].data.sectionBox;\n      var sbt = viewNode[0].data.sectionBoxTransform;\n\n      if (!sb || !sbt)\n      return null;\n\n      var sbTransformMatrix = new THREE.Matrix4().fromArray([\n      sbt[0], sbt[1], sbt[2], sbt[3],\n      sbt[4], sbt[5], sbt[6], sbt[7],\n      sbt[8], sbt[9], sbt[10], sbt[11],\n      sbt[12], sbt[13], sbt[14], sbt[15]]);\n\n\n      var box = new THREE.Box3();\n      box.min.set(sb[0], sb[1], sb[2]);\n      box.max.set(sb[3], sb[4], sb[5]);\n      box.transform = new THREE.Matrix4();\n\n      // Transform box according to the modelToViewerTransform of the related model.\n      // Note: The model that the bookmark refers to is not always in memory. However, \n      //   - The transform is always the same for all 3D views of a model.\n      //   - Since a CanvasBookmark is shown, at least some view of the same 3D model must be visible\n      // Therefore, we can always get the transform here from the visible view of that model.\n\n      var modelTransform = this.getRelatedModelTransform(bubbleNode);\n\n      if (modelTransform) {\n        box.transform.multiply(modelTransform);\n      }\n\n      box.transform.multiply(sbTransformMatrix);\n\n\n      return box;\n    }\n\n    // The overlay scene contains the frustum shapes and is always visible by default. We only hide it temporarily\n    // when baking an image for showin ghost floors\n  }, { key: \"setOverlaySceneVisible\", value: function setOverlaySceneVisible(visible) {\n      // Overlay may be null if this is currently unloaded\n      var overlay = this.viewer.impl.overlayScenes[OverlayName];\n      var scene = overlay && overlay.scene;\n      if (scene) {\n        scene.visible = visible;\n      }\n    } }, { key: \"getFadeExtension\", value: function getFadeExtension()\n\n    {\n      return this.viewer.getExtension('Autodesk.CrossFadeEffects');\n    }\n\n    // Render models without SectionBox into fading target\n  }, { key: \"showGhosting\", value: function showGhosting() {var _this8 = this;\n      // Ghosting is an optional effect that requires the CrossFade extension. If we don't have it,\n      // we omit ghosting, i.e., only apply the cutplanes for SectionBox previous.\n      var fadeExt = this.getFadeExtension();\n      if (!fadeExt) {\n        return;\n      }\n\n      // Take control over CrossFade effect. Purpose is to avoid conflicts with other effects based on CrossFade. E.g., if we are\n      // still showing ghost-floors from LevelsExtension, LevelsExtension will properly clean them up first.\n      fadeExt.acquireControl('CanvasBookmarks', function () {return _this8.stopGhosting();});\n\n      // If possible, reuse baked ghosting image from previous bookmark\n      if (!this.ghostingActive) {\n        this.viewer.impl.setCutPlaneSet(CutPlaneSetName); // disable current SectionBox\n        this.setOverlaySceneVisible(false); // make sure that we don't bake Frustum shapes into the screenshot\n        fadeExt.renderFadingImage(0); // render snapshot into fading target\n        this.applySectionBox(this.activeSectionBox); // recover current SectionBox\n        this.setOverlaySceneVisible(true); // show overlay scene again (We don't hide it anywhere else, otherwise we would need to save/restore visibility state)\n        this.ghostingActive = true;\n      } else {\n        // Reuse ghosting from before - just make sure that no fadeOut anim is in-progress\n        this.stopGhostFadeOut();\n      }\n      fadeExt.setCrossFadeOpacity(0, 0.3); // overlay full model with ghost opacity\n    } }, { key: \"stopGhosting\", value: function stopGhosting()\n\n    {\n      if (this.ghostingActive) {\n        this.stopGhostFadeOut();\n        var fadeExt = this.getFadeExtension();\n        fadeExt && fadeExt.releaseFadingImage(0);\n        this.ghostingActive = false;\n      }\n    } }, { key: \"stopGhostFadeOut\", value: function stopGhostFadeOut()\n\n    {\n      // skip fade-out animation if in progress\n      if (this.ghostFadeAnim) {\n        this.ghostFadeAnim.skip();\n        this.ghostFadeAnim = null;\n      }\n    }\n\n    // Fade-out cross-fade target containing the ghosted environment\n  }, { key: \"fadeOutGhosting\", value: function fadeOutGhosting() {\n      var fadeExt = this.getFadeExtension();\n      if (!this.ghostingActive || !fadeExt) {\n        // No ghosting active => nothing to do\n        return;\n      }\n\n      var ghostAlpha = fadeExt.getCrossFadeOpacity(0);\n      this.ghostFadeAnim = avp.fadeValue(ghostAlpha, 0.0, 0.5, function (t) {return fadeExt.setCrossFadeOpacity(0, t);});\n    } }, { key: \"onBookmarkMouseEnter\", value: function onBookmarkMouseEnter(\n\n    bookmark) {\n      var sectionBox = this.findSectionBox(bookmark.bubbleNode, bookmark.name);\n      if (sectionBox) {\n        this.showGhosting();\n        this.animateToSectionBox(sectionBox);\n      }\n\n      this.showFrustumShape(bookmark);\n      bookmark.hovered = true;\n    } }, { key: \"onBookmarkMouseLeave\", value: function onBookmarkMouseLeave(\n\n    bookmark) {\n      this.animateToSectionBox(null);\n      this.fadeOutGhosting();\n      bookmark.hovered = false;\n    } }, { key: \"onClusteredBookmarkMouseEnter\", value: function onClusteredBookmarkMouseEnter(\n\n    bookmark) {\n      bookmark.hovered = true;\n    } }, { key: \"onClusteredBookmarkMouseLeave\", value: function onClusteredBookmarkMouseLeave(\n\n    bookmark) {\n      bookmark.hovered = false;\n    } }, { key: \"onClusteredBookmarkClicked\", value: function onClusteredBookmarkClicked(\n\n    bookmark) {\n      // TODO:\n      //   - Zoom + zoom level computation\n      //   - \"Too many\" clustered bookmarks -> (n+1) icon should be \"...\"\n\n      if (bookmark.folded) {\n        var _rotate = function _rotate(vector, center, angle) {\n          var c = Math.cos(angle);\n          var s = Math.sin(angle);\n\n          var x = vector.x - center.x;\n          var y = vector.y - center.y;\n\n          vector.x = x * c - y * s + center.x;\n          vector.y = x * s + y * c + center.y;\n        };\n\n        var n = bookmark.cluster.length;\n        var alpha = Math.round(360.0 / n);\n\n        var center = new THREE.Vector2(bookmark.currentPosProjected.x, bookmark.currentPosProjected.y);\n\n        var start = new THREE.Vector2(center.x, center.y + 35);\n\n        for (var i = 0; i < n; ++i) {\n          var bm = bookmark.cluster[i];\n\n          var current = start.clone();\n          _rotate(current, center, i * alpha * Math.PI / 180.0);\n\n          bm.currentPosProjected.x = current.x;\n          bm.currentPosProjected.y = current.y;\n\n          bm.marker.container.style.transform = \"translate(\".concat(current.x, \"px, \").concat(current.y, \"px)\");\n          setButtonVisible(bm.marker, true);\n        }\n\n        bookmark.marker.container.classList.add('declustered-canvas-bookmark');\n      } else\n      {\n        bookmark.cluster.forEach(function (bm) {\n          setButtonVisible(bm.marker, false);\n        });\n\n        bookmark.marker.container.classList.remove('declustered-canvas-bookmark');\n      }\n\n      bookmark.folded = !bookmark.folded;\n    } }, { key: \"debounceBookmarksVisibility\", value: function debounceBookmarksVisibility()\n\n    {\n      if (this.changeBookmarksVisibilityTimeout) {\n        clearTimeout(this.changeBookmarksVisibilityTimeout);\n      }\n\n      this.changeBookmarksVisibilityTimeout = setTimeout(this.changeBookmarksVisibility, 100);\n    } }, { key: \"debounceResetBookmarks\", value: function debounceResetBookmarks()\n\n    {var _this9 = this;\n      if (this.resetBookmarksTimeout) {\n        clearTimeout(this.resetBookmarksTimeout);\n      }\n\n      this.resetBookmarksTimeout = setTimeout(function () {return _this9.resetBookmarks(_this9.bookmarkData);}, 100);\n    } }, { key: \"onModelTransformChanged\", value: function onModelTransformChanged()\n\n    {\n      this.onCameraMoved();\n      this.debounceResetBookmarks();\n    } }, { key: \"changeBookmarksVisibility\", value: function changeBookmarksVisibility()\n\n    {\n      this.updateBookmarkPositions();\n    } }, { key: \"updateBookmarkPositions\", value: function updateBookmarkPositions()\n\n    {var _this10 = this;\n      if (!this.isVisible()) {\n        return;\n      }\n\n      this.bookmarks.forEach(function (bookmark) {\n        // Use cropBox center (if available) or camera position to choose label position\n        var sBox = bookmark.bubbleNode.sectionBox;\n        var pos3D = sBox ? sBox.center() : bookmark.pos;\n\n        bookmark.currentPos3D = pos3D;\n\n        // In-canvas coordinates\n        var pos2D = _this10.project(pos3D);\n        pos2D.x -= bookmark.anchorX;\n        pos2D.y -= bookmark.anchorY;\n\n        bookmark.currentPosProjected = new THREE.Vector3(pos2D.x, pos2D.y, pos2D.z);\n        bookmark.marker.container.style.transform = \"translate(\".concat(pos2D.x, \"px, \").concat(pos2D.y, \"px)\");\n      });\n\n      var clusters = this._clusteringEnabled ? this.hcluster.createClusters(this.bookmarks) : [];\n      this.updateClusteredBookmarks(clusters);\n    } }, { key: \"updateClusteredBookmarks\", value: function updateClusteredBookmarks(\n\n    clusters) {var _this11 = this;\n      // delete all \"cluster\" bookmarks since we create them all the time (by design), hiding will not really work\n      this.clusteredBookmarks.forEach(function (bookmark) {\n        _this11.deleteBookmark(bookmark);\n      });\n      this.clusteredBookmarks = [];\n\n      // hide all bookmarks and reset \"clustered\" state\n      this.bookmarks.forEach(function (bookmark) {\n        setButtonVisible(bookmark.marker, false);\n      });\n\n      var floorSelector = this._getFloorSelector();\n      var currentLevel = floorSelector && floorSelector.currentFloor;\n      if (currentLevel !== undefined) {\n        return;\n      }\n\n      var visibleBookamrks = this.bookmarks.filter(this._filterOutInvisibleBookmark);\n      visibleBookamrks.forEach(function (bookmark) {\n        bookmark.clustered = false;\n        setButtonVisible(bookmark.marker, true);\n      });\n\n      for (var i = 0; i < clusters.length; i++) {\n        var c = clusters[i];\n\n        if (c.size > 1) {(function () {\n            var flCluster = HCluster.FlattenCluster(c);\n\n            var clusterBmVisible = false;\n            flCluster.forEach(function (bookmark) {\n              bookmark.clustered = true;\n              if (!clusterBmVisible && bookmark.marker.isVisible()) {\n                // if one of the included bookmarks is visible, mark the cluster bookmark as visible one\n                clusterBmVisible = true;\n              }\n              // now, mark the included bookmark as invisible one\n              setButtonVisible(bookmark.marker, false);\n            });\n\n            // IDs cannot start with some number\n            _this11.createClusteredBookmark(flCluster, \"c-\".concat(flCluster[0].bubbleNode.data.viewableID), clusterBmVisible);})();\n        }\n      }\n    } }, { key: \"project\", value: function project(\n\n    position) {\n      var containerBounds = this.viewer.navigation.getScreenViewport();\n      var p = new THREE.Vector3().copy(position);\n\n      var matrix = new THREE.Matrix4();\n      matrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);\n\n      p.applyProjection(matrix);\n\n      return new THREE.Vector3(\n      Math.round((p.x + 1) / 2 * containerBounds.width),\n      Math.round((-p.y + 1) / 2 * containerBounds.height),\n      p.z);\n\n    } }, { key: \"load\", value: function load()\n\n    {\n\n      this.viewer.prefs.add(VISIBILITY_PROP, true);\n\n      this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.cameraMovedCB);\n      this.viewer.addEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);\n\n      var floorSelector = this._getFloorSelector();\n      if (floorSelector) {\n        floorSelector.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.levelChangedCB);\n      }\n\n      this.viewer.addEventListener(av.EXTENSION_LOADED_EVENT, this.extensionLoadedCB);\n\n      // handle the case when this extension is loaded after LevelsExtension is loaded,\n      // without making this extension known to LevelsExtension\n      this.updateBookmarkPositions();\n\n      this.viewer.impl.createOverlayScene(OverlayName);\n\n      // trigger timer-calls for fading animations\n      this.lastTime = performance.now();\n      this.requestTimer();\n\n      if (!this.updateSettingsPanel) {\n        //We need to connect this to an event that happens after the settings panel has been\n        //create by the load sequence.\n        this.updateSettingsPanel = this.configureSettings.bind(this);\n        this.viewer.addEventListener(av.SETTINGS_PANEL_CREATED_EVENT, this.updateSettingsPanel);\n      }\n\n      return true;\n    } }, { key: \"unload\", value: function unload()\n\n    {\n      this.clearBookmarks();\n\n      this.viewer.impl.removeOverlayScene(OverlayName);\n\n      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.cameraMovedCB);\n      this.viewer.removeEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);\n\n      var floorSelector = this._getFloorSelector();\n      if (floorSelector) {\n        floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.levelChangedCB);\n      }\n\n      this.viewer.removeEventListener(av.EXTENSION_LOADED_EVENT, this.extensionLoadedCB);\n\n      // Stop timer for position updates\n      if (this.timerId) {\n        var _window = this.getWindow();\n        _window.cancelAnimationFrame(this.timerId);\n        this.timerId = null;\n      }\n\n      if (this.updateSettingsPanel) {\n        this.viewer.removeEventListener(av.SETTINGS_PANEL_CREATED_EVENT, this.updateSettingsPanel);\n        this.updateSettingsPanel = null;\n      }\n\n      return true;\n    } }, { key: \"applySectionBox\", value: function applySectionBox(\n\n    box) {\n      this.activeSectionBox = box;\n\n      // No box => clear cutplanes\n      if (!box) {\n        this.viewer.impl.setCutPlaneSet(CutPlaneSetName);\n        return;\n      }\n\n      var planes = avp.SceneMath.box2CutPlanes(box, box.transform);\n      this.viewer.impl.setCutPlaneSet(CutPlaneSetName, planes);\n    }\n\n    // get bbox of all visible models\n  }, { key: \"getModelBox\", value: function getModelBox() {\n      var mq = this.viewer.impl.modelQueue();\n      var models = mq.getModels();\n\n      var box = new THREE.Box3();\n      for (var i = 0; i < models.length; i++) {\n        box.union(models[i].getBoundingBox());\n      }\n\n      return box;\n    } }, { key: \"stopSectionBoxAnim\", value: function stopSectionBoxAnim()\n\n    {\n      if (this.sectionBoxAnim) {\n        this.sectionBoxAnim.stop();\n        this.sectionBoxAnim = null;\n      }\n    } }, { key: \"animateToSectionBox\", value: function animateToSectionBox(\n\n    newBox) {var _this12 = this;\n      // Nothing to animate\n      if (!newBox && !this.activeSectionBox) {\n        return;\n      }\n\n      // Don't allow overlapping animations\n      this.stopSectionBoxAnim();\n\n      var CutPlaneAnimInSeconds = 0.5;\n\n      // Start at latest SectionBox state or with the whole model\n      this.animStartBox = this.activeSectionBox ? cloneBox(this.activeSectionBox) : cloneBox(this.getModelBox());\n      this.animEndBox = newBox ? cloneBox(newBox) : cloneBox(this.getModelBox());\n\n      // Set target box\n      this.sectionBox = newBox;\n\n      // interpolated box used during anim\n      var tmpBox = new THREE.Box3();\n      tmpBox.transform = new THREE.Matrix4();\n\n      var onUpdate = function onUpdate(t) {\n        t = avp.smootherStep(t);\n        lerpBoxes(_this12.animStartBox, _this12.animEndBox, t, tmpBox);\n        _this12.applySectionBox(tmpBox);\n      };\n\n      var onFinished = function onFinished() {\n        _this12.applySectionBox(_this12.sectionBox);\n        _this12.sectionBoxAnim = null;\n      };\n\n      this.sectionBoxAnim = avp.fadeValue(0, 1, CutPlaneAnimInSeconds, onUpdate, onFinished);\n    } }, { key: \"enableClustering\", value: function enableClustering(\n\n    value) {\n      if (this._clusteringEnabled !== value) {\n        this._clusteringEnabled = value;\n        this.updateClusteredBookmarks([]);\n      }\n    } }, { key: \"setClusteringThreshold\", value: function setClusteringThreshold(\n\n    value) {\n      if (this._clusteringThreshold !== value) {\n        this._clusteringThreshold = value;\n        this.hcluster.setThreshold(value);\n        this.updateClusteredBookmarks([]);\n      }\n    }\n\n    // Returns true if there are no active transitions, i.e., state is stable and doesn't vary based on timing anymore.    \n  }, { key: \"isAllDone\", value: function isAllDone() {\n      // Note: Some aspects are not considered yet, e.g., css-based fading and debounced visibility. For\n      //       now, we only address everything that would introduce test instabilities otherwise.\n      var sectionBoxAnimActive = this.sectionBoxAnim && this.sectionBoxAnim.isRunning;\n      var visChangePending = this.bookmarks.some(function (b) {return b.marker && b.marker.visiblityChangePending;});\n      return !sectionBoxAnimActive && !this.isFrustumFading && !visChangePending;\n    }\n\n    // Returns a promise that resolves as soon as isAllDone() returns true.\n  }, { key: \"waitForAllDone\", value: function waitForAllDone() {var _this13 = this;\n\n      // Update frustum-fading to check whether there are any changes to process\n      this.onTimer();\n\n      if (this.isAllDone()) {\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve) {\n        _this13.waitingCallbacks.push(resolve);\n      });\n    } }, { key: \"_filterOutInvisibleBookmark\", value: function _filterOutInvisibleBookmark(\n\n    bm) {\n      var vp = this.viewer.navigation.getScreenViewport();\n\n      if (bm.currentPosProjected.x < 0 || bm.currentPosProjected.x > vp.width) {\n        return false;\n      }\n\n      if (bm.currentPosProjected.y < 0 || bm.currentPosProjected.y > vp.height) {\n        return false;\n      }\n\n      var viewingDirection = this.camera.target.clone().sub(this.camera.position);\n      var bookmarkDirection = bm.pos.clone().sub(this.camera.position);\n      return viewingDirection.dot(bookmarkDirection) > 0;\n    } }, { key: \"onLevelChanged\", value: function onLevelChanged()\n\n    /*event*/{\n      this.updateBookmarkPositions();\n    } }, { key: \"onExtensionLoaded\", value: function onExtensionLoaded(\n\n    event) {\n      if (event.extensionId === LEVEL_EXT) {\n        this.updateBookmarkPositions();\n      }\n    } }, { key: \"configureSettings\", value: function configureSettings()\n\n    {\n\n      //Is it a GUI viewer or not?\n      if (!this.viewer.getSettingsPanel)\n      return;\n\n      var panel = this.viewer.getSettingsPanel(true);\n\n      if (!panel.is3dMode)\n      return;\n\n      var navTab = av.Extensions.ViewerSettingTab.Navigation;\n      panel.addLabel(navTab, \"Location Icons\");\n\n      // add toggle to the hypermodeling tab of the viewer settings\n      if (panel && !panel.showLocationIconsChkBoxId) {\n        panel.showLocationIconsChkBoxId = panel.addCheckbox(\n        navTab,\n        \"Show location icons\",\n        \"Toggles availability of the location icons when looking at the project model\",\n        true,\n        this.onVisibilityChangedCB,\n        VISIBILITY_PROP);\n\n      }\n    } }, { key: \"_getFloorSelector\", value: function _getFloorSelector()\n\n    {\n      var levelExt = this.viewer.getExtension(LEVEL_EXT);\n      return levelExt && levelExt.floorSelector;\n    } }]);return CanvasBookmarkExtension;}(av.Extension);export { CanvasBookmarkExtension as default };\n\n\nnamespace.CanvasBookmarkExtension = CanvasBookmarkExtension;\n\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, CanvasBookmarkExtension);","\nexport function createCameraIcon() {\n  return [\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 114 114\">',\n  '<defs>',\n  '<path id=\"camera-view-icon-3-with-shadow-v3-b\" d=\"M60.934065,73.4602645 C54.1164768,73.4602645 48.5886781,67.9324658 48.5886781,61.1148776 C48.5886781,54.2963836 54.1164768,48.7694907 60.934065,48.7694907 C67.752559,48.7694907 73.2803577,54.2963836 73.2803577,61.1148776 C73.2803577,67.9324658 67.752559,73.4602645 60.934065,73.4602645 M78.7230158,42.834104 C77.2575106,42.9581919 75.7711731,42.808743 74.2984219,42.8748628 C73.4714712,42.9119986 72.9388896,42.637556 72.4470667,41.9817922 C70.947143,39.9827997 69.3693246,38.0417751 67.8621549,36.0491228 C67.287003,35.2873862 66.5959149,34.9939228 65.6521223,35.0029804 C62.0046628,35.0355874 58.354486,35.0401161 54.7070265,35.0002631 C53.7097946,34.9893941 53.0033088,35.3145587 52.4046073,36.1116196 C50.9028721,38.1088007 49.382116,40.0951128 47.7852769,42.0171165 C47.4311283,42.4437253 46.748192,42.7707014 46.1884378,42.8187062 C44.8515493,42.9346424 43.4974514,42.855842 41.9640149,42.855842 C41.9640149,42.2091358 41.9929989,41.6520989 41.9576746,41.0995907 C41.8897433,40.036239 41.3046281,39.4293858 40.2331246,39.4112707 C38.5112919,39.381381 36.7894591,39.3759465 35.0676263,39.4130822 C33.9934056,39.4366318 33.4291227,40.057977 33.3892696,41.1303863 C33.3693431,41.6557219 33.3856466,42.1819632 33.3856466,42.8078372 C31.121269,42.9074698 29.8523117,44.2289606 29,46.07941 L29,75.8722796 C30.0434252,78.4165343 31.9636175,79.1737422 34.6482636,79.1583444 C49.3911736,79.0686751 64.1340835,79.0713923 78.8769935,79.1556272 C81.5299383,79.1710249 83.372236,78.3377339 84.4011692,75.8722796 L84.4011692,46.07941 C83.3332887,43.5523646 81.4058504,42.6067605 78.7230158,42.834104\"/>',\n  '<filter id=\"camera-view-icon-3-with-shadow-v3-a\" width=\"125.3%\" height=\"131.7%\" x=\"-12.6%\" y=\"-11.3%\" filterUnits=\"objectBoundingBox\">',\n  '<feOffset dy=\"2\" in=\"SourceAlpha\" result=\"shadowOffsetOuter1\"/>',\n  '<feGaussianBlur in=\"shadowOffsetOuter1\" result=\"shadowBlurOuter1\" stdDeviation=\"2\"/>',\n  '<feColorMatrix in=\"shadowBlurOuter1\" values=\"0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.1 0\"/>',\n  '</filter>',\n  '<path id=\"camera-view-icon-3-with-shadow-v3-d\" d=\"M104.440851,57.2204256 C104.440851,83.2997158 83.2997158,104.440851 57.2204256,104.440851 C31.1411354,104.440851 10,83.2997158 10,57.2204256 C10,31.1411354 31.1411354,10 57.2204256,10 C83.2997158,10 104.440851,31.1411354 104.440851,57.2204256 Z\"/>',\n  '<filter id=\"camera-view-icon-3-with-shadow-v3-c\" width=\"125.5%\" height=\"125.5%\" x=\"-12.8%\" y=\"-10.6%\" filterUnits=\"objectBoundingBox\">',\n  '<feMorphology in=\"SourceAlpha\" operator=\"dilate\" radius=\"5.045\" result=\"shadowSpreadOuter1\"/>',\n  '<feOffset dy=\"2\" in=\"shadowSpreadOuter1\" result=\"shadowOffsetOuter1\"/>',\n  '<feMorphology in=\"SourceAlpha\" radius=\"5.045\" result=\"shadowInner\"/>',\n  '<feOffset dy=\"2\" in=\"shadowInner\" result=\"shadowInner\"/>',\n  '<feComposite in=\"shadowOffsetOuter1\" in2=\"shadowInner\" operator=\"out\" result=\"shadowOffsetOuter1\"/>',\n  '<feGaussianBlur in=\"shadowOffsetOuter1\" result=\"shadowBlurOuter1\" stdDeviation=\"2\"/>',\n  '<feColorMatrix in=\"shadowBlurOuter1\" values=\"0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.1 0\"/>',\n  '</filter>',\n  '</defs>',\n  '<g fill=\"none\" fill-rule=\"evenodd\">',\n  '<use fill=\"#000\" filter=\"url(#camera-view-icon-3-with-shadow-v3-a)\" xlink:href=\"#camera-view-icon-3-with-shadow-v3-b\"/>',\n  '<use fill=\"currentColor\" xlink:href=\"#camera-view-icon-3-with-shadow-v3-b\"/>',\n  '<g>',\n  '<use fill=\"#000\" filter=\"url(#camera-view-icon-3-with-shadow-v3-c)\" xlink:href=\"#camera-view-icon-3-with-shadow-v3-d\"/>',\n  '<use stroke=\"currentColor\" stroke-width=\"10.09\" xlink:href=\"#camera-view-icon-3-with-shadow-v3-d\"/>',\n  '</g>',\n  '</g>',\n  '</svg>'].\n  join('');\n}\n\nexport function createClusteredCameraIcon() {\n  return [\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 652 598\">',\n  '<path fill=\"currentColor\" d=\"M254.7,94.3A157.6,157.6,0,1,0,412.3,251.9,157.6,157.6,0,0,0,254.7,94.3ZM173.6,281.4a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,173.6,281.4Zm86.6,0a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,260.2,281.4Zm86.7,0a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,346.9,281.4Z\"/>',\n  '<circle fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"10\" stroke-width=\"42.87px\" cx=\"256\" cy=\"256\" r=\"221.5\" transform=\"translate(-101.8 200.6) rotate(-36.2)\"/>',\n  '</svg>'].\n  join('');\n}","'use strict';\n\n// Returns a THREE.Scene to represent the camera frustum\nexport function createFrustumShape(pos, dir) {\n  // The frustum shape is a symbol to explain pos and dir - not the exact frustum.\n  var FovVert = 17;\n  var FovHor = 17;\n\n  // Frustum shape/outline opacity when fully faded in\n  var FrustumOpacity = 0.05;\n  var LineOpacity = 1.0;\n\n  var radians = THREE.Math.degToRad;\n  var dx = Math.sin(radians(FovHor));\n  var dy = Math.sin(radians(FovVert));\n\n  // compute z in a way that the results are normalized\n  var dz = Math.sqrt(1 - dx * dx - dy * dy);\n\n  // compute directions for the 4 frustum-corners\n  var bottomLeft = new THREE.Vector3(-dx, -dy, dz);\n\n  var bottomRight = new THREE.Vector3(dx, -dy, dz);\n  var topLeft = new THREE.Vector3(-dx, dy, dz);\n  var topRight = new THREE.Vector3(dx, dy, dz);\n\n  // create mesh vertices: 4 corners + origin\n  var vertices = new Float32Array([\n  bottomLeft.x, bottomLeft.y, bottomLeft.z,\n  bottomRight.x, bottomRight.y, bottomRight.z,\n  topLeft.x, topLeft.y, topLeft.z,\n  topRight.x, topRight.y, topRight.z,\n  0, 0, 0]);\n\n\n  var bl = 0;\n  var br = 1;\n  var tl = 2;\n  var tr = 3;\n  var p0 = 4; // index of camera position vertex\n\n  var indices = new Uint32Array([\n  p0, br, bl, // bottom face\n  p0, tr, br, // right face\n  p0, tl, tr, // top face\n  p0, bl, tl, // left face\n  bl, br, tr, // far face lower tri\n  bl, tr, tl // face face upper tri\n  ]);\n\n  // Extract vertices to non-indexed, so that we can compute face-normals\n  var vertsNonIndexed = new Float32Array(3 * indices.length);\n  for (var i = 0; i < indices.length; i++) {\n    var index = indices[i];\n    vertsNonIndexed[3 * i] = vertices[3 * index];\n    vertsNonIndexed[3 * i + 1] = vertices[3 * index + 1];\n    vertsNonIndexed[3 * i + 2] = vertices[3 * index + 2];\n  }\n\n  var geometry = new THREE.BufferGeometry();\n  geometry.addAttribute('position', new THREE.BufferAttribute(vertsNonIndexed, 3));\n\n  geometry.computeVertexNormals();\n\n  var material = new THREE.MeshPhongMaterial({\n    color: 0x5050FF,\n    transparent: true,\n    opacity: 0.0, // will change with fade-in\n    depthTest: false,\n    depthWrite: false,\n    blending: THREE.NoBlending });\n\n\n  var mesh = new THREE.Mesh(geometry, material);\n\n  // create frustum lines\n  var lineIndices = new Uint32Array([\n  p0, bl,\n  p0, br,\n  p0, tr,\n  p0, tl,\n  bl, br,\n  br, tr,\n  tr, tl,\n  tl, bl]);\n\n\n  var lineGeom = new THREE.BufferGeometry();\n  lineGeom.addAttribute('index', new THREE.BufferAttribute(lineIndices, 1));\n  lineGeom.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n  lineGeom.isLines = true;\n\n  var lineMaterial = new THREE.LineBasicMaterial({\n    color: 0xFFFFFF,\n    transparent: true,\n    side: THREE.DoubleSide,\n    opacity: 0.0, // will change with fade-in\n    depthTest: false,\n    depthWrite: false,\n    blending: THREE.NoBlending // NOTE: Overlay target is blended anyway. So, using blend here would blend with black.\n  });\n\n  var lineMesh = new THREE.Mesh(lineGeom, lineMaterial);\n\n  // Create THREE Scene and add meshes\n  var scene = new THREE.Scene();\n  scene.add(mesh);\n  scene.add(lineMesh);\n\n  // Workaround: Tag geometry as visible - otherwise it is skipped by computeObjectBounds (see Viewer3DImpl).\n  // TODO: My guess is that this is a bug in LMV. Once we know for sure that it doesn't break anything\n  //       we should change it in LMV instead and don't need to set this manually anymore.\n  geometry.visible = true;\n  lineGeom.visible = true;\n\n  // Makes it more debugger-friendly (allow you to recognize this shape within LMV)\n  mesh.name = 'FrustumGizmo';\n\n  // Set frustum shape size\n  // TODO: Consider smarter way to determine size, e.g. consider model units or model box\n  var size = 50;\n  scene.scale.set(size, size, size);\n\n  // move tip of the frustum to camera position\n  scene.position.copy(pos);\n\n  // orient frustum shape to look towards camera direction\n  var origin = new THREE.Vector3(0, 0, 0);\n  var up = new THREE.Vector3(0, 0, 1);\n  var invDir = new THREE.Vector3(-dir.x, -dir.y, -dir.z); // lookat directions in THREE are defined 'towards' an object\n  var rotationMatrix = new THREE.Matrix4().lookAt(origin, invDir, up);\n  scene.rotation.setFromRotationMatrix(rotationMatrix);\n\n  // Just disable culling - it's not worth to care about computing BoundingSpheres etc.\n  scene.frustumCulled = false;\n  mesh.frustumCulled = false;\n  lineMesh.frustumCulled = false;\n\n  // Attach function to control overall opacity (fadeValue is in [0,1])\n  scene.setFadeValue = function (fadeValue) {\n    material.opacity = FrustumOpacity * fadeValue;\n    lineMaterial.opacity = LineOpacity * fadeValue;\n  };\n\n  return scene;\n}","'use strict';function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var\n\nHCluster = /*#__PURE__*/function () {_createClass(HCluster, null, [{ key: \"FlattenCluster\", value: function FlattenCluster(\n    c) {var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      if (c.value) {\n        values.push(c.value);\n      } else\n      {\n        HCluster.FlattenCluster(c.left, values);\n        HCluster.FlattenCluster(c.right, values);\n      }\n\n      return values;\n    } }, { key: \"ComputeMeanValueForFlattenCluster\", value: function ComputeMeanValueForFlattenCluster(\n\n    c) {\n      var bbox2D = new THREE.Box3();\n      var bbox3D = new THREE.Box3();\n\n      c.forEach(function (b) {\n        bbox2D.expandByPoint(b.currentPosProjected);\n        bbox3D.expandByPoint(b.currentPos3D);\n      });\n\n      return {\n        center2D: bbox2D.center(),\n        center3D: bbox3D.center() };\n\n    } }]);\n\n  function HCluster(clusterfck, distanceFunc) {var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;_classCallCheck(this, HCluster);\n    this._clusterfck = clusterfck;\n    this.setDistanceFuncAndThreshold(distanceFunc, threshold);\n  }_createClass(HCluster, [{ key: \"setDistanceFuncAndThreshold\", value: function setDistanceFuncAndThreshold(\n\n    distanceFunc) {var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      this._distanceFunc = distanceFunc;\n      this._threshold = threshold;\n    } }, { key: \"setThreshold\", value: function setThreshold(\n\n    threshold) {\n      this._threshold = threshold;\n    } }, { key: \"createClusters\", value: function createClusters(\n\n    clusterItems) {\n      var clusters = this._clusterfck.hcluster(clusterItems, this._distanceFunc, this._clusterfck.AVERAGE_LINKAGE, this._threshold);\n      //console.log(clusters);\n\n      return clusters;\n    } }]);return HCluster;}();export { HCluster as default };","\nvar content = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./DropMe.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./DropMe.css\", function() {\n\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./DropMe.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nimport DropMeTool from './DropMeTool.js';\nimport ViewObjectIn3D from './ViewObjectIn3D.js';\n\nvar av = Autodesk.Viewing,avu = Autodesk.Viewing.UI;\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar myExtensionName = 'Autodesk.AEC.DropMeExtension';var\n\nDropMeExtension = /*#__PURE__*/function (_av$Extension) {_inherits(DropMeExtension, _av$Extension);var _super = _createSuper(DropMeExtension);\n  function DropMeExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { teleportOnRelease: true };_classCallCheck(this, DropMeExtension);\n    _this = _super.call(this, viewer, options);\n\n    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));\n\n    _this.teleportOnRelease = options.teleportOnRelease; // teleportOnRelease used by default, not used on mobile apps.\n    _this.viewer = viewer;\n    _this._onModelLoaded = _this._onModelLoaded.bind(_assertThisInitialized(_this));\n    _this._deactivateTool = _this._deactivateTool.bind(_assertThisInitialized(_this));\n    _this._onViewportDataFetched = _this._onViewportDataFetched.bind(_assertThisInitialized(_this));\n    _this.onDropOverride = null;\n    _this.options = options;\n    _this.options.triggerDeactivate = _this._deactivateTool;\n    _this.toggleIndex = options.toggleIndex || 0; // at which position at the toolbar to toggle DropMe button\n    _this.enableGuidance = options.enableGuidance || false;\n\n    if (_this.options.enableViewIn3d) {\n      _this.viewObjectIn3D = new ViewObjectIn3D(_assertThisInitialized(_this), viewer, _this.options);\n    }return _this;\n  }_createClass(DropMeExtension, [{ key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this2 = this;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n\n\n                  this.viewer.loadExtension('Autodesk.AEC.ViewportsExtension'));case 2:this.viewportsExtension = _context.sent;\n                this.viewportsExtension.addEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this._onViewportDataFetched);\n\n                this.dropMeTool = new DropMeTool(this.viewer, function () {return _this2._onDrop.apply(_this2, arguments);}, this);\n\n                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._onModelLoaded);\n                if (this.viewer.model) {\n                  this._initUI(this.viewer.model);\n                }return _context.abrupt(\"return\",\n                true);case 8:case \"end\":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"unload\", value: function unload()\n\n\n    {\n      this.viewportsExtension.removeEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this._onViewportDataFetched);\n      this.viewportsExtension = null;\n\n      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._onModelLoaded);\n      this.viewer.toolController.setIsLocked(false);\n      this._deactivateTool();\n      this._destroyUI();\n      return true;\n    } }, { key: \"_onViewportDataFetched\", value: function _onViewportDataFetched()\n\n    {\n      // It's ok to assume that there is a single 2D model when using DropMe.\n      var model = this.viewer.model;\n\n      if (model) {\n        this._onModelLoaded({ model: this.viewer.model });\n      }\n    } }, { key: \"setOnDrop\", value: function setOnDrop(\n\n    cb) {\n      this.onDropOverride = cb;\n    } }, { key: \"_destroyUI\", value: function _destroyUI()\n\n    {\n      this._showDrop(false);\n\n      if (this.dropMeButton) {\n        this.dropMeButton.removeFromParent();\n        this.dropMeButton = null;\n      }\n\n      this.uiInitialized = false;\n    } }, { key: \"_onDrop\", value: function _onDrop(\n\n    pos, dir, mode, bubbleNode) {\n      // after drop action had been triggered, we need to deactivate tool as we are transitioning into another view.\n      if (this.teleportOnRelease) {\n        this.viewer.toolController.setIsLocked(false);\n        this._deactivateTool(true);\n      }\n\n      console.log(\"DropMe: 3D camera position is \".concat(JSON.stringify(pos)));\n      console.log(\"DropMe: 3D camera direction is \".concat(JSON.stringify(dir)));\n      this.dispatchEvent({ type: DropMeExtension.DROP_ME_EVENT, pos: pos, dir: dir, mode: mode, bubbleNode: bubbleNode });\n\n      if (this.onDropOverride) {\n        this.onDropOverride(pos, dir, mode, bubbleNode);\n      } else if (this.options.onDrop) {\n        this.options.onDrop(pos, dir, mode, bubbleNode);\n      } else {\n        console.warn('DropMe: No onDrop callback specified ');\n      }\n    } }, { key: \"_onModelLoaded\", value: function _onModelLoaded(\n\n    event) {\n      if (!this.uiInitialized) {\n        this._initUI(event.model);\n      } else {\n        this._updateUI(event.model);\n      }\n    } }, { key: \"_deactivateTool\", value: function _deactivateTool(\n\n    disableButton) {\n      // UI might not be initialized yet. E.g., this can happen if the extensionUnload happens\n      // before a model was added. In this case, dropMeButton and guidance UI will not exist anyway.\n      if (this.uiInitialized) {\n        this._showGuidenaceUI(false);\n\n        this.dropMeButton.setState(disableButton ? avu.Button.State.DISABLED : avu.Button.State.INACTIVE);\n      }\n\n      this.viewer.toolController.deactivateTool('drop-me');\n    } }, { key: \"isSupportedModel\", value: function isSupportedModel(\n\n    model) {\n      if (!(model === null || model === void 0 ? void 0 : model.is2d())) {\n        return false;\n      }\n\n      var bubbleNode = model.getDocumentNode();\n\n      if (!bubbleNode) {\n        return false;\n      }\n\n      // onlyTopViewPlans is currently true by default anyway, but it's better to explicitly put it here so it will be clear that we request only top view viewports.\n      //\n      // Notice that filterAndFlattenViewports returns only the viewports that were already fetched and cached.\n      // If other viewports will get added later (from an async provider) - it will trigger a VIEWPORT_DATA_FETCHED_EVENT event and we'll get here again.\n      var viewports = this.viewportsExtension.filterAndFlattenViewports(bubbleNode, { onlyTopViewPlans: true });\n\n      return viewports.length;\n    } }, { key: \"_updateUI\", value: function () {var _updateUI2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(\n\n      model) {var toolbar, controlGroup, isSupported;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n                toolbar = this.viewer.getToolbar && this.viewer.getToolbar();if (\n                toolbar) {_context2.next = 3;break;}return _context2.abrupt(\"return\");case 3:\n\n\n\n                this.dropMeButton.removeFromParent();\n\n                controlGroup = toolbar.getControl(this.options.toolbarGroup || av.TOOLBAR.NAVTOOLSID);\n                controlGroup.addControl(this.dropMeButton, { index: this.toggleIndex });\n                isSupported = this.isSupportedModel(model);\n                this._showDrop(isSupported);case 8:case \"end\":return _context2.stop();}}}, _callee2, this);}));function _updateUI(_x) {return _updateUI2.apply(this, arguments);}return _updateUI;}() }, { key: \"_initUI\", value: function _initUI(\n\n\n    model) {var _this3 = this;\n      // There is no need for this function when getToolbar doesn't exist (headless viewer).\n      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();\n\n      if (!toolbar) {\n        return;\n      }\n\n      this.dropMeButton = new avu.Button('drop-me-icon');\n      this.dropMeButton.icon.innerHTML = createDropMeIcon();\n\n      this.dropMeButton.onClick = function () {\n        if (_this3.dropMeTool.active) {\n          _this3._deactivateTool();\n        } else {\n          _this3.dropMeButton.setState(avu.Button.State.ACTIVE);\n          // TODO: when we activate tool we might want to forbid interaction with other tools\n          _this3.viewer.toolController.activateTool('drop-me');\n          _this3._showGuidenaceUI();\n        }\n      };\n      this.uiInitialized = true;\n\n      this._updateUI(model);\n    } }, { key: \"_showGuidenaceUI\", value: function _showGuidenaceUI()\n\n    {var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (!this.enableGuidance)\n      return;\n\n      if (show) {\n        var _document = this.getDocument();\n        this.guidenaceUI = _document.createElement('div');\n        this.guidenaceUI.className = 'dropme-guidenace-ui';\n        this.guidenaceUI.innerHTML = Autodesk.Viewing.i18n.translate('Click on a location to ground yourself, then select a camera direction');\n        this.viewer.container.appendChild(this.guidenaceUI);\n      } else {\n        if (this.viewer.container.contains(this.guidenaceUI)) {\n          this.viewer.container.removeChild(this.guidenaceUI);\n        }\n      }\n    } }, { key: \"_showDrop\", value: function _showDrop(\n\n    value) {\n      if (!this.dropMeButton) {\n        return;\n      }\n\n      var toolbar = this.viewer.getToolbar();\n      var controlGroup = toolbar.getControl(this.options.toolbarGroup || av.TOOLBAR.NAVTOOLSID);\n\n      if (controlGroup && !this.container) {\n        this.dropMeButton.setState(value ? avu.Button.State.INACTIVE : avu.Button.State.DISABLED);\n      }\n      var supportedTooltip = Autodesk.Viewing.i18n.translate('Click a 2D location to view that space in 3D');\n      var unsupportedTooltip = Autodesk.Viewing.i18n.translate('Current view is not supported by Place Me');\n\n      this.dropMeButton.setToolTip(value ? supportedTooltip : unsupportedTooltip);\n    } }]);return DropMeExtension;}(av.Extension);export { DropMeExtension as default };\n\n\nvar createDropMeIcon = function createDropMeIcon() {\n  return [\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 128 128\">',\n  '<g stroke=\"currentColor\" fill=\"currentColor\">',\n  '<path d=\"M67,0c2.4.5,4.8.9,7.1,1.6C87.5,5.3,96.6,16.6,98,31a37.2,37.2,0,0,1-2.1,16.2c-4.7,13-23.6,48.1-31.6,58.2-.3-.2-.6-.3-.8-.5-11.1-17.6-21.9-35.4-30-54.7-4.6-10.9-4.6-21.7.6-32.3S47.5,2.6,58.3.7l3-.7ZM64,47A11.8,11.8,0,1,0,52.3,34.9,12,12,0,0,0,64,47Z\"/>',\n  '<path d=\"M12.8,103.4c1.4-8,6.9-12.3,14-14.6s12-2.9,18.1-4.2c1.1-.2,2.4.5,3.4,1.5-4.5,1.1-9.1,1.8-13.5,3.3a35,35,0,0,0-9.6,5c-4,3-4.3,7.5-.7,10.9a28.7,28.7,0,0,0,9.6,6.2,87.3,87.3,0,0,0,59.9.1,28.2,28.2,0,0,0,8.7-5.2c4.9-4.1,4.8-9.7-.8-12.8S90.7,89.3,85,87.3c-1.6-.6-3.4-.6-5.3-1.7,1.1-.4,2.2-1.2,3.2-1.1,7.8.9,15.5,2.2,22.6,6,12,6.4,13,17.9,2.1,26.1-8.1,6.1-17.6,8.5-27.4,10L69.1,128H59.2l-5.2-.7c-9.1-.8-18-2.6-26.4-6.5s-13.4-8.1-14.9-16.8Z\"/>',\n  '</g>',\n  '</svg>'].\n  join('');\n};\n\nnamespace.DropMeExtension = DropMeExtension;\nDropMeExtension.POSITION_FOUND_EVENT = 'POSITION_FOUND_EVENT';\nDropMeExtension.OBJECT_SELECTED_EVENT = 'OBJECT_SELECTED_EVENT';\nDropMeExtension.DROP_ME_EVENT = 'DROP_ME_EVENT';\nDropMeExtension.DROP_ME_STARTED_EVENT = 'DROP_ME_STARTED_EVENT';\n\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, DropMeExtension);","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nimport ViewPortOverlay from './ViewPortOverlay.js';\n\nvar av = Autodesk.Viewing,avp = av.Private;\nvar GlobalManagerMixin = av.GlobalManagerMixin;\n\nvar DROPME_MODE = { auto: 'Auto', manual: 'Manual' };var\n\nDropMeTool = /*#__PURE__*/function (_av$ToolInterface) {_inherits(DropMeTool, _av$ToolInterface);var _super = _createSuper(DropMeTool);\n  function DropMeTool(viewer, onDrop, extension) {var _this;_classCallCheck(this, DropMeTool);\n    _this = _super.call(this);\n\n    _this.names = ['drop-me'];\n    _this.viewer = viewer;\n    _this.setGlobalManager(_this.viewer.globalManager);\n    _this.extension = extension;\n    _this.options = extension.options;\n    if (_this.options.teleportOnRelease === undefined) {\n      _this.options.teleportOnRelease = true; // Set true by default\n    }\n    _this.viewer.toolController.registerTool(_assertThisInitialized(_this));\n    _this.onDrop = onDrop;\n    _this.active = false;\n    _this._movedSinceFirstClick = false;\n\n    _this.init();\n\n    _this.cameraSelectionState = {\n      pending: false,\n      pos: null,\n      target: null,\n      inViewport: false,\n      initialVp: null };\n\n\n    _this.teleportationInProgress = 0;\n\n    // 'False' indicates if the user has clicked a first time alredy to choose position, so that the\n    // next click will determine view-direction and instantly invoke the transition.\n    _this.isFirstClick = true;\n\n    _this.viewPortOverlay = new ViewPortOverlay(_this.viewer);\n    _this.escapeHotkeyId = 'Autodesk.AEC.DropMeToolEsc';return _this;\n  }_createClass(DropMeTool, [{ key: \"init\", value: function init()\n\n    {var _this2 = this;\n\n      this.activate = function () {\n        var gestureHandler = _this2.viewer.toolController.getTool(\"gestures\");\n        if (gestureHandler) {\n          gestureHandler.setGestureParameter('drag', 'threshold', 0);\n        }\n\n        var hotkeys = [{\n          keycodes: [\n          Autodesk.Viewing.KeyCode.ESCAPE],\n\n          onRelease: function onRelease() {return _this2.options.triggerDeactivate();} }];\n\n        _this2.viewer.getHotkeyManager().pushHotkeys(_this2.escapeHotkeyId, hotkeys);\n        _this2.viewer.addEventListener(av.MODEL_ADDED_EVENT, _this2.options.triggerDeactivate);\n        _this2.viewer.impl.pauseHighlight(true);\n        _this2.active = true;\n        avp.analytics.track('viewer.place_me');\n      };\n\n      this.deactivate = function () {\n        var gestureHandler = _this2.viewer.toolController.getTool(\"gestures\");\n        if (gestureHandler) {\n          gestureHandler.restoreGestureParameterDefault('drag', 'threshold');\n        }\n\n        _this2.viewer.getHotkeyManager().popHotkeys(_this2.escapeHotkeyId);\n        _this2._cancelTeleportation();\n        _this2._destroyCameraSelectorUi();\n        _this2.viewer.removeEventListener(av.MODEL_ADDED_EVENT, _this2.options.triggerDeactivate);\n        _this2.viewer.impl.pauseHighlight(false);\n        _this2.active = false;\n        _this2._movedSinceFirstClick = false;\n      };\n\n      this.handleButtonDown = function (event) {\n        return true;\n      };\n\n      this.handleButtonUp = function (event) {\n        if (!this._movedSinceFirstClick || this.isFirstClick) {\n          return false;\n        }\n        return true;\n      };\n\n      this.handleSingleClick = function (e, isTouch) {\n        if (_this2.isFirstClick) {\n          var tmpres = _this2._get3DCameraPositionAndVp(e.canvasX, e.canvasY);\n          if (tmpres && tmpres.pos) {\n            _this2.cameraSelectionState.pos = { x: e.canvasX, y: e.canvasY };\n            _this2.cameraSelectionState.pending = true;\n            _this2.cameraSelectionState.initialVp = tmpres.vp;\n\n            _this2._createCameraSelectorUi(_this2.cameraSelectionState.pos);\n\n            requestAnimationFrame(function () {\n              // We should only trigger animation if mouse has not been moved since the first click.\n              if (!_this2._movedSinceFirstClick)\n              _this2.cameraSelectorPosition.classList.add('camera-selector-position--teleporting');\n            });\n\n            if (tmpres.vp.isTopViewViewport() && !isTouch) {\n              // while teleportation is pending this.handleMouseMove will move camera frustum\n              _this2._scheduleTeleportation();\n\n              // needed only for scheduled teleportation\n              _this2.isFirstClick = false;\n              _this2.cursor = 'none';\n              _this2.getCursor();\n            } else\n            {\n              _this2._runTeleportation(DROPME_MODE.auto);\n            }\n          }\n        } else\n        {\n          if (_this2.options.teleportOnRelease) {\n            _this2.teleport();\n          }\n        }\n\n        // As expectation of single click is a teleportation to another view, we simply consume event and do not propogate it further\n        return true;\n      };\n\n      this.teleport = function () {\n        _this2.cameraSelectionState.target = { x: _this2.lastX, y: _this2.lastY };\n        _this2._runTeleportation(DROPME_MODE.manual);\n        _this2.isFirstClick = _this2.options.teleportOnRelease;\n        _this2._movedSinceFirstClick = false;\n        _this2._recoverCursor();\n      };\n\n      this.handleMouseMove = function (e) {\n        if (!_this2.isFirstClick && !_this2._movedSinceFirstClick)\n        _this2._movedSinceFirstClick = true;\n\n        if (_this2.cursor)\n        _this2._recoverCursor();\n\n        var tmpres = _this2._get3DCameraPositionAndVp(e.canvasX, e.canvasY);\n\n        if (_this2.cameraSelectionState.initialVp && !_this2.isFirstClick) {\n          _this2._addVpOverlay(_this2.cameraSelectionState.initialVp);\n        } else\n        if (tmpres && tmpres.pos) {\n          _this2._addVpOverlay(tmpres.vp);\n        } else\n        {\n          _this2.viewPortOverlay.removeOverlay();\n        }\n\n        _this2.cameraSelectionState.inViewport = _this2.isFirstClick && tmpres && tmpres.pos || !_this2.isFirstClick;\n        _this2.getCursor();\n\n        if (!_this2.cameraSelectionState.pending) {\n          return;\n        }\n\n        if (_this2.teleportationInProgress) {\n          // cancel position animation\n          _this2.cameraSelectorPosition.classList.remove('camera-selector-position--teleporting');\n          clearTimeout(_this2.teleportationInProgress);\n          _this2.teleportationInProgress = 0;\n        }\n\n        _this2.lastX = e.canvasX;\n        _this2.lastY = e.canvasY;\n        var dx = e.canvasX - _this2.cameraSelectionState.pos.x;\n        var dy = e.canvasY - _this2.cameraSelectionState.pos.y;\n        var angle = Math.atan2(dy, dx) * 180 / Math.PI;\n\n        // In case the mouse moved:\n        if (dx !== 0 || dy !== 0) {\n          // atan measures the angle to the x-axis, but the frustum gizmo is originally aligned with y.\n          angle += 90;\n        }\n\n        _this2.cameraSelector.style.transform = \"rotate(\".concat(angle, \"deg)\");\n\n        if (!_this2.options.teleportOnRelease) {\n          _this2.teleport();\n        }\n\n        //console.log(angle);\n        return true;\n      };\n\n      this.handleSingleTap = function (event) {\n        return this.handleSingleClick(event, true);\n      };\n\n      this.handleResize = function () {\n        // As teleportation is going to be rather short interaction with a short-living UI, we just do not handle screen resize at all for now, but deactivate tool instead.\n        _this2.options.triggerDeactivate();\n      };\n\n      this.handleSingleTap = function (event, button) {\n        if (_this2.isFirstClick) {\n          _this2.handleSingleClick(event);\n        } else {\n          _this2.handleMouseMove(event);\n        }\n      };\n\n      this.handleGesture = function (event) {\n        switch (event.type) {\n          case 'dragstart':\n            break;\n          case 'dragmove':\n            return _this2.handleMouseMove(event, 0);\n          case 'dragend':\n            return true;\n          case 'panmove':\n          case 'panstart':\n          case 'panend':\n          case 'pinchmove':\n          case 'pinchstart':\n          case 'pinchend':\n            return true;\n          default:\n            break;}\n\n\n        return false;\n      };\n    } }, { key: \"_recoverCursor\", value: function _recoverCursor()\n\n    {\n      this.cursor = null;\n      this.getCursor();\n    } }, { key: \"getCursor\", value: function getCursor()\n\n    {\n      if (this.cursor)\n      return this.cursor;\n      return this.cameraSelectionState.inViewport ? 'cell' : 'default';\n    } }, { key: \"_addVpOverlay\", value: function _addVpOverlay(\n\n    vp) {\n      this.viewPortOverlay.removeOverlay();\n      var vpRect = vp.getViewportBounds(this.viewer.model.getUnitScale());\n      var min = vpRect.min;\n      var max = vpRect.max;\n      this.viewPortOverlay.addOverlay(min.x, min.y, max.x, max.y);\n    }\n\n    // mode is only required for analytics purposes\n  }, { key: \"_runTeleportation\", value: function _runTeleportation(mode) {\n      // Use this event in order to show a loading spinner until the drop-me is done.\n      this.extension.dispatchEvent({ type: Autodesk.AEC.DropMeExtension.DROP_ME_STARTED_EVENT });\n\n      this._mapToCameraPositionIn3D(mode);\n\n      // Although _mapToCameraPositionIn3D runs async functions, we do want to call triggerDeactivate right now,\n      // Since it might take a few seconds until we'll get all the required data in order to load the 3D model.\n      // Until then, disable button until dropping into the 3D model.\n      this.options.triggerDeactivate(true);\n    } }, { key: \"_scheduleTeleportation\", value: function _scheduleTeleportation()\n\n    {var _this3 = this;\n      this.teleportationInProgress = setTimeout(function () {\n        _this3._runTeleportation(DROPME_MODE.auto);\n      }, 3000); // this timeout is alligned with coresponding rule of camera-selector-position css class\n    } }, { key: \"_cancelTeleportation\", value: function _cancelTeleportation()\n\n    {\n      if (this.teleportationInProgress) {\n        clearTimeout(this.teleportationInProgress);\n        this.teleportationInProgress = 0;\n      }\n    } }, { key: \"_createCameraSelectorUi\", value: function _createCameraSelectorUi(\n\n    pos) {\n      //console.log(`camera position at ${pos.x}, ${pos.y}`);\n      var _document = this.getDocument();\n      this.cameraSelectorBackground = _document.createElement('div');\n      this.cameraSelectorBackground.className = 'camera-selector-background';\n      this.viewer.container.appendChild(this.cameraSelectorBackground);\n      this.cameraSelectorBackground.style.top = \"\".concat(pos.y, \"px\");\n      this.cameraSelectorBackground.style.left = \"\".concat(pos.x, \"px\");\n\n      this.cameraSelectorPosition = _document.createElement('div');\n      this.cameraSelectorPosition.className = 'camera-selector-position';\n      this.viewer.container.appendChild(this.cameraSelectorPosition);\n      this.cameraSelectorPosition.style.top = \"\".concat(pos.y - 10, \"px\");\n      this.cameraSelectorPosition.style.left = \"\".concat(pos.x - 10, \"px\");\n\n      this.cameraSelector = _document.createElement('div');\n      this.cameraSelector.className = 'camera-selector';\n      this.viewer.container.appendChild(this.cameraSelector);\n      this.cameraSelector.style.top = \"\".concat(pos.y - 100, \"px\");\n      this.cameraSelector.style.left = \"\".concat(pos.x - 50, \"px\");\n    } }, { key: \"_destroyCameraSelectorUi\", value: function _destroyCameraSelectorUi()\n\n    {\n      if (this.viewer.container.contains(this.cameraSelector)) {\n        this.viewer.container.removeChild(this.cameraSelector);\n      }\n\n      if (this.viewer.container.contains(this.cameraSelectorBackground)) {\n        this.viewer.container.removeChild(this.cameraSelectorBackground);\n      }\n\n      if (this.viewer.container.contains(this.cameraSelectorPosition)) {\n        this.viewer.container.removeChild(this.cameraSelectorPosition);\n      }\n\n      this.cameraSelectionState = {\n        pending: false,\n        pos: null,\n        target: null,\n        inViewport: false,\n        initialVp: null };\n\n\n      this.isFirstClick = true;\n\n      this.viewPortOverlay.removeOverlay();\n    }\n\n    // Given F2D world coords (Vec3), this function returns the viewport that was hit.\n  }, { key: \"_findViewport\", value: function _findViewport(f2dWorldPos) {\n      var p2d = new THREE.Vector2(f2dWorldPos.x, f2dWorldPos.y);\n      var sheet = this.viewer.model;\n\n      // onlyTopViewPlans is currently true by default anyway, but it's better to explicitly put it here so it will be clear that we request only top view viewports.\n      var viewport = this.extension.viewportsExtension.findViewportAtPoint(sheet, p2d, { onlyTopViewPlans: true });\n\n      return viewport;\n    } }, { key: \"_mapToCameraPositionIn3DForFloorPlan\", value: function () {var _mapToCameraPositionIn3DForFloorPlan2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(\n\n      vp, pos, mode) {var _this$options$getMain, _this$options;var sheetNode, main3DNode, target, posGeorefed, dir, x, y, resTarget, targetGeorefed, dirX, dirY, rotAxis;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n                sheetNode = this.viewer.model.getDocumentNode();\n                main3DNode = (_this$options$getMain = (_this$options = this.options).getMain3DView) === null || _this$options$getMain === void 0 ? void 0 : _this$options$getMain.call(_this$options, sheetNode);\n\n                // Store target here before reaching to the async parts - to make sure that it won't get cleared until we'll need to use it.\n                target = this.cameraSelectionState.target;if (\n\n                main3DNode) {_context.next = 7;break;}_context.next = 6;return (\n                  vp.get3DNodesForViewport());case 6:main3DNode = _context.sent[0];case 7:\n\n\n                posGeorefed = pos;if (!\n\n                vp.isMatrixInLocalCoords()) {_context.next = 12;break;}_context.next = 11;return (\n                  this._applyModelToViewerTransform(pos, main3DNode));case 11:posGeorefed = _context.sent;case 12:\n\n\n                dir = new THREE.Vector3(0.0, 1.0, 0.0);\n\n                // in the case of not specified target, use north direction\n                if (!target) {_context.next = 26;break;}\n                x = target.x;\n                y = target.y;\n\n                resTarget = this._get3DCameraPositionAndVp(x, y, true);if (!(\n                resTarget && resTarget.pos)) {_context.next = 26;break;}\n                targetGeorefed = resTarget.pos;if (!\n\n                vp.isMatrixInLocalCoords()) {_context.next = 23;break;}_context.next = 22;return (\n                  this._applyModelToViewerTransform(resTarget.pos, main3DNode));case 22:targetGeorefed = _context.sent;case 23:\n\n\n                dirX = targetGeorefed.x - posGeorefed.x;\n                dirY = targetGeorefed.y - posGeorefed.y;\n\n                if (dirX !== 0 || dirY !== 0) {\n                  dir.setX(dirX).setY(dirY);\n                  dir.normalize();\n                }case 26:\n\n\n\n                // mimic natural looking direction which is not really parallel to the ground\n                rotAxis = new THREE.Vector3(-dir.y, dir.x, 0.0);\n                dir.applyAxisAngle(rotAxis, Math.PI / 18.0); // 10 degrees\n\n                this.onDrop(posGeorefed, dir, mode, main3DNode);case 29:case \"end\":return _context.stop();}}}, _callee, this);}));function _mapToCameraPositionIn3DForFloorPlan(_x, _x2, _x3) {return _mapToCameraPositionIn3DForFloorPlan2.apply(this, arguments);}return _mapToCameraPositionIn3DForFloorPlan;}()\n\n\n    // Notice that this path is currently not reachable, since `filterAndFlattenViewports` returns only topViewViewports by default.\n    // If a section viewport support is required in the future, just supply different flags to it.\n  }, { key: \"_mapToCameraPositionIn3DForSection\", value: function () {var _mapToCameraPositionIn3DForSection2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(vp, pos, mode) {var _this$options$getMain2, _this$options2;var sheetNode, main3DNode, posGeorefed, dir, rotAxis;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n                sheetNode = this.viewer.model.getDocumentNode();\n                main3DNode = (_this$options$getMain2 = (_this$options2 = this.options).getMain3DView) === null || _this$options$getMain2 === void 0 ? void 0 : _this$options$getMain2.call(_this$options2, sheetNode);if (\n\n                main3DNode) {_context2.next = 6;break;}_context2.next = 5;return (\n                  vp.get3DNodesForViewport());case 5:main3DNode = _context2.sent[0];case 6:\n\n\n                posGeorefed = pos;if (!\n                vp.isMatrixInLocalCoords()) {_context2.next = 11;break;}_context2.next = 10;return (\n                  this._applyModelToViewerTransform(pos, main3DNode));case 10:pos = _context2.sent;case 11:\n\n\n                // by default we are looking into the north direction, in this case \"into the screen\"\n                dir = new THREE.Vector3(0.0, 1.0, 0.0);\n\n                // mimic natural looking direction which is not really parallel to the ground\n                rotAxis = new THREE.Vector3(-dir.y, dir.x, 0.0);\n                dir.applyAxisAngle(rotAxis, Math.PI / 18.0); // 10 degrees\n\n                this.onDrop(posGeorefed, dir, mode, main3DNode);case 15:case \"end\":return _context2.stop();}}}, _callee2, this);}));function _mapToCameraPositionIn3DForSection(_x4, _x5, _x6) {return _mapToCameraPositionIn3DForSection2.apply(this, arguments);}return _mapToCameraPositionIn3DForSection;}()\n\n\n    // if we will come up with a good visualization widget for dir selection for \"Section\" views\n    // the two methods \"_mapToCameraPositionIn3DForFloorPlan()\" and \"_mapToCameraPositionIn3DForSection()\"\n    // could be unified. we will still have two cases in \"if (resTarget && resTarget.pos) {...}\" code path\n    //   1. FloorPlan: x,y - change, z - constant\n    //   2. Section:   x - changes, y,z - constant\n  }, { key: \"_mapToCameraPositionIn3D\", value: function _mapToCameraPositionIn3D() {var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DROPME_MODE.manual;\n      var x = this.cameraSelectionState.pos.x;\n      var y = this.cameraSelectionState.pos.y;\n      var resPos = this._get3DCameraPositionAndVp(x, y);\n\n      if (resPos && resPos.pos && resPos.vp) {\n        if (resPos.vp.isTopViewViewport()) {\n          this._mapToCameraPositionIn3DForFloorPlan(resPos.vp, resPos.pos, mode);\n        } else {\n          this._mapToCameraPositionIn3DForSection(resPos.vp, resPos.pos, DROPME_MODE.auto);\n        }\n\n      }\n    } }, { key: \"_get3DCameraPositionAndVp\", value: function _get3DCameraPositionAndVp(\n\n    x, y) {var useInitialVp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var vpVec = this.viewer.impl.clientToViewport(x, y);\n      var point = this.viewer.impl.intersectGroundViewport(vpVec);\n\n      // if no viewport can be found for the current mouse position on a second click, try to use initial viewport\n      var hitViewport = this._findViewport(point) || useInitialVp && this.cameraSelectionState.initialVp;\n      if (!hitViewport) {\n        // Clicked outside of the viewport\n        // DropMe tool remains active and allows user to pick another point\n        return null;\n      }\n\n      // Get unitScale for current sheet\n      var sheetUnitScale = this.viewer.model.getUnitScale();\n\n      // Apply 2D->3D transform to get 3D world coords\n      var vpTransform = hitViewport.get2DTo3DMatrix(sheetUnitScale);\n      var pWorld = point.clone().applyMatrix4(vpTransform);\n\n      // Derive z from level metadata\n      var level = hitViewport.findLevelForViewport();\n      var isFloorPlan = hitViewport.isFloorPlan();\n\n      // Only add additional 1.75m to a floorPlan viewport type.\n      // Other types not necessarily located at the floor height and changing their elevation might result in incorrect position.\n      if (level && isFloorPlan) {\n        var avatarHeight = 5.74147; // 1.75m\n        pWorld.z = level.elevation + avatarHeight;\n      }\n\n      return {\n        pos: pWorld,\n        vp: hitViewport };\n\n    }\n\n    // Default function that extracts refPointTransform from the root node.\n  }, { key: \"_applyModelToViewerTransform\", value: function () {var _applyModelToViewerTransform2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(pos, bubbleNode) {var vec, matrix, root;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n                vec = pos.clone();\n\n                // Skip refPoint transform if wanted\n                if (!this.options.useLocalModelCoords) {_context3.next = 3;break;}return _context3.abrupt(\"return\",\n                vec);case 3:if (!(\n\n\n\n\n                bubbleNode && this.options.getTransformForNode)) {_context3.next = 7;break;}_context3.next = 6;return (\n\n\n                  this.options.getTransformForNode(bubbleNode));case 6:matrix = _context3.sent;case 7:\n\n\n                if (!matrix) {\n                  // This extension requires AEC model data, so there should always be a refPoint tranform\n                  root = this.viewer.model.getDocumentNode().getRootNode();\n                  matrix = root.extractRefPointTransform();\n                }\n\n                vec.applyMatrix4(matrix);return _context3.abrupt(\"return\",\n\n                vec);case 10:case \"end\":return _context3.stop();}}}, _callee3, this);}));function _applyModelToViewerTransform(_x7, _x8) {return _applyModelToViewerTransform2.apply(this, arguments);}return _applyModelToViewerTransform;}() }]);return DropMeTool;}(av.ToolInterface);export { DropMeTool as default };\n\n\n\nGlobalManagerMixin.call(DropMeTool.prototype);","function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { aecModelDataToLevels } from '../levels/LevelUtils';\nimport DropMeExtension from './DropMe.js';\n\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\n/*\n                      //   This file contains the logic of choosing the right position to watch a selected object in the 3D scene.\n                      //   The logic of choosing the right position is created in steps:\n                      //   1) Creating 8 different positions around the selected object.\n                      //   2) Check if there are intersections between the optional positions to the selected object.\n                      //      Choose the ones which have the least intersections, and ignore positions which looks on very narrow sides of the object\n                      //      (like in doors and walls).\n                      //   3) From the chosen positions, check more intersections between the position and different points on the object.\n                      //      Choose the one with the least intersections. If there are more then one with the same - choose the closest.\n                      //   If this logic is happening after the geometry was already loaded, we check intersections with raycast and actual geometries.\n                      //   If it happens before geometry was loaded we will wait for the bounding-boxes and check intersections with them.\n                      //   \n                      //   While waiting for the geometry to load, there is an interval that is eliminating objects that are hiding the object during the\n                      //   waiting time.\n                      */var\n\nViewObjectIn3D = /*#__PURE__*/function () {\n\n  function ViewObjectIn3D(dropMeExt, viewer, options) {var _this = this;_classCallCheck(this, ViewObjectIn3D);\n\n    this.viewer = viewer;\n    this.dropMeExt = dropMeExt;\n    this.options = options;\n    this._onModelAdded = this._onModelAdded.bind(this);\n    this._onGeometryLoaded = this._onGeometryLoaded.bind(this);\n    this._onModelUnloaded = this._onModelUnloaded.bind(this);\n    this._onAggregatedSelectionChanged = this._onAggregatedSelectionChanged.bind(this);\n\n    this.viewer.registerContextMenuCallback('ViewObjectIn3D', function (menu, status) {\n      var is2d = _this.viewer.model.is2d();\n      var isSupported = _this.options.enableViewIn3d && _this.dropMeExt.isSupportedModel(_this.viewer.model);\n      var selected = isSupported && _this.viewer.getAggregateSelection();\n      if (is2d && selected && selected.length === 1 && selected[0].selection.length === 1) {\n        _this.pos3dFrom2d = _this._getSelected3dPosFrom2d(selected[0].selection[0], selected[0].model);\n        menu.push({\n          title: \"View in 3D\",\n          target: function target() {return _this.selectObject(selected[0].selection[0]);} });\n\n      }\n    });\n  }_createClass(ViewObjectIn3D, [{ key: \"selectObject\", value: function selectObject(\n\n    selectedObjectID) {\n      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._onModelAdded, { once: true });\n      this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this._onGeometryLoaded);\n      this.viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this._onModelUnloaded);\n      this.viewer.addEventListener(av.AGGREGATE_SELECTION_CHANGED_EVENT, this._onAggregatedSelectionChanged);\n      this.selectedObjectID = selectedObjectID;\n      this.dropMeExt.dispatchEvent({ type: DropMeExtension.OBJECT_SELECTED_EVENT, selectedObjectID: selectedObjectID });\n      if (this.options.onDrop) {var _this$options$getMain, _this$options;\n        var sheetNode = this.viewer.model.getDocumentNode();\n        var main3DNode = (_this$options$getMain = (_this$options = this.options).getMain3DView) === null || _this$options$getMain === void 0 ? void 0 : _this$options$getMain.call(_this$options, sheetNode);\n        this.options.onDrop(undefined, undefined, undefined, main3DNode);\n      }\n      avp.analytics.track('viewer.view_in_3d');\n    }\n\n    // If another object was selected while waiting for the model to load, stop other selections.\n  }, { key: \"_onAggregatedSelectionChanged\", value: function _onAggregatedSelectionChanged(selection) {\n      var selected = selection.selections && selection.selections.length === 1 && selection.selections[0];\n      var dbId = selected.dbIdArray && selected.dbIdArray.length === 1 && selected.dbIdArray[0];\n      if (dbId === this.selectedObjectID || !selection.selections.length) {\n        return;\n      }\n\n      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);\n      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this._onGeometryLoaded);\n      this.viewer.removeEventListener(av.AGGREGATE_SELECTION_CHANGED_EVENT, this._onAggregatedSelectionChanged);\n      this.chosenPos = null;\n      this.selectedObjectID = null;\n    } }, { key: \"_onModelAdded\", value: function _onModelAdded(_ref)\n\n    {var _this2 = this;var model = _ref.model;\n      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);\n\n      if (!this.selectedObjectID || !model.is3d()) {\n        return;\n      }\n\n      this._waitForAllModels().then(function () {return _this2._placeMeToObject();});\n    } }, { key: \"_onModelUnloaded\", value: function _onModelUnloaded()\n\n    {\n      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);\n    } }, { key: \"_placeMeToObject\", value: function _placeMeToObject()\n\n    {var _this3 = this;\n\n      this.isGeometryLoaded = this._loadingAllGeometriesDone();\n\n      // Get the objects bounding boxes\n      var boxes = this._getAllBoundingBoxes();\n      this.selectionBox = boxes[this.selectedObjectID];\n\n      if (!this.selectionBox) {\n        // In case the selected object doesn't have a bounding box, locate the camera\n        // based on the 2D position and size of the selected object.\n        if (this.pos3dFrom2d) {\n          // look forward along the y axis\n          var target = this.pos3dFrom2d.clone().add(new THREE.Vector3(0, 1, 0));\n          this.dropMeExt.dispatchEvent({\n            type: DropMeExtension.POSITION_FOUND_EVENT,\n            position: this.pos3dFrom2d,\n            target: target,\n            isPosFrom2dTo3dMatrix: true });\n\n          if (this.options.onHandleViewIn3D) {\n            this.options.onHandleViewIn3D(this.pos3dFrom2d, target, true);\n          }\n        }\n        return;\n      } else {\n        this._setBoundingBoxPoints();\n\n        // Separate the selected object's bounding box\n        this.selectionCenter = this.selectionBox.center();\n        delete boxes[this.selectedObjectID];\n      }\n\n      // Create 8 optional positions around the selected target\n      var optionalPositionsObjects = this._createCandidates();\n\n      // Create a list of relatively close objects, so we don't check intersections with\n      // un-relevant objects and decrease performance.\n      var closeBoxesKeys = this._getCloseBoxesKeys(boxes);\n\n      // Choose the position options which have the least interferences\n      var betterOptions = this._getBetterCandidates(optionalPositionsObjects, boxes, closeBoxesKeys);\n\n      // Choose the best option from the betterOptions\n      this.chosenPos = this._chooseBestCandidate(betterOptions, boxes, closeBoxesKeys);\n\n      // console.log('Chosen Position >> ', this.chosenPos.index, this.chosenPos);\n\n      var applySelectionCB = function applySelectionCB() {return _this3._applySelections(_this3.chosenPos);};\n      // Notify about the chosen position\n      this.dropMeExt.dispatchEvent({\n        type: DropMeExtension.POSITION_FOUND_EVENT,\n        position: this.chosenPos.position,\n        target: this.selectionCenter,\n        applySelectionCB: applySelectionCB });\n\n      if (this.options.onHandleViewIn3D) {\n        this.options.onHandleViewIn3D(this.chosenPos.position, this.selectionCenter, false, applySelectionCB);\n      }\n\n      if (!this.isGeometryLoaded) {\n        this._waitForAllInstanceTrees().then(function () {\n          _this3.hidingObjectInterval && clearInterval(_this3.hidingObjectInterval);\n          _this3.hidingObjectInterval = setInterval(function () {return _this3._hideCurrentIntersections();}, ViewObjectIn3D.HIDING_INTERVAL_FREQUENCY);\n        });\n      }\n    } }, { key: \"_getAllBoundingBoxes\", value: function _getAllBoundingBoxes()\n\n    {\n      var boxes = {};\n      var models = this.viewer.getVisibleModels();\n      for (var i = 0; i < models.length; i++) {\n        var fragmentList = models[i].getFragmentList();\n        boxes = Object.assign(boxes, this._getBoundingBoxes(fragmentList));\n      }\n      return boxes;\n    } }, { key: \"_getBoundingBoxes\", value: function _getBoundingBoxes(\n\n    fragmentList) {\n      var boxes = {};\n      var tmpBox = new THREE.Box3();\n      for (var fragId = 0; fragId < fragmentList.fragments.length; fragId++) {\n        var dbid = fragmentList.fragments.fragId2dbId[fragId];\n        if (!boxes[dbid]) {\n          boxes[dbid] = new THREE.Box3();\n        }\n        fragmentList.getWorldBounds(fragId, tmpBox);\n        boxes[dbid].union(tmpBox);\n      }\n\n      return boxes;\n    } }, { key: \"_createCandidates\", value: function _createCandidates()\n\n    {\n\n      var height = this._getHeight(this.selectionCenter.z);\n      this.maxDistance = Number.MIN_VALUE;\n\n      // Checks if the object has a very wide side relatively to it's other side so we can ignore\n      // angles that look at it from the narrower side.\n      var rightVec = this.viewer.navigation.getWorldRightVector();\n      var upVec = this.viewer.navigation.getWorldUpVector();\n      var frontVec = upVec.cross(rightVec);\n      var size = this.selectionBox.size();\n\n      var rightSide = Math.abs(size.clone().multiply(rightVec).length());\n      var frontSide = Math.abs(size.clone().multiply(frontVec).length());\n\n      var widerVector;\n      var wideSide = Math.max(rightSide, frontSide);\n      var narrowSide = Math.min(rightSide, frontSide);\n      if (wideSide / narrowSide > ViewObjectIn3D.COVERAGE_FACTOR)\n      widerVector = wideSide === rightSide ? rightVec : frontVec;\n\n      // Set the camera to be Perspective before calling this.viewer.navigation.computeFit\n      // so we will get the right positions for bimwalk.\n      this.viewer.navigation.toPerspective();\n\n      var options = [];\n      for (var index = 0; index < ViewObjectIn3D.NUMBER_OF_POSITION; ++index) {\n        var angle = index / (ViewObjectIn3D.NUMBER_OF_POSITION / 2) * Math.PI;\n\n        // get a positon that fits the the selected object to view\n        var newPos = this.selectionCenter.clone().add(new THREE.Vector3(Math.cos(angle), -Math.sin(angle), 0));\n        var fov = this.viewer.navigation.getVerticalFov();\n        var camera = this.viewer.getCamera();\n        var aspect = camera.aspect;\n        var optionalPositionObject = this.viewer.navigation.computeFit(newPos, this.selectionCenter, fov, this.selectionBox, aspect);var\n        position = optionalPositionObject.position;\n\n        // get the camera a bit further from the object\n        var direction = position.clone().sub(this.selectionCenter);\n        position.add(direction.clone().multiplyScalar(0.1));\n\n        // set the height\n        position.z = height;\n\n        // If the wider side dot eye vector is greater then 0.8 we would like to ignore this position. \n        var dot = widerVector && direction.normalize().dot(widerVector);\n        var ignore = dot && Math.abs(dot) > Math.cos(THREE.Math.degToRad(ViewObjectIn3D.IGNORE_ANGLE));\n\n        // create a ray from the optional position towards the selected target and compute distances\n        var newDiff = this.selectionCenter.clone().sub(position.clone());\n        var dir = newDiff.clone().normalize();\n        var ray = new THREE.Ray(position.clone(), dir.clone());\n        var intersectionPos = ray.intersectBox(this.selectionBox);\n        var distanceToTarget = intersectionPos && intersectionPos.sub(position).length();\n        var distanceToCenterTarget = newDiff.length();\n\n        // this.maxDistance is used to remove un-relevant objects from calculations to improve performance\n        this.maxDistance = Math.max(this.maxDistance, distanceToTarget, distanceToCenterTarget);\n\n        // When the bounding box's size is 0 in one or more dimensions, the ray can miss the object, and in that case we eliminate this option.\n        distanceToTarget && !ignore && options.push({\n          index: index,\n          position: position,\n          ray: ray,\n          distanceToTarget: distanceToTarget,\n          distanceToCenterTarget: distanceToCenterTarget,\n          selectionID: this.selectedObjectID,\n          intersections: [],\n          cornerIntersections: [],\n          cornerIntersectionsToHide: [] });\n\n      }\n\n      return options;\n    } }, { key: \"_getClientViewBoundingBox\", value: function _getClientViewBoundingBox(\n\n    camera) {\n      var clientBB = new THREE.Box3();\n      for (var k = 0; k < this.boundingBoxPoints.length; k++) {\n        var vec = this.boundingBoxPoints[k];\n        var point = this.viewer.impl.worldToClient(vec, camera);\n        if (clientBB.min.x > point.x) clientBB.min.x = point.x;\n        if (clientBB.max.x < point.x) clientBB.max.x = point.x;\n        if (clientBB.min.y > point.y) clientBB.min.y = point.y;\n        if (clientBB.max.y < point.y) clientBB.max.y = point.y;\n      }\n      return clientBB;\n    } }, { key: \"_setBoundingBoxPoints\", value: function _setBoundingBoxPoints()\n\n    {\n      this.boundingBoxPoints = [];\n      for (var k = 0; k < 8; k++) {\n        var vec = new THREE.Vector3();\n        vec.x = !!(k & 0x1) === false ? this.selectionBox.max.x : this.selectionBox.min.x;\n        vec.y = !!(k & 0x2) === false ? this.selectionBox.max.y : this.selectionBox.min.y;\n        vec.z = !!(k & 0x4) === false ? this.selectionBox.max.z : this.selectionBox.min.z;\n        this.boundingBoxPoints.push(vec);\n      }\n    } }, { key: \"_getCloseBoxesKeys\", value: function _getCloseBoxesKeys(\n\n    boxes) {var _this4 = this;\n      return Object.keys(boxes).filter(function (key) {\n        var center = boxes[key].center();\n        var diff = center.clone().sub(_this4.selectionCenter);\n        var dist = diff.length();\n        return dist < _this4.maxDistance * ViewObjectIn3D.DISTANCE_FACTOR;\n      });\n    }\n\n    // Choose the position options which have the least interferences\n  }, { key: \"_getBetterCandidates\", value: function _getBetterCandidates(optionalPositionsObjects, boxes, closeBoxesKeys) {var _this5 = this;\n\n      var betterOptions = [];\n      var minIntersects = Number.POSITIVE_INFINITY;var _loop = function _loop(\n\n      i) {\n        var posObj = optionalPositionsObjects[i];\n\n        // This check is done on the object's bounding boxes and is used in cases when the geometry is not loaded yet.\n        if (!_this5.isGeometryLoaded) {\n          // Intersections between the camera's position and the object's bounding box\n          posObj.intersections = _this5._getIntersectionsOfRayWithBoundingBoxes(posObj, posObj.ray, minIntersects, boxes, closeBoxesKeys);\n        } else {\n          var candidates = [];\n          posObj.intersections = [];\n          _this5.viewer.impl.rayIntersect(posObj.ray, false, false, false, candidates);\n          var distToObject = _this5._getClosestIntersectionWithSelectedObject(candidates);\n          if (!distToObject) {\n            // If no intersection with object, use the distance to it's center.\n            distToObject = posObj.distanceToCenterTarget;\n          } else {\n            // If there is an intersection with object - use it, instead of the not-always-accurate the distance to the bounding-box.\n            posObj.distanceToTarget = distToObject;\n          }\n\n          // Consider only intersections that are closer than the selected object's intersection.\n          candidates.forEach(function (item) {\n            if (item.dbId !== _this5.selectedObjectID && posObj.intersections.indexOf(item.dbId) === -1 && item.distance < distToObject) {\n              posObj.intersections.push(item.dbId);\n            }\n          });\n        }\n\n        // Make a list of the optional positions that have the least objects interfering\n        if (posObj.intersections.length === minIntersects) {\n          betterOptions.push(posObj);\n        } else if (posObj.intersections.length < minIntersects) {\n          betterOptions = [posObj];\n          minIntersects = posObj.intersections.length;\n        }};for (var i = 0; i < optionalPositionsObjects.length; ++i) {_loop(i);\n      }\n\n      return betterOptions;\n    }\n\n    // Choose the best option from the betterOptions\n  }, { key: \"_chooseBestCandidate\", value: function _chooseBestCandidate(betterOptions, boxes, closeBoxesKeys) {var _this6 = this;\n\n      var chosenPos;\n      var minIntersections = Number.MAX_VALUE;\n      betterOptions.forEach(function (posObj) {\n\n        chosenPos = chosenPos || posObj;\n\n        // Create rays from the optional position to 8 corenrs of the selected object's bounding box\n        // and store the intersections\n        for (var k = 0; k < _this6.boundingBoxPoints.length; k++) {\n          var vec = _this6.boundingBoxPoints[k];\n\n          // Choose a point that is slightly towards the center of the object\n          var offset = vec.clone().sub(_this6.selectionCenter).multiplyScalar(0.1);\n          vec.sub(offset);\n\n          // To Do: If geometry is already loaded: find a better way to choose more points on the object.\n\n          var dir = vec.clone().sub(posObj.position).normalize();\n          var ray = new THREE.Ray(posObj.position.clone(), dir);\n\n          var cornerIntersections = [];\n\n          if (!_this6.isGeometryLoaded) {\n            cornerIntersections = _this6._getIntersectionsOfRayWithBoundingBoxes(posObj, ray, minIntersections, boxes, closeBoxesKeys);\n          } else {var _ret = function () {\n              _this6.viewer.impl.rayIntersect(ray, false, false, false, cornerIntersections);\n              var distToObject = _this6._getClosestIntersectionWithSelectedObject(cornerIntersections);\n              // If no intersection with the selected object, don't check intersections with other objects for this corner.\n              if (!distToObject) {\n                return \"continue\";\n              }\n\n              // Consider only objects that are closer then the selected object's intersection.\n              cornerIntersections = cornerIntersections.filter(function (intersection) {return intersection.dbId !== _this6.selectedObjectID && intersection.distance <= distToObject;});\n              cornerIntersections = cornerIntersections.map(function (intersection) {return intersection.dbId;});}();if (_ret === \"continue\") continue;\n          }\n\n          // This list is made for help choosing the right position.\n          // Make the array of corner intersections to be of unique ones.\n          if (cornerIntersections.length) {var _posObj$cornerInterse;\n            (_posObj$cornerInterse = posObj.cornerIntersections).push.apply(_posObj$cornerInterse, _toConsumableArray(cornerIntersections));\n            posObj.cornerIntersections = _toConsumableArray(new Set(posObj.cornerIntersections));\n            // No need to continiune checking in case there are more intersections then the minimum (of the current chosen one).\n            if (posObj.cornerIntersections.length > minIntersections) break;\n          }\n\n          // This is a list of objects to hide in case this optional position will be chosen.\n          // We would like to hide only objects that were intersected with the front parts of the bounding box.\n          if (_this6.isGeometryLoaded) {\n            var vecDir = vec.clone().sub(_this6.selectionCenter);\n            var eyeDot = vecDir.dot(posObj.ray.direction);\n            if (eyeDot > 0 && cornerIntersections.length) {var _posObj$cornerInterse2;\n              (_posObj$cornerInterse2 = posObj.cornerIntersectionsToHide).push.apply(_posObj$cornerInterse2, _toConsumableArray(cornerIntersections));\n              posObj.cornerIntersectionsToHide = _toConsumableArray(new Set(posObj.cornerIntersections));\n            }\n          }\n        }\n\n        var count = posObj.cornerIntersections.length;\n        if (_this6._isInsideOtherObject(posObj, boxes, closeBoxesKeys)) {\n          count++;\n        }\n\n        // Choose the option with the least corner intersections.\n        // If it is the same, choose the one that is closest to the center of the object.\n        // If it is the same, choose the one that is closer to intersection with the object / it's boundng-box.\n        if (count < minIntersections) {\n          minIntersections = count;\n          chosenPos = posObj;\n        } else if (count === minIntersections) {\n          if (posObj.distanceToCenterTarget === chosenPos.distanceToCenterTarget) {\n            if (posObj.distanceToTarget < chosenPos.distanceToTarget) {\n              chosenPos = posObj;\n            }\n          } else if (posObj.distanceToCenterTarget < chosenPos.distanceToCenterTarget) {\n            chosenPos = posObj;\n          }\n        }\n      });\n\n      return chosenPos;\n    } }, { key: \"_getIntersectionsOfRayWithBoundingBoxes\", value: function _getIntersectionsOfRayWithBoundingBoxes(\n\n    candidate, ray, minimumIntersections, boxes, keys) {\n      var intersections = [];\n      var l = keys.length;\n\n      for (var i = 0; i < l; ++i)\n      {\n        var dbid = keys[i];\n        var box = boxes[dbid];\n        var parsedDbId = parseInt(dbid);\n        var vec = box && ray.intersectBox(box);\n        var distToBox = vec && candidate.position.clone().sub(vec).length();\n\n        if (distToBox) {\n          if (distToBox < candidate.distanceToTarget) {\n            intersections.push(parsedDbId);\n            if (intersections.length > minimumIntersections) break;\n          }\n        }\n      }\n\n      return intersections;\n    } }, { key: \"_isInsideOtherObject\", value: function _isInsideOtherObject(\n\n    candidate, boxes, dbids) {\n      for (var i = 0; i < dbids.length; ++i)\n      {\n        var dbid = dbids[i];\n        var box = boxes[dbid];\n        var isContain = box.containsPoint(candidate.position);\n        if (isContain)\n        return true;\n      }\n\n      return false;\n    } }, { key: \"_getClosestIntersectionWithSelectedObject\", value: function _getClosestIntersectionWithSelectedObject(\n\n    intersections) {var _this7 = this;\n      var selectionDist = intersections.filter(function (intersection) {return intersection.dbId === _this7.selectedObjectID;});\n      var min = Number.MAX_VALUE;\n      if (!selectionDist[0]) {\n        return null;\n      }\n      for (var j = 0; j < selectionDist.length; j++) {\n        if (selectionDist[j].distance < min) {\n          min = selectionDist[j].distance;\n        }\n      }\n      return min;\n    } }, { key: \"_hideCurrentIntersections\", value: function _hideCurrentIntersections(\n\n    withCorners) {\n\n      if (!this.chosenPos) {\n        return;\n      }\n\n      var needsUpdate = false;\n      var candidates = [];\n      this.viewer.impl.rayIntersect(this.chosenPos.ray, false, false, false, candidates);\n      needsUpdate = this._hideIntersectionsCandidates(candidates, true);\n\n      // When geometry finnished loading we will check intersections towards the corners of object\n      if (withCorners) {\n        needsUpdate = this._hideCornersIntersections() || needsUpdate;\n      }\n\n      if (needsUpdate) {\n        this.viewer.impl.invalidate(true, true, true);\n      }\n    } }, { key: \"_hideCornersIntersections\", value: function _hideCornersIntersections()\n\n    {\n      var needsUpdate = false;\n      for (var k = 0; k < this.boundingBoxPoints.length; k++) {\n        var vec = this.boundingBoxPoints[k];\n        for (var i = 0; i < ViewObjectIn3D.NUMBER_OF_CORNER_INTERSECTIONS; i++) {\n          var cornerCandidates = [];\n          var offset = vec.clone().sub(this.selectionCenter).multiplyScalar(i / ViewObjectIn3D.NUMBER_OF_CORNER_INTERSECTIONS);\n          vec.sub(offset);\n          var dir = vec.clone().sub(this.chosenPos.position).normalize();\n          var ray = new THREE.Ray(this.chosenPos.position.clone(), dir);\n          this.viewer.impl.rayIntersect(ray, false, false, false, cornerCandidates);\n\n          needsUpdate = this._hideIntersectionsCandidates(cornerCandidates) || needsUpdate;\n        }\n      }\n\n      return needsUpdate;\n    } }, { key: \"_hideIntersectionsCandidates\", value: function _hideIntersectionsCandidates(\n\n    candidates, isCenterIntersection) {\n      var length = candidates.length;\n      var needsUpdate = false;\n      var distToObject;\n      if (length > 1) {\n        distToObject = this._getClosestIntersectionWithSelectedObject(candidates);\n        if (isCenterIntersection && distToObject && !this._isSelected(this.selectedObjectID) && this.allTreesLoaded()) {\n          this.viewer.select(this.selectedObjectID);\n        }\n        if (isCenterIntersection || distToObject) {\n          for (var i = 0; i < length; i++) {\n            var item = candidates[i];\n            if (item.dbId !== this.selectedObjectID && item.distance < (distToObject || this.chosenPos.distanceToCenterTarget)) {\n              this.viewer.hide(item.dbId);\n              needsUpdate = true;\n            }\n          }\n        }\n      }\n      return needsUpdate;\n    } }, { key: \"_isSelected\", value: function _isSelected(\n\n    dbId) {\n      var models = this.viewer.getVisibleModels();\n      for (var i = 0; i < models.length; ++i) {\n        if (models[i].selector.isSelected(dbId)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // Select the selected object and hide the covering objects\n  }, { key: \"_applySelections\", value: function _applySelections(chosenPos) {\n\n      if (!chosenPos || !this.allTreesLoaded()) {\n        return;\n      }\n\n      if (!this._isSelected(chosenPos.selectionID)) {\n        this.viewer.select(chosenPos.selectionID);\n      }\n\n      if (this.isGeometryLoaded) {\n        this._hideCurrentIntersections(true);\n      } else {\n\n        for (var i = 0; i < chosenPos.intersections.length; ++i) {\n          this.viewer.hide(chosenPos.intersections[i]);\n        }\n\n        for (var _i = 0; _i < chosenPos.cornerIntersectionsToHide.length; ++_i) {\n          this.viewer.hide(chosenPos.cornerIntersectionsToHide[_i]);\n        }\n      }\n    }\n\n    // get camera's position height from level's height + avatar's height\n  }, { key: \"_getHeight\", value: function _getHeight(elevation) {\n      var units = this.viewer.model.getData().metadata['distance unit'].value || 'foot';\n      var unitScale = Autodesk.Viewing.Private.convertUnits(units, 'm', 1, 1);\n      var avatarHeight = 1.8 / unitScale; // this.bimwalkExt.tool.navigator.get('cameraDistanceFromFloor')\n\n      var aec = this.viewer.model.getDocumentNode().getAecModelData();\n      var placementTf = this.viewer.model.myData.placementWithOffset;\n\n      var floors = aecModelDataToLevels(aec, placementTf);\n      if (!floors.length) {\n        return this.selectionBox.min.z + avatarHeight;\n      }\n\n      var level;\n      if (elevation < floors[0].zMin) {\n        level = floors[0];\n      } else\n      if (elevation > floors[floors.length - 1].zMax) {\n        level = floors[floors.length - 1];\n      } else\n      {\n        level = floors.find(function (f) {return f.zMin <= elevation && f.zMax >= elevation;});\n      }\n\n      return level.zMin + avatarHeight;\n    } }, { key: \"_pending3DLoaders\", value: function _pending3DLoaders()\n\n    {\n      return !!this.viewer.impl.loaders.filter(function (loader) {return loader.is3d();}).length;\n    } }, { key: \"_loadingAllGeometriesDone\", value: function _loadingAllGeometriesDone()\n\n    {\n      var models = this.viewer.getVisibleModels();\n      for (var i = 0; i < models.length; ++i) {\n        var loaded = models[i].isLoadDone();\n        if (!loaded) {\n          return false;\n        }\n      }\n      return !this._pending3DLoaders();\n    } }, { key: \"_waitForAllModels\", value: function _waitForAllModels()\n\n    {var _this8 = this;\n\n      return new Promise(function (resolve, reject) {\n\n        var allRootModelLoaded = function allRootModelLoaded() {\n          var models = _this8.viewer.getVisibleModels();\n          for (var i = 0; i < models.length; ++i) {\n            if (!models[i].modelRootLoaded) {\n              return false;\n            }\n          }\n          return !_this8._pending3DLoaders();\n        };\n\n        var cb = function cb(event) {\n          if (allRootModelLoaded()) {\n            resolve();\n          } else {\n            _this8.viewer.addEventListener(av.MODEL_ROOT_LOADED_EVENT, cb, { once: true });\n          }\n        };\n\n        cb();\n      });\n    } }, { key: \"allTreesLoaded\", value: function allTreesLoaded()\n\n    {\n      var models = this.viewer.getVisibleModels();\n      for (var i = 0; i < models.length; ++i) {\n        if (!models[i].getInstanceTree()) {\n          return false;\n        }\n      }\n      return !this._pending3DLoaders();\n    } }, { key: \"_waitForAllInstanceTrees\", value: function _waitForAllInstanceTrees()\n\n    {var _this9 = this;\n\n      return new Promise(function (resolve, reject) {\n\n        var cb = function cb(event) {\n          if (_this9.allTreesLoaded()) {\n            resolve();\n          } else {\n            _this9.viewer.addEventListener(av.OBJECT_TREE_CREATED_EVENT, cb, { once: true });\n          }\n        };\n\n        cb();\n      });\n    } }, { key: \"_onGeometryLoaded\", value: function _onGeometryLoaded()\n\n    {var _this10 = this;\n\n      if (!this._loadingAllGeometriesDone()) {\n        return;\n      }\n\n      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this._onGeometryLoaded);\n      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);\n\n      if (!this.selectedObjectID || !this.chosenPos) {\n        return;\n      }\n\n      // In case gemotry was loaded before the instance tree, it will not be possible to select the object.\n      // We will wait until the instance tree is loaded in order to select the object.\n      this._waitForAllInstanceTrees().then(function () {\n\n        // Select the right object again (clearSelection is called onGeometryLoaded)\n        _this10.viewer.clearSelection();\n        if (!_this10._isSelected(_this10.selectedObjectID)) {\n          _this10.viewer.select(_this10.selectedObjectID);\n        }\n\n        // Now that the geometey is loaded we can check with a raycast if objects have to be hidden\n        _this10._hideCurrentIntersections(true);\n\n        _this10.viewer.impl.invalidate(true, true, true);\n\n        _this10.chosenPos = null;\n        _this10.selectedObjectID = null;\n      });\n    }\n\n    // In cases the object is does not exist in the 3d view, we will locate the camera on the coordinations\n    // taken based on the 2d position of the selected object.\n  }, { key: \"_getSelected3dPosFrom2d\", value: function _getSelected3dPosFrom2d(selectedID, model) {\n      var bounds = this.viewer.impl.computeSelectionBounds([selectedID], model);\n      var point = this.viewer.impl.worldToClient(bounds.center());\n      var obj = this.dropMeExt.dropMeTool._get3DCameraPositionAndVp(point.x, point.y);\n      return obj && obj.pos;\n    } }]);return ViewObjectIn3D;}();\n\n\n// The frequency of checking objects to hide.\nexport { ViewObjectIn3D as default };ViewObjectIn3D.HIDING_INTERVAL_FREQUENCY = 300;\n\n// When geometry is already loaded we want to check intersections so we can hide them.\n// In order to hide as much covering objects as possible we take the 8 bounding box's corners and\n// raycast towards NUMBER_OF_CORNER_INTERSECTIONS points on the way between the center and the corners\nViewObjectIn3D.NUMBER_OF_CORNER_INTERSECTIONS = 10;\n\n// In order to reduce calculations of rey-box intersections we remove from the iteration boxes that are far away\n// from the chosen object (more than DISTANCE_FACTOR times the the distance between the camera and the object)\nViewObjectIn3D.DISTANCE_FACTOR = 3;\n\n// In case of narrow objects like doors and walls, when one side is wider then the other by more then COVERAGE_FACTOR times\n//  we would like to ignore positions that looks at the object from its narrow side.\nViewObjectIn3D.COVERAGE_FACTOR = 4.0;\n\n// When the angle between the camera's direction and to wider side of the object is less hen IGNORE_ANGLE dgrees\n// Ignore this position\nViewObjectIn3D.IGNORE_ANGLE = 35;\n\n// The number of position candidates we create around the chosen object.\nViewObjectIn3D.NUMBER_OF_POSITION = 8;","'use strict';function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\n\nvar av = Autodesk.Viewing,avp = av.Private;var\n\nViewPortOverlay = /*#__PURE__*/function () {\n  function ViewPortOverlay(viewer) {_classCallCheck(this, ViewPortOverlay);\n    this.viewer = viewer;\n    this.overlayName = 'DropMeViewPortOverlay';\n  }_createClass(ViewPortOverlay, [{ key: \"addOverlay\", value: function addOverlay(\n\n    xMin, yMin, xMax, yMax) {\n      this.viewer.impl.createOverlayScene(this.overlayName);\n\n      var mesh = this._createMesh(xMin, yMin, xMax, yMax);\n      this.viewer.impl.addOverlay(this.overlayName, mesh);\n    } }, { key: \"removeOverlay\", value: function removeOverlay()\n\n    {\n      this.viewer.impl.removeOverlayScene(this.overlayName);\n    } }, { key: \"_createMesh\", value: function _createMesh(\n\n    xMin, yMin, xMax, yMax) {\n      var vpId = 0;\n      var dbId = -1;\n      var layer = 0;\n      var borderColor = 0x99d79606;\n      var lineWidth = 0.1;\n      var totalDist = 0;\n\n      var vbb = new avp.VertexBufferBuilder(false, undefined, 4);\n\n      // add border\n      vbb.addSegment(xMin, yMin, xMax, yMin, totalDist, lineWidth, borderColor, dbId, layer, vpId);\n      vbb.addSegment(xMax, yMin, xMax, yMax, totalDist, lineWidth, borderColor, dbId, layer, vpId);\n      vbb.addSegment(xMax, yMax, xMin, yMax, totalDist, lineWidth, borderColor, dbId, layer, vpId);\n      vbb.addSegment(xMin, yMax, xMin, yMin, totalDist, lineWidth, borderColor, dbId, layer, vpId);\n\n      var meshData = vbb.toMesh();\n      var mdata = {\n        mesh: meshData,\n        is2d: true,\n        packId: '0',\n        meshIndex: 1 };\n\n\n      avp.BufferGeometryUtils.meshToGeometry(mdata);\n      var geom = mdata.geometry;\n\n      var materialParams = {\n        skipEllipticals: true,\n        skipCircles: true,\n        skipTriangleGeoms: true,\n        useInstancing: false };\n\n\n      var matman = this.viewer.impl.matman();\n      var matName = matman.create2DMaterial(this.viewer.impl.model, materialParams);\n      var material = matman.findMaterial(this.viewer.impl.model, matName);\n\n      var mesh = new THREE.Mesh(geom, material);\n      return mesh;\n    } }]);return ViewPortOverlay;}();export { ViewPortOverlay as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import AecData from '../common/AecModelData.js';\nimport { chooseMainModel } from \"../levels/LevelUtils\";\n\nvar LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';\n\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar extensionName = 'Autodesk.AEC.Hypermodeling';\n\n/**\n                                                   * The hypermodeling extension allows placing Revit 2D sheets at their correct location in the 3D model\n                                                   * This relies on the 2D-3D transform available from AEC model data, and as such is limited to a certain\n                                                   * type of sheets, namely floor plans (see {@link supports2DTo3DTransform})\n                                                   *\n                                                   * Future work: allow placing any sheet (such as PDFs) manually\n                                                   *              Open the 3D model from the sheet model (inverse workflow from the current one)\n                                                   */var\nHypermodelingExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(HypermodelingExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(HypermodelingExtension);\n  function HypermodelingExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, HypermodelingExtension);\n    _this = _super.call(this, viewer, options);\n\n    _this.loadedSheets = {};\n    _this.sheetsPerLevelCache = {};\n    _this.zPositionPerLevel = {};\n    _this.onModelRootLoaded = _this.onModelRootLoaded.bind(_assertThisInitialized(_this));\n    _this.onModelChanged = _this.onModelChanged.bind(_assertThisInitialized(_this));return _this;\n  }_createClass(HypermodelingExtension, [{ key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var model3D;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n\n\n\n\n                  this.viewer.loadExtension(LEVEL_EXT));case 2:this.levelExtension = _context.sent;\n\n                this.addListeners();\n\n                // Currently this extension works only for extending a 3D model with 2D sheets.\n                // Could be extended to support the opposite workflow.\n                model3D = chooseMainModel(this.viewer);\n                this.init(model3D);return _context.abrupt(\"return\",\n\n                true);case 7:case \"end\":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"onModelChanged\", value: function onModelChanged(_ref)\n\n\n    {var model = _ref.model;\n      if (model.is2d()) {\n        return;\n      }\n\n      var model3D = chooseMainModel(this.viewer);\n      if (model3D !== this.model3D) {\n        this.unloadAll();\n        this.init(model3D);\n      }\n    } }, { key: \"init\", value: function init(\n\n    model3D) {\n      this.loadedSheets = {};\n      this.sheetsPerLevelCache = {};\n      this.zPositionPerLevel = {};\n      this.floorSelector = this.levelExtension.floorSelector;\n\n      this.model3D = model3D;\n      if (!model3D) {\n        return;\n      }\n\n      this.rootNode = this.model3D.getDocumentNode().getRootNode();\n      this.document = this.rootNode.getDocument();\n      this.aec = this.rootNode.getAecModelData();\n    } }, { key: \"unload\", value: function unload()\n\n    {\n      this.removeListeners();\n\n      this.unloadAll();\n\n      this.floorSelector = null;\n      this.model3D = null;\n      this.rootNode = null;\n      this.document = null;\n      this.aec = null;\n\n      return true;\n    } }, { key: \"addListeners\", value: function addListeners()\n\n    {\n      this.viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, this.onModelRootLoaded);\n      this.viewer.addEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.onModelChanged);\n      this.viewer.addEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.onModelChanged);\n    } }, { key: \"removeListeners\", value: function removeListeners()\n\n    {\n      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, this.onModelRootLoaded);\n      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.onModelChanged);\n      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.onModelChanged);\n    } }, { key: \"getHashNameForViewportAndLevel\", value: function getHashNameForViewportAndLevel(\n\n    viewport, levelIndex) {\n      return viewport.viewportGuid + '.' + levelIndex;\n    } }, { key: \"onModelRootLoaded\", value: function onModelRootLoaded(_ref2)\n\n    {var model = _ref2.model;\n      if (model.is3d()) {\n        return;\n      }\n\n      // Since this is an async event, and multiple sheets might be loading at the same time, have to make sure\n      // we get the relevant level data for the correct one.\n      var hash = model.loader.options.customHash;\n      var loadedSheet = this.loadedSheets[hash];\n      if (!loadedSheet || !loadedSheet.loading) {\n        Autodesk.Viewing.Private.logger.warn('Model root loaded called for sheet not being loaded');\n        return;\n      }\n\n      // Only after the model root has being loaded can we fetch the unit scale.\n      // And this is just in time to set the placement transform before it's used\n      // to create the meshes.\n      var sheetUnitScale = model.getUnitScale();\n      var vpTransform = AecData.get2DTo3DMatrix(loadedSheet.viewport, sheetUnitScale);\n\n      var level = this.floorSelector.floorData[loadedSheet.levelIndex];\n\n      var placementTf = this.model3D.getModelToViewerTransform();\n      if (placementTf) {\n        vpTransform.multiplyMatrices(placementTf, vpTransform);\n      }\n      // Move an inch so it matches the floor. Reverses the hack in LevelUtils.js.\n      // Add another tenth of an inch to avoid z-fighting with the floor (no particular reason for this number,\n      // might be possible to lower it)\n      // Add another small value per level to avoid z-fighting in overlapping sheets\n      if (!this.zPositionPerLevel.hasOwnProperty(loadedSheet.levelIndex)) {\n        this.zPositionPerLevel[loadedSheet.levelIndex] = 0;\n      } else {\n        this.zPositionPerLevel[loadedSheet.levelIndex] += 0.001;\n      }\n      var zOffsetHack = 1 / 12 + 1 / 120 + this.zPositionPerLevel[loadedSheet.levelIndex];\n\n      var pos = new THREE.Vector3();\n      pos.setFromMatrixPosition(vpTransform);\n      //The level's zMin already contains the transform, so it's ok to overwrite.\n      pos.z = level.zMin + zOffsetHack;\n      vpTransform.setPosition(pos);\n\n      model.setPlacementTransform(vpTransform);\n    }\n\n    /**\n       * Returns the sheets available for the desired level index.\n       * @param {number} levelIndex\n       * @returns {array} - the sheets corresponding to the input level index\n       */ }, { key: \"getAvailableSheetsForLevel\", value: function getAvailableSheetsForLevel(\n    levelIndex) {var _this2 = this;\n      if (this.sheetsPerLevelCache[levelIndex]) {\n        return this.sheetsPerLevelCache[levelIndex];\n      }\n\n      var level = this.floorSelector.floorData[levelIndex];\n\n      var viewports = AecData.findViewportsForLevel(this.aec, level.guid);\n\n      viewports = viewports.filter(AecData.supports2DTo3DTransform);\n\n      if (viewports.length === 0) {\n        Autodesk.Viewing.Private.logger.warn('No supported viewports for current level');\n        return [];\n      }\n\n      var sheets = [];\n      var box = new THREE.Box3();\n\n      viewports.forEach(function (viewport) {\n        var geometries = _this2.rootNode.search({ type: 'geometry', role: '2d', guid: viewport.sheetGuid });\n        if (geometries.length) {\n          box.set(viewport.sectionBox.min, viewport.sectionBox.max);\n          var transform = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(viewport.sectionBox.transform);\n          box.applyMatrix4(transform);\n          var size = box.size();\n          sheets.push({ viewport: viewport, node: geometries[0], boxSize: size.x * size.y });\n        }\n      });\n\n      // Sort viewports by size, give priority to one with largest extent\n      // This might not work well in the future because it depends on the sectionBox being correct, and this is only\n      // true when `isCropBoxActive` is set during export from Revit. Right now this is the only supported situation\n      // (see supports2DTo3DTransform), but it might change in the future.\n      // TODO make sorting an option (with maybe other types of sort such as title)\n      sheets.sort(function (a, b) {return b.boxSize - a.boxSize;});\n\n      this.sheetsPerLevelCache[levelIndex] = sheets;\n\n      return sheets;\n    }\n\n    /**\n       * Loads a sheet corresponding to a level\n       * @param {number} levelIndex\n       * @param {number} [sheetIndex=0] - the index of the sheet according to the order returned by {@link getAvailableSheetsForLevel}\n       * @param {function} [cb=null] - an optional callback to run after the sheet has been loaded\n       */ }, { key: \"loadSheetFromLevel\", value: function loadSheetFromLevel(\n    levelIndex) {var _this3 = this;var sheetIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var sheets = this.getAvailableSheetsForLevel(levelIndex);\n\n      if (!sheets.length) {\n        return;\n      }\n\n      var selectedSheet = sheets[sheetIndex];\n      var hash = this.getHashNameForViewportAndLevel(selectedSheet.viewport, levelIndex);\n      var node = selectedSheet.node;\n\n      if (this.loadedSheets[hash]) {\n        var loadedSheet = this.loadedSheets[hash];\n        if (!loadedSheet.loading) {\n          // If already loaded just make sure sheet is visible\n          this.viewer.showModel(loadedSheet.model);\n        }\n        cb && cb({ hash: hash, model: loadedSheet.model });\n        return;\n      }\n\n      var options = {\n        isAEC: true,\n        useConsolidation: false,\n        preserveView: true,\n        keepCurrentModels: true,\n        disable3DModelLayers: true,\n        disablePrecomputedNodeBoxes: true,\n        noShadow: true,\n        doNotCut: true,\n        customHash: hash };\n\n\n      if (this.options.hidePaper) {\n        options.modelSpace = true;\n        options.bgColor = 0x0;\n      }\n\n      this.loadedSheets[hash] = { node: node, levelIndex: levelIndex, sheetIndex: sheetIndex, viewport: selectedSheet.viewport, loading: true };\n\n      this.viewer.loadDocumentNode(this.document, node, options).then(function (model) {\n        // Check if sheet hasn't been unloaded in the meantime\n        if (!_this3.loadedSheets[hash]) {\n          cb && cb({});\n          return;\n        }\n\n        _this3.loadedSheets[hash].loading = false;\n        _this3.loadedSheets[hash].model = model;\n        // When loading the 2D sheet on a 3D model, the visible bounds z length is larger than it should be\n        // Force a recalculation so that we get a correct value (needed for the SheetRenderContext)\n        model.invalidateBBoxes();\n        cb && cb({ hash: hash, model: model });\n      });\n    } }, { key: \"findLoadedSheetsFromLevelIndex\", value: function findLoadedSheetsFromLevelIndex(\n\n    levelIndex) {\n      var ret = []; // There might be more than one sheet loaded per level\n      for (var sheet in this.loadedSheets) {\n        if (this.loadedSheets[sheet].levelIndex === levelIndex) {\n          ret.push(sheet);\n        }\n      }\n\n      return ret;\n    } }, { key: \"findLoadedSheetFromLevelAndSheetIndex\", value: function findLoadedSheetFromLevelAndSheetIndex(\n\n    levelIndex, sheetIndex) {\n      for (var sheet in this.loadedSheets) {\n        if (this.loadedSheets[sheet].levelIndex === levelIndex && this.loadedSheets[sheet].sheetIndex === sheetIndex) {\n          return sheet;\n        }\n      }\n    } }, { key: \"unloadSheet\", value: function unloadSheet(\n\n    hash) {\n      var sheet = this.loadedSheets[hash];\n      if (!sheet) {\n        return;\n      }\n\n      this.viewer.unloadDocumentNode(sheet.node);\n      delete this.loadedSheets[hash];\n    } }, { key: \"hideModel\", value: function hideModel(\n\n    hash) {\n      var sheet = this.loadedSheets[hash];\n\n      if (sheet) {\n        if (sheet.model) {\n          this.viewer.hideModel(sheet.model);\n        } else if (sheet.loading) {\n          this.unloadSheet(hash);\n        }\n      }\n    } }, { key: \"hideSheetFromLevel\", value: function hideSheetFromLevel(\n\n    levelIndex, sheetIndex) {\n      var sheet = this.findLoadedSheetFromLevelAndSheetIndex(levelIndex, sheetIndex);\n      if (sheet) {\n        this.hideModel(sheet);\n      }\n    } }, { key: \"hideAllSheetsFromLevel\", value: function hideAllSheetsFromLevel(\n\n    levelIndex) {var _this4 = this;\n      var sheets = this.findLoadedSheetsFromLevelIndex(levelIndex);\n      sheets.forEach(function (sheet) {\n        _this4.hideModel(sheet);\n      });\n    } }, { key: \"unloadSheetsFromLevel\", value: function unloadSheetsFromLevel(\n\n    levelIndex) {var _this5 = this;\n      var sheets = this.findLoadedSheetsFromLevelIndex(levelIndex);\n      sheets.forEach(function (sheet) {\n        _this5.unloadSheet(sheet);\n      });\n    } }, { key: \"unloadAll\", value: function unloadAll()\n\n    {\n      for (var sheet in this.loadedSheets) {\n        this.viewer.unloadDocumentNode(this.loadedSheets[sheet].node);\n      }\n\n      this.loadedSheets = {};\n    } }]);return HypermodelingExtension;}(Autodesk.Viewing.Extension);export { HypermodelingExtension as default };\n\n\nnamespace.HypermodelingExtension = HypermodelingExtension;\nAutodesk.Viewing.theExtensionManager.registerExtension(extensionName, HypermodelingExtension);","'use strict';\n\n// Each one of these CSS imports gets injected into the HTML's headers inside its own <style>.\nimport CSS_1 from './ui/ListPanel.css';\nimport CSS_2 from './DropMe/DropMe.css';\nimport CSS_3 from './CanvasBookmark/CanvasBookmark.css';\n\nimport FloorSelector from './levels/FloorSelector.js';\nimport LevelsExtension from './levels/LevelsExtension.js';\nimport HyperlinkTracker from './hyperlinks/HyperlinkTracker.js';\nimport HyperlinkExtension from './hyperlinks/HyperlinkExtension.js';\nimport { ListPanel, ListPanelEvents } from './ui/ListPanel';\nimport DropMeExtension from './DropMe/DropMe.js';\nimport CanvasBookmarkExtension from './CanvasBookmark/CanvasBookmark.js';\nimport Minimap3DExtension from './Minimap3D/Minimap3D.js';\nimport Hypermodeling from \"./Hypermodeling/Hypermodeling\";\nimport AecModelData from './common/AecModelData.js';\nimport Locations from './Locations/index.js';\nimport AvatarExtension from './Avatar/AvatarExtension.js';\nimport SheetSyncExtension from './SheetSync/SheetSyncExtension.js';\nimport TopViewRendererExtension from './SheetSync/TopViewRenderer';\nimport ViewportsExtension from './Viewports/ViewportsExtension.js';\n\nexport {\nFloorSelector,\nListPanel,\nListPanelEvents,\nLevelsExtension,\nHyperlinkTracker,\nHyperlinkExtension,\nDropMeExtension,\nCanvasBookmarkExtension,\nMinimap3DExtension,\nAecModelData,\nLocations,\nAvatarExtension,\nSheetSyncExtension,\nTopViewRendererExtension,\nHypermodeling,\nViewportsExtension };","import { Shape } from '../../Edit2D/EditShapes';\n\n// Return true if locationA is a descendant of locationB.\nfunction isDescendant(locationA, locationB) {\n  if (!locationA || !locationB) {\n    return false;\n  }\n\n  if (locationA === locationB) {\n    return true;\n  }\n\n  return isDescendant(locationA.parent, locationB);\n};\n\n// Given a point and location list, return all the locations that the point is inside of them.\nexport function getPointLocations(point, locations) {\n  var candidates = [];\n\n  // For each location on the list, check if we have an intersection.\n  // In case of overlap, push both candidates.\n  for (var i = 0; i < locations.length; i++) {\n    var location = locations[i];\n\n    if (location.polygon.hitTest(point.x, point.y)) {\n      candidates.push(location);\n    }\n  }\n\n  // If one candidate is a parent of another, keep only the descendant.\n  for (var _i = 0; _i < candidates.length - 1; _i++) {\n    for (var j = _i + 1; j < candidates.length; j++) {\n      if (isDescendant(candidates[_i], candidates[j])) {\n        // Note the we remove the location node only from the candidates array - we are not deleting the parent itself.\n        candidates[j] = null;\n      } else if (isDescendant(candidates[j], candidates[_i])) {\n        candidates[_i] = null;\n      }\n    }\n  }\n\n  // Filter the candidates that we removed in previous step.\n  candidates = candidates.filter(function (e) {return e;});\n\n  return candidates;\n};\n\n// Given locations metadata array, return a new array of the form [{ metadata, polygon, parent }].\nexport function parseLocationsMetadata(locationsMetadata) {\n  var locationsMap = {};\n\n  var locations = locationsMetadata.map(function (metadata) {\n    if (metadata.area) {\n      if (metadata.area.format === 'Svg') {\n        var polygon = Shape.fromSVG(metadata.area.geometry);\n        polygon.name = metadata.name;\n\n        // Depends on the API that is being used, \"id\" attribute can be located in a different place.\n        // When using `getTreeDocuments` API, the id will be located under `node` object.\n        // When using `node:search` API, the id will be located on the root.\n        var id = metadata.node && metadata.node.id || metadata.id;\n\n        var location = {\n          id: id,\n          metadata: metadata,\n          polygon: polygon,\n          parent: undefined };\n\n\n        locationsMap[id] = location;\n\n        return location;\n      }\n    }\n  }).filter(function (e) {return e;});\n\n  // The location list the we get from the BE is flat.\n  // Traverse and link every location to its parent.\n  locations.forEach(function (location) {\n    // Depends on the API that is being used, \"parentId\" attribute can be located in a different place.\n    // When using `getTreeDocuments` API, the parentId will be located under `node` object.\n    // When using `node:search` API, the parentId will be located on the root.\n    var parentId = location.metadata.node && location.metadata.node.parentId || location.metadata.parentId;\n    location.parent = locationsMap[parentId];\n  });\n\n  return locations;\n};","function createRequest(requestType, url, contentType, token, onSuccess, onError) {\n  var xhr = new XMLHttpRequest();\n\n  xhr.open(requestType, url);\n\n  if (contentType) {\n    xhr.setRequestHeader('Content-Type', contentType);\n  }\n\n  xhr.setRequestHeader('Access-Control-Allow-Origin', '*');\n  xhr.setRequestHeader('Authorization', 'Bearer ' + token);\n\n  xhr.onload = function (event) {\n    if (event.currentTarget.status === 201 || event.currentTarget.status === 200 || event.currentTarget.status === 204) {\n      onSuccess(event.currentTarget.responseText);\n    } else {\n      onError();\n    }\n  };\n\n  xhr.onerror = onError;\n  xhr.ontimeout = onError;\n  xhr.onabort = onError;\n\n  return xhr;\n};\n\nfunction getApiSuffix(urlEnv) {\n  switch (urlEnv) {\n    case 'qa':\n      return '-qa';\n    case 'dev':\n    case 'local':\n      return '-dev';\n    default:\n      return '';}\n\n}\n\nfunction getApiEndpoint(urlEnv) {\n  switch (urlEnv) {\n    case 'staging':\n    case 'qa':\n    case 'dev':\n    case 'local':\n      return 'https://developer-stg.api.autodesk.com';\n    default:\n      return 'https://developer.api.autodesk.com';}\n\n}\n\nexport function fetch2dLocations(getAccessToken, containerId, documentLineageUrn, urlEnv) {\n  return new Promise(function (resolve, reject) {\n    getAccessToken(function (token) {\n      if (!token) {\n        return reject('Invalid access token.');\n      }\n\n      var endpoint = getApiEndpoint(urlEnv);\n      var suffix = getApiSuffix(urlEnv);\n      var api = \"bim360/locations\".concat(suffix, \"/v2\");\n      var treeId = 'default'; // Currently this is the only treeId that's supported.\n      var url = \"\".concat(endpoint, \"/\").concat(api, \"/containers/\").concat(containerId, \"/trees/\").concat(treeId, \"/nodes:search\");\n      var results = [];\n\n      // Handle fetching with pagination.\n      function doFetch(url) {\n        function onSuccess(response) {\n          var responseJson = JSON.parse(response);\n          results = results.concat(responseJson.results);\n\n          if (responseJson.pagination.next) {\n            doFetch(endpoint + responseJson.pagination.next);\n          } else {\n            resolve(results);\n          }\n        }\n\n        var xhr = createRequest('POST', url, 'application/json', token, onSuccess, reject);\n\n        var body = {\n          documentUrns: [documentLineageUrn] };\n\n\n        xhr.send(JSON.stringify(body));\n      }\n\n      doFetch(url);\n    });\n  });\n};","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nvar av = Autodesk.Viewing;\nvar avel = AutodeskNamespace('Autodesk.AEC.Locations');\n\nfunction _export(m, ns) {\n  for (var prop in m) {\n    if (m.hasOwnProperty(prop)) {\n      //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)\n      module.exports[prop] = m[prop];\n\n      //Export into the desired viewer namespace\n      ns[prop] = m[prop];\n    }\n  }\n}\n\n_export(require(\"./LocationsService\"), avel);\n_export(require(\"./LocationsCommon\"), avel);\n\nvar LOCATIONS_2D_CONTEXT_NAME = 'locations-2d-context';\nvar FILL_ALPHA = 0.2;\nvar FILL_ALPHA_HOVER = 0.5;\n\nvar POLYGON_STYLE = {\n  fillColor: \"rgb(205, 234, 247)\",\n  fillAlpha: FILL_ALPHA,\n  lineColor: \"rgb(0, 110, 175)\",\n  lineWidth: 2 };\n\n\nvar LABEL_CONTAINER_STYLE = {\n  background: \"#FFFFFF\",\n  borderRadius: \"17px\",\n  display: \"flex\",\n  flexDirection: \"row\",\n  padding: \"5px 9px\",\n  boxShadow: \"none\",\n  zIndex: 0 };\n\n\nvar LABEL_STYLE = {\n  color: \"#006EAF\",\n  fontSize: \"12px\",\n  lineHeight: \"12px\",\n  alignSelf: \"center\" };\n\n\nvar LABEL_SHADOW = \"0px 4px 14px rgba(12, 44, 84, 0.15), 0px 0px 2px rgba(12, 44, 84, 0.25)\";\n\n/**\n                                                                                               * 2D locations library extension\n                                                                                               */var\nLocationsExtension = /*#__PURE__*/function (_av$Extension) {\"use strict\";_inherits(LocationsExtension, _av$Extension);var _super = _createSuper(LocationsExtension);\n  function LocationsExtension(viewer, options) {var _this;_classCallCheck(this, LocationsExtension);\n    _this = _super.call(this, viewer, options);\n\n    _this.onModelAdded = _this.onModelAdded.bind(_assertThisInitialized(_this));return _this;\n  }_createClass(LocationsExtension, [{ key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var LocationLabel;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n\n                this.locations = [];_context.next = 3;return (\n\n                  this.viewer.loadExtension(\"Autodesk.Edit2D\"));case 3:this.edit2dExtension = _context.sent;\n\n                this.edit2dContext = this.edit2dExtension.registerTools(\n                LOCATIONS_2D_CONTEXT_NAME);\n\n\n                // Class definition has to be located here, only after loading Edit2D, since it extends a member of the namespace.\n                LocationLabel = /*#__PURE__*/function (_Autodesk$Edit2D$Fade) {_inherits(LocationLabel, _Autodesk$Edit2D$Fade);var _super2 = _createSuper(LocationLabel);function LocationLabel() {_classCallCheck(this, LocationLabel);return _super2.apply(this, arguments);}_createClass(LocationLabel, [{ key: \"apply\", value: function apply(\n                    label, shape, layer) {\n                      _get(_getPrototypeOf(LocationLabel.prototype), \"apply\", this).call(this, label, shape, layer);\n                      if (!label.styleInitialized) {\n                        label.styleInitialized = true;\n                        Object.assign(label.container.style, LABEL_CONTAINER_STYLE);\n                        Object.assign(label.textDiv.style, LABEL_STYLE);\n                      }\n\n                      if (label.hoverStyle ^ shape.hover) {\n                        label.hoverStyle = !!shape.hover;\n                        label.container.style.boxShadow = shape.hover ?\n                        LABEL_SHADOW :\n                        \"none\";\n                      }\n                    } }]);return LocationLabel;}(Autodesk.Edit2D.FadeOutStyleRule);\n\n\n                this.shapeLabelRule = new Autodesk.Edit2D.ShapeLabelRule(\n                this.edit2dContext.layer,\n                function (shape) {return shape.name;},\n                undefined,\n                new LocationLabel());\n\n\n                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);\n\n                this.onModelAdded();return _context.abrupt(\"return\",\n\n                true);case 10:case \"end\":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"unload\", value: function unload()\n\n\n    {\n      this.edit2dExtension && this.edit2dExtension.unregisterTools(LOCATIONS_2D_CONTEXT_NAME);\n\n      this.shapeLabelRule.dtor();\n      this.shapeLabelRule = null;\n      this.edit2dExtension = null;\n      this.edit2dContext = null;\n\n      this.locations = [];\n\n      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);\n\n      return true;\n    } }, { key: \"onModelAdded\", value: function onModelAdded()\n\n    {var _this$viewer$model;\n      // Since Leaflet coordinates are normalized, and locations are being saved in page coordinates,\n      // we need to set transformation for the locations layer - so it will be displayed correctly.\n      if (!((_this$viewer$model = this.viewer.model) === null || _this$viewer$model === void 0 ? void 0 : _this$viewer$model.isPageCoordinates())) {\n        var normalize = Autodesk.Viewing.PDFUtils.getLeafletNormalizingMatrix(\n        this.viewer);\n\n\n        if (!normalize) {\n          return;\n        }\n\n        var pageDimensions = this.viewer.model.getMetadata(\"page_dimensions\");\n        var scale = new THREE.Matrix4();\n        scale.makeScale(pageDimensions.page_width, pageDimensions.page_height, 1);\n\n        var layerToWorld = new THREE.Matrix4();\n        layerToWorld.multiplyMatrices(scale, normalize);\n        layerToWorld.getInverse(layerToWorld);\n\n        this.edit2dContext.setMatrix(layerToWorld);\n      }\n    }\n\n    /**\n       * Set locations array.\n       */ }, { key: \"setLocations\", value: function setLocations(\n    locations) {\n      this.locations = locations;\n\n      // In case showAllLocations was called before setLocations (because of slow network for example),\n      // Make sure to call it again, this time with the locations data.\n      if (this.allLocationsVisible) {\n        this.showAllLocations();\n      }\n    }\n\n    /**\n       * Get locations array.\n       */ }, { key: \"getLocations\", value: function getLocations()\n    {\n      return this.locations;\n    }\n\n    /**\n       * Get location item by id.\n       */ }, { key: \"getLocationById\", value: function getLocationById(\n    id) {\n      var location = this.locations.find(function (item) {return item.id === id;});\n\n      if (!location) {\n        console.warn(\"Cant find location: \", id);\n      }\n\n      return location;\n    }\n\n    /**\n       * Show location by id.\n       */ }, { key: \"showLocationById\", value: function showLocationById(\n    id) {\n      var location = this.getLocationById(id);\n      this.showLocationItem(location);\n    }\n\n    /**\n       * Hide location by id.\n       */ }, { key: \"hideLocationById\", value: function hideLocationById(\n    id) {\n      var location = this.getLocationById(id);\n      this.hideLocationItem(location);\n    }\n\n    /**\n       * Show location item.\n       */ }, { key: \"showLocationItem\", value: function showLocationItem(\n    location) {\n      if (location) {\n        var polygon = location.polygon;\n\n        // Update polygon style\n        Object.assign(polygon.style, POLYGON_STYLE);\n\n        if (!this.edit2dContext.layer.findShapeById(polygon.id)) {\n          this.edit2dContext.layer.addShape(polygon);\n        }\n      }\n    }\n\n    /**\n       * Hide location item.\n       */ }, { key: \"hideLocationItem\", value: function hideLocationItem(\n    location) {\n      if (location) {\n        var polygon = location.polygon;\n        this.edit2dContext.layer.removeShape(polygon);\n      }\n    }\n\n    /**\n       * Show all locations.\n       */ }, { key: \"showAllLocations\", value: function showAllLocations()\n    {var _this2 = this;\n      // Disable autoUpdate for this batch operation.\n      // Call update only onces at the end.\n      this.edit2dContext.layer.autoUpdate = false;\n\n      this.locations.forEach(function (location) {\n        _this2.showLocationItem(location);\n      });\n\n      this.edit2dContext.layer.autoUpdate = true;\n      this.edit2dContext.layer.update();\n\n      this.allLocationsVisible = true;\n    }\n\n    /**\n       * Hide all locations.\n       */ }, { key: \"hideAllLocations\", value: function hideAllLocations()\n    {var _this3 = this;\n      // Disable autoUpdate for this batch operation.\n      // Call update only onces at the end.\n      this.edit2dContext.layer.autoUpdate = false;\n\n      this.locations.forEach(function (location) {\n        _this3.hideLocationItem(location);\n      });\n\n      this.edit2dContext.layer.autoUpdate = true;\n      this.edit2dContext.layer.update();\n\n      this.allLocationsVisible = false;\n    } }, { key: \"getLocationIdsAtPoint\", value: function getLocationIdsAtPoint(\n\n    point) {\n      var intersectedLocations = Autodesk.AEC.Locations.getPointLocations(\n      point,\n      this.locations);\n\n\n      return intersectedLocations.map(function (location) {return location.id;});\n    } }, { key: \"onMouseMove\", value: function onMouseMove(\n\n    event) {\n      var rect = this.viewer.impl.getCanvasBoundingClientRect();\n\n      var point = this.viewer.clientToWorld(\n      event.clientX - rect.left,\n      event.clientY - rect.top,\n      undefined,\n      true).\n      point;\n\n      if (!this.viewer.model.isPageCoordinates()) {\n        // Locations are stored using page coordinate system.\n        // In case we are viewing a Leaflet document, the point position has to be converted into the same coordinate system.\n        point = Autodesk.Viewing.PDFUtils.leafletToPdfWorld(this.viewer, point);\n\n        if (!point) {\n          return;\n        }\n      }\n\n      var locationIds = this.getLocationIdsAtPoint(point);\n\n      // Hover only first location if available.\n      var singleLocationIdArray = locationIds.slice(0, 1);\n\n      this.hoverLocationsByIds(singleLocationIdArray);\n    }\n\n    /**\n       * Hover locations according to ids.\n       */ }, { key: \"hoverLocationsByIds\", value: function hoverLocationsByIds(\n    ids) {\n      var dirty = false;\n\n      this.locations.forEach(function (location) {\n        var polygon = location.polygon;\n        if (ids.indexOf(location.id) !== -1) {\n          if (!polygon.hover) {\n            polygon.style.fillAlpha = FILL_ALPHA_HOVER;\n            polygon.hover = true;\n            dirty = true;\n          }\n        } else {\n          if (polygon.hover) {\n            polygon.style.fillAlpha = FILL_ALPHA;\n            polygon.hover = false;\n            dirty = true;\n          }\n        }\n      });\n\n      if (dirty) {\n        this.edit2dContext.layer.update();\n      }\n    } }]);return LocationsExtension;}(av.Extension);\n\n\n// The ExtensionManager requires an extension to be registered.\nav.theExtensionManager.registerExtension('Autodesk.AEC.LocationsExtension', LocationsExtension);","\nvar content = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Minimap3D.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Minimap3D.css\", function() {\n\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Minimap3D.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nimport Minimap3DLayout from './Minimap3DLayout';\nimport { SheetSyncEvents } from \"../SheetSync/SheetSyncConstants\";\n\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\nvar Empty2DModelLoader = avp.Empty2DModelLoader;\n\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar myExtensionName = 'Autodesk.AEC.Minimap3DExtension';\n\nvar BIMWALK_EXT = 'Autodesk.BimWalk';\nvar AVATAR_EXT = 'Autodesk.AEC.AvatarExtension';\nvar TOP_VIEW_EXT = 'Autodesk.AEC.TopViewRendererExtension';\nvar LEVEL_EXT = \"Autodesk.AEC.LevelsExtension\";\nvar SHEET_SYNC_EXT = \"Autodesk.AEC.SheetSyncExtension\";\n\nvar VISIBILITY_PROP = 'miniMap3D';var\n\nMinimap3DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Minimap3DExtension, _av$Extension);var _super = _createSuper(Minimap3DExtension);\n  function Minimap3DExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, Minimap3DExtension);\n    _this = _super.call(this, viewer, options);\n\n    _this.mapViewerHighlightEnabled = options.mapViewerHighlightEnabled || false; // By default, mapViewer highlight (hover) is off.\n    _this.mapViewerSelectionEnabled = options.mapViewerSelectionEnabled || false; // By default, mapViewer 2D object selection is off.\n\n    _this.update = _this.update.bind(_assertThisInitialized(_this));\n    _this.onModelAdded = _this.onModelAdded.bind(_assertThisInitialized(_this));\n    _this.onVisibilityChanged = _this.onVisibilityChanged.bind(_assertThisInitialized(_this));\n\n    // Resize animation duration in seconds.\n    _this.resizeDuration = 0.3;return _this;\n  }_createClass(Minimap3DExtension, [{ key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this$levelExt;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n\n\n\n\n                  this.viewer.loadExtension(LEVEL_EXT));case 2:this.levelExt = _context.sent;\n\n                this.loaded = true;\n\n                this.viewer.prefs.add(VISIBILITY_PROP, true);\n\n                if (!this.configureSettings()) {\n                  if (!this.updateSettingsPanel) {\n                    //We need to connect this to an event that happens after the settings panel has been\n                    //create by the load sequence.\n                    this.updateSettingsPanel = this.configureSettings.bind(this);\n                    this.viewer.addEventListener(av.SETTINGS_PANEL_CREATED_EVENT, this.updateSettingsPanel);\n                  }\n                }\n\n                this.viewer.addEventListener(av.TOOL_CHANGE_EVENT, this.update);\n                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);\n\n                if ((_this$levelExt = this.levelExt) === null || _this$levelExt === void 0 ? void 0 : _this$levelExt.floorSelector) {\n                  this.levelExt.floorSelector.addEventListener(Autodesk.AEC.FloorSelector.FLOOR_DATA_CHANGED, this.update);\n                }\n\n                this.activate();return _context.abrupt(\"return\",\n\n                true);case 11:case \"end\":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"unload\", value: function unload()\n\n\n    {\n      this.loaded = false;\n\n      this.deactivate();\n\n      if (this.updateSettingsPanel) {\n        this.viewer.removeEventListener(av.SETTINGS_PANEL_CREATED_EVENT, this.updateSettingsPanel);\n        this.updateSettingsPanel = null;\n      }\n\n      this.viewer.removeEventListener(av.TOOL_CHANGE_EVENT, this.update);\n      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);\n\n      this.levelExt = null;\n\n      // Make sure that we don't leak models\n      return true;\n    } }, { key: \"onModelAdded\", value: function onModelAdded()\n\n    {\n      // In case the viewer is now on 2D mode, destroy the mapViewer, since it's not relevant anymore.\n      // By destroying mapViewer, it will unload all of it's minimap related extensions as well.\n\n      this.viewer.impl.is2d ? this.deactivate() : this.activate();\n    } }, { key: \"activate\", value: function activate()\n\n    {\n      if (this.active) {\n        return;\n      }\n\n      this.update();\n\n      this.active = true;\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {var _this$levelExt2;\n      if (!this.active) {\n        return;\n      }\n\n      this.active = false;\n\n      if (this.mapViewer) {\n        this.mapViewer.finish();\n        this.sheetSyncExtension = null;\n        this.mapViewer = null;\n      }\n\n      if (this.layout) {\n        this.layout.destroy && this.layout.destroy();\n        this.layout = null;\n      }\n\n      if ((_this$levelExt2 = this.levelExt) === null || _this$levelExt2 === void 0 ? void 0 : _this$levelExt2.floorSelector) {\n        this.levelExt.floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.FLOOR_DATA_CHANGED, this.update);\n      }\n    }\n\n    // Check if minimap is enabled in viewer config & BIM-Walk is active.\n  }, { key: \"isEnabled\", value: function isEnabled() {var _bimWalkExt$tool, _this$levelExt3, _this$levelExt3$floor, _this$levelExt3$floor2;\n      // Check if minimap pref is setting panel is enabled.\n      var prefEnabled = this.viewer.prefs && this.viewer.prefs.get(VISIBILITY_PROP);\n\n      // Check if bim walk is active.\n      var bimWalkExt = this.viewer.getExtension(BIMWALK_EXT);\n      var bimWalkEnabled = bimWalkExt === null || bimWalkExt === void 0 ? void 0 : (_bimWalkExt$tool = bimWalkExt.tool) === null || _bimWalkExt$tool === void 0 ? void 0 : _bimWalkExt$tool.active;\n\n      // Only if there is a valid floorData (based on AecModelData), the minimap can work.\n      // If enableWithoutAecModelData is given, the minimap can still work, but without level-based sectioning - which means that we'll always see the roof.\n      var hasAecData = this.options.enableWithoutAecModelData || ((_this$levelExt3 = this.levelExt) === null || _this$levelExt3 === void 0 ? void 0 : (_this$levelExt3$floor = _this$levelExt3.floorSelector) === null || _this$levelExt3$floor === void 0 ? void 0 : (_this$levelExt3$floor2 = _this$levelExt3$floor.floorData) === null || _this$levelExt3$floor2 === void 0 ? void 0 : _this$levelExt3$floor2.length) > 0;\n\n      return prefEnabled && (bimWalkEnabled && hasAecData || this.options.minimapDebugMode);\n    } }, { key: \"onVisibilityChanged\", value: function onVisibilityChanged(\n\n    visible) {\n      if (this.viewer.prefs) {\n        this.viewer.prefs.set(VISIBILITY_PROP, visible);\n      }\n\n      this.update();\n    } }, { key: \"initLayoutIfNeeded\", value: function initLayoutIfNeeded()\n\n    {\n      if (this.layout) {\n        return;\n      }\n\n      // Default layout is Minimap3DLayout. An optional LayoutClass can be used instead.\n      var LayoutClass = this.options.LayoutClass || Minimap3DLayout;\n      this.layout = new LayoutClass(this);\n    } }, { key: \"initMapViewerIfNeeded\", value: function initMapViewerIfNeeded()\n\n    {var _this$options$autoFoc,_this2 = this;\n      if (this.mapViewer) {\n        return;\n      }\n\n      var container = this.layout.getMapViewerContainer();\n\n      if (this.options.getMapViewer) {\n        // Get mapViewer using an external callback.\n        // Important! if you create a viewer of your own, make sure to initialize it with { webglInitParams: { alpha: true }.\n        // Otherwise, you won't be able to see the 3D top view.\n        this.mapViewer = this.options.getMapViewer(container);\n\n      } else {\n        // Generate a new mapViewer.       \n        var ViewerClass = this.options.MapViewerClass || Autodesk.Viewing.Viewer3D;\n\n        this.mapViewer = new ViewerClass(container, {});\n\n        // Map viewer has to have a transparent background in order to support topViewRenderer on the back. This is why `alpha:true` is mandatory.\n        this.mapViewer.start(undefined, undefined, undefined, undefined, { webglInitParams: { alpha: true } });\n      }\n\n      // Load SheetSync, Avatar & topViewRenderer extensions.\n      this.mapViewer.config.extensions = this.mapViewer.config.extensions || [];\n\n      this.mapViewer.config.sheetSyncOptions = {\n        targetViewer: this.viewer,\n        cropToViewport: true,\n        hideSheetWhenNotFocused: true,\n        autoSwitchSheet: true,\n        hidePaper: true,\n        useCustomModel: this.options.useCustomModel,\n        showSheet: this.options.showSheet,\n        loadDocumentNode: this.options.loadDocumentNode,\n        unloadModel: this.options.unloadModel,\n        minimapDebugMode: this.options.minimapDebugMode };\n\n\n      this.mapViewer.config.avatarOptions = {\n        trackUsage: this.options.trackUsage,\n        autoFocus: (_this$options$autoFoc = this.options.autoFocus) !== null && _this$options$autoFoc !== void 0 ? _this$options$autoFoc : !this.options.minimapDebugMode };\n\n\n      this.mapViewer.config.topViewRendererOptions = {\n        minimapDebugMode: this.options.minimapDebugMode };\n\n\n      if (this.mapViewer.config.extensions.indexOf(AVATAR_EXT) === -1) {\n        this.mapViewer.config.extensions.push(AVATAR_EXT);\n      }\n\n      if (this.mapViewer.config.extensions.indexOf(TOP_VIEW_EXT) === -1) {\n        this.mapViewer.config.extensions.push(TOP_VIEW_EXT);\n      }\n\n      this.mapViewer.disableHighlight(!this.mapViewerHighlightEnabled);\n      this.mapViewer.disableSelection(!this.mapViewerSelectionEnabled);\n\n      this.mapViewer.getExtensionAsync(SHEET_SYNC_EXT).then(function (sheetSyncExtension) {\n        _this2.sheetSyncExtension = sheetSyncExtension;\n      });\n\n      this.mapViewer.addEventListener(SheetSyncEvents.SHEET_VISIBILITY_CHANGED_EVENT, this.update);\n\n      // Load an empty model to initialize extensions and enable camera.\n      this.mapViewer.loadModel(\"Dummy\", { fileLoader: Empty2DModelLoader, headlessViewer: true });\n    } }, { key: \"update\", value: function update()\n\n    {\n      if (this.isEnabled()) {\n        this.initLayoutIfNeeded();\n        this.initMapViewerIfNeeded();\n      }\n\n      if (this.layout && this.layout.update) {\n        this.layout.update();\n      }\n    } }, { key: \"configureSettings\", value: function configureSettings()\n\n    {\n\n      //Is it a GUI viewer or not?\n      if (!this.viewer.getSettingsPanel)\n      return false;\n\n      var panel = this.viewer.getSettingsPanel();\n\n      if (!panel || !panel.is3dMode)\n      return false;\n\n      var navTab = av.Extensions.ViewerSettingTab.Navigation;\n      panel.addLabel(navTab, \"3D Mini-map\");\n\n      // add toggle to the hypermodeling tab of the viewer settings\n      if (!panel.showMinimapChkBoxId) {\n        panel.showMinimapChkBoxId = panel.addCheckbox(\n        navTab,\n        \"Show 3D mini-map\",\n        \"Toggles availability of the 3D mini-map when using first person mode\",\n        true,\n        this.onVisibilityChanged,\n        VISIBILITY_PROP);\n\n      }\n\n      return true;\n    }\n\n    // Toggle between auto-generated map image and sheets. Note that sheets may not be available for a level.\n    // In this case, we fall back to the default map.\n  }, { key: \"setSheetMapEnabled\", value: function setSheetMapEnabled(enabled) {\n      if (this.sheetSyncExtension) {\n        this.sheetSyncExtension.setShowSheet(enabled);\n        this.update();\n      }\n    } }, { key: \"getSheetMapEnabled\", value: function getSheetMapEnabled()\n\n    {var _this$sheetSyncExtens;\n      return (_this$sheetSyncExtens = this.sheetSyncExtension) === null || _this$sheetSyncExtens === void 0 ? void 0 : _this$sheetSyncExtens.getShowSheet();\n    } }, { key: \"setSideBySideEnabled\", value: function setSideBySideEnabled(\n\n    enabled) {var _this$layout;\n      if ((_this$layout = this.layout) === null || _this$layout === void 0 ? void 0 : _this$layout.setSideBySideEnabled) {\n        this.layout.setSideBySideEnabled(enabled);\n      }\n    } }, { key: \"setSideBySideSplit\", value: function setSideBySideSplit(\n\n    value) {var _this$layout2;\n      if ((_this$layout2 = this.layout) === null || _this$layout2 === void 0 ? void 0 : _this$layout2.setSideBySideSplit) {\n        this.layout.setSideBySideSplit(value);\n      }\n    } }, { key: \"isSheetVisible\", value: function isSheetVisible()\n\n    {var _this$sheetSyncExtens2;\n      return (_this$sheetSyncExtens2 = this.sheetSyncExtension) === null || _this$sheetSyncExtens2 === void 0 ? void 0 : _this$sheetSyncExtens2.isSheetVisible();\n    } }, { key: \"waitForRotationDone\", value: function () {var _waitForRotationDone = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var topViewRendererExt;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n\n\n                topViewRendererExt = this.mapViewer.getExtension(TOP_VIEW_EXT);_context2.next = 3;return (\n                  topViewRendererExt.waitForRotationDone());case 3:case \"end\":return _context2.stop();}}}, _callee2, this);}));function waitForRotationDone() {return _waitForRotationDone.apply(this, arguments);}return waitForRotationDone;}() }, { key: \"hideAvatarAndWait\", value: function () {var _hideAvatarAndWait = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {var avatarExt;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n\n\n\n                avatarExt = this.mapViewer.getExtension(AVATAR_EXT);_context3.next = 3;return (\n                  avatarExt.hide());case 3:case \"end\":return _context3.stop();}}}, _callee3, this);}));function hideAvatarAndWait() {return _hideAvatarAndWait.apply(this, arguments);}return hideAvatarAndWait;}() }, { key: \"expandSheetMap\", value: function () {var _expandSheetMap = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {var sheetNodePromise, viewerState, sheetNode;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:\n\n\n\n                // First, request sheetNode in the background (it might take time only if it wasn't loaded before).\n                sheetNodePromise = this.sheetSyncExtension.sheetMap.getSheetNode();\n\n                this.sheetSyncExtension.expandCropBounds(this.resizeDuration);\n                this.sheetSyncExtension.changePaperVisibility(true);_context4.next = 5;return (\n                  this.layout.expandSheetMap(this.resizeDuration));case 5:_context4.next = 7;return (\n                  this.waitForRotationDone());case 7:\n                this.sheetSyncExtension.setSheetOpaque(this.resizeDuration);_context4.next = 10;return (\n                  this.hideAvatarAndWait());case 10:\n                viewerState = this.mapViewer.getState();_context4.next = 13;return (\n\n                  sheetNodePromise);case 13:sheetNode = _context4.sent;_context4.next = 16;return (\n\n\n\n                  this.options.onExpand(sheetNode, this.sheetSyncExtension.getCustomHash()));case 16:\n                this.viewer.restoreState(viewerState, undefined, true);case 17:case \"end\":return _context4.stop();}}}, _callee4, this);}));function expandSheetMap() {return _expandSheetMap.apply(this, arguments);}return expandSheetMap;}() }]);return Minimap3DExtension;}(av.Extension);export { Minimap3DExtension as default };\n\n\n\nnamespace.Minimap3DExtension = Minimap3DExtension;\n\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, Minimap3DExtension);","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import MinimapDropdown from './MinimapDropdown.js';\nimport MinimapSideBySideButton from \"./MinimapSideBySideButton\";\nimport MinimapExpandButton from \"./MinimapExpandButton\";\nimport TopViewRenderer from '../SheetSync/TopViewRenderer';\nimport ResizeObserver from \"../../../thirdparty/resize-observer-polyfill/ResizeObserver.min.js\";\nimport { locales } from './Minimap3DLocales';\n\n// eslint-disable-next-line no-unused-vars\nimport CSS from './Minimap3D.css'; // IMPORTANT!!\n\nvar av = Autodesk.Viewing;\nvar GlobalManagerMixin = av.GlobalManagerMixin;\n\nvar BIMWALK_EXT = 'Autodesk.BimWalk';\n\n// int value to string, e.g. 50 => \"50px\" - to used for style assignments.\nvar toPixels = function toPixels(val) {\n  return val.toString() + 'px';\n};\n\n// int value to string, e.g. 50 => \"50%\" - to used for style assignments.\nvar toPercent = function toPercent(val) {\n  return val.toString() + \"%\";\n};\n\nvar DEFAULT_LEVEL_GUID = 'd53d4fd9-1bc6-4549-9084-1caed451e96f'; // Default Revit level guid.\nvar\nMinimap3DLayout = /*#__PURE__*/function () {\n  function Minimap3DLayout(minimap3DExtension) {_classCallCheck(this, Minimap3DLayout);\n    this.minimap3DExtension = minimap3DExtension;\n    this.viewer = this.minimap3DExtension.viewer;\n    this.options = minimap3DExtension.options;\n\n    this.setGlobalManager(this.viewer.globalManager);\n\n    minimap3DExtension.extendLocalization(locales);\n\n    this.sideBySideOptions = this.options.sideBySideOptions || {};\n\n    // By default, show header.\n    this.showHeader = this.options.showHeader === undefined ? true : this.options.showHeader;\n\n    this.update = this.update.bind(this);\n\n    // Map widget size\n    this.mapWidgetWidth = 300;\n    this.mapWidgetHeight = 300;\n\n    // Offset in pixels for the minimap's layout from its side (left of right).\n    this.sideOffset = this.options.sideOffset !== undefined ? this.options.sideOffset : 10;\n\n    // Map widget position\n    this.mapWidgetTop = 0;\n\n    if (this.sideBySideOptions.left2DView) {\n      this.mapWidgetLeft = 0;\n      this.mapWidgetRight = undefined;\n    } else {\n      this.mapWidgetLeft = undefined;\n      this.mapWidgetRight = 0;\n    }\n\n    // Params for choosing mapWidget size based on canvas size\n    this.relMapWidgetSizeLongEdge = 0.25; // Restrict to max 25% of the canvas along the longer axis with\n    this.relMapWidgetSizeShortEdge = 0.37; // Restrict to max 37% of the canvas along the shorter axis (more tolerance here, to keep map useful for widescreen)\n\n    // Dropdown for levels, only instantiated when there are levels\n    this.dropdown = null;\n\n    // Toggle between..\n    //  - Small map on top-right of the screen (false)\n    //  - Large map that fills left half of the screen (true)\n    this.sideBySideEnabled = this.sideBySideOptions.sideBySideDefault || false;\n\n    // Indicates if layout is currently configured for side-by-side view\n    // (always false when map is hidden, because viewer needs to be resized to full width then)\n    this.sideBySide = false;\n\n    // Indicates if layout is currently configured for expanded view (full viewer)\n    this.expanded = false;\n\n    // Percent of viewer width that we reserve for minimap in side-by-side mode. \n    // E.g. 40 => Minimap gets 40%, Main canvas gets 60%\n    this.sideBySideSplit = this.sideBySideOptions.sideBySideSplit || 40;\n\n    this.init();\n  }_createClass(Minimap3DLayout, [{ key: \"setMinimapVisible\", value: function setMinimapVisible(\n\n    visible) {var _this = this;\n      if (this.visible === visible) {\n        return;\n      }\n\n      this.visible = visible;\n\n      // While switching sheets, mapWidget might be null\n      if (!this.mapWidget)\n      return;\n\n      // Trigger css anim. Note that doing this synchronously would skip the animation.\n      var _window = this.getWindow();\n      _window.requestAnimationFrame(function () {\n        // Since the callback is async, we need to make sure the extension is still loaded when we get here (UI might be destroyed already).\n        if (!_this.mapWidgetRoot) {\n          return;\n        }\n\n        if (visible) {\n          _this.mapWidgetRoot.classList.add('visible');\n        } else {\n          _this.mapWidgetRoot.classList.remove('visible');\n        }\n\n        _this.viewer.getExtension(\"Autodesk.ViewCubeUi\", function (ext) {\n          ext.displayViewCube(!visible);\n          ext.displayHomeButton(!visible);\n        });\n      });\n\n      // Make sure that we reserve space for the minimap as soon as we start fade-in\n      this.updateBimWalkInfoButtonPos();\n\n      // Apply side-by-side layout immediately when starting to fade in. On fade-out, we\n      // delay this until the fade-out transition is done (see transitionend-handler in initWidgets)\n      if (visible) {\n        this.updateSideBySide();\n      }\n    } }, { key: \"initWidgets\", value: function initWidgets()\n\n    {var _this2 = this;\n      var _document = this.getDocument();\n\n      // Optional: add extra css class\n      var classPostfix = this.options.additionalWrapperCss ? ' ' + this.options.additionalWrapperCss : '';\n\n      // Root div for the minimap. This is only used for the toolbar: Since it is left outside the Minimap bounds, it cannot be inside the mapWidget directly,\n      // because the mapWidget uses overflow:hidden to implement scrolling.\n      this.mapWidgetRoot = _document.createElement('div');\n      this.mapWidgetRoot.style.width = toPixels(this.mapWidgetWidth);\n      this.mapWidgetRoot.style.height = toPixels(this.mapWidgetHeight);\n      this.mapWidgetRoot.className = \"minimap3D \".concat(classPostfix, \" \");\n      this.mapWidgetRoot.classList.add('adsk-viewing-viewer');\n      this.mapWidgetRoot.classList.add(this.viewer.theme);\n\n      this.mapWidgetHeader = _document.createElement('div');\n      this.mapWidgetHeader.className = 'minimap-header';\n      this.mapWidgetHeader.classList.add('adsk-viewing-viewer');\n      this.mapWidgetHeader.classList.add('adsk-control-group');\n      this.mapWidgetHeader.classList.add(this.viewer.theme);\n\n      if (this.showHeader) {\n        this.mapWidgetRoot.appendChild(this.mapWidgetHeader);\n      }\n\n      // Div showing the minimap\n      this.mapWidget = _document.createElement('div');\n      this.mapWidget.className = 'minimapScrollArea';\n      this.mapWidgetRoot.appendChild(this.mapWidget);\n\n      if (this.showHeader) {\n        // IE11 doesn't support canvas blending well.\n        // For that reason, we decided to hide the sheet-map overlay in IE11.\n        if (TopViewRenderer.isSheetMapSupported() && this.options.onExpand) {\n          this.expandButton = new MinimapExpandButton(this);\n        }\n\n        this.initDropdownIfNeeded();\n        this.sideBySideButton = new MinimapSideBySideButton(this);\n      }\n\n      // hidden until level map is set\n      this.setMinimapVisible(false);\n\n      // Whenver the mapWidget finished fading in or out, we might need to re-adjust\n      // the position of the annoying Info button of BimWalk to avoid overlapping.\n      this.mapWidgetRoot.addEventListener('transitionend', function () {\n        _this2.updateBimWalkInfoButtonPos();\n        _this2.updateSideBySide();\n      });\n    }\n\n    // Dropdown might be initialized only later, after all other widgets were already initialized, since\n    // the floorData might arrive only later.\n  }, { key: \"initDropdownIfNeeded\", value: function initDropdownIfNeeded() {var _this$minimap3DExtens, _this$minimap3DExtens2;\n      if (!this.showHeader || this.dropdown) {\n        return;\n      }\n\n      var floorData = (_this$minimap3DExtens = this.minimap3DExtension.levelExt) === null || _this$minimap3DExtens === void 0 ? void 0 : (_this$minimap3DExtens2 = _this$minimap3DExtens.floorSelector) === null || _this$minimap3DExtens2 === void 0 ? void 0 : _this$minimap3DExtens2.floorData;\n      var isDefaultRevitLevel = (floorData === null || floorData === void 0 ? void 0 : floorData.length) === 1 && floorData[0].guid === DEFAULT_LEVEL_GUID;\n\n      // In case there are no levels, or only Revit's default level - don't create levels dropdown.\n      if ((floorData === null || floorData === void 0 ? void 0 : floorData.length) > 0 && !isDefaultRevitLevel) {\n        this.dropdown = new MinimapDropdown(this);\n\n        // If the dropdown was added just now, make sure that the sideBySide button is added only after it (to the right).\n        if (this.sideBySideButton) {\n          this.sideBySideButton.dtor();\n          this.sideBySideButton = new MinimapSideBySideButton(this);\n        }\n      }\n    } }, { key: \"destroyWidgets\", value: function destroyWidgets()\n\n    {\n      if (this.widgetAnimation) {\n        this.widgetAnimation.stop();\n        this.widgetAnimation = null;\n      }\n\n      if (this.mapWidgetRoot.parentElement) {\n        this.mapWidgetRoot.parentElement.removeChild(this.mapWidgetRoot);\n      }\n\n      this.mapWidgetRoot = null;\n      this.mapWidget = null;\n      this.mapWidgetHeader = null;\n\n      if (this.dropdown) {\n        this.dropdown.dtor();\n        this.dropdown = null;\n      }\n\n      if (this.expandButton) {\n        this.expandButton.dtor();\n        this.expandButton = null;\n      }\n\n      if (this.sideBySideButton) {\n        this.sideBySideButton.dtor();\n        this.sideBySideButton = null;\n      }\n    } }, { key: \"init\", value: function init()\n\n    {var _this3 = this;\n      this.initWidgets();\n\n      this.initialViewerWidth = this.viewer.container.clientWidth;\n      this.initialViewerHeight = this.viewer.container.clientHeight;\n\n      this.resizeObserver = new ResizeObserver(function () {\n        _this3.updateSideBySide(true);\n      });\n\n      this.resizeObserver.observe(this.viewer.clientContainer);\n\n      // choose widget size based on current canvas size\n      this.updateMapSize(true);\n\n      this.viewer.clientContainer.appendChild(this.mapWidgetRoot);\n    } }, { key: \"destroy\", value: function destroy()\n\n    {\n      this.destroyWidgets();\n\n      if (this.resizeObserver) {\n        this.resizeObserver.disconnect();\n        this.resizeObserver = null;\n      }\n\n      // Restore viewer to its default dimensions.\n      this.restoreViewerContainerStyle();\n    } }, { key: \"getClientContainerWidth\", value: function getClientContainerWidth()\n\n    {\n      // In case clientContainer doesn't have a definite width, use the viewer's initial width.\n      // This scenario can happen when the clientContainer div doesn't have style at all - and the viewer's width is independent of the window width.\n      return this.viewer.clientContainer.clientWidth || this.initialViewerWidth;\n    } }, { key: \"getClientContainerHeight\", value: function getClientContainerHeight()\n\n    {\n      // In case clientContainer doesn't have a definite height, use the viewer's initial height.\n      // This scenario can happen when the clientContainer div doesn't have style at all - and the viewer's height is independent of the window size.\n      return this.viewer.clientContainer.clientHeight || this.initialViewerHeight;\n    } }, { key: \"updateToolbar\", value: function updateToolbar()\n\n    {\n      this.sideBySideButton && this.sideBySideButton.update();\n      this.expandButton && this.expandButton.update();\n    } }, { key: \"update\", value: function update()\n\n    {\n      this.initDropdownIfNeeded();\n\n      if (this.minimap3DExtension.isEnabled()) {\n        this.setMinimapVisible(true);\n      } else {\n        this.setMinimapVisible(false);\n      }\n\n      this.updateToolbar();\n      this.updateSideBySide();\n    } }, { key: \"setWidgetSize\", value: function setWidgetSize(\n\n    w, h, top, left, right, headerHeight) {\n      this.mapWidgetWidth = w;\n      this.mapWidgetHeight = h;\n      this.mapWidgetTop = top;\n      this.mapWidgetLeft = left;\n      this.mapWidgetRight = right;\n\n      this.mapWidgetRoot.style.width = toPixels(w);\n      this.mapWidgetRoot.style.height = toPixels(h);\n      this.mapWidgetRoot.style.top = toPixels(top);\n      this.mapWidgetRoot.style.left = left !== undefined ? toPixels(left) : 'initial';\n      this.mapWidgetRoot.style.right = right !== undefined ? toPixels(right) : 'initial';\n\n      if (headerHeight !== undefined) {\n        this.mapWidgetHeader.style.height = toPixels(headerHeight);\n        this.mapWidgetHeader.style.opacity = toPercent(headerHeight / this.getInitialHeaderHeight() * 100);\n      }\n\n      if (this.minimap3DExtension.mapViewer) {\n        this.minimap3DExtension.mapViewer.resize();\n      }\n\n      this.update();\n    } }, { key: \"setViewerSize\", value: function setViewerSize(\n\n    width, height, left, right, top) {\n      this.viewer.container.style.width = toPixels(width);\n      this.viewer.container.style.height = toPixels(height);\n      this.viewer.container.style.left = toPixels(left);\n      this.viewer.container.style.right = toPixels(right);\n      this.viewer.container.style.top = toPixels(top);\n\n      // keep canvas/camera in-sync, because we changed container size\n      this.viewer.resize();\n\n      this.update();\n    }\n\n    // Update mapWidget size based on canvas size\n  }, { key: \"updateMapSize\", value: function updateMapSize(immediate, duration) {\n      var canvasWidth = this.getClientContainerWidth();\n      var canvasHeight = this.getClientContainerHeight();\n\n      var width, height, top, left, right, showHeader;\n\n      if (this.expanded) {\n        width = canvasWidth;\n        height = canvasHeight;\n        top = 0;\n\n        if (this.sideBySideOptions.left2DView) {\n          left = 0;\n        } else {\n          right = 0;\n        }\n\n        showHeader = false;\n      } else if (this.sideBySide) {\n        // Fill x percent of the parent widget (x = sideBySideSplit)\n        if (this.verticalSideBySide) {\n          width = canvasWidth;\n          height = canvasHeight * (this.sideBySideSplit / 100);\n        } else {\n          width = canvasWidth * (this.sideBySideSplit / 100);\n          height = canvasHeight;\n        }\n\n        top = 0;\n\n        if (this.sideBySideOptions.left2DView) {\n          left = 0;\n        } else {\n          right = 0;\n        }\n\n        showHeader = true;\n      } else {\n        // Default mode: Small map on top-right of the screen\n        var longEdge = Math.max(canvasWidth, canvasHeight);\n        var shortEdge = Math.min(canvasWidth, canvasHeight);\n        var minimapWidthToHeightRatio = 0.66;\n        // Restrict mapSize to not exceed a certain percentage of canvas width/height\n        width = Math.min(this.relMapWidgetSizeLongEdge * longEdge, this.relMapWidgetSizeShortEdge * shortEdge);\n        height = width * minimapWidthToHeightRatio + this.mapWidgetHeader.clientHeight; // make the minimap ratio 2:3, and include the height for the header\n        top = 10;\n\n        if (this.sideBySideOptions.left2DView) {\n          left = this.sideOffset;\n        } else {\n          right = this.sideOffset;\n        }\n\n        showHeader = true;\n      }\n\n      if (immediate && !this.widgetAnimation) {\n        return this.setWidgetSize(width, height, top, left, right);\n      } else {\n        return this.animateWidgetSize(width, height, top, left, right, showHeader, duration);\n      }\n    } }, { key: \"getInitialHeaderHeight\", value: function getInitialHeaderHeight()\n\n    {\n      if (!this.headerHeight) {\n        this.headerHeight = this.mapWidgetHeader.clientHeight;\n      }\n\n      return this.headerHeight;\n    } }, { key: \"animateWidgetSize\", value: function animateWidgetSize(\n\n    targetWidth, targetHeight, targetTop, targetLeft, targetRight) {var _this4 = this;var showHeader = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;var duration = arguments.length > 6 ? arguments[6] : undefined;\n      var startWidth = this.mapWidgetWidth;\n      var startHeight = this.mapWidgetHeight;\n      var startTop = this.mapWidgetTop;\n      var startLeft = this.mapWidgetLeft;\n      var startRight = this.mapWidgetRight;\n      var startHeaderHeight = this.mapWidgetHeader.clientHeight;\n      duration = duration || this.minimap3DExtension.resizeDuration;\n\n      if (this.widgetAnimation) {\n        this.widgetAnimation.stop();\n        this.widgetAnimation = null;\n      }\n\n      var onTimer = function onTimer(t) {\n        t = Autodesk.Viewing.Private.smootherStep(t);\n\n        var width = Autodesk.Viewing.Private.lerp(startWidth, targetWidth, t);\n        var height = Autodesk.Viewing.Private.lerp(startHeight, targetHeight, t);\n        var top = Autodesk.Viewing.Private.lerp(startTop, targetTop, t);\n        var left = targetLeft !== undefined ? Autodesk.Viewing.Private.lerp(startLeft || 0, targetLeft, t) : undefined;\n        var right = targetRight !== undefined ? Autodesk.Viewing.Private.lerp(startRight || 0, targetRight, t) : undefined;\n        var headerHeight = Autodesk.Viewing.Private.lerp(startHeaderHeight, showHeader ? _this4.getInitialHeaderHeight() + (10 - targetTop) * 2 : 0, t);\n\n        _this4.setWidgetSize(\n        width,\n        height,\n        top,\n        left,\n        right,\n        headerHeight);\n\n      };\n\n      return new Promise(function (resolve) {\n        var onAnimEnd = function onAnimEnd() {\n          _this4.widgetAnimation = null;\n          resolve();\n        };\n\n        _this4.widgetAnimation = Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onAnimEnd);\n      });\n    }\n\n    // Relocate BimWalk info button to avoid overlap with Map widget\n  }, { key: \"updateBimWalkInfoButtonPos\", value: function updateBimWalkInfoButtonPos() {\n      var bimWalk = this.viewer.getExtension(BIMWALK_EXT);\n      var button = bimWalk && bimWalk.getInfoButton();\n      if (!button) {\n        return;\n      }\n\n      // If the infor icon is hidden, we don't need all the mess. Hopefully this will get the default\n      // state if others remove the info button as well\n      if (bimWalk.options.disableBimWalkInfoIcon) {\n        return;\n      }\n\n\n      // Only reserve space minimap is visible or about to fade in.\n      var _window = this.getWindow();\n      var style = _window.getComputedStyle(this.mapWidgetRoot);\n      var visible = this.visible || style.opacity > 0;\n      var reservedWidth = visible ? this.mapWidgetWidth : 0;\n\n      // Shifting the info button is not needed in side-by-side mode,\n      // because the map widget is outside the viewer canvas in this case.\n      if (this.sideBySide) {\n        reservedWidth = 0;\n      }\n\n      // Includes space between InfoButton and MapWidget + Space between MapWidget and right canvas boundary\n      var Margin = 20;\n      var right = reservedWidth + Margin;\n      button.style.right = toPixels(right);\n    } }, { key: \"setSideBySideEnabled\", value: function setSideBySideEnabled(\n\n    value) {\n      this.sideBySideEnabled = value;\n      this.updateSideBySide();\n    } }, { key: \"setSideBySideSplit\", value: function setSideBySideSplit(\n\n    value) {\n      this.sideBySideSplit = value;\n      this.updateSideBySide(true);\n      this.updateBimWalkInfoButtonPos();\n    } }, { key: \"animateViewerSize\", value: function animateViewerSize(\n\n    targetWidth, targetHeight, targetLeft, targetRight, targetTop, duration) {var _this5 = this;\n      var startWidth = this.viewer.container.clientWidth;\n      var startHeight = this.viewer.container.clientHeight;\n      var startLeft = this.viewer.container.clientLeft;\n      var startRight = this.viewer.container.clientRight;\n      var startTop = this.viewer.container.clientTop;\n\n      if (this.viewerResizeAnimation) {\n        this.viewerResizeAnimation.stop();\n        this.viewerResizeAnimation = null;\n      }\n\n      duration = duration || this.minimap3DExtension.resizeDuration;\n\n      var onTimer = function onTimer(t) {\n        t = Autodesk.Viewing.Private.smootherStep(t);\n\n        var width = Autodesk.Viewing.Private.lerp(startWidth, targetWidth, t);\n        var height = Autodesk.Viewing.Private.lerp(startHeight, targetHeight, t);\n        var top = Autodesk.Viewing.Private.lerp(startTop, targetTop, t);\n        var left = Autodesk.Viewing.Private.lerp(startLeft, targetLeft, t);\n        var right = Autodesk.Viewing.Private.lerp(startRight, targetRight, t);\n\n        _this5.setViewerSize(\n        width,\n        height,\n        left,\n        right,\n        top);\n\n      };\n\n      return new Promise(function (resolve) {\n        var onAnimEnd = function onAnimEnd() {\n          _this5.viewerResizeAnimation = null;\n          resolve();\n        };\n\n        _this5.viewerResizeAnimation = Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onAnimEnd);\n      });\n    }\n\n    // Make sure that side-by-side layout is activated if and only if minimap is visible\n  }, { key: \"updateSideBySide\", value: function updateSideBySide(force) {\n\n      var wasSideBySide = this.sideBySide;\n      this.sideBySide = this.visible && this.sideBySideEnabled;\n\n      if (!force && wasSideBySide === this.sideBySide) {\n        return;\n      }\n\n      var targetWidth, targetHeight, targetLeft, targetRight, targetTop;\n\n      var clientHeight = this.getClientContainerHeight();\n      var clientWidth = this.getClientContainerWidth();\n\n      if (this.sideBySide) {\n        this.mapWidgetRoot.classList.add('side-by-side');\n\n        if (clientWidth >= clientHeight) {\n          targetWidth = (100 - this.sideBySideSplit) / 100 * clientWidth;\n          targetHeight = clientHeight;\n\n          if (this.sideBySideOptions.left2DView) {\n            targetLeft = this.sideBySideSplit / 100 * clientWidth;\n            targetRight = 0;\n          } else {\n            targetLeft = 0;\n            targetRight = this.sideBySideSplit / 100 * clientWidth;\n          }\n\n          targetTop = 0;\n\n          if (this.sideBySideOptions.left2DView) {\n            this.mapWidgetRoot.classList.add('left-2d-view');\n          }\n\n          this.verticalSideBySide = false;\n        } else {\n          targetWidth = clientWidth;\n          targetHeight = (100 - this.sideBySideSplit) / 100 * clientHeight;\n          targetLeft = 0;\n          targetRight = 0;\n          targetTop = this.sideBySideSplit / 100 * clientHeight;\n\n          this.verticalSideBySide = true;\n        }\n\n        if (this.sideBySideOptions.onSideBySideUpdated) {\n          this.sideBySideOptions.onSideBySideUpdated(this.sideBySideSplit);\n        }\n      } else {\n        targetWidth = clientWidth;\n        targetHeight = clientHeight;\n        targetLeft = 0;\n        targetRight = 0;\n        targetTop = 0;\n\n        this.mapWidgetRoot.classList.remove('side-by-side');\n        this.mapWidgetRoot.classList.remove('left-2d-view');\n      }\n\n      if (force) {\n        this.setViewerSize(targetWidth, targetHeight, targetLeft, targetRight, targetTop);\n      } else {\n        this.animateViewerSize(targetWidth, targetHeight, targetLeft, targetRight, targetTop);\n      }\n\n      this.updateMapSize(force);\n    }\n\n    // Restores default state of container for 3D Minimap and Design Diff Extensions\n  }, { key: \"restoreViewerContainerStyle\", value: function restoreViewerContainerStyle() {\n      if (this.viewerResizeAnimation) {\n        this.viewerResizeAnimation.stop();\n        this.viewerResizeAnimation = null;\n      }\n\n      this.viewer.container.style.width = \"100%\";\n      this.viewer.container.style.height = \"100%\";\n      this.viewer.container.style.left = \"\";\n      this.viewer.container.style.right = \"\";\n      this.viewer.container.style.top = \"\";\n\n      // Update viewer size.\n      this.viewer.resize();\n    } }, { key: \"getMapViewerContainer\", value: function getMapViewerContainer()\n\n    {\n      return this.mapWidget;\n    } }, { key: \"expandSheetMap\", value: function expandSheetMap(\n\n    duration) {\n      if (this.expanded) {\n        return;\n      }\n\n      this.expanded = true;\n\n      this.mapWidgetHeader.style.pointerEvents = 'none';\n\n      this.setSideBySideEnabled(false);\n\n      return this.updateMapSize(false, duration);\n    } }]);return Minimap3DLayout;}();export { Minimap3DLayout as default };\n\n\nGlobalManagerMixin.call(Minimap3DLayout.prototype);","/**\n * Include each locale json file and return it in an object\n * that can be consumed by i18n\n */\n\nimport json_en from '../../../res/locales/en/nobundle-minimap3D.loc.json';\n\nimport json_en_GB from '../../../res/locales/en-GB/nobundle-minimap3D.loc.json';\nimport json_cs from '../../../res/locales/cs/nobundle-minimap3D.loc.json';\nimport json_de from '../../../res/locales/de/nobundle-minimap3D.loc.json';\nimport json_es from '../../../res/locales/es/nobundle-minimap3D.loc.json';\nimport json_fr from '../../../res/locales/fr/nobundle-minimap3D.loc.json';\nimport json_fr_CA from '../../../res/locales/fr-CA/nobundle-minimap3D.loc.json';\nimport json_it from '../../../res/locales/it/nobundle-minimap3D.loc.json';\nimport json_ja from '../../../res/locales/ja/nobundle-minimap3D.loc.json';\nimport json_ko from '../../../res/locales/ko/nobundle-minimap3D.loc.json';\nimport json_pl from '../../../res/locales/pl/nobundle-minimap3D.loc.json';\nimport json_pt_BR from '../../../res/locales/pt-BR/nobundle-minimap3D.loc.json';\nimport json_ru from '../../../res/locales/ru/nobundle-minimap3D.loc.json';\nimport json_tr from '../../../res/locales/tr/nobundle-minimap3D.loc.json';\nimport json_zh_HANS from '../../../res/locales/zh-HANS/nobundle-minimap3D.loc.json';\nimport json_zh_HANT from '../../../res/locales/zh-HANT/nobundle-minimap3D.loc.json';\nimport json_zh_HK from '../../../res/locales/zh-HK/nobundle-minimap3D.loc.json';\nimport json_nl from '../../../res/locales/nl/nobundle-minimap3D.loc.json';\nimport json_sv from '../../../res/locales/sv/nobundle-minimap3D.loc.json';\nimport json_da from '../../../res/locales/da/nobundle-minimap3D.loc.json';\nimport json_no from '../../../res/locales/no/nobundle-minimap3D.loc.json';\n\nexport var locales = {\n  en: json_en,\n  'en-GB': json_en_GB,\n  cs: json_cs,\n  de: json_de,\n  es: json_es,\n  fr: json_fr,\n  \"fr-CA\": json_fr_CA,\n  it: json_it,\n  ja: json_ja,\n  ko: json_ko,\n  pl: json_pl,\n  \"pt-BR\": json_pt_BR,\n  ru: json_ru,\n  tr: json_tr,\n  \"zh-HANS\": json_zh_HANS,\n  \"zh-HANT\": json_zh_HANT,\n  \"zh-HK\": json_zh_HK,\n  nl: json_nl,\n  sv: json_sv,\n  da: json_da,\n  no: json_no };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var av = Autodesk.Viewing;\nvar analytics = av.Private.analytics;\nvar GlobalManagerMixin = av.GlobalManagerMixin;\nvar BIMWALK_EXT = \"Autodesk.BimWalk\";\nvar LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';var\n\nMinimapDropdown = /*#__PURE__*/function () {\n  function MinimapDropdown(parent) {var _this = this;_classCallCheck(this, MinimapDropdown);\n    var DROPDOWN_HEIGHT = 50;\n    this.parent = parent;\n    this.viewer = parent.viewer;\n    this.setGlobalManager(this.viewer.globalManager);\n    this.dropdownWrapper = null;\n    this.parentContainer = parent.mapWidgetHeader;\n    this.onClickOptionHandler = this.onClickOption.bind(this);\n\n    this.createWrapper(DROPDOWN_HEIGHT);\n\n    var floorData = this.getFloorDataFromLevelExtension();\n    this.createDropdown(floorData);\n\n    if (floorData.length === 0) {\n      this.dropdownWrapper.classList.add(\"hidden\");\n    }\n\n    this.onLevelChanged = this.onLevelChanged.bind(this);\n\n    this.viewer.addEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.onLevelChanged);\n\n    this.viewer.getExtensionAsync(LEVEL_EXT).then(function (levelExt) {\n      levelExt.floorSelector.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, _this.onLevelChanged);\n      _this.onLevelChanged();\n    });\n  }_createClass(MinimapDropdown, [{ key: \"createWrapper\", value: function createWrapper(\n\n    dropdownHeight) {\n      var _document = this.getDocument();\n      var wrapper = _document.createElement(\"div\");\n      wrapper.classList.add(\"minimap-dropdown-wrapper\");\n      wrapper.id = 'minimap-dropdown-wrapper';\n      wrapper.style.height = dropdownHeight;\n\n      if (!this.parent.expandButton) {\n        wrapper.style.paddingLeft = '14px';\n      }\n\n      this.parentContainer.appendChild(wrapper);\n\n      this.dropdownWrapper = wrapper;\n    } }, { key: \"createDropdown\", value: function createDropdown(\n\n    floorData) {var _this2 = this;\n      var _document = this.getDocument();\n      this.titleElement = _document.createElement(\"div\");\n      this.titleElement.classList.add(\"minimap-title\");\n      this.dropdownWrapper.appendChild(this.titleElement);\n      this.createDropdownOptions(floorData);\n\n      this.dropdownWrapper.addEventListener(\"click\", function (event) {\n        _this2.dropdownElement.classList.toggle(\"active\");\n        event.stopPropagation();\n      });\n    } }, { key: \"onClickOption\", value: function onClickOption(\n\n    e) {\n      var _document = this.getDocument();\n      this.titleElement.id = e.target.id;\n      var bimWalk = this.viewer.getExtension(BIMWALK_EXT);\n      bimWalk.jumpToFloor(e.target.id);\n      var event = _document.createEvent(\"Event\");\n\n      event.initEvent(\"change\", true, true);\n\n      analytics.track('viewer.3d_minimap.levels');\n\n      this.titleElement.dispatchEvent(event);\n\n      Array.from(this.dropdownElement.children).forEach(function (e) {return (\n          e.classList.remove(\"active\"));});\n\n      this.dropdownWrapper.classList.toggle(\"active\");\n      e.target.classList.toggle(\"active\");\n    } }, { key: \"createDropdownOptions\", value: function createDropdownOptions(\n\n    floorData) {\n      var _document = this.getDocument();\n      this.dropdownElement &&\n      this.dropdownWrapper.removeChild(this.dropdownElement);\n\n      this.dropdownElement = _document.createElement(\"ul\");\n      this.dropdownElement.classList.add(\"minimap-dropdown\");\n      this.dropdownElement.id = 'minimap-dropdown';\n      this.dropdownWrapper.appendChild(this.dropdownElement);\n\n      // Reordering floors in 3D minimap to match the order in Levels Panel\n      for (var i = floorData.length - 1; i >= 0; i--) {\n        this.createNewOption(floorData[i].name, i);\n      }\n    } }, { key: \"createNewOption\", value: function createNewOption(\n\n    name, id) {\n      var _document = this.getDocument();\n      var optionElement = _document.createElement(\"li\");\n\n      optionElement.appendChild(_document.createTextNode(name));\n      optionElement.setAttribute(\"id\", id);\n      optionElement.onclick = this.onClickOptionHandler;\n      this.dropdownElement.appendChild(optionElement);\n    } }, { key: \"onLevelChanged\", value: function onLevelChanged()\n\n    {\n      var levelExt = this.viewer.getExtension(LEVEL_EXT);\n      var level = levelExt.getCurrentLevel();\n\n      if (level) {\n        var floorData = this.getFloorDataFromLevelExtension();\n        this.update(level.index, floorData);\n      }\n    } }, { key: \"getFloorDataFromLevelExtension\", value: function getFloorDataFromLevelExtension()\n\n    {var _levelExt$floorSelect;\n      var levelExt = this.viewer.getExtension(LEVEL_EXT);\n      if (levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect = levelExt.floorSelector) === null || _levelExt$floorSelect === void 0 ? void 0 : _levelExt$floorSelect.floorData) {\n        return levelExt.floorSelector.floorData;\n      }\n      return [];\n    } }, { key: \"update\", value: function update(\n\n    floorIndex, floorData) {\n      if (floorData.length === 0) {\n        this.dropdownWrapper.classList.add(\"hidden\");\n      } else {\n        this.dropdownWrapper.classList.remove(\"hidden\");\n      }\n      this.createDropdownOptions(floorData);\n      if (floorIndex >= 0 && floorData[floorIndex]) {\n        var floor = floorData[floorIndex];\n        this.dropdownWrapper.style.display = \"flex\";\n\n        this.setSelectedValue(floor.name);\n\n        Array.from(this.dropdownElement.children).forEach(function (element) {\n          element.classList.remove(\"active\");\n          if (element.textContent === floor.name) {\n            element.classList.add(\"active\");\n          }\n        });\n      }\n    } }, { key: \"setSelectedValue\", value: function setSelectedValue(\n\n    valueToSet) {\n      this.titleElement.textContent = valueToSet;\n    } }, { key: \"dtor\", value: function dtor()\n\n    {var _levelExt$floorSelect2;\n      this.viewer.removeEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.onLevelChanged);\n\n      var levelExt = this.viewer.getExtension(LEVEL_EXT);\n      levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect2 = levelExt.floorSelector) === null || _levelExt$floorSelect2 === void 0 ? void 0 : _levelExt$floorSelect2.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.onLevelChanged);\n\n      this.dropdownWrapper.parentNode.removeChild(this.dropdownWrapper);\n      this.dropdownWrapper = null;\n    } }]);return MinimapDropdown;}();export { MinimapDropdown as default };\n\n\nGlobalManagerMixin.call(MinimapDropdown.prototype);","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import adjustButtonStyle from \"./adjustButtonStyle\";\nimport { expandIcon } from './resources/Icons';\nvar av = Autodesk.Viewing;\nvar avu = av.UI;\n\nvar GlobalManagerMixin = av.GlobalManagerMixin;var\n\nMinimapExpandButton = /*#__PURE__*/function () {\n  function MinimapExpandButton(parent) {_classCallCheck(this, MinimapExpandButton);\n    this.parent = parent;\n    this.parentElement = parent.mapWidgetHeader;\n    this.viewer = parent.viewer;\n    this.setGlobalManager(parent.viewer.globalManager);\n\n    this.expandButton = new avu.Button(\"Minimap_Expand\");\n    this.expandButton.setGlobalManager(this.globalManager);\n    this.expandButton.onClick = function () {return (\n        parent.minimap3DExtension.expandSheetMap());};\n    this.expandButton.icon.innerHTML = expandIcon;\n    this.expandButton.icon.style.width = \"20px\";\n    this.expandButton.icon.style.height = \"20px\";\n    this.parentElement.appendChild(this.expandButton.container);\n\n    adjustButtonStyle(this.expandButton, false);\n\n    // Set icons and tooltips\n    this.update();\n  }_createClass(MinimapExpandButton, [{ key: \"update\", value: function update()\n\n    {\n      this.expandButton.setState(\n      this.parent.minimap3DExtension.isSheetVisible() ?\n      avu.Button.State.INACTIVE :\n      avu.Button.State.DISABLED);\n\n\n      // Set tooltips based on current states\n      var Expand = Autodesk.Viewing.i18n.translate(\"Go to 2D\");\n      this.expandButton.setToolTip(Expand);\n    } }, { key: \"dtor\", value: function dtor()\n\n    {\n      this.viewer = null;\n    } }]);return MinimapExpandButton;}();export { MinimapExpandButton as default };\n\n\nGlobalManagerMixin.call(MinimapExpandButton.prototype);","// Utility functions used by Minimap\n\n\n// Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.\nvar worldToMapPixels = function worldToMapPixels(pos3D, mapMatrix, mapWidth, mapHeight) {\n  var p = pos3D.clone().applyProjection(mapMatrix);\n  var res = new THREE.Vector2(\n  (p.x + 1) / 2 * mapWidth,\n  (-p.y + 1) / 2 * mapHeight);\n\n  return res;\n};\n\nvar mapPixelsToWorld = function mapPixelsToWorld(posX, posY, zWorld, mapMatrixInv, mapWidth, mapHeight) {\n  // convert pixels to normalized viewport coords in [-1,1]\n  var vx = 2 * (posX / mapWidth) - 1.0;\n  var vy = 2 * (posY / mapHeight) - 1.0;\n\n  // Beware of the annoying y-flip\n  var p = new THREE.Vector3(vx, -vy, 0.0).applyProjection(mapMatrixInv);\n  p.z = zWorld;\n  return p;\n};\n\n// Checks whether the given 3D position would appear inside the map for the given mapMatrix.\n//  @param {Vector3} pos3D\n//  @param {Matrix4} mapMatrix\n//  @returns {bool}\nvar _tmpVec = null;\nvar posIsInsideMap = function posIsInsideMap(pos3D, mapMatrix) {\n\n  _tmpVec = _tmpVec || new THREE.Vector3();\n\n  // Compute position in map space [-1, 1] that we would get when using this map\n  var mapPos = _tmpVec.copy(pos3D).applyProjection(mapMatrix);\n\n  // Check if camera position is inside\n  return Math.abs(mapPos.x) < 1.0 && Math.abs(mapPos.y) < 1.0;\n};\n\n// Configures the ortho-camera from given 3 points, so that:\n//  p0: appears at lower-left corner\n//  p1: appears at lower-right corner\n//  p2: appears at upper-left corner\n//\n// We assume that camera target.z is already set and on the sheet-plane level\nvar setCameraFromFrustumCorners = function setCameraFromFrustumCorners(camera, p0, p1, p2) {\n\n  // up-vector: p2-p0\n  camera.up.x = p2.x - p0.x;\n  camera.up.y = p2.y - p0.y;\n\n  // position\n  camera.position.x = 0.5 * (p1.x + p2.x);\n  camera.position.y = 0.5 * (p1.y + p2.y);\n\n  var frustumHeight = camera.up.length();\n\n  // normalize up-vector\n  camera.up.multiplyScalar(1.0 / frustumHeight);\n\n  // For LMV ortho-cameras...\n  // - The vertical frustum height is identical with the orthoScale \n  // - The orthoScale is determined by the distance between position and target\n  // - For sheets, the view direction is always -z and zoom is manipulated by changing pos.z while having a constant target.z\n  // Therefore, we obtain the desired frustum height by:\n  var targetDist = frustumHeight;\n  camera.position.z = camera.target.z + targetDist;\n\n  // keep horizontal target position in sync\n  camera.target.x = camera.position.x;\n  camera.target.y = camera.position.y;\n\n  // This updates the camera quaternion. Without this, modifying the up-vector would not have any effect.\n  Autodesk.Viewing.Navigation.prototype.orient(camera, camera.target, camera.position, camera.up);\n\n  camera.dirty = true;\n};\n\nvar setTopView = function setTopView(camera, bbox, zMin, zMax, orthoScale) {\n\n  var center = THREE.Box3.prototype.center.call(bbox);\n\n  // set camera pos to upper face center\n  camera.position.copy(center);\n  camera.position.z = zMax;\n\n  // target distance defines orthoScale, which finally\n  // defines the height of the orthoCam frustum in world-space\n  camera.target.copy(camera.position);\n  camera.target.z -= orthoScale;\n  camera.isPerspective = false;\n\n  // set up-vector for view from top\n  camera.up.set(0, 1, 0);\n  camera.worldup.set(0, 1, 0);\n\n  // Configure near/far to see only zMin/zMax range\n  camera.near = 0;\n  camera.far = zMax - zMin;\n\n  // This makes sure that compute3DTo2DMatrix() produces always the same resuts, no matter whether we do it before or after rendering.\n  camera.updateCameraMatrices();\n};\n\n// Computes a Matrix4 that transforms from 3D model position to\n// normalized viewport coords ([-1,1]^2) on the minimap.\nvar compute3DTo2DMatrix = function compute3DTo2DMatrix(camera, dstMatrix) {\n  dstMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n};\n\n// Helper function to smoothen movement of scroll position and zoomScale.\n//  @param {number} dist      - distance to move to reach target directly. Must be >=0.\n//  @param {number} elapsed   - elapsed time in seconds\n//  @param {number} maxSpeed  - maximum allowed distance units per second\n//  @param {number} lastSpeed - motion speed according to last cycle (delta / elapsed)\n//  @param {number} acc       - acceleration speed (in distance units per s^2)\n//  @returns {number} Result is a distance <=dist, which is slowed down if needed for smoother movement.\nvar motionSmoothing = function motionSmoothing(dist, elapsed, maxSpeed, lastSpeed, acc) {\n\n  // Limit max scroll speed and avoid too sudden acceleration compared to last cycle\n  var speed = Math.min(maxSpeed, lastSpeed + acc * elapsed);\n\n  // Slow down with constant deceleration when approaching the target position:\n  //\n  //   With a constant acceleration a for a time of t seconds, we have:\n  //     speed    = t*a\n  //     distance = 0.5 * a * t^2\n  //\n  // To scroll a given distance d with constant acceleration a, the time needed is:\n  //   t = sqrt(2*d / a)\n  //\n  // The speed reached at that point is:\n  //   s = a * sqrt(2*d / a)\n  //\n  // Therefore, s as given above gives us the speed that we must have if distance d\n  // to the target if we want to stop at the target given a constant deceleration of a.\n  var slowDownSpeed = acc * Math.sqrt(2 * dist / acc);\n  speed = Math.min(slowDownSpeed, speed);\n\n  // restrict distance based on computed speed limit\n  var maxDist = speed * elapsed;\n  return Math.min(dist, maxDist);\n};\n\n// Rotates p around the center point. Works for Vector3 in xy too.\n//  @param {Vector2} p\n//  @param {Vector2} center\n//  @param {number}  angle  - counterclockwise angle in radians\nvar rotateAround = function rotateAround(p, center, angle) {\n\n  var c = Math.cos(angle);\n  var s = Math.sin(angle);\n\n  var x = p.x - center.x;\n  var y = p.y - center.y;\n\n  p.x = x * c - y * s + center.x;\n  p.y = x * s + y * c + center.y;\n};\n\n// Expands rect in-place by expanding the smallest axis around the center.\n//  @param {Box2} rect\nvar expandToSquare = function expandToSquare(rect) {\n\n  // determine scale factor from max-axis of sheet bounds\n  var diag = rect.size();\n  var center = rect.center();\n\n  var radius = 0.5 * Math.max(diag.x, diag.y);\n\n  rect.min.set(center.x - radius, center.y - radius);\n  rect.max.set(center.x + radius, center.y + radius);\n};\n\n// Rescales a point p within srcBounds to [0.1]^2. Works in-place.\n//  @param {Vector2} p\n//  @param {Box2} srcBounds\nvar boundsToUnitQuad = function boundsToUnitQuad(p, srcBounds) {\n  var diagX = srcBounds.max.x - srcBounds.min.x;\n  var diagY = srcBounds.max.y - srcBounds.min.y;\n\n  p.x -= srcBounds.min.x;\n  p.y -= srcBounds.min.y;\n\n  p.x /= diagX;\n  p.y /= diagY;\n};\n\n// Compute rotation angle for camera view-cone on map.\n//  @param {THREE.Vector2} pos    - camera position     in minimap pixel space\n//  @param {THREE.Vector2} target - camera target point in minimap pixel space\n//  @returns {number}  Rotation angle in radians to transform a originally up-facing div located\n//                     in a way that it points towards (p2-p1).\nvar computeAngle = function computeAngle(pos, target) {\n  var dx = target.x - pos.x;\n  var dy = target.y - pos.y;\n  var angle = Math.atan2(dy, dx);\n\n  // atan measures the angle to the x-axis, but we want it to work for divs originally aligned with +y.\n  angle += Math.PI / 2;\n\n  return angle;\n};\n\nexport {\nworldToMapPixels,\nmapPixelsToWorld,\nposIsInsideMap,\nsetCameraFromFrustumCorners,\nsetTopView,\ncompute3DTo2DMatrix,\nmotionSmoothing,\nrotateAround,\nexpandToSquare,\nboundsToUnitQuad,\ncomputeAngle };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import adjustButtonStyle from \"./adjustButtonStyle\";\nimport { sideBySideIcon, minimapIcon } from \"./resources/Icons\";\nvar av = Autodesk.Viewing;\nvar avu = av.UI;\n\nvar GlobalManagerMixin = av.GlobalManagerMixin;var\n\nMinimapSideBySideButton = /*#__PURE__*/function () {\n  function MinimapSideBySideButton(parent) {_classCallCheck(this, MinimapSideBySideButton);\n    this.parent = parent;\n    this.parentElement = parent.mapWidgetHeader;\n    this.setGlobalManager(parent.viewer.globalManager);\n    // Create toggle to switch between small map and side-by-side map\n    this.sideBySideButton = new avu.Button(\"Minimap_SideBySide\");\n    this.sideBySideButton.setGlobalManager(this.globalManager);\n    this.sideBySideButton.onClick = function () {return (\n        parent.setSideBySideEnabled(!parent.sideBySideEnabled));};\n    this.sideBySideButton.icon.innerHTML = sideBySideIcon;\n    this.sideBySideButton.icon.style.width = \"20px\";\n    this.sideBySideButton.icon.style.height = \"20px\";\n    this.parentElement.appendChild(this.sideBySideButton.container);\n\n    // Create alternative icon that we show in side-by-side mode\n    var _document = this.getDocument();\n    this.shrinkIcon = _document.createElement(\"div\");\n    this.shrinkIcon.innerHTML = minimapIcon;\n    this.shrinkIcon.style.width = \"20px\";\n    this.shrinkIcon.style.height = \"20px\";\n    this.sideBySideButton.container.appendChild(this.shrinkIcon);\n\n    adjustButtonStyle(this.sideBySideButton, true);\n\n    // Set icons and tooltips\n    this.update();\n  }_createClass(MinimapSideBySideButton, [{ key: \"setSideBySideButtonDisabled\", value: function setSideBySideButtonDisabled(\n\n    disable) {\n      this.sideBySideButtonDisabled = disable;\n    } }, { key: \"update\", value: function update()\n\n    {\n      var sideBySideIsEnabled = this.parent.sideBySideEnabled;\n      // Show expand/collapse icon depending on current state\n      this.shrinkIcon.style.display = sideBySideIsEnabled ? \"block\" : \"none\";\n      this.sideBySideButton.icon.style.display = sideBySideIsEnabled ?\n      \"none\" :\n      \"block\";\n\n      this.sideBySideButton.setState(\n      this.sideBySideButtonDisabled ?\n      avu.Button.State.DISABLED :\n      avu.Button.State.INACTIVE);\n\n\n      // Set tooltips based on current states\n      var SideBySide = Autodesk.Viewing.i18n.translate(\"Side by side\");\n      var Minimap = Autodesk.Viewing.i18n.translate(\"Small map\");\n      this.sideBySideButton.setToolTip(sideBySideIsEnabled ? Minimap : SideBySide);\n    } }, { key: \"dtor\", value: function dtor()\n\n    {\n      this.parentElement.removeChild(this.sideBySideButton.container);\n      this.sideBySideButton = null;\n      this.shrinkIcon = null;\n    } }]);return MinimapSideBySideButton;}();export { MinimapSideBySideButton as default };\n\n\nGlobalManagerMixin.call(MinimapSideBySideButton.prototype);","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} //\n// SheetMap is used by Minimap in order to display a sheet in an own viewer instance - instead of a pre-rendered image containg the automatically generated map.\n//\n\nimport AecData from '../common/AecModelData.js';var\n\nSheetMapConfig = /*#__PURE__*/function () {\n  function SheetMapConfig(viewport, mapMatrix, levelGuid) {_classCallCheck(this, SheetMapConfig);\n    // {object}: viewport on the sheet, as obtained from AecModelData\n    this.viewport = viewport;\n\n    // {Matrix4} transforms from 3D world coords to sheetmap coords in [-1,1]^2\n    this.mapMatrix = mapMatrix;\n    this.mapMatrixInv = new THREE.Matrix4().getInverse(mapMatrix);\n\n    // {string}\n    this.levelGuid = levelGuid;\n\n    // {SheetMapThumbnail}\n    this.thumbnail = undefined;\n  }_createClass(SheetMapConfig, [{ key: \"getSheetNode\", value: function () {var _getSheetNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:if (\n\n\n                this._sheetNode) {_context.next = 4;break;}_context.next = 3;return (\n                  this.viewport.getParentSheetNode());case 3:this._sheetNode = _context.sent;case 4:return _context.abrupt(\"return\",\n\n\n                this._sheetNode);case 5:case \"end\":return _context.stop();}}}, _callee, this);}));function getSheetNode() {return _getSheetNode.apply(this, arguments);}return getSheetNode;}() }]);return SheetMapConfig;}();var\n\n\n\nSheetMap = /*#__PURE__*/function () {function SheetMap() {_classCallCheck(this, SheetMap);}_createClass(SheetMap, null, [{ key: \"computeMapMatrix\",\n\n    // Computes a mapMatrix based on a viewport on a sheet. The matrix transforms from 3D model coordinates to \n    // normalized map coords in [-1,1]^2.\n    //  @param {Object} viewport - Viewport data obtained from AECModelData.json    \n    //  @param {av.Model} model3D  - A currently visible 3D model of the Revit document for which we found the sheet.\n    //  @returns THREE.Matrix4\n    value: function computeMapMatrix(viewport, model3D) {\n\n      // We map from model coords via sheet coords to finally [-1,1]^2.\n      //\n      // The functions getViewportBounds() and get3DTo2DMatrix() work in sheet-space, so that they require\n      // the sheetUnitScale - which we don't know before loading the sheet.\n      //\n      // But, since we finally map the viewport to [-1,1] anyway, a uniform scaling of the sheet has no impact on \n      // the final map matrix anyway. So we can assume a dummy unitScale of 1.0 here.\n      var DummyUnitScale = 1.0;\n\n      var sheetRegion = viewport.getViewportBounds(DummyUnitScale);\n\n      // Create matrix to map sheetRegion to [-1,1]^2\n      var sheetToMap = AecData.remapRectangle(\n      sheetRegion.min.x, sheetRegion.min.y, sheetRegion.max.x, sheetRegion.max.y, // from: SheetRegion\n      -1, -1, 1, 1 // to: [0,1]^2\n      );\n\n      var modelToSheet = viewport.get3DTo2DMatrix(DummyUnitScale);\n      var mapMatrix = new THREE.Matrix4().multiplyMatrices(sheetToMap, modelToSheet);\n\n      if (viewport.isMatrixInLocalCoords()) {\n        // The mapMatrix computed so far maps local model coordinates to map coordinates. \n        // Finally, we want to map from local LMV coordinates. Therefore, the final transform\n        // must revert any load-time transforms first.\n        var modelTransform = model3D.getInverseModelToViewerTransform();\n\n        if (modelTransform) {\n          mapMatrix.multiply(modelTransform);\n        }\n      }\n\n      return mapMatrix;\n    }\n\n    // Creates sheetMap configurations for all sheetMaps that are found on the current floor.\n    //  @param {av.Model[]} models - 3D models in which we search for viewports/sheets\n    //  @param {string}     levelGuid\n    //  @returns {SheetMapConfig[]} \n  }, { key: \"createSheetMapConfigs\", value: function createSheetMapConfigs(models3D, levelGuid, viewportsExtension) {\n\n      // Find all viewports that would be suitable as a floor map. \n      var maps = [];\n\n      for (var i = 0; i < models3D.length; i++) {\n\n        // Find viewports for levelGuid in the document of mapModel[i]\n        var model3D = models3D[i];\n        var bubbleNode = model3D.getDocumentNode();\n\n        if (!bubbleNode) {\n          continue;\n        }\n\n        var modelViewports = viewportsExtension.findViewportsInLevel(model3D, levelGuid);\n\n        // For each viewport...\n        for (var j = 0; j < modelViewports.length; j++) {\n\n          var viewport = modelViewports[j];\n\n          // Compute mapMatrix for this viewport\n          var mapMatrix = SheetMap.computeMapMatrix(viewport, model3D);\n\n          // We found a candidate (viewport, sheet) pair\n          var map = new SheetMapConfig(viewport, mapMatrix, levelGuid);\n\n          maps.push(map);\n        }\n      }\n\n      return maps;\n    } }]);return SheetMap;}();export { SheetMap as default };","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport { expandToSquare, boundsToUnitQuad } from './MinimapMath.js';\n\nvar av = Autodesk.Viewing;\n\n// Use the largest we can get from DS\nvar DsThumbnailSize = 400;\nvar GeneratedThumbnailSize = 1500;\n\nvar getThumbnailCropRegion = function getThumbnailCropRegion(sheetBox, viewport) {var sheetUnitScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0254;\n\n  // Thumbnails are square and contain empty pixels to expand the rectangle to a square.\n  // Therefore, the whole thumbnail image does not match the sheet bounds exactly,\n  // but actually corresponds to the square containing it.\n  expandToSquare(sheetBox);\n\n  // Actually, we shouldn't care about sheetUnitScale here. We only\n  // need it because Revit extractor gives us viewport bounds and sheet bounds in different coordinate systems. \n  // Unfortunately, we have to guess the sheetUnitScale here, because we cannot load all sheets first just to get the unitScale.\n  //\n  // TODO: If we provide the viewport boundary in sheet coordinates in Revit extractor, we don't need this hack anymore.\n\n  // get viewport bounds in sheet coords (usually inches)    \n  var viewportBounds = viewport.getViewportBounds(sheetUnitScale).clone();\n\n  // map from sheetBox to thumbnail pixels\n  boundsToUnitQuad(viewportBounds.min, sheetBox);\n  boundsToUnitQuad(viewportBounds.max, sheetBox);\n\n  return viewportBounds;\n};\n\n// Applies css styling on image element, so that the given cropRegion fits the parent div\n//\n// @param {Box2}  cropRegion - in [0,1]^2, relative to the full image\n// @param {Image} image      - html image element\nvar cropImage = function cropImage(image, cropRegion) {\n  var _document = av.getGlobal().document;\n  var canvas = _document.createElement(\"canvas\");\n  var ctx = canvas.getContext(\"2d\");\n\n  // compute size of crop region (relative to full image)\n  var cropWidthRatio = cropRegion.max.x - cropRegion.min.x;\n  var cropHeightRatio = cropRegion.max.y - cropRegion.min.y;\n\n  var destWidth = cropWidthRatio * image.width;\n  var destHeight = cropHeightRatio * image.height;\n\n  canvas.width = destWidth;\n  canvas.height = destHeight;\n\n  ctx.drawImage(\n  image,\n  cropRegion.min.x * image.width, (1 - cropRegion.max.y) * image.height,\n  destWidth, destHeight,\n  0, 0,\n  destWidth, destHeight);\n\n\n  var texImage = new Image();\n  texImage.src = canvas.toDataURL();\n\n  return texImage;\n};\n\n// Sheetmap thumbnails are embedded in the minimap to display for which regions inside the minimap a sheetmap is available. \n// A sheetmap thumbnail is a sheet thumbnail that is cropped down to a single viewport and embedded into the main map.\nvar SheetMapThumbnail = /*#__PURE__*/function () {\n\n  // @param {SheetMapConfig} sheetMapConfig - Config object for the sheet to be represented by this thumbnail\n  function SheetMapThumbnail(sheetMapConfig, viewer, onThumbnailReady) {var _this = this;_classCallCheck(this, SheetMapThumbnail);\n    this.sheetMapConfig = sheetMapConfig;\n\n    this.viewer = viewer;\n\n    this.thumbnailImage = null;\n\n    this.thumbnailRefined = false;\n\n    this.onThumbnailReady = onThumbnailReady;\n\n    this.img = new Image();\n    this.img.onload = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var sheetNode, viewNode, viewBoxValues, sheetBox, cropRegion;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n                _this.sheetMapConfig.getSheetNode());case 2:sheetNode = _context.sent;\n\n              // get full sheet bounds from viewbox\n              viewNode = sheetNode.search({ type: 'view' })[0];\n\n              // We can't crop the thumbnail without knowing the sheet's original dimensions.\n              // The problem is that the thumbnail is always square - and the sheet isn't.\n              // Even if we know the exact dimensions of the viewport - it's not enough in order to decide how to crop the squared thumbnail.\n              if (viewNode) {_context.next = 6;break;}return _context.abrupt(\"return\");case 6:\n\n\n\n              viewBoxValues = viewNode.getViewBox();\n              sheetBox = new THREE.Box2();\n              sheetBox.min.set(viewBoxValues[0], viewBoxValues[1]);\n              sheetBox.max.set(viewBoxValues[2], viewBoxValues[3]);\n              cropRegion = getThumbnailCropRegion(sheetBox, _this.sheetMapConfig.viewport);\n\n              _this.cropThumbnail(_this.img, cropRegion);case 12:case \"end\":return _context.stop();}}}, _callee);}));\n\n  }_createClass(SheetMapThumbnail, [{ key: \"cropThumbnail\", value: function cropThumbnail(\n\n    img, cropRegion) {var _this2 = this;\n      var croppedThumbnail = cropImage(img, cropRegion);\n\n      croppedThumbnail.onload = function () {\n        _this2.thumbnailImage = croppedThumbnail;\n        _this2.onThumbnailReady(_this2.sheetMapConfig);\n      };\n    } }, { key: \"onThumbnailDownloaded\", value: function onThumbnailDownloaded(\n\n    blobUrl) {\n      // Verify that the thumbnail wasn't generated locally meanwhile.\n      if (!this.thumbnailRefined) {\n        this.img.src = blobUrl;\n      }\n    }\n\n    // Creates a div containing the thumbnail of a given sheet node as an image element.\n  }, { key: \"requestThumbnail\", value: function () {var _requestThumbnail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var _this3 = this;var sheetNode, root, doc, options, url, onReceive;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (\n\n                  this.sheetMapConfig.getSheetNode());case 2:sheetNode = _context2.sent;\n\n                // get thumbnail url\n                root = sheetNode.getRootNode();\n                doc = root.getDocument();\n\n                options = doc.getThumbnailOptions(sheetNode.data, DsThumbnailSize, DsThumbnailSize);\n\n                // takes care of local bubbles\n                if (sheetNode.data.thumbnailUrn) {\n                  options.urn = sheetNode.getDocument().getFullPath(sheetNode.data.thumbnailUrn);\n                  options.responseType = 'blob';\n                  Autodesk.Viewing.Private.ViewingService.getThumbnail(Autodesk.Viewing.initLoadContext(), options.urn, function (response) {\n                    var reader = new FileReader();\n                    reader.onload = function (e) {\n                      _this3.onThumbnailDownloaded(e.target.result);\n                    };\n                    reader.readAsDataURL(response);\n\n                  },\n                  function (error) {console.warn(\"Failed to load sheet thumbnail. Error: \".concat(error, \", Urn: \").concat(options.urn, \", SheetName: \").concat(sheetNode.name()));},\n                  options);\n                } else if (Autodesk.Viewing.endpoint.getUseCookie()) {\n                  // Set derivative service Url directly and use cookie for credentials\n                  url = doc.getThumbnailPath(sheetNode.data, DsThumbnailSize, DsThumbnailSize);\n                  this.onThumbnailDownloaded(url);\n                } else {\n                  // When not using a cookie for credentials, we have to request the thumbnails using ViewingService.\n                  onReceive = function onReceive(error, blob) {\n\n                    // Display a warning if overlay thumbnail will not show up\n                    if (error) {\n                      console.warn(\"Failed to load sheet thumbnail. Error: \".concat(error, \", Urn: \").concat(options.urn, \", SheetName: \").concat(sheetNode.name()));\n                      return;\n                    }\n\n                    // assign imageUrl \n                    var blobUrl = av.getGlobal().URL.createObjectURL(blob);\n                    _this3.onThumbnailDownloaded(blobUrl);\n                  };\n\n                  // Request thumbnail from DS\n                  Autodesk.Viewing.Document.requestThumbnailWithSecurity(options, onReceive);\n                }case 7:case \"end\":return _context2.stop();}}}, _callee2, this);}));function requestThumbnail() {return _requestThumbnail.apply(this, arguments);}return requestThumbnail;}()\n\n\n    // Takes a screenshot of the 2D sheet, and replace the low-res thumbnail with it.\n  }, { key: \"refineThumbnail\", value: function refineThumbnail() {var _this4 = this;\n\n      // Make sure that we do the screenshot only once per sheetMap\n      if (this.thumbnailRefined) {\n        return;\n      }\n\n      this.thumbnailRefined = true;\n\n      // Align camera to capture the whole sheet\n      var box = this.viewer.model.getBoundingBox(true);\n\n      // Setup camera for the snapshot\n      var camera = new Autodesk.Viewing.UnifiedCamera(GeneratedThumbnailSize, GeneratedThumbnailSize);\n      camera.setViewFromBox(box, true);\n\n      var onScreenshotDone = function onScreenshotDone(imageUrl) {\n        _this4.img.src = imageUrl;\n\n        _this4.img.onload = function () {\n          var cropRegion = getThumbnailCropRegion(box, _this4.sheetMapConfig.viewport, _this4.viewer.model.getUnitScale());\n          _this4.cropThumbnail(_this4.img, cropRegion);\n        };\n      };\n\n      var options = {\n        camera: camera };\n\n\n      this.viewer.impl.getScreenShotProgressive(GeneratedThumbnailSize, GeneratedThumbnailSize, onScreenshotDone, options);\n    } }]);return SheetMapThumbnail;}();export { SheetMapThumbnail as default };","// Some customizations for LMV buttons\nexport default (function (button, rightTooltip) {\n  //Default LMV buttons are too large for the minimap\n  button.container.style.width = \"20px\";\n  button.container.style.height = \"20px\";\n  button.container.style.padding = \"3px 8px\";\n\n  // The icon class adds a top-padding of 3 which broke the centering of the button.\n  button.icon.classList.remove(\"adsk-button-icon\");\n\n  // Show tooltips left of the buttons and vertically centered.\n  // The default behavior would place the tooltip outside of canvas and minimap,\n  // so that they would not be visible.\n  button.setToolTip(\"\"); // Init tooltip element\n  var tts = button._toolTipElement.style;\n  tts.bottom = \"0px\";\n  tts.top = \"auto\";\n  tts.height = \"fit-content\";\n\n  if (rightTooltip) {\n    tts.left = \"auto\";\n    tts.right = \"130%\";\n  } else {\n    tts.top = \"40px\";\n  }\n\n  tts.zIndex = 3;\n});","var expandIcon = [\n'<svg viewBox=\"2 2 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">',\n'<path d=\"M20 10V17C20 17.5523 19.5523 18 19 18H5C4.44772 18 4 17.5523 4 17V7C4 6.44772 4.44772 6 5 6H16M20 10L16 6M20 10H17C16.4477 10 16 9.55228 16 9V6\" stroke=\"currentColor\"/>',\n'<path d=\"M13 9H7V15.5H12V13\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>',\n'<path d=\"M11.5 15.5H16V12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>',\n'<path d=\"M10 9V11.5\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>',\n\"</svg>\"].\njoin(\"\");\n\nvar sideBySideIcon = [\n'<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">',\n'<rect width=\"24\" height=\"24\" fill=\"none\"/>',\n'<rect x=\"3\" y=\"5\" width=\"18\" height=\"14\" rx=\"2\" stroke=\"currentColor\" stroke-width=\"1.5\"/>',\n'<rect x=\"13.5\" y=\"7.5\" width=\"5\" height=\"9\" rx=\"0.5\" fill=\"currentColor\" stroke=\"currentColor\"/>',\n'</svg>'].\njoin(\"\");\n\nvar minimapIcon = [\n'<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">',\n'<rect width=\"24\" height=\"24\" fill=\"none\"/>',\n'<rect x=\"3\" y=\"5\" width=\"18\" height=\"14\" rx=\"2\" stroke=\"currentColor\" stroke-width=\"1.5\"/>',\n'<rect x=\"13.5\" y=\"7.5\" width=\"5\" height=\"3.16667\" rx=\"0.5\" fill=\"currentColor\" stroke=\"currentColor\"/>',\n\"</svg>\"].\njoin(\"\");\n\nexport {\nexpandIcon,\nsideBySideIcon,\nminimapIcon };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var OVERLAY_SCENE = 'camera-near-far-overlay-scene';\n\nvar EPSILON = 0.001;\nvar PLANE_WIDTH = 200; // px\nvar PLANE_HEIGHT = 4; // px\n\n// Useful for debugging - displays the camera's near & far planes on the minimap.\nvar NearFarOverlay = /*#__PURE__*/function () {\n  function NearFarOverlay(topViewViewer, targetViewer) {_classCallCheck(this, NearFarOverlay);\n    this.topViewViewer = topViewViewer;\n    this.targetViewer = targetViewer;\n\n    this.topViewViewer.impl.createOverlayScene(OVERLAY_SCENE);\n\n    this.planeGeometry = new THREE.PlaneBufferGeometry(1, 1);\n    this.nearPlane = this.createMesh(0x005BCE); // Blu-ish\n    this.farPlane = this.createMesh(0xe8b22c); // Yellow-ish\n\n    this.show();\n    this.update();\n\n    this.update = this.update.bind(this);\n    this.targetViewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.update);\n    this.topViewViewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.update);\n  }_createClass(NearFarOverlay, [{ key: \"createMesh\", value: function createMesh(\n\n    color) {\n      var material = new THREE.MeshBasicMaterial({\n        color: color,\n        opacity: 1,\n        transparent: false,\n        depthTest: false,\n        depthWrite: false,\n        side: THREE.DoubleSide });\n\n\n      var mesh = new THREE.Mesh(this.planeGeometry, material);\n\n      return mesh;\n    } }, { key: \"show\", value: function show()\n\n    {\n      this.topViewViewer.impl.addOverlay(OVERLAY_SCENE, this.nearPlane);\n      this.topViewViewer.impl.addOverlay(OVERLAY_SCENE, this.farPlane);\n    } }, { key: \"hide\", value: function hide()\n\n    {\n      this.topViewViewer.impl.removeOverlay(OVERLAY_SCENE, this.nearPlane);\n      this.topViewViewer.impl.removeOverlay(OVERLAY_SCENE, this.farPlane);\n    } }, { key: \"getScale\", value: function getScale(\n\n    pixelSize) {\n      var worldHeight = this.topViewViewer.getCamera().orthoScale;\n      var viewport = this.topViewViewer.navigation.getScreenViewport();\n      var scale = pixelSize * worldHeight / viewport.height;\n\n      return scale;\n    } }, { key: \"update\", value: function update()\n\n    {\n      var camera = this.targetViewer.getCamera();\n\n      var eyeDir = camera.target.clone().sub(camera.position).normalize();\n      var angle = Math.atan2(camera.target.y - camera.position.y, camera.target.x - camera.position.x) + THREE.Math.degToRad(90);\n\n      var pixelToWorld = this.getScale(1); // 1 pixel world scale\n      var z = this.topViewViewer.getCamera().position.z - EPSILON;\n\n      // Update near plane mesh\n      var nearPos = camera.position.clone().add(eyeDir.clone().multiplyScalar(camera.near));\n      nearPos.z = z;\n      this.nearPlane.position.copy(nearPos);\n      this.nearPlane.scale.set(pixelToWorld * PLANE_WIDTH, pixelToWorld * PLANE_HEIGHT, 1);\n      this.nearPlane.rotation.set(0, 0, angle);\n\n      // Update far plane mesh\n      var farPos = camera.position.clone().add(eyeDir.clone().multiplyScalar(camera.far));\n      farPos.z = z;\n      this.farPlane.position.copy(farPos);\n      this.farPlane.scale.set(pixelToWorld * PLANE_WIDTH, pixelToWorld * PLANE_HEIGHT, 1);\n      this.farPlane.rotation.set(0, 0, angle);\n\n      this.topViewViewer.impl.invalidate(false, false, true);\n    } }, { key: \"destroy\", value: function destroy()\n\n    {\n      this.planeGeometry.dispose();\n      this.planeGeometry = null;\n\n      this.topViewViewer.impl.removeOverlayScene(OVERLAY_SCENE);\n\n      this.targetViewer.removeEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.update);\n      this.topViewViewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.update);\n\n      this.topViewViewer = null;\n      this.targetViewer = null;\n    } }]);return NearFarOverlay;}();export { NearFarOverlay as default };","export var SheetSyncEvents = {\n  MAIN_MAP_CHANGED_EVENT: 'mapChanged',\n  CHANGING_SHEET_EVENT: 'changingSheet',\n  SHEET_VISIBILITY_CHANGED_EVENT: 'sheetVisibilityChanged' };\n\n\nexport var SHEET_OPACITY = 0.8; // When sheet is displayed on top of top view screenshot, it should be half transparent.\nexport var FADE_DURATION = 0.7; // Time to fade sheet's opacity. Value matches \"transition: opacity 0.7s\" inside Avatar.scss\nexport var ROTATION_DURATION = 2.0; // Time to rotate a sheet in order for it to face upwards.\nexport var WAIT_BEFORE_ROTATION = 1.0; // Time to rotate a sheet in order for it to face upwards.","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import SheetMap from '../Minimap3D/SheetMap';\nimport TopViewRenderer from \"./TopViewRenderer\";\nimport { compute3DTo2DMatrix, setTopView, posIsInsideMap } from '../Minimap3D/MinimapMath';\nimport { SheetSyncEvents } from './SheetSyncConstants';\nimport SheetVisibilityManager from './SheetVisibilityManager';\n\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\nvar Empty2DModelLoader = avp.Empty2DModelLoader;\n\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar myExtensionName = 'Autodesk.AEC.SheetSyncExtension';\n\n/**\n                                                         // SheetSyncExtension - A viewer extension that syncs between a 3D model and its corresponding 2D sheet.\n                                                         //                      Works only when BimWalk is active. Whenever the player changes position, the 2D sheet will be updated according to the correct viewport.\n                                                         //\n                                                         // @param {Viewer3D} [viewer]                       - viewer instance\n                                                         // @param {Object} [options]                        - Configuration options for SheetSyncExtension\n                                                         // @param {Viewer3D} [options.targetViewer]         - Target viewer instance.\n                                                         // @param {bool} [options.cropToViewport]           - When enabled, the viewport that's related to the 3D camera will be cropped.\n                                                         // @param {bool} [options.hideSheetWhenNotFocused]  - When enabled, when the 3D camera is not inside the sheet's viewport, the sheet will disappear.\n                                                         // @param {function} [options.autoSwitchSheet]      - Automatically load sheet when map has been changed.\n                                                         // @param {function} [options.loadDocumentNode]     - Optional item loading API.\n                                                         // @param {function} [options.unloadModel]          - Optional item unloading loading API.\n                                                         // @param {Viewer3D} [options.hidePaper]            - Hide the white paper from the 2D sheet.\n                                                         // @param {Viewer3D} [options.useCustomModel]       - Use a specific 3D model to sync, instead of using all visible models by default.\n                                                         */var\nSheetSyncExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(SheetSyncExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(SheetSyncExtension);\n  function SheetSyncExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, SheetSyncExtension);\n    _this = _super.call(this, viewer, options);\n\n    _this.options = _this.options.sheetSyncOptions || _this.options;\n    _this.targetViewer = _this.options.targetViewer;\n\n    // SheetMap that is relevant to the current camera position.\n    _this.sheetMap = null;\n\n    // Models in 3D target viewer that we are going to sync to.\n    _this.targetModels = [];\n\n    // Cache for all sheetMapConfigs.\n    _this.mapCache = {};\n\n    // Cache for fuzzyBox per model id.\n    _this.modelIdToFuzzyBox = [];\n\n    // [modelKey -> boolean] map that represents if a sheet model is being currently loaded.\n    _this.isModelLoadingMap = {};\n\n    // Whether to show 2D sheet. Show sheet by default.\n    var showSheet = _this.options.showSheet !== undefined ? _this.options.showSheet : true;\n    _this.setShowSheet(showSheet);\n\n    // Controller of 2D sheet visibility and crop.\n    _this.sheetVisibilityManager = new SheetVisibilityManager(_this.viewer, _this.options);\n\n    _this.onNavigationToolChanged = _this.onNavigationToolChanged.bind(_assertThisInitialized(_this));\n    _this.onSheetGeometryLoaded = _this.onSheetGeometryLoaded.bind(_assertThisInitialized(_this));\n    _this.on3dGeometryLoaded = _this.on3dGeometryLoaded.bind(_assertThisInitialized(_this));\n    _this.updateSheetAppearance = _this.updateSheetAppearance.bind(_assertThisInitialized(_this));\n    _this.isCameraInsideMap = _this.isCameraInsideMap.bind(_assertThisInitialized(_this));\n    _this.onModelTransformChanged = _this.onModelTransformChanged.bind(_assertThisInitialized(_this));\n    _this.update = _this.update.bind(_assertThisInitialized(_this));\n    _this.onViewportDataFetched = _this.onViewportDataFetched.bind(_assertThisInitialized(_this));return _this;\n  }_createClass(SheetSyncExtension, [{ key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n\n\n                  this.targetViewer.loadExtension('Autodesk.AEC.ViewportsExtension'));case 2:this.viewportsExtension = _context.sent;\n\n                this.targetViewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.onNavigationToolChanged);\n\n                this.onNavigationToolChanged();return _context.abrupt(\"return\",\n\n                true);case 6:case \"end\":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"unload\", value: function unload()\n\n\n    {\n      this.deactivate();\n\n      this.viewportsExtension = null;\n\n      // Clear cut planes if needed, and update opacity.\n      this.sheetVisibilityManager.setVisibilityImmediate(true);\n      this.sheetVisibilityManager.updateCrop(null);\n\n      // Restore paper for all sheets.\n      this.changePaperVisibility(true);\n\n      this.sheetMap = null;\n      this.targetModels = [];\n\n      this.targetViewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.onNavigationToolChanged); // This listener should be removed specifically here, not inside removeListeners.\n\n      return true;\n    } }, { key: \"onViewportDataFetched\", value: function onViewportDataFetched()\n\n    {\n      this.invalidateSheetMaps();\n    } }, { key: \"changePaperVisibility\", value: function changePaperVisibility(\n\n    show, models) {\n      // Nothing to change in case hidePaper was never set.\n      if (!this.options.hidePaper) {\n        return;\n      }\n\n      models = models || this.viewer.getAllModels();\n\n      models.forEach(function (model) {\n        model.changePaperVisibility(show);\n      });\n\n      this.viewer.impl.invalidate(true);\n    } }, { key: \"activate\", value: function activate()\n\n    {\n      if (this.active) {\n        return;\n      }\n\n      this.active = true;\n\n      this.addListeners();\n\n      this.on3dGeometryLoaded();\n\n      // Make sure all papers are hidden if needed.\n      this.changePaperVisibility(false);\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      if (!this.active) {\n        return;\n      }\n\n      this.active = false;\n\n      this.sheetMap = null;\n\n      this.removeListeners();\n    } }, { key: \"addListeners\", value: function addListeners()\n\n    {var _levelExt$floorSelect, _levelExt$floorSelect2;\n      this.targetViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update);\n      this.targetViewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update);\n      this.targetViewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.update);\n      this.targetViewer.addEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);\n      this.targetViewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.on3dGeometryLoaded);\n      this.targetViewer.addEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.updateSheetAppearance);\n      this.viewer.addEventListener(av.MODEL_ROOT_LOADED, this.onSheetGeometryLoaded);\n      this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);\n      this.viewer.addEventListener(av.TEXTURES_LOADED_EVENT, this.onSheetGeometryLoaded);\n      this.viewer.addEventListener(SheetSyncEvents.MAIN_MAP_CHANGED_EVENT, this.updateSheetAppearance);\n\n      this.viewportsExtension.addEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this.onViewportDataFetched);\n\n      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');\n      levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect = levelExt.floorSelector) === null || _levelExt$floorSelect === void 0 ? void 0 : _levelExt$floorSelect.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);\n      levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect2 = levelExt.floorSelector) === null || _levelExt$floorSelect2 === void 0 ? void 0 : _levelExt$floorSelect2.addEventListener(Autodesk.AEC.FloorSelector.FLOOR_DATA_CHANGED, this.onViewportDataFetched);\n\n    } }, { key: \"removeListeners\", value: function removeListeners()\n\n    {var _levelExt$floorSelect3, _levelExt$floorSelect4;\n      this.targetViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);\n      this.targetViewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);\n      this.targetViewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.update);\n      this.targetViewer.removeEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);\n      this.targetViewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.on3dGeometryLoaded);\n      this.targetViewer.removeEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.updateSheetAppearance);\n      this.viewer.removeEventListener(av.MODEL_ROOT_LOADED, this.onSheetGeometryLoaded);\n      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);\n      this.viewer.removeEventListener(av.TEXTURES_LOADED_EVENT, this.onSheetGeometryLoaded);\n      this.viewer.removeEventListener(SheetSyncEvents.MAIN_MAP_CHANGED_EVENT, this.updateSheetAppearance);\n\n      this.viewportsExtension.removeEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this.onViewportDataFetched);\n\n      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');\n      levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect3 = levelExt.floorSelector) === null || _levelExt$floorSelect3 === void 0 ? void 0 : _levelExt$floorSelect3.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);\n      levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect4 = levelExt.floorSelector) === null || _levelExt$floorSelect4 === void 0 ? void 0 : _levelExt$floorSelect4.removeEventListener(Autodesk.AEC.FloorSelector.FLOOR_DATA_CHANGED, this.onViewportDataFetched);\n    } }, { key: \"isEnabled\", value: function isEnabled()\n\n    {var _this$targetViewer$ge;\n      return this.targetViewer.getActiveNavigationTool() === 'bimwalk' || ((_this$targetViewer$ge = this.targetViewer.getExtension('Autodesk.AEC.Minimap3DExtension')) === null || _this$targetViewer$ge === void 0 ? void 0 : _this$targetViewer$ge.isEnabled());\n    } }, { key: \"onNavigationToolChanged\", value: function onNavigationToolChanged()\n\n    {\n      if (this.isEnabled()) {\n        this.activate();\n      } else {\n        this.deactivate();\n      }\n\n      this.update();\n    }\n\n    // Update sheet's opacity and crop bounds.\n  }, { key: \"updateSheetAppearance\", value: function updateSheetAppearance() {\n      if (!this.isSheetMapLoaded(this.sheetMap) || !this.isMapOnCurrentLevel(this.sheetMap)) {\n        this.sheetVisibilityManager.setVisibilityImmediate(false);\n        this.sheetVisibilityManager.updateCrop(null);\n      } else {\n        var visible = this.showSheet && this.isCameraInsideMap(this.sheetMap) && this.isEnabled();\n        this.sheetVisibilityManager.updateSheetAppearance(this.sheetMap, visible);\n      }\n    }\n\n    // Get a union of all targetModel's fuzzy-boxes.\n  }, { key: \"getFuzzyBox\", value: function getFuzzyBox() {\n      var fuzzyBoxRes = new THREE.Box3();\n\n      // sum up fuzzy boxes of all map models\n      for (var i = 0; i < this.targetModels.length; i++) {\n\n        var model = this.targetModels[i];\n\n        // get bbox from cache if possible\n        var bbox = this.modelIdToFuzzyBox[model.id];\n\n        if (!bbox) {\n          // compute fuzzybox and add it to cache\n          bbox = model.getFuzzyBox();\n\n          if (model.isLoadDone()) {\n            this.modelIdToFuzzyBox[model.id] = bbox;\n          }\n        }\n\n        fuzzyBoxRes.union(bbox);\n      }\n\n      return fuzzyBoxRes;\n    }\n\n    // Generate a dummy sheetMap, according to the entire 3D model bounding box.\n    // Initially, the map should fully fit the canvas.\n  }, { key: \"generateDummyMap\", value: function generateDummyMap() {\n      // If sheetmap already set, no need to generate dummy map.\n      if (this.sheetMap) {\n        return;\n      }\n\n      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');\n      var currentLevel = levelExt && levelExt.getCurrentLevel();\n      var zRange = currentLevel && levelExt.getZRange(currentLevel.index);\n\n      var modelFuzzyBox = this.getFuzzyBox();\n\n      if (modelFuzzyBox.empty()) {\n        return;\n      }\n\n      // If no level zRange is specified, use the zRange enclosing all visible models\n      var zMin = zRange ? zRange.zMin : modelFuzzyBox.min.z;\n      var zMax = zRange ? zRange.zMax : modelFuzzyBox.max.z;\n\n      modelFuzzyBox.min.z = 0;\n      modelFuzzyBox.max.z = 0;\n\n      var renderer = this.viewer.impl.renderer();\n      var canvasWidth = renderer.settings.logicalWidth;\n      var canvasHeight = renderer.settings.logicalHeight;\n\n      var camera = new av.UnifiedCamera(canvasWidth, canvasHeight);\n      setTopView(camera, modelFuzzyBox, zMin, zMax, modelFuzzyBox.size().y);\n\n      var mapMatrix = new THREE.Matrix4();\n      var mapMatrixInv = new THREE.Matrix4();\n      compute3DTo2DMatrix(camera, mapMatrix);\n      mapMatrixInv.getInverse(mapMatrix);\n\n      var min = this.viewer.clientToWorld(0, 0, undefined, true).point;\n      var max = this.viewer.clientToWorld(canvasWidth, canvasHeight, undefined, true).point;\n\n      var viewportBounds = new THREE.Box3().setFromPoints([min, max]);\n\n      this.sheetMap = {\n        viewportBounds: viewportBounds,\n        mapMatrix: mapMatrix,\n        mapMatrixInv: mapMatrixInv,\n        viewport: {\n          getGuid: function getGuid() {return 'dummyViewportGuid';},\n          getSheetName: function getSheetName() {return 'dummySheetName';},\n          getSheetUrn: function getSheetUrn() {return 'dummySheetUrn';} } };\n\n\n\n      this.viewer.dispatchEvent({ type: SheetSyncEvents.MAIN_MAP_CHANGED_EVENT, sheetMap: this.sheetMap });\n\n      this.update();\n    } }, { key: \"on3dGeometryLoaded\", value: function on3dGeometryLoaded()\n\n    {\n      this.updateTargetModels();\n\n      // No target models yet.\n      if (!this.targetModels) {\n        return;\n      }\n\n      this.generateDummyMap();\n\n      this.update();\n    }\n\n    // Hide sheet's paper.\n  }, { key: \"onSheetGeometryLoaded\", value: function onSheetGeometryLoaded(_ref) {var model = _ref.model;\n      this.changePaperVisibility(false, [model]);\n      this.update();\n    } }, { key: \"invalidateSheetMaps\", value: function invalidateSheetMaps()\n\n    {var _this2 = this;\n      Object.keys(this.mapCache).forEach(function (guid) {\n        // Create a new mapMatrix according to the transformed models.\n        var newMaps = SheetMap.createSheetMapConfigs(_this2.targetModels, guid, _this2.viewportsExtension);\n\n        newMaps.forEach(function (newMap) {\n          var map = _this2.mapCache[guid].find(function (m) {return m.viewport.getGuid() === newMap.viewport.getGuid();});\n\n          // It's important to keep the original maps, and change only the matrix,\n          // since there is additional attributes that already assigned to the map instances(i.e.thumbnail).\n          if (map) {var _map$thumbnail;\n            map.mapMatrix = newMap.mapMatrix;\n            map.mapMatrixInv = newMap.mapMatrixInv;\n\n            // Mark the thumbnail mesh as dirty, so in ThumbnailOverlay it will be repositioned.\n            if ((_map$thumbnail = map.thumbnail) === null || _map$thumbnail === void 0 ? void 0 : _map$thumbnail.mesh) {\n              map.thumbnail.mesh.dirty = true;\n            }\n          } else {\n            // New map detected.\n            // Calculate viewport bounds and store it as part of the sheetMap.\n            newMap.viewportBounds = newMap.viewport.getViewportBounds(_this2.viewer.model.getUnitScale());\n            _this2.mapCache[guid].push(newMap);\n          }\n        });\n      });\n\n      this.update();\n\n      // This is needed in order to sync the camera of the TopViewRenderer, as it was a new sheetMap.\n      this.viewer.dispatchEvent({ type: SheetSyncEvents.MAIN_MAP_CHANGED_EVENT, sheetMap: this.sheetMap });\n    } }, { key: \"onModelTransformChanged\", value: function onModelTransformChanged(_ref2)\n\n    {var model = _ref2.model;\n      // If model is not part of targetModels - skip.\n      if (!this.targetModels.includes(model)) {\n        return;\n      }\n\n      // Clear fuzzyBox cache for the transformed model, so it will get calculated again.\n      this.modelIdToFuzzyBox[model.id] = null;\n\n      this.invalidateSheetMaps();\n    } }, { key: \"updateTargetModels\", value: function updateTargetModels()\n\n    {\n      if (!this.options.useCustomModel) {\n        // Filter only 3D models.\n        var models = this.targetViewer.getVisibleModels().filter(function (m) {return m.is3d();});\n        this.setTargetModels(models);\n      }\n    } }, { key: \"setTargetModels\", value: function setTargetModels(\n\n    models) {\n      this.targetModels = models;\n    } }, { key: \"getSheetNodeKey\", value: function getSheetNodeKey(\n\n    map) {\n      var key = map && \"\".concat(map.viewport.getSheetUrn(), \"_\").concat(map.viewport.getSheetName());\n      return key;\n    } }, { key: \"isLoadingSheetNode\", value: function isLoadingSheetNode(\n\n    map) {\n      var key = this.getSheetNodeKey(map);\n      return key && this.isModelLoadingMap[key];\n    } }, { key: \"shouldSwitchSheet\", value: function shouldSwitchSheet()\n\n    {\n      var showSheet = this.showSheet;\n      var isAutoSwitchEnabled = this.options.autoSwitchSheet;\n      var isDifferentSheetLoaded = !this.isSheetMapLoaded(this.sheetMap);\n      var isCameraInside = this.isCameraInsideMap(this.sheetMap);\n      var isAlreadyLoading = this.isLoadingSheetNode(this.sheetMap);\n      var isMinimapDebugMode = this.options.minimapDebugMode;\n\n      return isAutoSwitchEnabled && isDifferentSheetLoaded && showSheet && isCameraInside && !isAlreadyLoading && !isMinimapDebugMode;\n    } }, { key: \"getCurrentLevel\", value: function getCurrentLevel()\n\n    {\n      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');\n\n      if (!levelExt) {\n        return;\n      }\n\n      return levelExt.getCurrentLevel();\n    } }, { key: \"update\", value: function update()\n\n    {\n      if (!this.viewer.model) {\n        return;\n      }\n\n      var level = this.getCurrentLevel();\n\n      if (!level) {\n        return;\n      }\n\n      if (!this.isEnabled()) {\n        return;\n      }\n\n      this.updateTargetModels();\n\n      this.updateSheetMaps();\n\n      this.updateSheetAppearance();\n\n      this.switchSheetIfNeededDebounce();\n    } }, { key: \"switchSheetIfNeededDebounce\", value: function switchSheetIfNeededDebounce()\n\n    {\n      if (this.debounceTimeout) {\n        clearTimeout(this.debounceTimeout);\n      }\n\n      this.debounceTimeout = setTimeout(this.switchSheetIfNeeded.bind(this), 300);\n    }\n\n    // Return a custom hash that encapsulates the current sheet map viewer id.\n  }, { key: \"getCustomHash\", value: function getCustomHash() {\n      return \"sheetsync_\".concat(this.viewer.id);\n    } }, { key: \"switchSheetIfNeeded\", value: function () {var _switchSheetIfNeeded = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var _this3 = this;var previousModel, sheetMap, sheetNode, doc, initialOpacity, loadFunction, unloadFunction, key;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:if (!\n\n\n                this.shouldSwitchSheet()) {_context2.next = 16;break;}\n                this.viewer.dispatchEvent({ type: SheetSyncEvents.CHANGING_SHEET_EVENT });\n\n                // Load sheet\n                previousModel = this.viewer.model;\n                sheetMap = this.sheetMap;_context2.next = 6;return (\n                  this.sheetMap.getSheetNode());case 6:sheetNode = _context2.sent;if (!(\n\n\n                sheetMap !== this.sheetMap)) {_context2.next = 9;break;}return _context2.abrupt(\"return\");case 9:\n\n\n\n                doc = sheetNode.getRootNode().getDocument();\n                initialOpacity = this.options.hideSheetWhenNotFocused ? 0.0 : 1.0;\n                loadFunction = this.options.loadDocumentNode || this.viewer.loadDocumentNode.bind(this.viewer);\n                unloadFunction = this.options.unloadModel || this.viewer.unloadModel.bind(this.viewer);\n                key = this.getSheetNodeKey(sheetMap);\n                this.isModelLoadingMap[key] = true;\n                // There are some critical flags here:\n                // loadAsHidden - We have to first load the model is hidden, and only then show it. The reason is because we\n                //                have to make sure that `renderer.enter2DMode()` will be called, and it won't get called if there is more the one loaded model.\n                //                Without calling `enter2DMode`, there is a chance for different rendering errors.\n                //\n                // keepCurrentModels - In order to prevent tearDown of the viewer, a thing that will cause the navigation to stop,\n                //                     we have to first load the new model (as hidden), then hide the previous model, and then show the new one.\n                // preserveView - Keeps the camera in the same spot.\n                loadFunction(doc, sheetNode, { opacity: initialOpacity, preserveView: true, keepCurrentModels: true, loadAsHidden: true, customHash: this.getCustomHash() }).\n                catch(function (error) {return console.error(\"Failed to load sheet: \", sheetNode.name(), \": \", error);}).\n                then(function (model) {\n                  if (previousModel && previousModel !== model) {\n                    // In case the previous model was the initial empty model - just unload it. There is no reason to support caching it.\n                    if (previousModel.loader instanceof Empty2DModelLoader) {\n                      _this3.viewer.unloadModel(previousModel);\n                    } else {\n                      unloadFunction(previousModel);\n                    }\n                  }\n\n                  _this3.isModelLoadingMap[key] = false;\n                  _this3.viewer.showModel(model, true);\n\n                  // In case we loaded a leaflet, we don't want to restrict zoom in/out when viewing in the minimap.\n                  // Therefore, we revert the constraints that are being set up in viewer.initializeFirstModelPresets.\n                  _this3.viewer.navigation.setConstraints2D();\n\n                  _this3.sheetVisibilityManager.setVisibilityImmediate(false);\n\n                  // Update viewportBounds with model unit scale.\n                  sheetMap.viewportBounds = sheetMap.viewport.getViewportBounds(model.getUnitScale());\n                  sheetMap.model = model;\n\n                  _this3.update();\n                  _this3.viewer.dispatchEvent({ type: SheetSyncEvents.MAIN_MAP_CHANGED_EVENT, sheetMap: sheetMap });\n                });case 16:case \"end\":return _context2.stop();}}}, _callee2, this);}));function switchSheetIfNeeded() {return _switchSheetIfNeeded.apply(this, arguments);}return switchSheetIfNeeded;}()\n\n\n\n    // we can't just shallow compare the instances, because SheetMap.createSheetMapConfigs returns a new pointer each time.\n    // Instead, we compare the viewportGuid, that stays the same.\n  }, { key: \"isSheetMapsEqual\", value: function isSheetMapsEqual(map1, map2) {\n      return (map1 === null || map1 === void 0 ? void 0 : map1.viewport.getGuid()) === (map2 === null || map2 === void 0 ? void 0 : map2.viewport.getGuid());\n    } }, { key: \"isMapOnCurrentLevel\", value: function isMapOnCurrentLevel(\n\n    map) {\n      if (!map) {\n        return false;\n      }\n\n      var currentLevel = this.getCurrentLevel();\n\n      // Different level.\n      if (!currentLevel || map.levelGuid !== currentLevel.guid) {\n        return false;\n      }\n\n      return true;\n    } }, { key: \"isSheetMapLoaded\", value: function isSheetMapLoaded(\n\n    map) {\n      return (map === null || map === void 0 ? void 0 : map.model) === this.viewer.model;\n    }\n\n    // Is current 3D camera is inside a loaded map.\n  }, { key: \"isCameraInsideMap\", value: function isCameraInsideMap(map) {\n      if (!map) {\n        return false;\n      }\n\n      if (!this.isMapOnCurrentLevel(map)) {\n        return false;\n      }\n\n      // Relevant sheet is not currently loaded.\n      if (!this.options.autoSwitchSheet && !this.isSheetMapLoaded(map)) {\n        return false;\n      }\n\n      return posIsInsideMap(this.targetViewer.getCamera().position, map.mapMatrix);\n    }\n\n    // Update current sheet map according to current level.\n  }, { key: \"updateSheetMaps\", value: function updateSheetMaps() {\n      var maps;\n\n      var currentLevel = this.getCurrentLevel();\n\n      if (!this.mapCache[currentLevel.guid]) {\n        // Find maps that are relevant to these models, and for the current level.\n        maps = SheetMap.createSheetMapConfigs(this.targetModels, currentLevel.guid, this.viewportsExtension);\n\n        var currentModel = this.viewer.model;\n        var currentBubbleNode = currentModel.getDocumentNode();\n\n        maps.forEach(function (map) {\n          // Calculate viewport bounds and store it as part of the sheetMap.\n          map.viewportBounds = map.viewport.getViewportBounds(currentModel.getUnitScale());\n\n          // If the current loaded model is the map's model.\n          if (map.viewport.getSheetName() === currentBubbleNode.name() && map.viewport.getSheetUrn() === currentBubbleNode.urn(true)) {\n            map.model = currentModel;\n          }\n        });\n\n        this.mapCache[currentLevel.guid] = maps;\n      } else {\n        maps = this.mapCache[currentLevel.guid];\n      }\n\n      // In case we didn't find another map - keep it only if cropToViewport.\n      // Otherwise, it can cause a confusion when the avatar is floating above a viewport that it doesn't really belongs to.\n      // In that case, unset the map.\n      var map = maps.find(this.isCameraInsideMap) || (this.options.cropToViewport ? this.sheetMap : undefined);\n\n      var mapChanged = !this.isSheetMapsEqual(this.sheetMap, map);\n\n      this.sheetMap = map;\n\n      if (mapChanged) {\n        this.viewer.dispatchEvent({ type: SheetSyncEvents.MAIN_MAP_CHANGED_EVENT, sheetMap: this.sheetMap });\n      }\n    } }, { key: \"setShowSheet\", value: function setShowSheet(\n\n    show) {\n      if (!show || TopViewRenderer.isSheetMapSupported()) {\n        this.showSheet = show;\n\n        if (this.active) {\n          this.update();\n        }\n      }\n    } }, { key: \"getShowSheet\", value: function getShowSheet()\n\n    {\n      return this.showSheet;\n    } }, { key: \"isSheetVisible\", value: function isSheetVisible()\n\n    {\n      return (\n        this.showSheet &&\n        this.isSheetMapLoaded(this.sheetMap) &&\n        this.sheetVisibilityManager.isSheetVisible() &&\n        this.viewer.model.isLoadDone());\n\n    } }, { key: \"expandCropBounds\", value: function expandCropBounds(\n\n    duration) {\n      this.sheetVisibilityManager.expandCropBounds(this.sheetMap, duration);\n    } }, { key: \"setSheetOpaque\", value: function setSheetOpaque(\n\n    duration) {\n      this.sheetVisibilityManager.setSheetOpaque(duration);\n    } }]);return SheetSyncExtension;}(Autodesk.Viewing.Extension);export { SheetSyncExtension as default };\n\nObject.assign(namespace, { SheetSyncEvents: SheetSyncEvents });\nnamespace.SheetSyncExtension = SheetSyncExtension;\nav.theExtensionManager.registerExtension(myExtensionName, SheetSyncExtension);","import * as MinimapMath from '../Minimap3D/MinimapMath.js';\n\n// Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.\nexport function worldToMapPixels(sheetMap, pos3D) {\n  var size = sheetMap.viewportBounds.size();\n  return MinimapMath.worldToMapPixels(pos3D, sheetMap.mapMatrix, size.x, size.y);\n};\n\n// Convert minimap pixel coords (+ world-z) to 3D world position. Minimap pixels are absolute, i.e. not affected by scrolling.\nexport function mapPixelsToWorld(sheetMap, posX, posY, zWorld) {\n  var size = sheetMap.viewportBounds.size();\n  return MinimapMath.mapPixelsToWorld(posX, posY, zWorld, sheetMap.mapMatrixInv, size.x, size.y);\n};\n\nexport function mapPixelsToSheet(sheetMap, p) {\n  // Widget pixel origin is at top-left, i.e., y-axis points down.\n  // For that reason, we have to flip the y coordinate.\n  p.y = sheetMap.viewportBounds.size().y - p.y;\n\n  var min = sheetMap.viewportBounds.min;\n  p.x += min.x;\n  p.y += min.y;\n};\n\n// @param {Vector2} p - point in map-pixel space:             Value range is [0, 0] x [viewportSize.width, viewportSize.height]\n// Converts p to a relative pixel-position in the map widget: Value range is [0, 0] x [viewerWidth, viewerHeight]\nexport function mapPixelsToWidget(sheetMap, viewer, p) {\n  mapPixelsToSheet(sheetMap, p);\n  p.copy(viewer.worldToClient(p));\n};\n\nvar EPSILON = 0.001;\n\n// @param {Vector2} p               - transformed in-place from viewer pixels to map image pixels\n//                                    widget pixel origin is at top-left, i.e., y-axis points down (compatible to mouse events)\n// @param {boolean} clamp           - In case the resulting position is outside of the map, clamp the value to fit the maps' border.\n// @param {boolena} usePixelCenter  - By default (true), input widget coordinates are assumed to be integer pixel coordinates as you get\n//                                    from events. Therefore, pixel (0,0) is actually interpreted as the pixel midpoint\n//                                    of pixel (0,0).\n//\n//                                    If usePixelCenter is false, the input is interpreted as a floating-point position\n//                                    in pixel-space [0, widgetWidth] x [0, widgetHeight] instead. I.e., (0,0) corresponds\n//                                    to the accurate minPoint of pixel (0,0).\nexport function widgetToMapPixels(sheetMap, viewer, p, clamp) {var usePixelCenter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  // Note: The clientToViewport conversion assumes client coords as integer pixel coords. So, it always adds\n  //       0.5 pixels offset in x/y to hit the pixel center. If this is not wanted, we have to add\n  //       the pixel-offset first.\n  var clientX = p.x;\n  var clientY = p.y;\n\n  if (!usePixelCenter) {\n    clientX -= 0.5;\n    clientY -= 0.5;\n  }\n\n  // We can't use viewer.clientToWorld, because we do want to support the case where p is outside of the paper.\n  p.copy(viewer.clientToWorld(clientX, clientY, undefined, true).point);\n\n  var min = sheetMap.viewportBounds.min;\n  p.x -= min.x;\n  p.y -= min.y;\n\n  // Widget pixel origin is at top-left, i.e., y-axis points down.\n  // For that reason, we have to flip the y coordinate.\n  p.y = sheetMap.viewportBounds.size().y - p.y;\n\n  if (clamp) {\n    var size = sheetMap.viewportBounds.size();\n    p.x = THREE.Math.clamp(p.x, EPSILON, size.x - EPSILON);\n    p.y = THREE.Math.clamp(p.y, EPSILON, size.y - EPSILON);\n  }\n};\n\nexport function getCameraRotationAngle(viewer) {\n  var upVec = viewer.navigation.getCameraUpVector();\n  return Math.atan2(upVec.y, upVec.x) - 0.5 * Math.PI;\n};","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { SheetSyncEvents, SHEET_OPACITY, FADE_DURATION } from './SheetSyncConstants';\n\nvar INFINITE_BOX = new THREE.Box3().setFromPoints([new THREE.Vector3(-1e20, -1e20, -1e20), new THREE.Vector3(1e20, 1e20, 1e20)]);\n\n/**\n                                                                                                                                  // SheetVisibilityManager - Manage the visibility of the sheet - opacity and crop.\n                                                                                                                                  */var\nSheetVisibilityManager = /*#__PURE__*/function () {\n  function SheetVisibilityManager(viewer, options) {_classCallCheck(this, SheetVisibilityManager);\n    this.viewer = viewer;\n    this.options = options;\n  }\n\n  // Update sheet's opacity and crop bounds.\n  _createClass(SheetVisibilityManager, [{ key: \"updateSheetAppearance\", value: function updateSheetAppearance(sheetMap, visible) {var _this = this;\n      var model = this.viewer.model;\n\n      if (!model) {\n        return;\n      }\n\n      var targetOpacity = visible ? SHEET_OPACITY : 0.0;\n      var viewportBounds = sheetMap && sheetMap.viewportBounds;\n\n      if (visible) {\n        this.updateCrop(visible, viewportBounds);\n      }\n\n      this.animateOpacity(this.viewer.model, targetOpacity, function () {\n        _this.updateCrop(visible, viewportBounds);\n      });\n    }\n\n    // Set sheet visibility immediately.\n  }, { key: \"setVisibilityImmediate\", value: function setVisibilityImmediate(visible) {var _this2 = this;\n      var models = this.viewer.getAllModels();\n\n      models.forEach(function (model) {\n        if (model.fadeAnim) {\n          model.fadeAnim.stop();\n          model.fadeAnim = null;\n        }\n\n        _this2.setModelOpacity(model, visible ? 1.0 : 0.0);\n      });\n    }\n\n    // Animate sheet's opacity.\n  }, { key: \"animateOpacity\", value: function animateOpacity(model, targetValue, onFadeDone) {var _this3 = this;var duration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : FADE_DURATION;\n      if (!model) {\n        return;\n      }\n\n      if (model.fadeAnim) {\n        model.fadeAnim.stop();\n        model.fadeAnim = null;\n      }\n\n      var startVal = model.opacity || 0.0;\n\n      var onTimer = function onTimer(t) {\n        t = Autodesk.Viewing.Private.smootherStep(t);\n        var opacity = Autodesk.Viewing.Private.lerp(startVal, targetValue, t);\n        _this3.setModelOpacity(model, opacity);\n      };\n\n      var onFadeEnd = function onFadeEnd() {\n        model.fadeAnim = null;\n        onFadeDone && onFadeDone();\n      };\n\n      model.fadeAnim = Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onFadeEnd);\n      model.fadeAnim.targetValue = targetValue;\n    }\n\n    // Change all sheet's materials to be in with a given opacity.\n  }, { key: \"setModelOpacity\", value: function setModelOpacity(model, value) {\n      if (!this.options.hideSheetWhenNotFocused) {\n        return;\n      }\n\n      if (model) {\n        var materialsManager = this.viewer.impl.matman();\n        var materials = materialsManager.getModelMaterials(model).mats;\n\n        var changed = false;\n\n        Object.keys(materials).forEach(function (key) {\n          if (materials[key].uniforms && materials[key].uniforms.opacity && materials[key].uniforms.opacity.value !== value) {\n            materials[key].uniforms.opacity.value = value;\n            changed = true;\n          }\n        });\n\n        model.opacity = value;\n\n        if (changed) {\n          this.viewer.dispatchEvent({\n            type: SheetSyncEvents.SHEET_VISIBILITY_CHANGED_EVENT,\n            model: model,\n            value: value });\n\n\n          this.viewer.impl.invalidate(true);\n        }\n      }\n    } }, { key: \"expandCropBounds\", value: function expandCropBounds(\n\n    sheetMap) {var _this4 = this;var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FADE_DURATION;\n      var startBounds = sheetMap.viewportBounds;\n      var modelBounds = this.viewer.model.getBoundingBox();\n\n      var box = new THREE.Box2();\n\n      var onTimer = function onTimer(t) {\n        t = Autodesk.Viewing.Private.smootherStep(t);\n        box.min.lerpVectors(startBounds.min, modelBounds.min, t);\n        box.max.lerpVectors(startBounds.max, modelBounds.max, t);\n        _this4.updateCrop(true, box);\n      };\n\n      Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer);\n    }\n\n    // Update the crop according to given viewport bounds.\n  }, { key: \"updateCrop\", value: function updateCrop(visible) {var bounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INFINITE_BOX;\n      if (this.options.cropToViewport) {\n        var model = this.viewer.model;\n\n        if (!model) {\n          return;\n        }\n\n        if (!model.latestCropBounds) {\n          model.latestCropBounds = new THREE.Box3();\n        }\n\n        var cropBounds;\n        if (visible) {\n          cropBounds = bounds;\n        } else {\n          // put the cut planes in infinity.\n          // This is more efficient then removing the cutplanes from all the materials.\n          cropBounds = INFINITE_BOX;\n        }\n\n        if (!model.latestCropBounds.equals(cropBounds)) {\n          model.latestCropBounds = cropBounds.clone();\n          this.viewer.impl.setViewportBounds(model, cropBounds.empty() ? null : cropBounds);\n        }\n      }\n    } }, { key: \"isSheetVisible\", value: function isSheetVisible()\n\n    {var _this$viewer, _this$viewer$model;\n      return ((_this$viewer = this.viewer) === null || _this$viewer === void 0 ? void 0 : (_this$viewer$model = _this$viewer.model) === null || _this$viewer$model === void 0 ? void 0 : _this$viewer$model.opacity) !== 0;\n    } }, { key: \"setSheetOpaque\", value: function setSheetOpaque(\n\n    duration) {var _this5 = this;\n      this.animateOpacity(this.viewer.model, 1.0, undefined, duration);\n\n      var onTimer = function onTimer(t) {\n        t = Autodesk.Viewing.Private.smootherStep(t);\n        var opacity = Autodesk.Viewing.Private.lerp(0, 1, t);\n        _this5.viewer.impl && _this5.viewer.setBackgroundOpacity(opacity);\n      };\n\n      Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer);\n    } }]);return SheetVisibilityManager;}();export { SheetVisibilityManager as default };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { mapPixelsToWorld } from './SheetTransforms';\nimport { rotateAround } from '../Minimap3D/MinimapMath.js';\nimport SheetMapThumbnail from '../Minimap3D/SheetThumbnail';\nimport { FADE_DURATION, SHEET_OPACITY } from './SheetSyncConstants';\n\nvar OVERLAY_SCENE = 'thumbnail-overlay-scene';\nvar EPSILON = 0.0001;\n\n// ThumbnailsOverlay - An overlay of sheet thumbnails.\n// For every sheet on the current level, a request for DS will be made in order to get its thumbnail.\n// The thumbnail will be displayed as a plane as an overlay on top of the top-view 3D rendering.\n//\n// In case that the 2D sheet is fully displayed, a (sort of) high-res snapshot of the sheet will be taken,\n// and will be used as the thumbnail texture.\nvar ThumbnailsOverlay = /*#__PURE__*/function () {\n  function ThumbnailsOverlay(viewer, sheetSyncExt) {_classCallCheck(this, ThumbnailsOverlay);\n    this.viewer = viewer;\n    this.sheetSyncExt = sheetSyncExt;\n\n    this.planeGeometry = new THREE.PlaneBufferGeometry(1, 1);\n\n    this.viewer.impl.createOverlayScene(OVERLAY_SCENE);\n    this.createThumbnailMesh = this.createThumbnailMesh.bind(this);\n  }\n\n  // Create a plane, position it in the correct place in the scene, and assign the thumbnail texture to it.\n  _createClass(ThumbnailsOverlay, [{ key: \"createThumbnailMesh\", value: function createThumbnailMesh(map) {\n      if (!this.viewer) return;\n      var mesh = map.thumbnail.mesh;\n\n      if (!mesh) {\n        var material = new THREE.MeshBasicMaterial({\n          opacity: 0.0, // Initially, thumbnail should be hidden.\n          transparent: true });\n\n\n        mesh = new THREE.Mesh(this.planeGeometry, material);\n\n        this.setMeshTransform(mesh, map);\n        map.thumbnail.mesh = mesh;\n\n        var texture = new THREE.Texture();\n        texture.minFilter = THREE.LinearFilter;\n        mesh.material.map = texture;\n      }\n\n      // Update texture.\n      mesh.material.map.image = map.thumbnail.thumbnailImage;\n      mesh.material.map.needsUpdate = true;\n\n      this.update();\n    } }, { key: \"setMeshTransform\", value: function setMeshTransform(\n\n    mesh, map) {\n      var minWorld = mapPixelsToWorld(map, map.viewportBounds.min.x, map.viewportBounds.min.y, 0);\n      var maxWorld = mapPixelsToWorld(map, map.viewportBounds.max.x, map.viewportBounds.max.y, 0);\n      var p2 = mapPixelsToWorld(map, map.viewportBounds.max.x, map.viewportBounds.min.y, 0);\n\n      var angle = Math.atan2(p2.y - minWorld.y, p2.x - minWorld.x);\n      var box = new THREE.Box3().setFromPoints([minWorld, maxWorld]);\n      var boxCenter = box.center();\n      rotateAround(minWorld, boxCenter, -angle);\n      rotateAround(maxWorld, boxCenter, -angle);\n\n      box.setFromPoints([minWorld, maxWorld]);\n\n      var meshSize = box.size();\n      var mapSize = map.viewportBounds.size();\n\n      // Height of the plane is camera position minus epsilon, in order to make sure the plane is inside the frustum.\n      var center = mapPixelsToWorld(map, mapSize.x / 2, mapSize.y / 2, this.viewer.getCamera().position.z - EPSILON);\n\n      mesh.position.copy(center);\n      mesh.rotation.set(0, 0, angle);\n      mesh.scale.set(meshSize.x, meshSize.y, 1);\n      mesh.dirty = false;\n    } }, { key: \"showThumbnail\", value: function showThumbnail(\n\n    thumbnail) {\n      if (thumbnail && thumbnail.mesh) {\n        if (this.viewer.impl.overlayScenes[OVERLAY_SCENE].scene.children.indexOf(thumbnail.mesh) === -1) {\n          this.viewer.impl.addOverlay(OVERLAY_SCENE, thumbnail.mesh);\n          this.animateOpacity(thumbnail, 0.5);\n        }\n      }\n    } }, { key: \"hideThumbnail\", value: function hideThumbnail(\n\n    thumbnail, immediate) {var _this = this;\n      if (thumbnail && thumbnail.mesh) {\n        if (this.viewer.impl.overlayScenes[OVERLAY_SCENE].scene.children.indexOf(thumbnail.mesh) !== -1) {\n          if (immediate) {\n            this.viewer.impl.removeOverlay(OVERLAY_SCENE, thumbnail.mesh);\n            thumbnail.mesh.material.opacity = 0;\n          } else {\n            this.animateOpacity(thumbnail, 0.0, function () {\n              _this.viewer.impl.removeOverlay(OVERLAY_SCENE, thumbnail.mesh);\n            });\n          }\n        }\n      }\n    } }, { key: \"animateOpacity\", value: function animateOpacity(\n\n    thumbnail, targetValue, onDone) {var _this2 = this;\n      if (thumbnail.fadeAnim) {\n        if (thumbnail.fadeAnim.targetValue === targetValue) {\n          return;\n        }\n\n        thumbnail.fadeAnim.stop();\n        thumbnail.fadeAnim = null;\n      }\n\n      var startVal = thumbnail.mesh.material.opacity;\n\n      var onTimer = function onTimer(t) {\n        // In case viewer was destroyed during animation.\n        if (!_this2.viewer) {\n          return;\n        }\n\n        t = Autodesk.Viewing.Private.smootherStep(t);\n        var opacity = Autodesk.Viewing.Private.lerp(startVal, targetValue, t);\n        _this2.setThumbnailOpacity(thumbnail, opacity);\n      };\n\n      var onFadeEnd = function onFadeEnd() {\n        thumbnail.fadeAnim = null;\n        onDone && onDone();\n      };\n\n      thumbnail.fadeAnim = Autodesk.Viewing.Private.fadeValue(0, 1, FADE_DURATION, onTimer, onFadeEnd);\n      thumbnail.fadeAnim.targetValue = targetValue;\n    } }, { key: \"setThumbnailOpacity\", value: function setThumbnailOpacity(\n\n    thumbnail, value) {\n      if (thumbnail.mesh.material.opacity !== value) {\n        thumbnail.mesh.material.opacity = value;\n        this.viewer.impl.invalidate(false, false, true);\n      }\n    } }, { key: \"requestThumbnailDebounce\", value: function requestThumbnailDebounce(\n\n    map) {var _this3 = this;\n      if (this.debounceTimeout) {\n        clearTimeout(this.debounceTimeout);\n      }\n\n      this.debounceTimeout = setTimeout(function () {\n        if (!_this3.sheetSyncExt) return;\n\n        map.thumbnail = new SheetMapThumbnail(map, _this3.sheetSyncExt.viewer, _this3.createThumbnailMesh);\n\n        if (!_this3.tryRefineThumbnail(map)) {\n          map.thumbnail.requestThumbnail();\n        }\n      }, 300);\n    } }, { key: \"tryRefineThumbnail\", value: function tryRefineThumbnail(\n\n    map) {\n      if (this.sheetSyncExt.isSheetMapLoaded(map) &&\n      this.sheetSyncExt.viewer.model.isLoadDone(true) &&\n      this.sheetSyncExt.viewer.model.opacity === SHEET_OPACITY) {\n\n        map.thumbnail.refineThumbnail();\n        return true;\n      }\n\n      return false;\n    }\n\n    // Verify all the thumbnails are displayed correctly.\n  }, { key: \"update\", value: function update() {var _this4 = this;\n      var sheetMaps = this.sheetSyncExt.mapCache;\n      var currentLevel = this.sheetSyncExt.getCurrentLevel();\n\n      if (!currentLevel) {\n        return;\n      }\n\n      var showSheetEnabled = this.sheetSyncExt.getShowSheet();\n\n      Object.keys(sheetMaps).forEach(function (levelGuid) {\n        var levelMaps = sheetMaps[levelGuid];\n        var sameLevel = levelGuid === currentLevel.guid;\n        levelMaps.forEach(function (map) {var _map$thumbnail, _map$thumbnail$mesh;\n          var showThumbnail = sameLevel && showSheetEnabled && !_this4.sheetSyncExt.isCameraInsideMap(map);\n\n          if (sameLevel) {\n            if (!map.thumbnail) {\n              // Thumbnail was not fetched yet - initialize thumbnail object and request thumbnail image.\n              // Update when loaded.\n              _this4.requestThumbnailDebounce(map);\n            } else if (!map.thumbnail.thumbnailRefined) {\n              _this4.tryRefineThumbnail(map);\n            }\n          }\n\n          // Update transform if model transform was changed.\n          if ((_map$thumbnail = map.thumbnail) === null || _map$thumbnail === void 0 ? void 0 : (_map$thumbnail$mesh = _map$thumbnail.mesh) === null || _map$thumbnail$mesh === void 0 ? void 0 : _map$thumbnail$mesh.dirty) {\n            _this4.setMeshTransform(map.thumbnail.mesh, map);\n          }\n\n          if (showThumbnail) {\n            // If thumbnail mesh is ready - add it to the overlay scene if it's not there already.\n            _this4.showThumbnail(map.thumbnail);\n          } else {\n            // Thumbnail mesh is ready, but should be hidden because it's not on the current level -\n            // Remove it from the overlay scene if it's there.\n            _this4.hideThumbnail(map.thumbnail, levelGuid !== currentLevel.guid);\n          }\n        });\n      });\n    } }, { key: \"destroy\", value: function destroy()\n\n    {\n      this.planeGeometry.dispose();\n      this.planeGeometry = null;\n\n      this.viewer.impl.removeOverlayScene(OVERLAY_SCENE);\n\n      this.sheetSyncExt = null;\n      this.viewer = null;\n    } }]);return ThumbnailsOverlay;}();export { ThumbnailsOverlay as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import { setTopView, rotateAround } from '../Minimap3D/MinimapMath.js';\nimport { mapPixelsToWorld, widgetToMapPixels, getCameraRotationAngle, mapPixelsToSheet, worldToMapPixels } from './SheetTransforms';\nimport { SheetSyncEvents, ROTATION_DURATION, WAIT_BEFORE_ROTATION } from './SheetSyncConstants';\nimport ThumbnailsOverlay from './ThumbnailsOverlay';\n\nvar av = Autodesk.Viewing;\nvar ProgressState = av.ProgressState;\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar myExtensionName = 'Autodesk.AEC.TopViewRendererExtension';\n\nvar tempVec3 = new THREE.Vector3();\nvar tempVec2 = new THREE.Vector2();\nvar box = new THREE.Box3();\n\n/**\n                            // TopViewRenderer - A viewer extension renders a 3D top view of a target model.\n                            //                   It is highly recommended to use LeechViewer for the target viewer - otherwise the 3D model will be loaded again,\n                            //                   and no shared resources will be used.\n                            //\n                            // @param {Viewer3D} [viewer]                       - viewer instance\n                            // @param {Object} [options]                        - Configuration options for TopViewRenderer\n                            */var\nTopViewRenderer = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(TopViewRenderer, _Autodesk$Viewing$Ext);var _super = _createSuper(TopViewRenderer);\n  function TopViewRenderer(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, TopViewRenderer);\n    _this = _super.call(this, viewer, options);\n\n    _this.options = _this.options.topViewRendererOptions || _this.options;\n\n    // [modelKey -> boolean] map that represents if a model is being currently loaded on the topViewViewer.\n    _this.isModelLoadingMap = {};\n\n    // Time to wait before start rotating to sheet origin.\n    _this.waitBeforeRotation = WAIT_BEFORE_ROTATION;\n\n    // Rotation speed.\n    _this.rotationDuration = ROTATION_DURATION;\n\n    _this.onBeginScene = _this.onBeginScene.bind(_assertThisInitialized(_this));\n    _this.update = _this.update.bind(_assertThisInitialized(_this));\n    _this.onMainMapChanged = _this.onMainMapChanged.bind(_assertThisInitialized(_this));\n    _this.onResize = _this.onResize.bind(_assertThisInitialized(_this));\n    _this.rotateToSheet = _this.rotateToSheet.bind(_assertThisInitialized(_this));\n    _this.onSheetGeometryLoaded = _this.onSheetGeometryLoaded.bind(_assertThisInitialized(_this));\n\n    // Callbacks to be invoked at the end of rotation\n    _this.pendingFinishedCallbacks = [];return _this;\n  }_createClass(TopViewRenderer, [{ key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this2 = this;var NearFarOverlay, modelQueue, originalReset;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n\n\n                  this.viewer.loadExtension('Autodesk.AEC.SheetSyncExtension', this.viewer.config));case 2:this.sheetSyncExt = _context.sent;\n\n                this.targetViewer = this.sheetSyncExt.targetViewer;\n\n                this.initTopViewViewer();\n\n                if (this.options.minimapDebugMode) {\n                  NearFarOverlay = require('./NearFarOverlay').default;\n                  this.nearFarOverlay = new NearFarOverlay(this.topViewViewer, this.targetViewer);\n\n                  modelQueue = this.topViewViewer.impl.modelQueue();\n                  originalReset = modelQueue.reset.bind(modelQueue);\n\n                  modelQueue.reset = function () {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n                    // In order to present frustum culling in the top view minimap, we need to \"steal\" the target viewer's camera when calculating the frustum.\n                    args[0] = _this2.targetViewer.getCamera();\n                    originalReset.apply(void 0, args);\n                  };\n\n                } else {\n                  this.thumbnailsOverlay = new ThumbnailsOverlay(this.topViewViewer, this.sheetSyncExt);\n                }\n\n                this.addListeners();case 7:case \"end\":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"initTopViewViewer\", value: function initTopViewViewer()\n\n\n    {var _this$targetViewer$co;\n      var container = this.viewer.container;\n      var sharedResources = this.targetViewer.sharedResources;\n\n      var config = {};\n      if ((_this$targetViewer$co = this.targetViewer.config) === null || _this$targetViewer$co === void 0 ? void 0 : _this$targetViewer$co.profileSettings) {\n        config.profileSettings = Object.assign({}, this.targetViewer.config.profileSettings);\n      }\n\n      // In case targetViewer is a LeechViewer, create a leechViewer and use the shared resources.\n      if (sharedResources) {\n        this.topViewViewer = Autodesk.Viewing.createLeechViewer(container, config, sharedResources, Autodesk.Viewing.Viewer3D);\n      } else {\n        // Otherwise, it's unfortunate, and you'll have to create a regular Viewer3D, without resource sharing.\n        console.warn('TopViewRenderer - It is highly recommended using LeechViewer as your target viewer when using this extension.');\n        this.topViewViewer = new Autodesk.Viewing.Viewer3D(container, config);\n      }\n\n      this.viewer.container.insertBefore(this.topViewViewer.container, this.viewer.container.firstChild);\n      this.topViewViewer.container.style.zIndex = -1;\n      this.topViewViewer.container.style.pointerEvents = 'none';\n      this.topViewViewer.container.style.transition = 'opacity 0.7s'; // Value matches \"FADE_DURATION\" inside SheetSyncConstants.js\n      this.topViewViewer.container.style.backgroundColor = 'transparent';\n      this.topViewViewer.start(undefined, undefined, undefined, undefined, { webglInitParams: { alpha: true } });\n      this.topViewViewer.impl.skipCameraUpdate = true; // Used in order to set near-far values manually.\n      this.topViewViewer.setBackgroundOpacity(0);\n\n      this.backgroundColorBackup = this.viewer.container.style.backgroundColor;\n      this.viewer.container.style.backgroundColor = 'transparent';\n      this.backgroundOpacityBackup = this.viewer.impl.glrenderer().getClearAlpha();\n      this.viewer.setBackgroundOpacity(0);\n\n      if (!TopViewRenderer.isSheetMapSupported()) {\n        this.viewer.canvasWrap.style.opacity = 0;\n      }\n    } }, { key: \"destroyTopViewViewer\", value: function destroyTopViewViewer()\n\n    {\n      if (this.topViewViewer) {\n        this.topViewViewer.finish();\n        this.topViewViewer = null;\n        this.viewer.container.style.backgroundColor = this.backgroundColorBackup;\n        this.viewer.setBackgroundOpacity(this.backgroundOpacityBackup);\n\n        // Restore canvas wrap visibility.\n        if (!TopViewRenderer.isSheetMapSupported()) {\n          this.viewer.canvasWrap.style.opacity = 1;\n        }\n      }\n    } }, { key: \"unload\", value: function unload()\n\n    {\n      this.removeListeners();\n\n      if (this.thumbnailsOverlay) {\n        this.thumbnailsOverlay.destroy();\n        this.thumbnailsOverlay = null;\n      }\n\n      if (this.nearFarOverlay) {\n        this.nearFarOverlay.destroy();\n        this.nearFarOverlay = null;\n      }\n\n      this.destroyTopViewViewer();\n\n      if (this.rotationAnim) {\n        this.rotationAnim.stop();\n        this.rotationAnim = null;\n      }\n\n      this.rotationTimeout && clearTimeout(this.rotationTimeout);\n\n      this.viewer = null;\n      this.targetViewer = null;\n      this.sheetSyncExt = null;\n\n      this.pendingFinishedCallbacks = [];\n\n      return true;\n    } }, { key: \"addListeners\", value: function addListeners()\n\n    {\n      this.targetViewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);\n      this.targetViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update);\n      this.targetViewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update);\n      this.targetViewer.addEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.update);\n      this.viewer.addEventListener(av.PROGRESS_UPDATE_EVENT, this.onBeginScene);\n      this.viewer.addEventListener(av.RENDER_SCENE_PART, this.update);\n      this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this.onResize);\n      this.viewer.addEventListener(SheetSyncEvents.MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);\n      this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);\n      this.topViewViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update);\n\n      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');\n      levelExt && levelExt.floorSelector && levelExt.floorSelector.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);\n\n      // In minimap debug mode - we need to render the minimap even when there is no actual movement in the top view.\n      // This is needed in order to update the frustum according to target viewer.\n      if (this.options.minimapDebugMode) {\n        this.targetViewer.addEventListener(av.PROGRESS_UPDATE_EVENT, this.onBeginScene);\n      }\n    } }, { key: \"removeListeners\", value: function removeListeners()\n\n    {\n      this.targetViewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);\n      this.targetViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);\n      this.targetViewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);\n      this.targetViewer.removeEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.update);\n      this.viewer.removeEventListener(av.PROGRESS_UPDATE_EVENT, this.onBeginScene);\n      this.viewer.removeEventListener(av.RENDER_SCENE_PART, this.update);\n      this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.onResize);\n      this.viewer.removeEventListener(SheetSyncEvents.MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);\n      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);\n      this.topViewViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);\n\n      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');\n      levelExt && levelExt.floorSelector && levelExt.floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);\n\n      if (this.options.minimapDebugMode) {\n        this.targetViewer.removeEventListener(av.PROGRESS_UPDATE_EVENT, this.onBeginScene);\n      }\n    }\n\n    // Make sure that when the main 2D viewer is resizing - topViewViewer updates as well.\n  }, { key: \"onResize\", value: function onResize(_ref) {var width = _ref.width,height = _ref.height;\n      this.topViewViewer.impl.resize(width, height, true);\n      this.update();\n    } }, { key: \"onMainMapChanged\", value: function onMainMapChanged()\n\n    {\n      this.syncCamera();\n      this.update();\n      this.validateRotation();\n    } }, { key: \"onSheetGeometryLoaded\", value: function onSheetGeometryLoaded()\n\n    {\n      this.validateRotation();\n    } }, { key: \"validateRotation\", value: function validateRotation()\n\n    {\n      this.rotationTimeout && clearTimeout(this.rotationTimeout);\n      this.rotationTimeout = setTimeout(this.rotateToSheet, this.waitBeforeRotation * 1000);\n    } }, { key: \"isDraggingAvatar\", value: function isDraggingAvatar()\n\n    {\n      var avatarExt = this.viewer.getExtension('Autodesk.AEC.AvatarExtension');\n      var isDraggingAvatar = !avatarExt || !avatarExt.avatarWidget || avatarExt.avatarWidget.isDragging();\n\n      return isDraggingAvatar;\n    } }, { key: \"rotateToSheet\", value: function rotateToSheet()\n\n    {var _this3 = this;\n      if (!this.viewer) {\n        return;\n      }\n\n      // Rotate only if sheet is shown. Otherwise there is no reason to rotate.\n      if (!this.sheetSyncExt.getShowSheet()) {\n        return;\n      }\n\n      if (this.rotationAnim) {\n        this.rotationAnim.stop();\n        this.rotationAnim = null;\n      }\n\n      // In case the avatar is currently being dragged - don't rotate yet, cause it's annoying.\n      if (this.isDraggingAvatar()) {\n        // Postpone rotation to the next timeout.\n        this.validateRotation();\n        return;\n      }\n\n      var startAngle = getCameraRotationAngle(this.viewer);\n\n      // Find shortest rotation (keep angle between -PI and PI)\n      if (startAngle < -Math.PI) {\n        startAngle += 2 * Math.PI;\n      } else if (startAngle > Math.PI) {\n        startAngle -= 2 * Math.PI;\n      }\n\n      // No rotation needed.\n      if (startAngle === 0) {\n        return;\n      }\n\n      var onTimer = function onTimer(t) {\n        t = Autodesk.Viewing.Private.smootherStep(t);\n        var rotation = startAngle * (1 - t);\n        var camera = _this3.viewer.getCamera();\n        camera.up.set(0, 1, 0);\n        rotateAround(camera.up, tempVec3, rotation);\n        camera.dirty = true;\n        camera.updateCameraMatrices();\n      };\n\n      var onRotationEnd = function onRotationEnd() {\n        _this3.rotationAnim = null;\n\n        _this3.pendingFinishedCallbacks.forEach(function (cb) {return cb();});\n        _this3.pendingFinishedCallbacks = [];\n      };\n\n      this.rotationAnim = Autodesk.Viewing.Private.fadeValue(0, 1, this.rotationDuration, onTimer, onRotationEnd);\n    } }, { key: \"waitForRotationDone\", value: function waitForRotationDone()\n\n    {var _this4 = this;\n      var promise = new Promise(function (resolve) {\n        // In case there is no active rotation, resolve immediately.\n        if (!_this4.rotationAnim) {\n          return resolve();\n        }\n\n        // Otherwise, wait for rotation callback to be called.\n        _this4.pendingFinishedCallbacks.push(resolve);\n      });\n\n      return promise;\n    }\n\n    // Sync top view whenever the 2d sheet starts rendering.\n  }, { key: \"onBeginScene\", value: function onBeginScene(_ref2) {var percent = _ref2.percent,state = _ref2.state;\n      if (percent === 0 && state === ProgressState.RENDERING) {\n        this.update();\n      }\n    }\n\n    // Jump the camera to make the illusion that we keep the same position, scale and rotation while switching to a different sheetMap.\n  }, { key: \"syncCamera\", value: function syncCamera() {\n      if (!this.sheetSyncExt || !this.sheetSyncExt.sheetMap || !this.viewer.model || !this.worldBoundingBox) {\n        return;\n      }\n\n      var camera = this.viewer.getCamera();\n      var map = this.sheetSyncExt.sheetMap;\n\n      var viewportLowerLeft = mapPixelsToWorld(map, map.viewportBounds.min.x, map.viewportBounds.min.y, 0);\n      var viewportLowerRight = mapPixelsToWorld(map, map.viewportBounds.max.x, map.viewportBounds.min.y, 0);\n\n      var angle = Math.atan2(viewportLowerRight.y - viewportLowerLeft.y, viewportLowerRight.x - viewportLowerLeft.x);\n\n      // Rotate bounding box according to the map's rotation.\n      var center = this.worldBoundingBox.center();\n      rotateAround(this.worldBoundingBox.min, center, angle);\n      rotateAround(this.worldBoundingBox.max, center, angle);\n\n      var p0 = worldToMapPixels(map, this.worldBoundingBox.min.clone());\n      var p1 = worldToMapPixels(map, new THREE.Vector3(this.worldBoundingBox.min.x, this.worldBoundingBox.max.y, 0));\n      var p2 = worldToMapPixels(map, this.worldBoundingBox.max.clone());\n\n      p0.z = 0;\n      p1.z = 0;\n      p2.z = 0;\n\n      mapPixelsToSheet(map, p0);\n      mapPixelsToSheet(map, p2);\n      mapPixelsToSheet(map, p1);\n\n      box.setFromPoints([p0, p2]);\n\n      camera.setViewFromBox(box, true);\n\n      var worldAngle = getCameraRotationAngle(this.topViewViewer);\n      rotateAround(camera.up, tempVec3, worldAngle - angle);\n\n      camera.dirty = true;\n      camera.updateCameraMatrices();\n\n      this.viewer.impl.invalidate(true);\n\n      // Restart rotation if it's during rotation.\n      if (this.rotationAnim) {\n        this.rotateToSheet();\n      }\n    }\n\n    // Setup a virtual camera according to sheetMap's bounds.\n    // This camera should be used in the 3D scene in order to create a top view screenshot.\n  }, { key: \"updateTopViewViewerCamera\", value: function updateTopViewViewerCamera() {\n      // If there is no 2D model loaded, worldBounds are infinity, and it will cause calculation errors here.\n      // For this reason, we have to wait until there is a loaded model.\n      if (!this.viewer.model) {\n        return;\n      }\n\n      var currentLevel = this.sheetSyncExt.getCurrentLevel();\n\n      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');\n      var zRangeMax = currentLevel ? levelExt.getZRange(currentLevel.index).zMax : Infinity;\n\n      var renderer = this.viewer.impl.renderer();\n      var canvasWidth = renderer.settings.logicalWidth;\n      var canvasHeight = renderer.settings.logicalHeight;\n      var up = this.viewer.getCamera().up.clone();\n\n      // Normally, widgetToMapPixels is used with event pixel coords (which are integer in x/y). \n      // Here, we need the input coords to be interpreted as accurate float-positions within [0, widgetWidth] x [0, widgetHeight] instead.\n      // Otherwise, we get a half-pixel shift when computing the camera.\n      var usePixelCenter = false;\n\n      // get position within map widget\n      var p0 = tempVec2.set(0, canvasHeight); // lower-left corner\n      widgetToMapPixels(this.sheetSyncExt.sheetMap, this.viewer, p0, false, usePixelCenter);\n      var p0World = mapPixelsToWorld(this.sheetSyncExt.sheetMap, p0.x, p0.y, 0);\n\n      var p1 = tempVec2.set(canvasWidth, canvasHeight); // lower-right corner\n      widgetToMapPixels(this.sheetSyncExt.sheetMap, this.viewer, p1, false, usePixelCenter);\n      var p1World = mapPixelsToWorld(this.sheetSyncExt.sheetMap, p1.x, p1.y, 0);\n\n      var p2 = tempVec2.set(canvasWidth, 0); // upper-right corner\n      widgetToMapPixels(this.sheetSyncExt.sheetMap, this.viewer, p2, false, usePixelCenter);\n      var p2World = mapPixelsToWorld(this.sheetSyncExt.sheetMap, p2.x, p2.y, 0);\n\n      // First set the box in order to get its center. It's needed for calculating the rotation.\n      box.setFromPoints([p0World, p2World]);\n      var center = box.center();\n\n      // calculate world angle according the world direction from lower left corner, to lower right corner.\n      var cameraAngle = getCameraRotationAngle(this.viewer);\n      var worldAngle = Math.atan2(p1World.y - p0World.y, p1World.x - p0World.x);\n\n      rotateAround(p0World, center, -worldAngle);\n      rotateAround(p2World, center, -worldAngle);\n      rotateAround(up, tempVec3, worldAngle - cameraAngle);\n\n      // Bounding box rotated according to camera rotation.\n      box.setFromPoints([p0World, p2World]);\n\n      // Save worldBoundingBox for later use - in order to sync the camera position.\n      this.worldBoundingBox = box.clone();\n\n      var worldBounds = this.targetViewer.impl.getVisibleBounds();\n\n      // The near and far plans are determined according to these values.\n      var zMax = Math.min(zRangeMax, worldBounds.max.z);\n      var zMin = worldBounds.min.z;\n\n      // Set camera according to the bounding box.\n      var camera = this.topViewViewer.getCamera();\n      setTopView(camera, box, zMin, zMax, box.size().y);\n\n      // Rotate 3D camera's up vector according to world angle.\n      camera.up.copy(up);\n      camera.updateCameraMatrices();\n      camera.dirty = true;\n    } }, { key: \"unloadIrrelevant3DModels\", value: function unloadIrrelevant3DModels()\n\n    {var _this5 = this;\n      if (!this.sheetSyncExt.targetModels) {\n        return;\n      }\n\n      var visibleModelsKeys = this.sheetSyncExt.targetModels.map(function (model) {return model.getModelKey();});\n\n      this.topViewViewer.getVisibleModels().forEach(function (model) {\n        var key = model.getModelKey();\n        if (visibleModelsKeys.indexOf(key) === -1) {\n          _this5.topViewViewer.unloadModel(model);\n          _this5.isModelLoadingMap[key] = false;\n        }\n      });\n    } }, { key: \"loadRelevant3DModels\", value: function loadRelevant3DModels()\n\n    {var _this6 = this;\n      if (!this.sheetSyncExt.targetModels) {\n        return;\n      }\n\n      var visibleModelsKeys = this.topViewViewer.getVisibleModels().map(function (model) {return model.getModelKey();});\n\n      this.sheetSyncExt.targetModels.forEach(function (model) {\n        var key = model.getModelKey();\n\n        if (visibleModelsKeys.indexOf(key) === -1 && !_this6.isModelLoadingMap[key]) {\n          _this6.isModelLoadingMap[key] = true;\n          var loadOptions = model.getData().loadOptions;\n          _this6.topViewViewer.loadDocumentNode(\n          model.getDocumentNode().getRootNode().getDocument(),\n          model.getDocumentNode(),\n          {\n            keepCurrentModels: true,\n            preserveView: true,\n            globalOffset: loadOptions.globalOffset,\n            applyRefPoint: loadOptions.applyRefPoint,\n            placementTransform: loadOptions.placementTransform,\n            applyPlacementInModelUnits: loadOptions.applyPlacementInModelUnits }).\n\n          then(function () {\n            // Set topView render config.\n            var config = _this6.targetViewer.impl.renderer().getConfig();\n            config.renderEdges = true;\n            config.envMapBackground = null;\n            config.aoEnabled = false;\n            config.antialias = true;\n            config.envMap = null; // Can't share this resource between viewers.\n            _this6.topViewViewer.impl.renderer().applyConfig(config);\n            _this6.topViewViewer.setBackgroundOpacity(0);\n          });\n        }\n      });\n    } }, { key: \"hideTopViewViewer\", value: function hideTopViewViewer()\n\n    {\n      if (this.topViewViewer) this.topViewViewer.container.style.opacity = 0;\n    } }, { key: \"showTopViewViewer\", value: function showTopViewViewer()\n\n    {\n      if (this.topViewViewer) this.topViewViewer.container.style.opacity = 1;\n    } }, { key: \"update\", value: function update()\n\n    {var _this$thumbnailsOverl;\n      if (!this.sheetSyncExt || !this.sheetSyncExt.sheetMap || !this.viewer || !this.targetViewer || !this.topViewViewer) {\n        this.hideTopViewViewer();\n        return;\n      }\n\n      this.showTopViewViewer();\n\n      // Remove unused 3D models from topViewViewer.\n      this.unloadIrrelevant3DModels();\n\n      // Load relevant 3D models to toViewViewer.\n      this.loadRelevant3DModels();\n\n      // Update top view camera, according to the current sheet map.\n      this.updateTopViewViewerCamera();\n\n      (_this$thumbnailsOverl = this.thumbnailsOverlay) === null || _this$thumbnailsOverl === void 0 ? void 0 : _this$thumbnailsOverl.update();\n    }\n\n    // IE11 & iOS don't support canvas blending.\n    // For that reason, we decided to hide the sheet-map overlay in these browsers.\n  }], [{ key: \"isSheetMapSupported\", value: function isSheetMapSupported() {\n      return !(Autodesk.Viewing.isIE11Only || Autodesk.Viewing.isIOSDevice());\n    } }]);return TopViewRenderer;}(Autodesk.Viewing.Extension);export { TopViewRenderer as default };\n\n\nnamespace.TopViewRenderer = TopViewRenderer;\nav.theExtensionManager.registerExtension(myExtensionName, TopViewRenderer);","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import AecModelDataViewport from '../ViewportTypes/AecModelDataViewport';\nimport ViewportProviderInterface from './ViewportProviderInterface';var\n\nAecModelDataViewportProvider = /*#__PURE__*/function (_ViewportProviderInte) {_inherits(AecModelDataViewportProvider, _ViewportProviderInte);var _super = _createSuper(AecModelDataViewportProvider);function AecModelDataViewportProvider() {_classCallCheck(this, AecModelDataViewportProvider);return _super.apply(this, arguments);}_createClass(AecModelDataViewportProvider, [{ key: \"fetchViewports\",\n    /**\n                                                                                                                                                                                                                                                                                                                                                                                                              * Fetch viewports for a given bubble.\n                                                                                                                                                                                                                                                                                                                                                                                                              * \n                                                                                                                                                                                                                                                                                                                                                                                                              * @param {Autodesk.Viewing.BubbleNode} bubbleNode - bubbleNode.\n                                                                                                                                                                                                                                                                                                                                                                                                              * \n                                                                                                                                                                                                                                                                                                                                                                                                              * @returns {Promise<[Viewport]>} Promise with array of viewports.\n                                                                                                                                                                                                                                                                                                                                                                                                              */value: function () {var _fetchViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(\n      bubbleNode) {var rootNode, aecModelData, viewportsRaw, viewports;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n                rootNode = bubbleNode.getRootNode();\n                aecModelData = rootNode.getAecModelData();\n\n                viewportsRaw = bubbleNode.is2D() ?\n                Autodesk.AEC.AecModelData.findViewportsOnSheet(bubbleNode) :\n                aecModelData === null || aecModelData === void 0 ? void 0 : aecModelData.viewports;if (\n\n                viewportsRaw) {_context.next = 5;break;}return _context.abrupt(\"return\",\n                []);case 5:\n\n\n                viewports = viewportsRaw.map(function (viewportRaw) {\n                  // Since viewport name is not extracted to AecModelData - we use the sheet's name for now.\n                  var sheetNode = rootNode.search({ guid: viewportRaw.sheetGuid })[0];\n\n                  if (!sheetNode) {\n                    console.warn(\"Shouldn't happen - couldn't find corresponding sheet.\");\n                    return;\n                  }\n\n                  var name = sheetNode.name();\n                  var urn = rootNode.urn();\n\n                  // Since viewport name is not included in AecModelData - we use the sheet's name for now.\n                  var sheetName = name;\n\n                  return new AecModelDataViewport(viewportRaw, name, urn, sheetName, { aecModelData: aecModelData, sheetNode: sheetNode });\n                });return _context.abrupt(\"return\",\n\n                viewports);case 7:case \"end\":return _context.stop();}}}, _callee);}));function fetchViewports(_x) {return _fetchViewports.apply(this, arguments);}return fetchViewports;}()\n\n\n    /**\n                                                                                                                                                                                             * @returns {string} Name of viewport provider\n                                                                                                                                                                                             */ }, { key: \"getProviderName\", value: function getProviderName()\n    {\n      return 'AecModelDataViewportProvider';\n    } }]);return AecModelDataViewportProvider;}(ViewportProviderInterface);export { AecModelDataViewportProvider as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i[\"return\"] != null) _i[\"return\"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import AlignmentServiceViewport from '../ViewportTypes/AlignmentServiceViewport';\nimport ViewportProviderInterface from './ViewportProviderInterface';var\n\nAlignmentServiceViewportProvider = /*#__PURE__*/function (_ViewportProviderInte) {_inherits(AlignmentServiceViewportProvider, _ViewportProviderInte);var _super = _createSuper(AlignmentServiceViewportProvider);\n  /** @param options:\n                                                                                                                                                                                                                  *                   Must include a service (AlignmentService)\n                                                                                                                                                                                                                  *                   Must include a getVersionUrn function that given a lineageUrn returns the latest versionUrn\n                                                                                                                                                                                                                  *                   Must include a loadDocument function that fetches the document for a model\n                                                                                                                                                                                                                  * \n                                                                                                                                                                                                                  */\n  function AlignmentServiceViewportProvider(options) {var _this;_classCallCheck(this, AlignmentServiceViewportProvider);\n    _this = _super.call(this, options);\n\n    _this.service = _this.options.service;\n    _this.getVersionUrn = _this.options.getVersionUrn;\n    _this.loadDocument = _this.options.loadDocument;\n\n    if (!_this.service || !_this.getVersionUrn || !_this.loadDocument) {\n      console.error('One of AlignmentServiceViewportProvider callbacks is missing.');\n      throw 'AlignmentServiceViewportProvider callbacks is missing';\n    }\n\n    _this.fetch3DNodeForViewport = _this.fetch3DNodeForViewport.bind(_assertThisInitialized(_this));\n    _this.fetchSheetNodeForViewport = _this.fetchSheetNodeForViewport.bind(_assertThisInitialized(_this));return _this;\n  }\n\n  /**\n     * Fetch viewports for a given bubble.\n     * \n     * @param {Autodesk.Viewing.BubbleNode} bubbleNode - bubbleNode.\n     * \n     * @returns {Promise<[Viewport]>} Promise with array of viewports.\n     */_createClass(AlignmentServiceViewportProvider, [{ key: \"fetchViewports\", value: function () {var _fetchViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(\n      bubbleNode) {var viewports;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n                  bubbleNode.is2D() ? this.fetchViewportsFromBubble2D(bubbleNode) : this.fetchViewportsForBubble3D(bubbleNode));case 2:viewports = _context.sent;return _context.abrupt(\"return\",\n\n                viewports);case 4:case \"end\":return _context.stop();}}}, _callee, this);}));function fetchViewports(_x) {return _fetchViewports.apply(this, arguments);}return fetchViewports;}()\n\n\n    /**\n                                                                                                                                                                                                   * @returns {string} Name of viewport provider\n                                                                                                                                                                                                   */ }, { key: \"getProviderName\", value: function getProviderName()\n    {\n      return 'AlignmentServiceViewportProvider';\n    }\n\n    // Fetches viewports for a model and save it in cache, using the provided service\n  }, { key: \"fetchViewportsFromBubble2D\", value: function () {var _fetchViewportsFromBubble2D = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(bubbleNode) {var _this2 = this;var viewableName2D, lineageUrn2D, versionUrn2D, versionUrn2DEncoded, viewportsRaw, viewports;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n                viewableName2D = bubbleNode.name();\n\n                // Given lineageUrn, get latest versionUrn.\n                lineageUrn2D = bubbleNode.lineageUrn();_context2.next = 4;return (\n                  this.getVersionUrn(lineageUrn2D));case 4:versionUrn2D = _context2.sent;\n                versionUrn2DEncoded = Autodesk.Viewing.Private.toUrlSafeBase64(versionUrn2D);_context2.next = 8;return (\n\n                  this.service.loadRegions(versionUrn2DEncoded, viewableName2D));case 8:viewportsRaw = _context2.sent;if (!(\n\n                !viewportsRaw || !viewportsRaw.length)) {_context2.next = 11;break;}return _context2.abrupt(\"return\",\n                []);case 11:\n\n\n                viewports = viewportsRaw.map(function (viewportRaw) {return (\n                    // Since viewport name is not included in the service - we use the sheet's name for now.\n                    _this2._createViewport(viewportRaw, viewableName2D, versionUrn2DEncoded, viewableName2D));});return _context2.abrupt(\"return\",\n\n\n                viewports);case 13:case \"end\":return _context2.stop();}}}, _callee2, this);}));function fetchViewportsFromBubble2D(_x2) {return _fetchViewportsFromBubble2D.apply(this, arguments);}return fetchViewportsFromBubble2D;}() }, { key: \"fetchViewportsForBubble3D\", value: function () {var _fetchViewportsForBubble3D = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(\n\n\n      bubbleNode) {var lineageUrn3D, viewableName3D, relationships, relatedViewports, i, relationship, relatedModel, _relatedModel$id$spli, _relatedModel$id$spli2, lineageUrn2D, rest, nameAndRegion, _nameAndRegion$split, _nameAndRegion$split2, name2D, regionId, versionUrn2D, versionUrn2DEncoded, viewportRaw, viewport;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n                lineageUrn3D = bubbleNode.lineageUrn();\n                viewableName3D = bubbleNode.name();_context3.prev = 2;_context3.next = 5;return (\n\n\n\n\n                  this.service.getRelationships(Autodesk.AlignmentService.RelationshipEntityTypes.Model3D, lineageUrn3D, viewableName3D));case 5:relationships = _context3.sent;_context3.next = 12;break;case 8:_context3.prev = 8;_context3.t0 = _context3[\"catch\"](2);\n\n                console.warn('getRelationships Error: ' + _context3.t0);return _context3.abrupt(\"return\",\n                []);case 12:\n\n\n                relatedViewports = [];\n\n                i = 0;case 14:if (!(i < relationships.length)) {_context3.next = 38;break;}\n                relationship = relationships[i];\n                relatedModel = relationship.entities.find(function (e) {return e.type === Autodesk.AlignmentService.RelationshipEntityTypes.Region;});if (\n\n                relatedModel) {_context3.next = 20;break;}\n                console.warn('Related model not found');return _context3.abrupt(\"continue\", 35);case 20:_relatedModel$id$spli =\n\n\n\n                relatedModel.id.split('?'), _relatedModel$id$spli2 = _slicedToArray(_relatedModel$id$spli, 2), lineageUrn2D = _relatedModel$id$spli2[0], rest = _relatedModel$id$spli2[1];\n                nameAndRegion = rest.slice(Autodesk.AlignmentService.RelationshipIdPrefix.Name.length);_nameAndRegion$split =\n                nameAndRegion.split(Autodesk.AlignmentService.RelationshipIdPrefix.Region), _nameAndRegion$split2 = _slicedToArray(_nameAndRegion$split, 2), name2D = _nameAndRegion$split2[0], regionId = _nameAndRegion$split2[1];\n\n                // Given lineageUrn, get latest versionUrn.\n                _context3.next = 25;return this.getVersionUrn(lineageUrn2D);case 25:versionUrn2D = _context3.sent;\n                versionUrn2DEncoded = Autodesk.Viewing.Private.toUrlSafeBase64(versionUrn2D);_context3.next = 29;return (\n\n                  this.service.loadRegion(versionUrn2DEncoded, name2D, regionId));case 29:viewportRaw = _context3.sent;if (\n\n                viewportRaw) {_context3.next = 33;break;}\n                console.warn('Viewport not found.', versionUrn2DEncoded, name2D, regionId);return _context3.abrupt(\"continue\", 35);case 33:\n\n\n\n                // Since viewport name is not included in the service - we use the sheet's name for now.\n                viewport = this._createViewport(viewportRaw, name2D, versionUrn2DEncoded, name2D);\n\n                relatedViewports.push(viewport);case 35:i++;_context3.next = 14;break;case 38:return _context3.abrupt(\"return\",\n\n\n                relatedViewports);case 39:case \"end\":return _context3.stop();}}}, _callee3, this, [[2, 8]]);}));function fetchViewportsForBubble3D(_x3) {return _fetchViewportsForBubble3D.apply(this, arguments);}return fetchViewportsForBubble3D;}() }, { key: \"fetchSheetNodeForViewport\", value: function () {var _fetchSheetNodeForViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(\n\n\n      viewport) {var result;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:_context4.next = 2;return (\n                  this._fetchBubbleNode(viewport.getSheetUrn(), viewport.getSheetName()));case 2:result = _context4.sent;return _context4.abrupt(\"return\",\n                result);case 4:case \"end\":return _context4.stop();}}}, _callee4, this);}));function fetchSheetNodeForViewport(_x4) {return _fetchSheetNodeForViewport.apply(this, arguments);}return fetchSheetNodeForViewport;}() }, { key: \"fetch3DNodeForViewport\", value: function () {var _fetch3DNodeForViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(\n\n\n      viewport) {var _relationship;var lineageUrn2D, viewableName2D, regionId, relationship, _yield$this$service$g, _yield$this$service$g2, relatedModel, _relatedModel$id$spli3, _relatedModel$id$spli4, lineageUrn3D, name3D, versionUrn3D, urn3DEncoded, name, node;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:\n                lineageUrn2D = viewport.getSheetLineageUrn();\n                viewableName2D = viewport.getSheetName();\n                regionId = viewport.getGuid();_context5.prev = 3;_context5.next = 6;return (\n\n\n\n\n                  this.service.getRelationships(Autodesk.AlignmentService.RelationshipEntityTypes.Region, lineageUrn2D, viewableName2D, regionId));case 6:_yield$this$service$g = _context5.sent;_yield$this$service$g2 = _slicedToArray(_yield$this$service$g, 1);relationship = _yield$this$service$g2[0];_context5.next = 15;break;case 11:_context5.prev = 11;_context5.t0 = _context5[\"catch\"](3);\n\n                console.warn('No relationship found. Error: ' + _context5.t0);throw _context5.t0;case 15:\n\n\n\n                relatedModel = (_relationship = relationship) === null || _relationship === void 0 ? void 0 : _relationship.entities.find(function (e) {return e.type === Autodesk.AlignmentService.RelationshipEntityTypes.Model3D;});if (\n\n                relatedModel) {_context5.next = 18;break;}throw (\n                  'No related model found for sheet-model transition');case 18:_relatedModel$id$spli3 =\n\n\n                relatedModel.id.split('?'), _relatedModel$id$spli4 = _slicedToArray(_relatedModel$id$spli3, 2), lineageUrn3D = _relatedModel$id$spli4[0], name3D = _relatedModel$id$spli4[1];\n\n                // Given lineageUrn, get latest versionUrn.\n                _context5.next = 21;return this.getVersionUrn(lineageUrn3D);case 21:versionUrn3D = _context5.sent;\n\n                // Encode versionUrn\n                urn3DEncoded = Autodesk.Viewing.toUrlSafeBase64(versionUrn3D);\n\n                name = decodeURIComponent(name3D.slice(Autodesk.AlignmentService.RelationshipIdPrefix.Name.length));_context5.next = 26;return (\n\n                  this._fetchBubbleNode(urn3DEncoded, name));case 26:node = _context5.sent;return _context5.abrupt(\"return\",\n\n\n\n                [node]);case 28:case \"end\":return _context5.stop();}}}, _callee5, this, [[3, 11]]);}));function fetch3DNodeForViewport(_x5) {return _fetch3DNodeForViewport.apply(this, arguments);}return fetch3DNodeForViewport;}() }, { key: \"_createViewport\", value: function _createViewport(\n\n\n    viewportRaw, viewportName, urn2D, sheetName) {\n      var options = {\n        fetch3DNodeForViewport: this.fetch3DNodeForViewport,\n        fetchSheetNodeForViewport: this.fetchSheetNodeForViewport };\n\n\n      return new AlignmentServiceViewport(viewportRaw, viewportName, urn2D, sheetName, options);\n    } }, { key: \"_fetchBubbleNode\", value: function () {var _fetchBubbleNode2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(\n\n      urn, name) {var doc, rootNode, nodes;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:_context6.prev = 0;_context6.next = 3;return (\n\n\n\n                  this.loadDocument(urn));case 3:doc = _context6.sent;_context6.next = 9;break;case 6:_context6.prev = 6;_context6.t0 = _context6[\"catch\"](0);throw (\n\n                  'Could not load document');case 9:\n\n\n                rootNode = doc.getRoot();\n                nodes = rootNode.search({ type: 'geometry', name: name });return _context6.abrupt(\"return\",\n\n                nodes[0]);case 12:case \"end\":return _context6.stop();}}}, _callee6, this, [[0, 6]]);}));function _fetchBubbleNode(_x6, _x7) {return _fetchBubbleNode2.apply(this, arguments);}return _fetchBubbleNode;}() }]);return AlignmentServiceViewportProvider;}(ViewportProviderInterface);export { AlignmentServiceViewportProvider as default };","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var ViewportProviderInterface = /*#__PURE__*/function () {\n  function ViewportProviderInterface() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, ViewportProviderInterface);\n    this.options = options;\n  }\n\n  /**\n     * Fetch viewports for a given bubble.\n     * \n     * @param {Autodesk.Viewing.BubbleNode} bubbleNode - bubbleNode.\n     * \n     * @returns {Promise<[Viewport]>} Promise with array of viewports.\n     */_createClass(ViewportProviderInterface, [{ key: \"fetchViewports\", value: function () {var _fetchViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(\n      bubbleNode) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:throw (\n                  \"fetchViewports not implemented\");case 1:case \"end\":return _context.stop();}}}, _callee);}));function fetchViewports(_x) {return _fetchViewports.apply(this, arguments);}return fetchViewports;}()\n\n\n    /**\n                                                                                                                                                                                                                      * @returns {string} Name of viewport provider\n                                                                                                                                                                                                                      */ }, { key: \"getProviderName\", value: function getProviderName()\n    {\n      throw \"getProviderName not implemented\";\n    } }]);return ViewportProviderInterface;}();export { ViewportProviderInterface as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import ViewportInterface from './ViewportInterface';\n\nvar AecModelData = Autodesk.AEC.AecModelData;var\n\nAecModelDataViewport = /*#__PURE__*/function (_ViewportInterface) {_inherits(AecModelDataViewport, _ViewportInterface);var _super = _createSuper(AecModelDataViewport);\n\n  function AecModelDataViewport() {var _this;_classCallCheck(this, AecModelDataViewport);for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _this.sheetNode = _this.options.sheetNode;\n    _this.aecModelData = _this.options.aecModelData;return _this;\n  }_createClass(AecModelDataViewport, [{ key: \"getGuid\", value: function getGuid()\n\n    {\n      return this.viewportRaw.viewportGuid;\n    } }, { key: \"isMatrixInLocalCoords\", value: function isMatrixInLocalCoords()\n\n    {\n      return true;\n    }\n\n    // Viewports in AecModelData are being stored in Feet, regardless of the model's actual units.\n    // For this reason, unitScale must be provided whenever calling getViewportBounds, get2DTo3DMatrix & get3DTo2DMatrix.\n    // Unfortunately, unitScale can't be provided in the construction of the class, since this info doesn't exist in the bubble nor inside AecModelData.\n    // We discover the model's units only after it is loaded.\n  }, { key: \"getViewportBounds\", value: function getViewportBounds(unitScale) {\n      if (!unitScale) {\n        console.error('Unit scale must be provided');\n        return null;\n      }\n\n      return AecModelData.getViewportBounds(this.viewportRaw, unitScale);\n    } }, { key: \"get2DTo3DMatrix\", value: function get2DTo3DMatrix(\n\n    unitScale) {\n      if (!unitScale) {\n        console.error('Unit scale must be provided');\n        return null;\n      }\n\n      var matrix = AecModelData.get2DTo3DMatrix(this.viewportRaw, unitScale);\n\n      // For floorPlans, override the height with the level elevation.\n      if (this.isFloorPlan()) {\n        var level = this.findLevelForViewport();\n\n        // Take elevation from level\n        if (level) {\n          var zOffsetHack = 1 / 120; // Offset to place slightly above floor\n          var pos = new THREE.Vector3();\n          pos.setFromMatrixPosition(matrix);\n          pos.z = level.elevation + zOffsetHack;\n          matrix = matrix.clone().setPosition(pos);\n        }\n      }\n\n      return matrix;\n    } }, { key: \"getParentSheetNode\", value: function () {var _getParentSheetNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:return _context.abrupt(\"return\",\n\n\n                this.sheetNode);case 1:case \"end\":return _context.stop();}}}, _callee, this);}));function getParentSheetNode() {return _getParentSheetNode.apply(this, arguments);}return getParentSheetNode;}() }, { key: \"get3DNodesForViewport\", value: function () {var _get3DNodesForViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var views;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n\n\n\n                views = this.sheetNode.getRootNode().search(Autodesk.Viewing.BubbleNode.MODEL_NODE);\n\n                if (!views.length) {\n                  console.error(\"That shouldn't happen - No AEC views\");\n                }return _context2.abrupt(\"return\",\n\n                views);case 3:case \"end\":return _context2.stop();}}}, _callee2, this);}));function get3DNodesForViewport() {return _get3DNodesForViewport.apply(this, arguments);}return get3DNodesForViewport;}() }, { key: \"findLevelForViewport\", value: function findLevelForViewport()\n\n\n    {\n      return AecModelData.findLevelForViewport(this.aecModelData, this.viewportRaw);\n    } }, { key: \"isViewportInLevel\", value: function isViewportInLevel(\n\n    level) {\n      var linkedLevelGuid = AecModelData.getLinkedLevel(this.viewportRaw);\n      return level.guid === linkedLevelGuid;\n    } }, { key: \"supports2DTo3DTransform\", value: function supports2DTo3DTransform()\n\n    {\n      return AecModelData.supports2DTo3DTransform(this.viewportRaw);\n    } }, { key: \"isTopViewViewport\", value: function isTopViewViewport()\n\n    {\n      return AecModelData.TopViewViewportTypes.includes(this.viewportRaw.viewType);\n    } }, { key: \"isFloorPlan\", value: function isFloorPlan()\n\n    {\n      return this.viewportRaw.viewType === 'FloorPlan';\n    } }]);return AecModelDataViewport;}(ViewportInterface);export { AecModelDataViewport as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import ViewportInterface from './ViewportInterface';var\n\nAlignmentServiceViewport = /*#__PURE__*/function (_ViewportInterface) {_inherits(AlignmentServiceViewport, _ViewportInterface);var _super = _createSuper(AlignmentServiceViewport);\n\n  function AlignmentServiceViewport() {var _this;_classCallCheck(this, AlignmentServiceViewport);for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _this.fetchSheetNodeForViewport = _this.options.fetchSheetNodeForViewport;\n    _this.fetch3DNodeForViewport = _this.options.fetch3DNodeForViewport;return _this;\n  }_createClass(AlignmentServiceViewport, [{ key: \"getGuid\", value: function getGuid()\n\n    {\n      return this.viewportRaw.regionId;\n    } }, { key: \"isMatrixInLocalCoords\", value: function isMatrixInLocalCoords()\n\n    {\n      return false;\n    } }, { key: \"getViewportBounds\", value: function getViewportBounds()\n\n    {\n      return this.viewportRaw.boundingBox;\n    } }, { key: \"get2DTo3DMatrix\", value: function get2DTo3DMatrix()\n\n    {\n      return this.viewportRaw.transform;\n    } }, { key: \"getParentSheetNode\", value: function () {var _getParentSheetNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n\n                if (!this.parentSheetNodePromise) {\n                  this.parentSheetNodePromise = this.fetchSheetNodeForViewport(this);\n                }return _context.abrupt(\"return\",\n\n                this.parentSheetNodePromise);case 2:case \"end\":return _context.stop();}}}, _callee, this);}));function getParentSheetNode() {return _getParentSheetNode.apply(this, arguments);}return getParentSheetNode;}() }, { key: \"get3DNodesForViewport\", value: function () {var _get3DNodesForViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:return _context2.abrupt(\"return\",\n\n\n\n                this.fetch3DNodeForViewport(this));case 1:case \"end\":return _context2.stop();}}}, _callee2, this);}));function get3DNodesForViewport() {return _get3DNodesForViewport.apply(this, arguments);}return get3DNodesForViewport;}() }, { key: \"findLevelForViewport\", value: function findLevelForViewport()\n\n\n    {\n      if (!this.isTopViewViewport()) {\n        return null;\n      }\n\n      // Generate synthetic level data.\n      return { elevation: this.getElevation() };\n    } }, { key: \"isViewportInLevel\", value: function isViewportInLevel(\n\n    level) {\n      if (!this.isTopViewViewport()) {\n        return false;\n      }\n\n      var z = this.getElevation();\n\n      // Notice that both matrix and level are in world coordinates.\n      return z > level.zMin && z < level.zMax;\n    } }, { key: \"supports2DTo3DTransform\", value: function supports2DTo3DTransform()\n\n    {\n      return true;\n    } }, { key: \"isTopViewViewport\", value: function isTopViewViewport()\n\n    {\n      if (this._topViewViewport === undefined) {\n        var matrix = this.get2DTo3DMatrix();\n        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);\n        var z = new THREE.Vector3(0, 0, 1);\n\n        var direction = z.clone().applyMatrix3(normalMatrix);\n        var angle = direction.angleTo(z);\n\n        // Support upside down viewports\n        if (angle >= Math.PI) {\n          angle -= Math.PI;\n        }\n\n        var AngleThreshold = 0.05;\n        this._topViewViewport = Math.abs(angle) < AngleThreshold;\n      }\n\n      return this._topViewViewport;\n    } }, { key: \"isFloorPlan\", value: function isFloorPlan()\n\n    {\n      // Assume all top-view manually aligned viewports are floor plans.\n      return this.isTopViewViewport();\n    } }]);return AlignmentServiceViewport;}(ViewportInterface);export { AlignmentServiceViewport as default };","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var ViewportInterface = /*#__PURE__*/function () {\n  function ViewportInterface(viewportRaw) {var viewportName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';var sheetUrn = arguments.length > 2 ? arguments[2] : undefined;var sheetName = arguments.length > 3 ? arguments[3] : undefined;var options = arguments.length > 4 ? arguments[4] : undefined;_classCallCheck(this, ViewportInterface);\n    this.viewportRaw = viewportRaw;\n    this.viewportName = viewportName;\n    this.sheetUrn = sheetUrn;\n    this.lineageUrn = Autodesk.Viewing.BubbleNode.parseLineageUrnFromEncodedUrn(sheetUrn);\n    this.sheetName = sheetName;\n    this.options = options;\n  }\n\n  // Unique viewport guid.\n  _createClass(ViewportInterface, [{ key: \"getGuid\", value: function getGuid() {\n      throw \"getGuid not implemented\";\n    }\n\n    // Is matrix in model-local coordinates, or world coordinates.\n  }, { key: \"isMatrixInLocalCoords\", value: function isMatrixInLocalCoords() {\n      throw \"isMatrixInLocalCoords not implemented\";\n    }\n\n    // Sheet's version urn that the viewport is part of.\n  }, { key: \"getSheetUrn\", value: function getSheetUrn() {\n      return this.sheetUrn;\n    }\n\n    // Sheet's lineage urn that the viewport is part of.\n  }, { key: \"getSheetLineageUrn\", value: function getSheetLineageUrn() {\n      return this.lineageUrn;\n    }\n\n    // Sheet name that the viewport is part of.\n  }, { key: \"getSheetName\", value: function getSheetName() {\n      return this.sheetName;\n    }\n\n    // Viewport name.\n  }, { key: \"getName\", value: function getName() {\n      return this.viewportName;\n    }\n\n    // Box2 - viewport bounds.\n  }, { key: \"getViewportBounds\", value: function getViewportBounds() {var unitScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;\n      throw \"getViewportBounds not implemented\";\n    }\n\n    // 2D to 3D transform.\n  }, { key: \"get2DTo3DMatrix\", value: function get2DTo3DMatrix() {var unitScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;\n      throw \"get2DTo3DMatrix not implemented\";\n    }\n\n    // 3D to 2D transform.\n  }, { key: \"get3DTo2DMatrix\", value: function get3DTo2DMatrix() {var unitScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;\n      var matrix = this.get2DTo3DMatrix(unitScale).clone();\n      matrix.getInverse(matrix);\n\n      return matrix;\n    }\n\n    // Get 2D sheet BubbleNode containing the given viewport.\n  }, { key: \"getParentSheetNode\", value: function () {var _getParentSheetNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:throw (\n                  \"getParentSheetNode not implemented\");case 1:case \"end\":return _context.stop();}}}, _callee);}));function getParentSheetNode() {return _getParentSheetNode.apply(this, arguments);}return getParentSheetNode;}()\n\n\n    // Get 3D BubbleNodes related to the given viewport.\n  }, { key: \"get3DNodesForViewport\", value: function () {var _get3DNodesForViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:throw (\n                  \"get3DNodesForViewport not implemented\");case 1:case \"end\":return _context2.stop();}}}, _callee2);}));function get3DNodesForViewport() {return _get3DNodesForViewport.apply(this, arguments);}return get3DNodesForViewport;}()\n\n\n    // Find a level containing the given viewport.\n  }, { key: \"findLevelForViewport\", value: function findLevelForViewport() {\n      throw \"findLevelForViewport not implemented\";\n    }\n\n    // Given a level, check if viewport is inside it.\n  }, { key: \"isViewportInLevel\", value: function isViewportInLevel(level) {\n      throw \"isViewportInLevel not implemented\";\n    }\n\n    // Does the viewport supports 2D to 3D transform.\n  }, { key: \"supports2DTo3DTransform\", value: function supports2DTo3DTransform() {\n      throw \"supports2DTo3DTransform not implemented\";\n    }\n\n    // Does the viewport faces up (top view).\n  }, { key: \"isTopViewViewport\", value: function isTopViewViewport() {\n      throw \"isTopViewViewport not implemented\";\n    }\n\n    // Does the viewport represents a floor plan.\n  }, { key: \"isFloorPlan\", value: function isFloorPlan() {\n      throw \"isFloorPlan not implemented\";\n    }\n\n    // Returns viewport Z position.\n  }, { key: \"getElevation\", value: function getElevation() {\n      return this.get2DTo3DMatrix().elements[14];\n    } }]);return ViewportInterface;}();export { ViewportInterface as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import ViewportProviderInterface from './Providers/ViewportProviderInterface';\nimport AecModelDataViewportProvider from './Providers/AecModelDataViewportProvider';\nimport AlignmentServiceViewportProvider from './Providers/AlignmentServiceViewportProvider';\nimport AlignmentServiceViewport from './ViewportTypes/AlignmentServiceViewport';\nimport AecModelDataViewport from './ViewportTypes/AecModelDataViewport';\nimport { zOffsetHack } from '../levels/LevelUtils';\nimport Level from '../levels/Level';\nimport { locales } from './ViewportsLocales';\n\nvar av = Autodesk.Viewing;\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar extensionName = 'Autodesk.AEC.ViewportsExtension';\n\nvar MAX_INT_32 = 2147483647;\n/**\n                              * Viewports Extension is a centralized place that manages all of the viewports associated with models.\n                              * By default, viewports from AecModelData will be fetched and cached.\n                              * Any other viewport providers can be added (Alignment Service for example).\n                              *\n                              * @example\n                              *   viewer.loadExtension('Autodesk.AEC.ViewportsExtension', options)\n                              *\n                              * @memberof Autodesk.Viewing.Extensions\n                              * @alias Autodesk.Viewing.Extensions.Viewports\n                              * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                              * @class\n                              */\nexport var ViewportsExtension = /*#__PURE__*/function (_av$Extension) {_inherits(ViewportsExtension, _av$Extension);var _super = _createSuper(ViewportsExtension);\n\n  function ViewportsExtension(viewer, options) {var _this;_classCallCheck(this, ViewportsExtension);\n    _this = _super.call(this, viewer, options);\n\n    av.EventDispatcher.prototype.apply(_assertThisInitialized(_this));\n\n    _this.name = 'Viewports';\n\n    _this.onModelAdded = _this.onModelAdded.bind(_assertThisInitialized(_this));\n    _this.onViewportDataCreated = _this.onViewportDataCreated.bind(_assertThisInitialized(_this));return _this;\n  }_createClass(ViewportsExtension, [{ key: \"load\", value: function load()\n\n    {\n      _get(_getPrototypeOf(ViewportsExtension.prototype), \"load\", this).call(this);\n\n      this.extendLocalization(locales);\n\n      this.cache = this.getCache();\n\n      if (!this.cache.viewports) {\n        this.cache.viewports = {};\n      }\n\n      this.providers = {};\n\n      // Load AecModelDataViewportProvider by default.\n      this.addViewportProvider(new AecModelDataViewportProvider());\n\n      this.addEventListeners();\n\n      this.fetchViewportsForAllModels();\n\n      return true;\n    } }, { key: \"unload\", value: function unload()\n\n    {\n      _get(_getPrototypeOf(ViewportsExtension.prototype), \"unload\", this).call(this);\n\n      this.providers = null;\n\n      this.removeEventListeners();\n      return true;\n    } }, { key: \"addViewportProvider\", value: function addViewportProvider(\n\n    provider) {\n      if (!this.providers[provider.getProviderName()]) {\n        this.providers[provider.getProviderName()] = provider;\n      }\n\n      // Update viewports for all existing models.\n      // Don't worry, if viewports already fetched for a given model & provider - it will be skipped.\n      this.fetchViewportsForAllModels();\n    } }, { key: \"removeViewportProvider\", value: function removeViewportProvider(\n\n    provider) {\n      delete this.providers[provider.getProviderName()];\n    } }, { key: \"fetchViewportsForAllModels\", value: function fetchViewportsForAllModels()\n\n    {var _this2 = this;\n      var models = this.viewer.getAllModels();\n      models.forEach(function (model) {return _this2.fetchViewports(model.getDocumentNode());});\n    } }, { key: \"addEventListeners\", value: function addEventListeners()\n\n    {\n      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);\n      this.addEventListener(ViewportsExtension.Events.VIEWPORT_DATA_CREATED_EVENT, this.onViewportDataCreated);\n    } }, { key: \"removeEventListeners\", value: function removeEventListeners()\n\n    {\n      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);\n      this.removeEventListener(ViewportsExtension.Events.VIEWPORT_DATA_CREATED_EVENT, this.onViewportDataCreated);\n    } }, { key: \"onModelAdded\", value: function onModelAdded(_ref)\n\n    {var model = _ref.model;\n      this.fetchViewports(model.getDocumentNode());\n    }\n\n    // Generate artificial levels based on viewports.\n  }, { key: \"generateLevelsFromViewports\", value: function () {var _generateLevelsFromViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(bubbleNode) {var viewports, levels, LevelHeightThreshold, i, _i, currentElevation, nextElevation;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n                  this.getViewportsAsync(bubbleNode));case 2:viewports = _context.sent;if (\n\n                viewports) {_context.next = 5;break;}return _context.abrupt(\"return\",\n                []);case 5:\n\n\n                levels = [];\n                LevelHeightThreshold = 1;\n\n                viewports.sort(function (v1, v2) {return v1.getElevation() - v2.getElevation();});\n\n                for (i = 0; i < viewports.length - 1; i++) {\n                  // Don't generate more than one level per height.\n                  // In case two viewports have about the same height, create a single level based on the first one.\n                  if (Math.abs(viewports[i].getElevation() - viewports[i + 1].getElevation()) < LevelHeightThreshold) {\n                    viewports.splice(i + 1, 1);\n                    i--;\n                  }\n                }\n\n                for (_i = 0; _i < viewports.length; _i++) {\n                  currentElevation = viewports[_i].getElevation();\n                  nextElevation = undefined;\n\n                  // Topmost level - we don't know its height, so we'll assume it's REALLY tall.\n                  if (_i === viewports.length - 1) {\n                    nextElevation = MAX_INT_32; // Equivalent to the top level values in AecModelData levels.\n                  } else {\n                    // For every other level, calculate its height according to the next level on top of it.\n                    nextElevation = viewports[_i + 1].getElevation();\n                  }\n\n                  levels.push(\n                  new Level(\n                  _i,\n                  _i.toString(), \"\".concat(\n                  Autodesk.Viewing.i18n.translate('Level'), \" #\").concat(_i + 1),\n                  currentElevation - zOffsetHack,\n                  nextElevation));\n\n\n                }return _context.abrupt(\"return\",\n\n                levels);case 11:case \"end\":return _context.stop();}}}, _callee, this);}));function generateLevelsFromViewports(_x) {return _generateLevelsFromViewports.apply(this, arguments);}return generateLevelsFromViewports;}() }, { key: \"onViewportDataCreated\", value: function onViewportDataCreated(_ref2)\n\n\n    {var _this3 = this;var models = _ref2.models;\n      models.forEach(function (model) {\n        // Invalidate cache and refetch the viewports data\n        var key = model.getModelKey();\n        if (_this3.cache.viewports[key]) {\n          delete _this3.cache.viewports[key];\n\n          // Refetch viewports.\n          _this3.onModelAdded({ model: model });\n        }\n      });\n    }\n\n    // Fetch and get viewports for a given bubble.\n    // In case that the viewports were previously requested - don't worry, you'll get them from cache.\n  }, { key: \"getViewportsAsync\", value: function () {var _getViewportsAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(bubbleNode, filterOptions) {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (\n                  this.fetchViewports(bubbleNode));case 2:return _context2.abrupt(\"return\",\n                this.filterAndFlattenViewports(bubbleNode, filterOptions));case 3:case \"end\":return _context2.stop();}}}, _callee2, this);}));function getViewportsAsync(_x2, _x3) {return _getViewportsAsync.apply(this, arguments);}return getViewportsAsync;}()\n\n\n    // Returns only from what's already cached\n  }, { key: \"getViewports\", value: function getViewports(bubbleNode, filterOptions) {\n      return this.filterAndFlattenViewports(bubbleNode, filterOptions);\n    }\n\n    // Filter viewports according to given flags, and organize them in a flat array.\n    // filterOptions:\n    //          - filter2DTo3DTransformSupport: filter only viewports that support 2D to 3D transform.\n    //          - onlyTopViewPlans: filter only top view viewports.\n    //          - filterCB: additional filter callback.\n  }, { key: \"filterAndFlattenViewports\", value: function filterAndFlattenViewports(bubbleNode) {var _filterOptions$filter, _filterOptions$onlyTo;var filterOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var filter2DTo3DTransformSupport = (_filterOptions$filter = filterOptions.filter2DTo3DTransformSupport) !== null && _filterOptions$filter !== void 0 ? _filterOptions$filter : true;\n      var onlyTopViewPlans = (_filterOptions$onlyTo = filterOptions.onlyTopViewPlans) !== null && _filterOptions$onlyTo !== void 0 ? _filterOptions$onlyTo : true;\n      var filterCB = filterOptions.filterCB;\n\n      var key = bubbleNode.getModelKey();\n      var viewportsPerProvider = this.cache.viewports[key];\n\n      if (!viewportsPerProvider) {\n        return [];\n      }\n\n      var viewports = Object.values(viewportsPerProvider).flat();\n\n      if (filter2DTo3DTransformSupport) {\n        viewports = viewports.filter(function (viewport) {return viewport.supports2DTo3DTransform();});\n      }\n\n      if (onlyTopViewPlans) {\n        viewports = viewports.filter(function (viewport) {return viewport.isTopViewViewport();});\n      }\n\n      if (filterCB) {\n        viewports = viewports.filter(filterCB);\n      }\n\n      return viewports;\n    }\n\n    // Fetch viewports for a given bubbleNode.\n  }, { key: \"fetchViewports\", value: function () {var _fetchViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(bubbleNode) {var _this4 = this;var key;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:\n                key = bubbleNode.getModelKey();\n                if (!this.cache.viewports[key]) {\n                  this.cache.viewports[key] = {};\n                }\n\n                // Wait for all providers to finish before returning from function,\n                // but run each provider in parallel so nothing is blocked.\n                _context4.next = 4;return Promise.all(Object.values(this.providers).map( /*#__PURE__*/function () {var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(provider) {var providerName, viewports;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n                            providerName = provider.getProviderName();\n\n                            // Fetch viewports only if they are not in cache yet.\n                            if (_this4.cache.viewports[key][providerName]) {_context3.next = 11;break;}\n                            // Add a placeholder in cache so it won't fetch viewports multiple times for the\n                            // same provider (in case of multiple calls to fetchViewports)\n                            _this4.cache.viewports[key][providerName] = [];\n\n                            // Save the current promise to be returned on subsequent fetchViewports calls,\n                            // so that we don't return those calls until data is ready\n                            _this4.cache.viewports[key][providerName].pendingPromise = provider.fetchViewports(bubbleNode);_context3.next = 6;return (\n                              _this4.cache.viewports[key][providerName].pendingPromise);case 6:viewports = _context3.sent;\n\n                            delete _this4.cache.viewports[key][providerName].pendingPromise;\n\n                            if (viewports.length) {\n                              _this4.cache.viewports[key][providerName] = viewports;\n                              _this4.fireEvent({ type: ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, viewports: viewports });\n                            }_context3.next = 14;break;case 11:if (!\n                            _this4.cache.viewports[key][providerName].pendingPromise) {_context3.next = 14;break;}_context3.next = 14;return (\n                              _this4.cache.viewports[key][providerName].pendingPromise);case 14:case \"end\":return _context3.stop();}}}, _callee3);}));return function (_x5) {return _ref3.apply(this, arguments);};}()));case 4:case \"end\":return _context4.stop();}}}, _callee4, this);}));function fetchViewports(_x4) {return _fetchViewports.apply(this, arguments);}return fetchViewports;}()\n\n\n\n\n    // Given a viewport array, a sheet and a point on that sheet, this function returns the viewport containing it.\n    // If multiple viewports overlap, we choose the one where (x,y) is \"most inside\", i.e., \n    // where the distance from the viewport edges is largest.\n    //\n    //  @param {av.Model}         sheet\n    //  @param {Vector2}          point            - Point in sheet world-coords.\n    //  @param {Object}           filterOptions\n    //\n    //  @returns {Viewport|null} \n  }, { key: \"findViewportAtPoint\", value: function findViewportAtPoint(sheet, point, filterOptions) {\n      var viewports = this.filterAndFlattenViewports(sheet.getDocumentNode(), filterOptions);\n\n      // Couple each viewport with viewport bounds \n      viewports = viewports.map(function (vp) {\n        return {\n          viewport: vp,\n          bounds: vp.getViewportBounds(sheet.getUnitScale()) };\n\n      });\n\n      // Reduce to viewports containing the given point\n      var containsPoint = function containsPoint(vp) {var _vp$bounds;return (_vp$bounds = vp.bounds) === null || _vp$bounds === void 0 ? void 0 : _vp$bounds.containsPoint(point);};\n\n      viewports = viewports.filter(containsPoint);\n\n      // Point may be outside of all viewports\n      if (!viewports.length) {\n        return null;\n      }\n\n      // Viewports may overlap. For this case, we need a heuristic metric\n      // to choose the best match. For this, we use the\n      // distance to the viewport boundary edges.\n      var distanceFromEdge = function distanceFromEdge(box, p) {\n        return Math.min(\n        Math.min(p.x - box.min.x, box.max.x - p.x),\n        Math.min(p.y - box.min.y, box.max.y - p.y));\n\n      };\n\n      // Pick the viewport that minimizes distanceFromEdge\n      var getBestMatch = function getBestMatch(vp1, vp2) {\n        var d1 = distanceFromEdge(vp1.bounds, point);\n        var d2 = distanceFromEdge(vp2.bounds, point);\n        return d2 > d1 ? vp2 : vp1;\n      };\n\n      return viewports.reduce(getBestMatch).viewport;\n    }\n\n    // Given a level guid, find all viewports that are contained in this level.\n    //\n    //  @param {av.Model}         model3D          - A 3D model that contains levels & viewports.\n    //  @param {String}           levelGuid        - Level guid\n    //\n    //  @returns {Array<Viewport>} \n  }, { key: \"findViewportsInLevel\", value: function findViewportsInLevel(model3D, levelGuid) {\n      var levelExt = this.viewer.getExtension('Autodesk.AEC.LevelsExtension');\n\n      if (!levelExt) {\n        return [];\n      }\n\n      var levels = levelExt.floorSelector.floorData;\n      var level = levels.find(function (level) {return level.guid === levelGuid;});\n\n      // No matching level for the given level guid.\n      if (!level) {\n        return [];\n      }\n\n      var viewports = this.getViewports(model3D.getDocumentNode(), {\n        filterCB: function filterCB(viewport) {return viewport.isViewportInLevel(level);} });\n\n\n      return viewports;\n    } }]);return ViewportsExtension;}(av.Extension);\n\n\nnamespace.ViewportsExtension = ViewportsExtension;\n\n// Events\nViewportsExtension.Events = {\n  VIEWPORT_DATA_FETCHED_EVENT: 'viewportDataFetched',\n  VIEWPORT_DATA_CREATED_EVENT: 'viewportDataCreated' };\n\n\n// Exports\nViewportsExtension.ViewportProviderInterface = ViewportProviderInterface;\nViewportsExtension.AecModelDataViewportProvider = AecModelDataViewportProvider;\nViewportsExtension.AlignmentServiceViewportProvider = AlignmentServiceViewportProvider;\nViewportsExtension.AlignmentServiceViewport = AlignmentServiceViewport;\nViewportsExtension.AecModelDataViewport = AecModelDataViewport;\n\nav.theExtensionManager.registerExtension(extensionName, ViewportsExtension);","/**\n * Include each locale json file and return it in an object\n * that can be consumed by i18n\n */\n\nimport json_en from '../../../res/locales/en/nobundle-viewports.loc.json';\n\nimport json_en_GB from '../../../res/locales/en-GB/nobundle-viewports.loc.json';\nimport json_cs from '../../../res/locales/cs/nobundle-viewports.loc.json';\nimport json_de from '../../../res/locales/de/nobundle-viewports.loc.json';\nimport json_es from '../../../res/locales/es/nobundle-viewports.loc.json';\nimport json_fr from '../../../res/locales/fr/nobundle-viewports.loc.json';\nimport json_fr_CA from '../../../res/locales/fr-CA/nobundle-viewports.loc.json';\nimport json_it from '../../../res/locales/it/nobundle-viewports.loc.json';\nimport json_ja from '../../../res/locales/ja/nobundle-viewports.loc.json';\nimport json_ko from '../../../res/locales/ko/nobundle-viewports.loc.json';\nimport json_pl from '../../../res/locales/pl/nobundle-viewports.loc.json';\nimport json_pt_BR from '../../../res/locales/pt-BR/nobundle-viewports.loc.json';\nimport json_ru from '../../../res/locales/ru/nobundle-viewports.loc.json';\nimport json_tr from '../../../res/locales/tr/nobundle-viewports.loc.json';\nimport json_zh_HANS from '../../../res/locales/zh-HANS/nobundle-viewports.loc.json';\nimport json_zh_HANT from '../../../res/locales/zh-HANT/nobundle-viewports.loc.json';\nimport json_zh_HK from '../../../res/locales/zh-HK/nobundle-viewports.loc.json';\nimport json_nl from '../../../res/locales/nl/nobundle-viewports.loc.json';\nimport json_sv from '../../../res/locales/sv/nobundle-viewports.loc.json';\nimport json_da from '../../../res/locales/da/nobundle-viewports.loc.json';\nimport json_no from '../../../res/locales/no/nobundle-viewports.loc.json';\n\nexport var locales = {\n  en: json_en,\n  'en-GB': json_en_GB,\n  cs: json_cs,\n  de: json_de,\n  es: json_es,\n  fr: json_fr,\n  \"fr-CA\": json_fr_CA,\n  it: json_it,\n  ja: json_ja,\n  ko: json_ko,\n  pl: json_pl,\n  \"pt-BR\": json_pt_BR,\n  ru: json_ru,\n  tr: json_tr,\n  \"zh-HANS\": json_zh_HANS,\n  \"zh-HANT\": json_zh_HANT,\n  \"zh-HK\": json_zh_HK,\n  nl: json_nl,\n  sv: json_sv,\n  da: json_da,\n  no: json_no };","//\n// Utility functions to work with AEC-specific model data. These are stored in a separate JSON file AECModelData.json. \n// Currently only available for Revit files.\n//\n\nvar namespace = AutodeskNamespace('Autodesk.AEC');\n\nvar TopViewViewportTypes = ['FloorPlan', 'CeilingPlan', 'EngineeringPlan'];\n\n// Computes a Matrix4 that maps the 'from' rectangle to the 'to' rectangle in xy.\nvar remapRectangle = function remapRectangle(\nxMinFrom, yMinFrom, xMaxFrom, yMaxFrom,\nxMinTo, yMinTo, xMaxTo, yMaxTo)\n{\n  var scaleX = (xMaxTo - xMinTo) / (xMaxFrom - xMinFrom);\n  var scaleY = (yMaxTo - yMinTo) / (yMaxFrom - yMinFrom);\n\n  // Note that the translation component of the matrix works on the scaled values.\n  // The scaling alone would map xMinFrom to scaleX * xMinFrom. We want \n  // to map it to xMinTo instead. (analog for y)\n  var offsetX = xMinTo - scaleX * xMinFrom;\n  var offsetY = yMinTo - scaleY * yMinFrom;\n\n  // Create Matrix4 that applies both\n  var matrix = new THREE.Matrix4();\n  matrix.elements[0] = scaleX;\n  matrix.elements[5] = scaleY;\n  matrix.elements[12] = offsetX;\n  matrix.elements[13] = offsetY;\n  return matrix;\n};\n\nvar getFeetToSheetUnits = function getFeetToSheetUnits(sheetUnitScale) {\n  var FeetToMeter = 0.3048;\n  var MeterToSheetUnits = 1.0 / sheetUnitScale;\n  return FeetToMeter * MeterToSheetUnits;\n};\n\n// Returns the 2D bbox of a viewport on a sheet.\n// \n// @param {Object} vp             - Viewport data as read from AECModelData\n// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().\n// @returns {THREE.Box2|null}\nvar getViewportBounds = function getViewportBounds(vp, sheetUnitScale) {\n\n  // viewport region in foot as array (6 floats)\n  var values = vp.geometryViewportRegion;\n  if (!values) {\n    return null;\n  }\n\n  // Convert from foot to sheet units (usually inches)\n  var scale = getFeetToSheetUnits(sheetUnitScale);\n\n  // The viewport region returned by Revit is incorrect. It's enlarged by an offset of 0.01 ft.\n  // We remove that offset before scaling. \n  // See https://thebuildingcoder.typepad.com/blog/2010/09/view-location-on-sheet.html (search for 0.01 in that page)\n  var boundsCorrection = 0.01;\n\n  var res = new THREE.Box2();\n  res.min.x = (values[0] + boundsCorrection) * scale;\n  res.min.y = (values[1] + boundsCorrection) * scale;\n  res.max.x = (values[3] - boundsCorrection) * scale;\n  res.max.y = (values[4] - boundsCorrection) * scale;\n  return res;\n};\n\n// Handle available view rotation modes in Revit\n// If a view was rotated in Revit, this swapped/inverted some viewport axes. We must revert this modification when transforming back to world coords.\n// This function returns a Matrix4 that performs this rotation on an input vector p in normalized viewport coords (in [0,1])\n//\n//  @param {number} viewRotationType - as read from AECModelData. Enum value in {0,1,2}. see Revit API doc:\n//                                     http://www.revitapidocs.com/2018/abd81744-b44a-e578-cb62-3cc40a334acc.htm\n//  @returns {THREE.Vector2/3} Copy of vpCoords with swapped/inverted axes according to viewport rotation\nvar getInverseViewportRotation = function getInverseViewportRotation(viewRotationType) {\n\n  var matrix = new THREE.Matrix4();\n  switch (viewRotationType) {\n    // No rotation => done\n    case 0:return matrix;\n\n    // Revit view was rotated by 90 degrees clockwise => Rotate by 90 degrees ccw\n    case 1:{\n        // Note that a rotation would actually mean result.x = -y. But, we just revert the effect the rotation effect on the\n        // viewport axes here. I.e., input and output are in [0,1]. For this, swapping an axis means taking 1.0-value, not just the negative.\n        // Therefore, the desired effect of the matrix is:\n        //\n        //  (x, y) => (1-y, x)\n        //\n        // Note the memory layout of THREE matrices is column-major.\n\n        // out.x = (1-y)\n        matrix.elements[0] = 0; //  0 * in.x\n        matrix.elements[4] = -1; // -1 * in.y\n        matrix.elements[12] = 1; // + 1\n\n        // out.y = x\n        matrix.elements[1] = 1; // 1 * in.x\n        matrix.elements[5] = 0; // 0 * in.y\n\n        break;\n      }\n\n    // Revit view was rotated 90 degrees counterclockwise => Rotate by 90 degrees cw\n    case 2:{\n        // Desired transform here is:\n        //\n        // (x, y) => (y, 1-x)\n\n        // out.x = y\n        matrix.elements[0] = 0; // 0 * in.x\n        matrix.elements[4] = 1; // 1 * in.y\n\n        // out.y = (1-x)\n        matrix.elements[1] = -1; //    -in.x\n        matrix.elements[5] = 0; // 0 * in.y\n        matrix.elements[13] = 1; // + 1\n\n        break;\n      }\n    default:console.warn('Unexpected enum value for view rotation: ', viewRotationType);}\n\n  return matrix;\n};\n\nvar get3DTo2DModelSheetTransform = function get3DTo2DModelSheetTransform(vp, sheetUnitScale) {\n  // Only if AECModelData has been produced using latest RevitAPI changes, \n  // we get the 3DTo2D matrix directly. Otherwise return null.\n  if (!vp.modelToSheetTransform) {\n    return null;\n  }\n\n  var values = vp.modelToSheetTransform;\n  var matrix = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(values);\n\n  // apply post-scaling from feet to sheet-units\n  // Note that using multiplyScalar() here is only similar, but not the same: E.g., it would also multiply component 15\n  // which may cause weird side-effects when multiplying with other matrices.\n  // The Z value of the scale is set to feetToSheetUnits as well so that getMaxScaleOnAxis\n  // returns a meaningful result (used to be 1, which would skew the results)\n  var feetToSheetUnits = getFeetToSheetUnits(sheetUnitScale);\n  var scaleTf = new THREE.Matrix4().makeScale(feetToSheetUnits, feetToSheetUnits, feetToSheetUnits);\n  matrix.multiplyMatrices(scaleTf, matrix);\n\n  return matrix;\n};\n\nvar compute2Dto3DTransform = function compute2Dto3DTransform(vp, sheetUnitScale) {\n  // Viewport bbox on sheet (Box2)\n  var sheetRegion = getViewportBounds(vp, sheetUnitScale);\n\n  // SectionBox (Box3 + Matrix4): Oriented box in 3D world coords. Represents the volume\n  // that is mapped to the sheet.\n  var sectionBox = vp.sectionBox;\n  var sectionBoxTransform = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(sectionBox.transform);\n\n  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2\n  var sheetToViewport = remapRectangle(\n  sheetRegion.min.x, sheetRegion.min.y, sheetRegion.max.x, sheetRegion.max.y, // ...from viewport rectangle in sheet coordinates\n  0, 0, 1, 1 // ...to [0,1] \n  );\n\n  // Consider Revit viewport rotation. Result keeps within viewport coords ([0,1]^2)\n  var vpRotationInv = getInverseViewportRotation(vp.viewportRotation);\n\n  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2\n  var viewportToSectionBox = remapRectangle(\n  0, 0, 1, 1, // ...from normalized viewport coords\n  sectionBox.min.x, sectionBox.min.y, sectionBox.max.x, sectionBox.max.y // ...to the xy-extent of the untransformed SectionBox\n  );\n\n  // Finally, apply the sectionBoxTransform to obtain world coords. Note that matrix products must be done in reverse order.\n  return sectionBoxTransform.\n  multiply(viewportToSectionBox).\n  multiply(vpRotationInv).\n  multiply(sheetToViewport);\n};\n\n// Compute matrix to convert 2D sheet coords within the given viewport to 3D model coordinates.\n//\n// @param {Object} vp             - Viewport data as read from AECModelData\n// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().\n//\n// @returns {THREE.Matrix4}\n//\n// Note: Not all viewports provide A 2D/3D transform is not provided by all This feature is only available for a subset of  viewports. \nvar get2DTo3DMatrix = function get2DTo3DMatrix(vp, sheetUnitScale) {\n  var matrix = get3DTo2DModelSheetTransform(vp, sheetUnitScale);\n\n  if (matrix) {\n    return matrix.getInverse(matrix);\n  }\n\n  return compute2Dto3DTransform(vp, sheetUnitScale);\n};\n\n// Compute matrix to convert 3D model coords to 2D sheet coords within a given viewport. See get2Dto3DMatrix().\nvar get3DTo2DMatrix = function get3DTo2DMatrix(vp, sheetUnitScale) {\n  var matrix = get3DTo2DModelSheetTransform(vp, sheetUnitScale);\n\n  if (matrix) {\n    return matrix;\n  }\n\n  matrix = compute2Dto3DTransform(vp, sheetUnitScale);\n  return matrix.getInverse(matrix);\n};\n\n// Find Sheet BubbleNode containing the given viewport.\n//\n//  @params {av.BubbleNode} root - root node of a manifest in which we search for sheets\n//  @params {Object}        vp   - Viewport as obtained from AecModelData.json file (aecData.viewports)\n//  @returns {av.BubbleNode[]|undefined} BubbleNode of the sheet containing the viewport (if any).\nvar findSheetForViewport = function findSheetForViewport(root, vp) {\n  var sheetNodes = root.search(Autodesk.Viewing.BubbleNode.SHEET_NODE);\n  var linkedByVp = function linkedByVp(node) {return node.guid() === vp.sheetGuid;};\n  return sheetNodes.find(linkedByVp);\n};\n\n// Find all viewports on a given sheet. The sheet can be specified as model or BubbleNode.\n// Note that not all viewports support 2D/3D transform.\n//\n//  @param {av.BubbleNode|av.Model} sheet\nvar findViewportsOnSheet = function findViewportsOnSheet(sheet) {\n\n  // get aecModelData from model or node\n  var isNode = sheet instanceof Autodesk.Viewing.BubbleNode;\n  var sheetNode = isNode ? sheet : sheet.getDocumentNode();\n  var aec = sheetNode.getAecModelData();\n  if (!aec || !aec.viewports) {\n    return [];\n  }\n\n  // Find viewports linking the sheet guid\n  return aec.viewports.filter(function (vp) {return vp.sheetGuid === sheetNode.guid();});\n};\n\n// Given a sheet and a point on that sheet, this function returns the viewport containing it.\n// If multiple viewports overlap, we choose the one where (x,y) is \"most inside\", i.e., \n// where the distance from the viewport edges is largest.\n//\n//  @param {av.Model}         sheet\n//  @param {Vector2}          point            - Point in sheet world-coords.\n//  @param {function(Object)} [viewportFilter] - Option to exclude certain viewports\n//\n//  @returns {Object|undefined} \nvar findViewportAtPoint = function findViewportAtPoint(sheet, point) {var viewportFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n  console.warn('Please use ViewportExtension.findViewportAtPoint instead.');\n\n  // Find sheets linking this sheet\n  var viewports = findViewportsOnSheet(sheet);\n\n  // Apply option filter\n  if (viewportFilter) {\n    viewports = viewports.filter(viewportFilter);\n  }\n\n  // Couple each viewport with viewport bounds \n  viewports = viewports.map(function (vp) {\n    return {\n      viewport: vp,\n      bounds: getViewportBounds(vp, sheet.getUnitScale()) };\n\n  });\n\n  // Reduce to viewports containing the given point\n  var containsPoint = function containsPoint(vp) {\n    return vp.bounds && vp.bounds.containsPoint(point);\n  };\n  viewports = viewports.filter(containsPoint);\n\n  // Point may be outside of all viewports\n  if (!viewports.length) {\n    return;\n  }\n\n  // Viewports may overlap. For this case, we need a heuristic metric\n  // to choose the best match. For this, we use the\n  // distance to the viewport boundary edges.\n  var distanceFromEdge = function distanceFromEdge(box, p) {\n    return Math.min(\n    Math.min(p.x - box.min.x, box.max.x - p.x),\n    Math.min(p.y - box.min.y, box.max.y - p.y));\n\n  };\n\n  // Pick the viewport that minimizes distanceFromEdge\n  var getBestMatch = function getBestMatch(vp1, vp2) {\n    var d1 = distanceFromEdge(vp1.bounds, point);\n    var d2 = distanceFromEdge(vp2.bounds, point);\n    return d2 > d1 ? vp2 : vp1;\n  };\n  return viewports.reduce(getBestMatch).viewport;\n};\n\n// Get guid of the level shown by a viewport (may be null, e.g. for SectionViews)\n//  @param {Object} vp - viewport object from aecModelData\n//  @returns {string|undefined} levelGuid\nvar getLinkedLevel = function getLinkedLevel(vp) {\n\n  // Viewports come directly from aecModelData json and do not always reference a level. \n  // So, we should not crash if anything is null here.\n  var viewRange = vp.extensions && vp.extensions.viewRange;\n  var cutPlane = viewRange && viewRange.cutPlane;\n  return cutPlane && cutPlane.levelGuid;\n};\n\n// Find all viewports in the document that link the level indicated by levelGuid\n//\n// @param {Object} aecData   - as obtained from AECModelData.json\n// @param {string} levelGuid\n// @retuns {Object[]} Array of viewport data objects\nvar findViewportsForLevel = function findViewportsForLevel(aecData, levelGuid) {\n\n  // Find viewports that links this level\n  var viewports = aecData.viewports || [];\n\n  var matchesLevel = function matchesLevel(vp) {\n    var vpLevelGuid = getLinkedLevel(vp);\n    return vpLevelGuid === levelGuid;\n  };\n  return viewports.filter(matchesLevel);\n};\n\n// Find level in aecModelData that links the given viewport.\n//\n// @param {Object} aecData - as obtained from AECModelData.json\n// @param {Object} viewport object\n// @retuns {Object|undefined} level object from aecModelData\nvar findLevelForViewport = function findLevelForViewport(aecData, viewport) {\n  var levelGuid = getLinkedLevel(viewport);\n\n  // Search for a level with this levelGuid\n  var hasLevelGuid = function hasLevelGuid(level) {return level.guid === levelGuid;};\n  return levelGuid && aecData.levels.find(hasLevelGuid);\n};\n\n// Checks if a viewport provides all required information to compute a 2D/3D transform.\n//  @param {Object} vp - vieport data object as obtained from AecModelData.json\nvar supports2DTo3DTransform = function supports2DTo3DTransform(vp) {\n\n  // If AECModelData contains a modelToSheetTransform (only possible for models produced using latest RevitAPI changes), we get a matrix directly\n  // and don't have to care for sectionBox or isCropBoxActive anymore.\n  var canUseTransform = Boolean(vp.modelToSheetTransform);\n\n  // Check if we can use the old code path to reverse-engineer the transform from the SectionBox\n  var canUseWorkaround = Boolean(vp.sectionBox && vp.isCropBoxActive);\n\n  // If neither of the two work, we can stop here.\n  if (!canUseTransform && !canUseWorkaround) {\n    return false;\n  }\n\n  var supportedViewportTypes = [].concat(TopViewViewportTypes, ['Section']);\n\n  return Boolean(supportedViewportTypes.includes(vp.viewType) &&\n  vp.geometryViewportRegion && // We need the viewport outline that corresponds 1:1 with the view sectionBox (excluding labels etc.)\n  !vp.hasBreaks && // A view in Revit may be split into separate parts using \"View breaks\". This is not supported yet.\n  !vp.extensions.hasRegions); // The 2D/3D transform may actually vary within a single view. We currently don't get the required data to support this.\n};\n\nvar AEC_CACHE = {};\n\n// Returns all the fragments that belong to a specific dbId. This only takes the leaf nodes, so we can't\n// just call enumNodeFragments with recurse directly.\nvar getLevelFragmentsIds = function getLevelFragmentsIds(instanceTree, levelDbId) {\n  var leafIds = [];\n  var _collectLeafNodeIds = function _collectLeafNodeIds(id) {\n    var childCount = 0;\n    instanceTree.enumNodeChildren(id, function (childId) {\n      _collectLeafNodeIds(childId);\n      childCount += 1;\n    });\n    if (childCount === 0) {\n      leafIds.push(id);\n    }\n  };\n  _collectLeafNodeIds(levelDbId);\n\n  var fragIds = [];\n  leafIds.forEach(function (leafId) {\n    instanceTree.enumNodeFragments(leafId, function (fragId) {fragIds.push(fragId);});\n  });\n  return fragIds;\n};\n\n// This function holds heuristics around getting bounding boxes for levels:\n// 1. Compute fuzzyBoundingBox to make sure things like pipes coming through multiple floors do not make bounding box too large\n// 2. Given that levels are coming in bottom up order, we check that newly computed bounding box does not intersect with the last known level\n//    and if it does, reduce the largest box among both levels. This step helps when bounding box is large by nature (e.g. due to high walls spreading over multiple levels)\nvar getLevelBoundingBox = function getLevelBoundingBox(dbId, model, lastLevel) {\n  var instanceTree = model.getData().instanceTree;\n  if (!instanceTree) {\n    return;\n  }\n\n  var fragIds = getLevelFragmentsIds(instanceTree, dbId);\n  var newBox = model.getFuzzyBox({ allowlist: fragIds });\n\n  // If there is some levels in the storage already, we need to check for intersection\n  if (lastLevel.min.z !== Infinity && lastLevel.max.z > newBox.min.z) {\n    // there is an intersection and some box need to be cropped\n    var newBoxHeight = Math.abs(newBox.max.z - newBox.min.z);\n    var lastKnownBoxHeight = Math.abs(lastLevel.max.z - lastLevel.min.z);\n    if (lastKnownBoxHeight > newBoxHeight) {\n      lastLevel.max.z = lastLevel.min.z;\n    } else {\n      newBox.min.z = lastLevel.max.z;\n    }\n  }\n  lastLevel.copy(newBox);\n  return newBox;\n};\n\nvar computeLevels = function computeLevels(levels, model) {\n  // Need to get and apply opposite to elevation as it will be reapplied elsewhere\n  var refPointTf = model.myData.placementWithOffset;\n  if (!refPointTf) {\n    refPointTf = new THREE.Matrix4();\n  }\n\n  var lastLevel = new THREE.Box3();\n  levels.forEach(function (level, idx) {\n    var levelBox = getLevelBoundingBox(level.dbId, model, lastLevel);\n    if (levelBox && levelBox.min.z !== Infinity && levelBox.max.z !== Infinity) {\n      level.elevation = levelBox.min.z - (refPointTf ? refPointTf.elements[14] : 0);\n      if (idx === levels.length - 1) {\n        level.height = model.getBoundingBox().max.z - levelBox.min.z;\n      } else {\n        level.height = levelBox.max.z - levelBox.min.z;\n      }\n    }\n  });\n\n  if (levels.some(function (l) {return !l.elevation;})) {\n    console.warn('Failed to derive elevation for some levels');\n    return;\n  }\n\n  var refP = [\n  refPointTf.elements[0], refPointTf.elements[1], refPointTf.elements[2],\n  refPointTf.elements[4], refPointTf.elements[5], refPointTf.elements[6],\n  refPointTf.elements[8], refPointTf.elements[9], refPointTf.elements[10],\n  refPointTf.elements[12], refPointTf.elements[13], refPointTf.elements[14]];\n\n  var aecModelData = {\n    version: '1.0.0', phases: [{ name: 'Default' }], levels: levels, scopeBoxes: [], refPointTransformation: refP };\n\n\n  return aecModelData;\n};\n\n// Couple of queries used here will only work for OTG property database\n// In order to make it work for SVF we need to use other property names, coming from Navisworks (Lc*)\nvar findLevelsOTG = function findLevelsOTG(onDone, onError, model) {\n  model.search(\n  'IFCBUILDING',\n  function (dbIds) {\n    model.getBulkProperties(\n    dbIds, null,\n    function (elements) {\n      if (elements.length !== 1) {\n        // Should find one element (if not, we consider it an edge case --maybe 2 buildings within\n        // single IFC file-- for now and do nothing)\n        return onDone(undefined);\n      }\n      var levelCandidates = elements[0].properties.\n      filter(function (e) {return e.displayName === 'child';}) // get direct children\n      .map(function (e) {return e.displayValue;}); // get dbId of each child\n\n      model.getBulkProperties(\n      levelCandidates, ['Name', 'Type'],\n      function (levelElements) {\n        // Levels are stored in Db as they are presented in IFC -> bottom up order, so we must not mess it up\n        var levels = levelElements.map(function (lev) {\n          var type = lev.properties.find(function (p) {return p.displayName === 'Type';});\n          var name = lev.properties.find(function (p) {return p.displayName === 'Name';});\n          // TODO: this might be localization dependent\n          if (type && type.displayValue.includes('Level') && name) {\n            return {\n              guid: lev.dbId.toString(),\n              name: name.displayValue,\n              // NOTE: elevation and height will be populated later\n              dbId: lev.dbId,\n              extension: {\n                buildingStory: true,\n                structure: false,\n                computationHeight: 0,\n                groundPlane: false,\n                hasAssociatedViewPlans: false } };\n\n\n          }\n        }).filter(Boolean);\n\n        onDone(levels);\n      },\n      onError);\n\n    },\n    onError);\n\n  }, onError, ['Type']);\n\n};\n\nvar findLevelsSVF = function findLevelsSVF(onDone, onError, model) {\n  model.search(\n  'IfcBuildingStorey',\n  function (dbIds) {\n    model.getBulkProperties(\n    dbIds,\n    ['Type', 'GUID', 'NAME', 'Name', 'ELEVATION', 'Elevation', 'IfcElevation'],\n    function (elements) {\n      var levels = [];\n      for (var i = 0; i < elements.length; i++) {\n        if (elements[i].properties.length > 1) {\n          var guidIdx = elements[i].properties.findIndex(function (element) {return element.displayName === 'GUID';});\n          var levelIdx = elements[i].properties.findIndex(function (element) {return element.displayValue === 'Levels: Level: Level 1';});\n          var nameIdx = -1;\n          var elevationIdx = -1;\n          if (levelIdx >= 0) {\n            nameIdx = elements[i].properties.findIndex(function (element) {return (\n                (element.attributeName.toLowerCase() === 'name' ||\n                element.attributeName === 'LcOaNode:LcOaSceneBaseUserName') &&\n                element.displayCategory === 'Item');});\n          } else {\n            nameIdx = elements[i].properties.findIndex(function (element) {return (\n                element.displayName.toLowerCase() === 'name' && (\n                element.displayCategory === 'IFC' ||\n                element.attributeName === 'LcOaNode:LcOaSceneBaseUserName' &&\n                element.displayCategory === 'Item' ||\n                element.attributeName ===\n                'LcRevitData_Element:LcRevitPropertyElementName' &&\n                element.displayCategory === 'Element'));});\n            elevationIdx = elements[i].properties.findIndex(function (element) {return (\n                element.displayName === 'ELEVATION' &&\n                element.displayCategory === 'IFC' ||\n                (element.displayName === 'IfcElevation' ||\n                element.displayName === 'Elevation') &&\n                element.displayCategory === 'Element');});\n          }\n          if (nameIdx >= 0 && (elevationIdx >= 0 || levelIdx >= 0)) {\n            var guid = guidIdx > -1 ? elements[i].properties[guidIdx].displayValue : elements[i].dbId;\n\n            levels.push({\n              guid: guid.toString(),\n              name: elements[i].properties[nameIdx].displayValue,\n              dbId: elements[i].dbId,\n              extension: {\n                buildingStory: true,\n                structure: false,\n                computationHeight: 0,\n                groundPlane: false,\n                hasAssociatedViewPlans: false } });\n\n\n          }\n        }\n      }\n\n      onDone(levels);\n    },\n    onError);\n\n  },\n  onError, ['Type']);\n\n};\n\nvar computeAecModelDataForIfc = function computeAecModelDataForIfc(model) {\n  if (!model) {\n    return null;\n  }\n\n  var cacheKey = model.getModelKey();\n\n  if (AEC_CACHE[cacheKey]) {// We had a heavy computation already, return result from cache\n    return AEC_CACHE[cacheKey];\n  }\n\n  var promise = new Promise(function (resolve) {\n    var onDone = function onDone(levels) {\n      if (!levels || !levels.length) {\n        return resolve(null);\n      }\n\n      var aecModelData = computeLevels(levels, model);\n      if (cacheKey) {\n        AEC_CACHE[cacheKey] = Object.assign({}, aecModelData);\n      }\n      resolve(aecModelData);\n    };\n\n    var onError = function onError(error) {\n      console.error(error);\n      resolve(null);\n    };\n\n    if (model.isOTG()) {\n      findLevelsOTG(onDone, onError, model);\n    } else {\n      findLevelsSVF(onDone, onError, model);\n    }\n  });\n\n  if (cacheKey) {\n    // Cache the promise so if this is called multiple times it won't start the same computation in parallel\n    AEC_CACHE[cacheKey] = promise;\n  }\n\n  return promise;\n};\n\nvar AecModelData = {\n  get2DTo3DMatrix: get2DTo3DMatrix,\n  get3DTo2DMatrix: get3DTo2DMatrix,\n  getViewportBounds: getViewportBounds,\n  remapRectangle: remapRectangle,\n  findSheetForViewport: findSheetForViewport,\n  findViewportsForLevel: findViewportsForLevel,\n  supports2DTo3DTransform: supports2DTo3DTransform,\n  getLinkedLevel: getLinkedLevel,\n  findViewportsOnSheet: findViewportsOnSheet,\n  findViewportAtPoint: findViewportAtPoint,\n  findLevelForViewport: findLevelForViewport,\n  computeAecModelDataForIfc: computeAecModelDataForIfc,\n  TopViewViewportTypes: TopViewViewportTypes };\n\n\nexport default AecModelData;\n\nnamespace.AecModelData = AecModelData;","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nvar av = Autodesk.Viewing;\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar myExtensionName = 'Autodesk.AEC.HyperlinkExtension';\nimport HyperlinkTracker from './HyperlinkTracker';\n\n// Hyperlink extension which will display hyperlinks in 2D sheets to other sheets\n//  @param {Number} options.rootBubbleNode Root bubble node of model\n//  @callback options.loadViewableCb Will be called in case a hyperlink is clicked with bubble node of the sheet and\n//      the total number of hyperlinks present in the sheet\n//  @callback options.hyperlinksAddedCb Will be called each time hyperlinks have been added to a sheet with the id of\n//      the model and the total number of hyperlinks present in the sheet\nvar HyperlinkExtension = /*#__PURE__*/function (_av$Extension) {_inherits(HyperlinkExtension, _av$Extension);var _super = _createSuper(HyperlinkExtension);\n  function HyperlinkExtension(viewer, options) {var _this;_classCallCheck(this, HyperlinkExtension);\n    _this = _super.call(this, viewer, options);\n\n    _this.hyperlinkTracker = new HyperlinkTracker(_this.viewer, _this.options.rootBubbleNode,\n    _this.options.loadViewableCb, _this.options.hyperlinksAddedCb);return _this;\n  }_createClass(HyperlinkExtension, [{ key: \"load\", value: function load()\n\n    {\n      this.viewer.toolController.activateTool('hyperlink-tracker');\n      return true;\n    } }, { key: \"unload\", value: function unload()\n\n    {\n      this.viewer.toolController.deactivateTool('hyperlink-tracker');\n      return true;\n    } }]);return HyperlinkExtension;}(av.Extension);export { HyperlinkExtension as default };\n\n\nnamespace.HyperlinkExtension = HyperlinkExtension;\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, HyperlinkExtension);","\n//A tool that:\n//Implements heuristically derived hyperlinks from text geometries in F2D drawings (and mouse hover support for hyperlinks)\n//Taken from Fluent POC:\n// https://git.autodesk.com/fluent/lmv-ui/blob/master/app/scripts/tools/mouse-tracker.js#L273\n// https://git.autodesk.com/fluent/lmv-ui/blob/master/app/scripts/tools/mouse-tracker.js#L171\n\n\n'use strict';function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function (_e) {function e(_x) {return _e.apply(this, arguments);}e.toString = function () {return _e.toString();};return e;}(function (e) {throw e;}), f: F };}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function (_e2) {function e(_x2) {return _e2.apply(this, arguments);}e.toString = function () {return _e2.toString();};return e;}(function (e) {didErr = true;err = e;}), f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}\n\nvar av = Autodesk.Viewing,\navp = Autodesk.Viewing.Private;\n\nexport default function HyperlinkTracker(viewer, rootBubbleNode, loadViewableCb, hyperlinksAddedCb) {\n  av.ToolInterface.call(this);\n  this.names = ['hyperlink-tracker'];\n  viewer.toolController.registerTool(this);\n\n  var _viewer = viewer;\n  var _loadViewableCb = loadViewableCb;\n  var _hyperlinksAddedCb = hyperlinksAddedCb;\n  var _idRead = [0, 0];\n  var _linkMaps = {};\n  var _dbId = 0;\n  var _lastX, _lastY;\n  var _mouseMoved = false;\n  var _isDragging = false;\n\n  this.update = function () {\n    if (!_isDragging) {\n      if (_mouseMoved) {\n        var vp = _viewer.impl.clientToViewport(_lastX, _lastY);\n        _dbId = _viewer.impl.renderer().idAtPixel(vp.x, vp.y, _idRead);\n        _mouseMoved = false;\n      }\n    } else {\n      _dbId = 0;\n    }\n    return false;\n  };\n\n  function getCurrentModel() {\n    var mq = _viewer.impl.modelQueue();\n    var visibleModels = mq.getModels();\n\n    return visibleModels.length === 1 ? visibleModels[0] : undefined;\n  }\n\n  function getCurrentLinkMap() {\n    var linkMap = _linkMaps[_idRead[1]];\n\n    //Fallback for when a single model is loaded and the Model ID buffer is not working\n    if (!linkMap) {\n      var cm = getCurrentModel();\n      if (cm) {\n        linkMap = _linkMaps[cm.id];\n      }\n    }\n\n    return linkMap;\n  }\n\n  function isLinkMapValid(map) {\n    return map && Object.keys(map).length > 0;\n  }\n\n  this.handleSingleClick = function () {\n    if (!_viewer.model || !_viewer.model.is2d())\n    return;\n\n    var vp = _viewer.impl.clientToViewport(_lastX, _lastY);\n    _dbId = _viewer.impl.renderer().idAtPixel(vp.x, vp.y, _idRead);\n\n    var linkMap = getCurrentLinkMap();\n\n    var linkNode = isLinkMapValid(linkMap) ? linkMap[_dbId] : null;\n\n    if (linkNode) {\n      _loadViewableCb(linkNode, linkMap.numHyperlinks);\n      return true;\n    }\n\n    return false;\n  };\n\n  this.handleButtonDown = function (event) {\n    _isDragging = true;\n    _lastX = event.canvasX;\n    _lastY = event.canvasY;\n    return false;\n  };\n\n  this.handleButtonUp = function () {\n    _isDragging = false;\n    return false;\n  };\n\n  this.handleMouseMove = function (event) {\n    _lastX = event.canvasX;\n    _lastY = event.canvasY;\n    _mouseMoved = true;\n    return false;\n  };\n\n  function addRenderBox(vbb, f2d, stringIndex, modelScale) {\n    var i4 = 4 * stringIndex;\n\n    var miny = f2d.stringBoxes[i4 + 1];\n    var maxy = f2d.stringBoxes[i4 + 3];\n    var border = (maxy - miny) * 0.2;\n    miny = miny - border;\n    maxy = maxy + border;\n    var minx = f2d.stringBoxes[i4] - border;\n    var maxx = f2d.stringBoxes[i4 + 2] + border;\n\n    var dbId = f2d.stringDbIds[stringIndex];\n    var vbase = vbb.vcount;\n\n    var linkFillColor = 0x77bfbb3f;\n    vbb.addVertexPolytriangle(minx, miny, linkFillColor, dbId, 0, 0);\n    vbb.addVertexPolytriangle(maxx, miny, linkFillColor, dbId, 0, 0);\n    vbb.addVertexPolytriangle(maxx, maxy, linkFillColor, dbId, 0, 0);\n    vbb.addVertexPolytriangle(minx, maxy, linkFillColor, dbId, 0, 0);\n\n    vbb.addIndices([0, 1, 2, 0, 2, 3], vbase);\n\n    vbb.addSegment(minx, miny, maxx, miny, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);\n    vbb.addSegment(maxx, miny, maxx, maxy, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);\n    vbb.addSegment(maxx, maxy, minx, maxy, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);\n    vbb.addSegment(minx, maxy, minx, miny, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);\n  }\n\n  function addLinkBoxMesh(model, vbb) {\n    var fragId = model.getFragmentList().vizmeshes.length;\n    var mdata = { mesh: vbb.toMesh(), is2d: true, packId: '0', meshIndex: fragId };\n    avp.BufferGeometryUtils.meshToGeometry(mdata);\n\n    var matman = _viewer.impl.matman();\n    var materialId = matman.create2DMaterial(model, {});\n    var m = _viewer.impl.setupMesh(model, mdata.geometry, materialId, model.getData().loadOptions.placementTransform);\n    model.activateFragment(fragId, m);\n    return fragId;\n  }\n\n  function removeLinkBoxMesh(model, fragId) {\n    // get link box mesh\n    var fragList = model.getFragmentList();\n    var mesh = fragList.vizmeshes[fragId];\n\n    // Dispose geometry. MaterialManager will take care of the material dispose on model unload. \n    // We don't dispose material here because it may be shared with other fragments of the model.\n    mesh.geometry.dispose();\n\n    delete fragList.vizmeshes[fragId];\n  }\n\n  function initializeHyperlinks(model) {\n    if (!model || !model.is2d()) {\n      return;\n    }\n\n    // Check if this model has been initialized already\n    var linkMap = _linkMaps[model.id];\n    if (linkMap) {\n      return;\n    }\n\n    // find all sheets of the same document\n    var node = model.getDocumentNode();\n    var root = node && node.getRootNode();\n    var sheets = root && root.search({ role: '2d', type: 'geometry' });\n    if (!sheets || !sheets.length) {\n      return;\n    }\n\n    linkMap = _linkMaps[model.id] = {};\n\n    var currentSheetBasePath = '';\n    if (model.myData) {\n      currentSheetBasePath = model.myData.basePath;\n    }\n\n    var getSheetUrn = function getSheetUrn(sheet) {\n      var resourceType = 'resource';\n      if (sheet.children) {var _iterator = _createForOfIteratorHelper(\n        sheet.children),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var child = _step.value;\n            if (child.type() === resourceType) {\n              var urn = child.urn();\n              if (urn) {\n                // We remove the primaryGraphics.f2d part from the urn\n                var elements = urn.split('/');\n                elements.pop();\n                return elements.join('/');\n              }\n            }\n          }} catch (err) {_iterator.e(err);} finally {_iterator.f();}\n      }\n      return null;\n    };\n\n    var sheetIds = sheets.map(function (s) {\n      var sheetUrn = getSheetUrn(s);\n      //exclude current sheet, i. e. no links to self\n      if (currentSheetBasePath.indexOf(sheetUrn) === -1) {\n        var split = s.name().split(' ');\n        var sheetName = split[0];\n        if (sheetName.length > 2) {\n          return sheetName;\n        }\n      }\n      return '';\n    });\n\n    //while finding hyperlink strings, we will also\n    //create a geometry buffer containing all their bboxes\n    //so we can render with their IDs.\n    linkMap.numHyperlinks = 0;\n    var vbb = new avp.VertexBufferBuilder();\n    var modelScale = 1.0 / (model.getData().loadOptions.modelScale || 1);\n    var f2d = model.getData();\n    for (var i = 0; i < f2d.strings.length; i++) {\n\n      var idx = sheetIds.indexOf(f2d.strings[i]);\n\n      if (idx >= 0) {\n        linkMap[f2d.stringDbIds[i]] = sheets[idx];\n\n        addRenderBox(vbb, f2d, i, modelScale);\n        linkMap.numHyperlinks++;\n      }\n    }\n\n    linkMap.boxFragId = addLinkBoxMesh(model, vbb);\n\n    if (_hyperlinksAddedCb) {\n      _hyperlinksAddedCb(e.model.id, linkMap.numHyperlinks);\n    }\n  }\n\n  function onGeomLoaded(e) {\n    initializeHyperlinks(e.model);\n  }\n\n  // Execute cb for all sheets that are (completely) in memory\n  function forAllSheetsInMemory(cb) {\n    var allModels = _viewer.getAllModels();\n    for (var i = 0; i < allModels.length; i++) {\n      var model = allModels[i];\n      if (model.is2d() && model.isLoadDone()) {\n        cb(model);\n      }\n    }\n  }\n\n  function removeHyperlinks() {\n\n    // Keep _linkMaps consistent with models: We don't want to leak dead box meshes in the models.\n    // Therefore, we remove them from all models in memory\n    forAllSheetsInMemory(function (model) {\n      var linkMap = _linkMaps[model.id];\n      if (linkMap) {\n        removeLinkBoxMesh(model, linkMap.boxFragId);\n      }\n    });\n\n    _linkMaps = {};\n\n    // make sure that removed hyperlink quads are not visible anymore\n    _viewer.impl.invalidate(true, true);\n  }\n\n  this.activate = function () {\n\n    // Make sure that we don't forget to init hyperlinks if the geom-load event has already happened\n    forAllSheetsInMemory(function (model) {\n      initializeHyperlinks(model);\n    });\n\n    _viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, onGeomLoaded);\n\n    // make sure that added hyperlink quads appear instantly\n    _viewer.impl.invalidate(true, true);\n  };\n\n  this.deactivate = function () {\n    _viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, onGeomLoaded);\n    removeHyperlinks();\n  };\n\n  // Show a hand cursor, if the cursor is close to a hyperlink\n  this.getCursor = function () {\n    var linkMap = getCurrentLinkMap();\n\n    if (_dbId < -1 && isLinkMapValid(linkMap) && linkMap[_dbId]) {\n      return 'pointer';\n    }\n\n    return null;\n  };\n}\n\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nnamespace.HyperlinkTracker = HyperlinkTracker;","'use strict';function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\n\nvar av = Autodesk.Viewing;\nvar avp = Autodesk.Viewing.Private;\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nimport FloorSelectorFilter from './FloorSelectorFilter.js';\n\n// FloorSelector provides graphics effects to be used by UI for floor selection.\n//\n// This includes:\n//\n//  - Setting cutplanes accordingly when a floor is selected.\n//\n//  - Animated transitions if the selected floor changes.\n//\n//  - Applying mouse-over highlighting of floors - to be used when hovering over a floor button\n//\n//  - \"Ghost-Floors\": By default, we render selected floors only. If the mouse enters the floor panel, we\n//     also fade-in the other floors, but with strongly reduced opacity. (+ fade-out on mouse leave)\n//\n//\n// How to use it:\n//\n//  1. Create a FloorSelector by passing the viewer to the ctor.\n//\n//  2. Before using the FloorSelector, you have to provide floor data that you get from the Revit metadata\n//     json file. (see setFloorData comment)\n//\n//  3. Connect events for hovering over floor selector UI panel:\n//     - Connect mouseover  to floorSelector.enterHoverMode()\n//     - Connect mouseleave to floorSelector.existHoverMode()\n//\n//  4. Connect events for hovering over floor selection buttons: For each floor button...\n//     - Connect mouseover  to floorSelector.rollOverFloor(floorIndex) - floorIndex must be the index into the floor array (see setFloorData)\n//     - Connect mouseleave to floorSelector.rollOverFloor()\n//\n//  5. Connect floor selection button: For each floor button,\n//     connect button mousedown to floorSelector.selectFloor(floorIndex, true)\n//\n//  6. If the set of visible models has changed\n//\n//  7. When discarding the FloorSelector (while keeping the Viewer alive), call FloorSelector dtor.\n//\n// How to enable the optional filtering of objects by dbIds per model provided by the AECModelData.json on level selection?\n//\n//  1. You have to provide floor filter data containing a Map of dbIds per model. The key has to be the model version URN (see setFloorFilterData).\n//\n//     Example on how to set the floor filter data:\n//\n//     const modelsDbIds = new Map();\n//     modelsDbIds.set(model, [1, 2, 3, 4]);\n//     var floorFilterData = {\n//         modelsDbIds: modelsDbIds\n//     };\n//\n//     floorSelector.setFloorFilterData(floorFilterData);\n//\n// How to control the calculated lower level boundary value by defining the levelHeightFactor factor? The factor is multiplied with the level height\n// and added to the level minZ value. This newly calculated minZ value defines the lower level boundary used to filter the Floor and Ceiling elements.\n//\n//     Example on how to set the floor filter data with a levelHeightFactor:\n//\n//     const modelsDbIds = new Map();\n//     modelsDbIds.set(model, [1, 2, 3, 4]);\n//     var floorFilterData = {\n//         modelsDbIds: modelsDbIds,\n//         levelHeightFactor: 0.6 // Allowed values have to be within 0-1.\n//     };\n//\n//     floorSelector.setFloorFilterData(floorFilterData);\n//\n// Technical requirements/restrictions to be aware of:\n//\n//  - Cross-Fading Support: FloorSelector uses LMV render target fading for some effects. For this, it activates\n//    cross-fading support in LMV (if not active already). This requires 2 extra color targets, i.e.\n//    consumes some additional GPU-side memory.\n//\n//  - Camera Movement: The camera should not be moving while using the floor selector.\n//    This is because we partially use static images for the fading effects.\n//    If the user moves the camera, we instantly switch off the ghost floors.\n//\n//  - SAO opacity: FloorSelector needs to temporarily hide SAO. For this, we have to overwrite SAO opacity\n//    and recover it later. This requires that the SAO opacity is not changed in the meantime\n//    while using the FloorSelector. Otherwise, it will cause a warning and may cause visual\n//    artifacts.\n\n\n\n// Time in seconds to fade in/out ghosted floors when hovering over the floor selector panel\nvar GhostFloorFadingTime = 0.5;\n\n// Opacity for ghost floors when fade-in is finished.\nvar MaxGhostFloorOpacity = 0.2;\n\n// These should actually be infinity and -infinity, but since the values are passed to a shader,\n// we have to use large finite values instead. Setting as cutplane elevations actually corresponds to\n// switching cutplanes off. But, changes the number of cutplanes triggers expesnive shader recompiles.\nvar MaxZLimit = 1e20;\nvar MinZLimit = -MaxZLimit;\n\n// Internally used enum values for state management\nvar FloorRenderMode = {\n\n  // mouse is hovering over a floor button\n  Hovering: 0,\n\n  // new floor has been selected and anim is running\n  Transition: 1,\n\n  // default rendering\n  Off: 2 };\n\n\n// Reserved floor-index constant to select all floors at once.\nvar AllFloors = -1;\nvar NoFloor = undefined;\n\n// Used for setCutPlane calls to lmv. This ensures that FloorSelector controls its own cutplanes,\n// which is independent of other cutplane changes like from SectionTool.\nvar CutPlaneSetName = 'Autodesk.AEC.FloorSelector';var\n\nFloorSelector = /*#__PURE__*/function () {\n\n  // @param {Viewer3D} viewer\n  function FloorSelector(viewer) {_classCallCheck(this, FloorSelector);\n\n    av.EventDispatcher.prototype.apply(this);\n\n    this._viewer = viewer;\n    this._renderer = viewer.impl.renderer();\n\n    // Make sure that ghost-floors are switched off as soon as the user starts navigating.\n    // This is needed because the selected floor is just a static image when ghost-floors are shown.\n    this._cameraMovedCB = this._interruptFading.bind(this);\n    viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this._cameraMovedCB);\n\n    // Stop panel-hover effect on viewer-resize: Ghost-floors use a static image overlay that becomes unusable\n    // if the target size changes.\n    this._viewerResizeCB = this._onViewerResized.bind(this);\n    viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this._viewerResizeCB);\n\n    // If SAO is switched off, we have to switch off roll-over highlighting too.\n    this._renderOptionsChangedCB = this._onRenderOptionsChanged.bind(this);\n    viewer.addEventListener(av.RENDER_OPTION_CHANGED_EVENT, this._renderOptionsChangedCB);\n\n    // callback for the floor selection filtering\n    this._floorSelectionFilterToBeUpdated = this._runFloorSelectorFilterEventHandler.bind(this);\n    viewer.addEventListener(av.MODEL_ADDED_EVENT, this._floorSelectionFilterToBeUpdated);\n    viewer.addEventListener(av.OBJECT_TREE_CREATED_EVENT, this._floorSelectionFilterToBeUpdated);\n\n    // callback for the unloading of disabled models\n    this._modelUnloadingCB = this._runModelUnloadingEventHandler.bind(this);\n    viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this._modelUnloadingCB);\n\n    // {Object[]} Contains the floor data. see setFloorData() comment.\n    this._floors = [];\n\n    // current state (hover/transition/off)\n    this._currentMode = FloorRenderMode.Off;\n    this._hovering = false; // used to track hovering state while in transition mode\n\n    // current floor section (if cutplanes are active)\n    this._floorSectionMin = undefined;\n    this._floorSectionMax = undefined;\n\n    // Determine z-range for \"all-floors\"\n    // We determine that dynamically from the currently visible models.\n    // Note that we need this value also for cutplane transitions - so we cannot\n    // simply choose something arbitrarily far outside.\n    this._zMinAllModels = undefined;\n    this._zMaxAllModels = undefined;\n\n    // {AnimControl} Needed to interrupt a running cutplane animation (see moveFloors)\n    this._floorAnim = null;\n\n    // {AnimControl} Needed to interrupt a runnign fade-in/out anim for ghost-floors\n    this._fadeAnim = null;\n\n    // Opacity of the render target that shows floors that are currently not selected (\"ghost floors\")\n    // Always 0.0 if the extra target for ghost floors is not used.\n    this._ghostFloorOpacity = 0.0;\n\n    // {number|undefined} index of selected floor (or undefined if no floor is selected)\n    this._currentFloor = undefined;\n\n    // We render ghost-floors without AO, because AO cannot be smoothly faded out with them.\n    // To activate AO, we need to 'backup' the current AO opacity and recover it later.\n    this._aoVisible = true;\n    this._aoOpacity = undefined; // if ao is blocked, we store the original ao opacity here to recover it later.\n\n    this._floorSelectorFilter = new FloorSelectorFilter(this._viewer);\n    this._floorFilterData = undefined;\n\n    // Indicates if we are currently using mouse-over highlighting for a floor.\n    this._floorRollOverActive = false;\n\n    // Whether to use the ghosting effect\n    this._fadeEnabled = true;\n\n    // If disabled, make sure that cutplanes keep unset. This is needed to avoid side-effects on 2D views.\n    this.enabled = true;\n\n    // Maximum time in ms that we allow for rendering offline images for fading effects.\n    // By default (undefined), we use the frameBudget of regular rendering.\n    this.offscreenRenderBudget = undefined;\n\n    this.fadingTime = GhostFloorFadingTime;\n  }_createClass(FloorSelector, [{ key: \"dtor\", value: function dtor()\n\n    {\n      if (this._viewer) {\n        this._viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this._cameraMovedCB);\n        this._viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this._viewerResizeCB);\n        this._viewer.removeEventListener(av.RENDER_OPTION_CHANGED_EVENT, this._renderOptionsChangedCB);\n        this._viewer.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, this._floorSelectionFilterToBeUpdated);\n        this._viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._floorSelectionFilterToBeUpdated);\n        this._viewer.removeEventListener(av.MODEL_UNLOADED_EVENT, this._modelUnloadingCB);\n        this._viewer = null;\n      }\n    }\n\n    // -----------------\n    // --- Main API ----\n    // -----------------\n\n    // Before selecting any floors, setFloorData() must be called to provide the elevation ranges\n    // of all available floors.\n    //  @param {Object[]} floors - data about available floors, each item f must contain two finite floats f.zMin < f.zMax\n  }, { key: \"resetState\",\n\n\n\n\n\n\n\n\n\n\n\n    // sets back level isolation, selection filter and the floors.\n    value: function resetState() {\n      // we have to clear the settings\n      this._floors = [];\n      this._selectFloor(NoFloor);\n      this._clearFloorSection();\n      this._floorSelectorFilter.clearFilter();\n    }\n\n    // Before any objects can be filtered using the FloorSelectorFilter, setFloorFilterData() must be called to\n    // provide the array of Floor and Ceiling dbIds per model.\n    //  @param {Object[]} floorFilterData - A floor filter data object containing an array of dbIds per model.\n  }, { key: \"enterHoverMode\",\n\n\n\n\n\n\n\n    // Fades in the ghost-floors.\n    // Triggered when floor selection begins, i.e., mouse is entering floor selector panel.\n    value: function enterHoverMode() {\n\n      // make sure that the ghosted floors are in a static image,\n      // so that we can move the solid floor\n      if (this._currentMode !== FloorRenderMode.Transition) {\n        this._setMode(FloorRenderMode.Hovering);\n      }\n\n      // track hovering state - so that we can recover it after transitions\n      this._hovering = true;\n    }\n\n    // Fades out the ghost floors.\n    // Triggered when floor selection ends, i.e., mouse is leaving the floor selector panel.\n    // @param {boolean} [force] - will exit ghosting immediately even if during transition\n  }, { key: \"exitHoverMode\", value: function exitHoverMode(force) {\n\n      // If a floor-transition is running, we only track the hover state and\n      // set the mode when the transition has finished.\n      if (this._currentMode !== FloorRenderMode.Transition || force) {\n        this._setMode(FloorRenderMode.Off);\n      }\n      this._hovering = false;\n\n      // make sure that no spatial filter for mouse-over highlight is set anymore, so that we don't\n      // have side-effects on subsequent object selection.\n      this._setSpatialFilterForRollOver();\n    } }, { key: \"setPanelHoverEffectEnabled\", value: function setPanelHoverEffectEnabled(\n\n    enabled) {\n      this.exitHoverMode(true);\n      this._skipFadeAnimations();\n      this._fadeEnabled = enabled;\n    } }, { key: \"_getFadeExtension\", value: function _getFadeExtension()\n\n    {\n      return this._fadeEnabled && this._viewer.getExtension('Autodesk.CrossFadeEffects');\n    }\n\n    // Ghosted display of inactive floors on panel hover is only supported if CrossFadeEffects extension is loaded\n  }, { key: \"_ghostFloorsEnabled\", value: function _ghostFloorsEnabled() {\n      return Boolean(this._getFadeExtension());\n    }\n\n    // Select for which floor rollOver highlighting is shown.\n    //   @param {number} [floorIndex] must be either\n    //                                a) a valid index into this.floors\n    //                                b) a reserved constant (FloorSelector.AllFloors or FloorSelector.NoFloor)\n  }, { key: \"rollOverFloor\", value: function rollOverFloor(floorIndex) {\n\n      // If we don't show ghost-floors, roll-over highlighting does not make much sense if only 1 floor is visible anyway.\n      // It just looks confusing, because occasionally it would only be visible for the selected floor and some parts of others\n      // that overlap the z-range a bit.\n      var enabled = this._ghostFloorsEnabled() || this._currentFloor === NoFloor;\n\n      // rollOver highlight is only possible if SAO is enabled and supported.\n      var supported = this._renderer.spatialFilterForRollOverSupported();\n      if (floorIndex === undefined || !supported || !enabled) {\n\n        // switch off floor highlight\n        this._setSpatialFilterForRollOver();\n        this._renderer.rolloverObjectId(0);\n        return;\n      }\n\n      // Activate roll-over highlighting for all objects\n      this._renderer.rolloverObjectId(1);\n\n      // restrict highlighting to floor range unless all floors are selected.\n      this._setSpatialFilterForRollOver(floorIndex);\n\n      // TODO: Clarify why this call is needed. It should actually not required to re-render here.\n      this._viewer.impl.invalidate(false, true, true);\n    }\n\n    // Sets the currently visible floor.\n    //  @param {number}   [floorIndex]    A valid index into the floor data array (see setFloors) selects a single floor.\n    //                                    FloorSelector.NoFloor discards the floor selection => all floors visible.\n    //  @param {bool}     [useTransition] If true, a short animation is used to morph between previous and new floor\n    //  returns false in case no selection cannot be performed\n  }, { key: \"selectFloor\", value: function selectFloor(floorIndex, useTransition) {\n\n      if (!this.floorSelectionValid(floorIndex)) {\n        return;\n      }\n\n      if (useTransition) {\n        this._moveToFloor(floorIndex);\n      } else {\n        this._selectFloor(floorIndex);\n      }\n\n      this._runFloorSelectorFilter();\n\n      // If no ghosting is used, we disable rollOver highlighting if only a single floor is visible.\n      if (!this._ghostFloorsEnabled()) {\n        this.rollOverFloor();\n      }\n\n      this.fireEvent({ type: FloorSelector.SELECTED_FLOOR_CHANGED, levelIndex: floorIndex });\n    }\n\n    // Gets the index of the current selected floor or FloorSelector.NoFloor\n  }, { key: \"floorSelectionValid\",\n\n\n\n    // Returns whether a floorSelection can be performed with the specified floor\n    // checks for valid value, whether floorData is available, the floor is already selected\n    // and whether the floor is within the expected range.\n    value: function floorSelectionValid() {var newFloor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NoFloor;\n      // force boolean\n      return !!((Number.isInteger(newFloor) || newFloor === NoFloor) && // not a valid value\n      this.floorData && this.floorData.length !== 0 // has no floor data\n      && this.currentFloor !== newFloor // newFloor floor is not selected\n      && (newFloor === NoFloor ||\n      newFloor >= 0 || this.floorData.length > newFloor)); // new floor is in range;\n    }\n\n    // returns true if a dbId is either hidden by FloorSelectorFilter or fully outside the cutplanes\n  }, { key: \"isVisible\", value: function isVisible(model, dbId) {\n\n      // reused tmp variable\n      if (!this._tmpNodeBox) {\n        this._tmpNodeBox = new Float32Array(6);\n      }\n\n      // Determine zMin/zMax to ceck against. We could use _floorSectionMin/Max. But this would\n      // make this function depending on current animation state. Since we don't want to do permanent\n      // filter-updates during animations, we use currentFloor instead, which represents the target state - independent of animations.\n      var floor = this._floors[this._currentFloor];\n      if (floor === NoFloor) {\n        // No floor selected => Nothing hidden\n        return true;\n      }\n\n      var instanceTree = model.getInstanceTree();\n      if (!instanceTree) {\n        // If there is not instance tree, FloorSelectorFilter would have warned already if a floor was selected.\n        return true;\n      }\n\n      // get zMin/zMax for this node\n      var nodeBox = this._tmpNodeBox;\n      instanceTree.getNodeBox(dbId, nodeBox);\n      var nodeBoxZMin = nodeBox[2];\n      var nodeBoxZMax = nodeBox[5];\n\n      // Node is hidden if...\n      //  a) outside the level's cutplanes, or\n      //  b) hidden by levels filter\n      var outsideCutplane = nodeBoxZMin > floor.zMax || nodeBoxZMax < floor.zMin;\n      return !outsideCutplane && this._floorSelectorFilter.isVisible(model, dbId);\n    } }, { key: \"setEnabled\", value: function setEnabled(\n\n    enabled) {\n      this.enabled = enabled;\n      this._applySelectedFloorSection();\n    }\n\n    // ------------------------\n    // --- Internal methods ---\n    // ------------------------\n  }, { key: \"_stopFloorAnim\", value: function _stopFloorAnim()\n    {\n      if (this._floorAnim) {\n        this._floorAnim.stop();\n        this._floorAnim = null;\n      }\n    } }, { key: \"_stopFadeAnim\", value: function _stopFadeAnim()\n\n    {\n      if (this._fadeAnim) {\n        this._fadeAnim.stop();\n        this._fadeAnim = null;\n      }\n    } }, { key: \"_skipFadeAnimations\", value: function _skipFadeAnimations()\n\n    {\n      if (this._fadeAnim) {\n        this._fadeAnim.skip();\n        this._fadeAnim = null;\n      }\n\n      if (this._floorAnim) {\n        this._floorAnim.skip();\n        this._floorAnim = null;\n      }\n    } }, { key: \"_leaveHoverMode\", value: function _leaveHoverMode()\n\n    {\n\n      var fadeExt = this._getFadeExtension();\n      if (!fadeExt) {\n        // Nothing todo if ghosting effect is not used.\n        return;\n      }\n\n      // release any baked images\n      fadeExt.releaseFadingImage(0);\n      fadeExt.releaseFadingImage(1);\n\n      // make sure that model is rendered into default color target\n      fadeExt.setModelTargetIndexForAll(undefined);\n\n      // apply cutplanes according to currently selected floor\n      this._applySelectedFloorSection();\n\n      // we are now rendering real floors again,\n      // so that we can switch SAO on again.\n      this._setAOVisible(true);\n    }\n\n    // When rendering ghost-floors, the static part is always a static image.\n    // Therefore, we have to skip the fading if the user moves the camera.\n  }, { key: \"_interruptFading\", value: function _interruptFading() {\n\n      // If we just left hover-mode, but the floors did not finish to fade out yet,\n      // stop the anim and finish it immediately.\n      if (!this._hovering && this._fadeAnim && this._fadeAnim.isRunning) {\n        this._stopFadeAnim();\n        this._leaveHoverMode();\n      }\n    } }, { key: \"_onViewerResized\", value: function _onViewerResized()\n\n    {\n      this.forceImageRefresh();\n    } }, { key: \"forceImageRefresh\", value: function forceImageRefresh()\n\n    {\n      // Stop any image-based hovering effects immediately, because the baked ghost-floor image has incorrect size now.\n      var isHovering = this._hovering;\n\n      this.exitHoverMode();\n      this._skipFadeAnimations();\n\n      // Restart hovering effect if mouse is still on the panel. Now using the new render target size.\n      if (isHovering) {\n        this.enterHoverMode();\n        this._skipFadeAnimations();\n      }\n    } }, { key: \"_onRenderOptionsChanged\", value: function _onRenderOptionsChanged()\n\n    {\n      // Make sure that we stop using roll-over-floor highlight if the depth\n      // target is not available anymore.\n      if (this._floorRollOverActive && !this._renderer.spatialFilterForRollOverSupported()) {\n        this.rollOverFloor();\n      }\n    }\n\n    // Get array of all visible models\n  }, { key: \"_getVisibleModels\", value: function _getVisibleModels() {\n      var mq = this._viewer.impl.modelQueue();\n      return mq.getModels();\n    }\n\n    // Updates min/max limits for cutplane z-level, based on the bboxes of all visible models\n  }, { key: \"_updateZLimits\", value: function _updateZLimits() {\n      var models = this._getVisibleModels();\n\n      this._zMinAllModels = MaxZLimit;\n      this._zMaxAllModels = MinZLimit;\n      for (var i = 0; i < models.length; i++) {\n        var model = models[i];\n        var box = model.getBoundingBox();\n\n        this._zMinAllModels = Math.min(box.min.z, this._zMinAllModels);\n        this._zMaxAllModels = Math.max(box.max.z, this._zMaxAllModels);\n      }\n\n      // make sure the range is valid also when no models are available\n      if (this._zMinAllModels > this._zMaxAllModels) {\n        this._zMinAllModels = MinZLimit;\n        this._zMaxAllModels = MaxZLimit;\n      }\n    } }, { key: \"_setAOVisible\", value: function _setAOVisible(\n\n    visible) {\n      if (visible === this._aoVisible) {\n        return;\n      }\n      this._aoVisible = visible;\n\n      var blendPass = this._renderer.getBlendPass();\n\n      var newOpacity = 0.0;\n      if (!visible) {\n        // ao switched off => backup original ao opacity\n        this._aoOpacity = blendPass.uniforms['aoOpacity'].value;\n      } else {\n\n        // Opacity should be 0. Any other value indicates that it has been changed from\n        // outside while ao was hidden by floor selector.\n        var curOpacity = blendPass.uniforms['aoOpacity'].value;\n        if (curOpacity !== 0.0) {\n          console.warn('ao opacity should not be changed while FloorSelector is in use.');\n        }\n\n        // ao switched on => recover original ao opacity\n        newOpacity = this._aoOpacity;\n      }\n\n      this._renderer.setAOOptions(this._renderer.getAORadius(), this._renderer.getAOIntensity(), newOpacity);\n    }\n\n    // @param {number} val - float in [0,1]\n  }, { key: \"_setGhostFloorOpactiy\", value: function _setGhostFloorOpactiy(val) {\n\n      // ghost-floors are always rendered into extra target 1\n      var fadeExt = this._getFadeExtension();\n      fadeExt && fadeExt.setCrossFadeOpacity(1, val);\n\n      this._ghostFloorOpacity = val;\n\n    }\n\n    // Apply/Remove spatial filter that restricts rollOver highlighting to a single floor\n    //  @param {number} If floorIndex is a valid index into this.floors, highlighting is restricted to that floor.\n    //                  Otherwise, the spatial filter is switched off.\n  }, { key: \"_setSpatialFilterForRollOver\", value: function _setSpatialFilterForRollOver(floorIndex) {\n\n      var filter = undefined;\n      var floor = this._floors[floorIndex];\n\n      var createSpatialFilter = function createSpatialFilter(zMin, zMax) {\n        // Define filter to restrict rollOver highlighting to floor elevation range\n        return 'bool spatialFilter(vec3 worldPos) { return (worldPos.z >= float(' + zMin + ') && worldPos.z <= float(' + zMax + ')); }';\n      };\n\n      if (floor) {\n        filter = createSpatialFilter(floor.zMin, floor.zMax);\n      } else if (floorIndex === FloorSelector.AllFloors) {\n        filter = createSpatialFilter(this._zMinAllModels, this._zMaxAllModels);\n      }\n\n      this._renderer.setSpatialFilterForRollOver(filter);\n\n      // If spatial filter is defined, make sure that ghost floors are always rendered to depth target.\n      // Otherwise, the spatial filter for roll-over highlighting does not work.\n      var fadeExt = this._getFadeExtension();\n      fadeExt && fadeExt.crossFade.setSaoHeuristicEnabled(!filter);\n\n      this._floorRollOverActive = !!filter;\n    } }, { key: \"_applyFloorSection\", value: function _applyFloorSection(\n\n    zMin, zMax) {\n\n      // Do not allow any cutplane when disabled\n      if (!this.enabled) {\n        this._viewer.impl.setCutPlaneSet(CutPlaneSetName, null);\n        return;\n      }\n\n      // reset the defined z values to the minimum in case the value is not specified\n      if (!Number.isFinite(zMin)) {\n        zMin = MinZLimit;\n      }\n      if (!Number.isFinite(zMax)) {\n        zMax = MaxZLimit;\n      }\n\n\n      var planes = [new THREE.Vector4(0, 0, -1, zMin), new THREE.Vector4(0, 0, 1, -zMax)];\n      this._viewer.impl.setCutPlaneSet(CutPlaneSetName, planes);\n    }\n\n    // Set cut plane according to currently selected floor\n  }, { key: \"_applySelectedFloorSection\", value: function _applySelectedFloorSection() {\n\n      // If no floor section is active, set cutplanes to maximum range.\n      // Doing this instead of clearing them avoids the repeated shader recompile\n      var zMin = this._floorSectionMin !== undefined ? this._floorSectionMin : MinZLimit;\n      var zMax = this._floorSectionMax !== undefined ? this._floorSectionMax : MaxZLimit;\n      this._applyFloorSection(zMin, zMax);\n    } }, { key: \"_setFloorSection\", value: function _setFloorSection(\n\n    minElev, maxElev) {\n      this._floorSectionMin = isNaN(minElev) ? undefined : minElev;\n      this._floorSectionMax = isNaN(maxElev) ? undefined : maxElev;\n      this._applySelectedFloorSection();\n    }\n\n    // Temporarily disable floor section cut planes. This is needed to render ghost floors.\n  }, { key: \"_clearFloorSection\", value: function _clearFloorSection() {\n      // Changing the number of cutplanes would cause a shader recompile.\n      // To avoid that, we set dummy cutplanes instead.\n      this._updateZLimits();\n      this._applyFloorSection();\n    } }, { key: \"_setMode\", value: function _setMode(\n\n    mode) {var _this = this;\n\n      if (mode === this._currentMode) {\n        return;\n      }\n      this._currentMode = mode;\n\n      if (mode === FloorRenderMode.Hovering) {\n\n        var fadeExt = this._getFadeExtension();\n        if (fadeExt) {\n\n          // Take control over CrossFade effect.\n          // NOTE: As long as the mouse is hovering over the LevelsPanel, we assume that no one else overtakes the crossFade effect. If the mouse leaves the LevelsPanel\n          //       the ghost-floors a fading out. If the fading is needed for something else at that time, we skip the fading and drop the ghost floors immediately.\n          fadeExt.acquireControl('FloorSelector', function () {return _this._interruptFading();});\n\n          // Render snapshot of selected floors into target 0\n          fadeExt.setModelTargetIndexForAll(undefined); // render to main target\n          this._applySelectedFloorSection(); // set cutplanes according to selected floor\n          this._renderer.rolloverObjectId(0); // keep mouse-over highlighting out of the snapshot\n          this._setAOVisible(true); // Make sure that the selected floors are rendered with AO\n          fadeExt.renderFadingImage(0, this.offscreenRenderBudget); // render static snapshot of selected floors into extra target 0\n\n          // show this snapshot at full opacity\n          fadeExt.setCrossFadeOpacity(0, 1.0);\n\n          // Render remaining floors...\n          this._clearFloorSection();\n\n          // ..into target 1\n          fadeExt.setModelTargetIndexForAll(1);\n\n          // before starting to fade-in the ghost-floors,\n          // hide SAO. Otherwise, SAO of the ghost\n          // floors would pop in at fade start.\n          this._setAOVisible(false);\n\n          // stop any prior fade-anim\n          this._stopFadeAnim();\n\n          // fade-in ghost floors (starting at the prior opacity)\n          var onTimer = this._setGhostFloorOpactiy.bind(this);\n          this._fadeAnim = avp.fadeValue(this._ghostFloorOpacity, MaxGhostFloorOpacity, this.fadingTime, onTimer);\n        }\n      } else if (mode === FloorRenderMode.Transition) {\n\n        // protect ghost floors from clear\n        var _fadeExt = this._getFadeExtension();\n        if (_fadeExt) {\n          _fadeExt.setClearEnabled(1, false);\n\n          // render into target 0 again\n          _fadeExt.setClearEnabled(0, true);\n          _fadeExt.setModelTargetIndexForAll(0);\n\n          // make sure that target 0 has full opacity to make sure that floor keeps visible after moving to target 0\n          _fadeExt.setCrossFadeOpacity(0, 1.0);\n        }\n\n        // reactivate AO\n        this._setAOVisible(true);\n\n        // Render selected/moving floor...\n        this._applySelectedFloorSection();\n\n      } else if (mode === FloorRenderMode.Off) {\n\n        // stop any prior fade-anim\n        this._stopFadeAnim();\n\n        // fade-out ghost floors (starting at current opacity)\n        var _onTimer = this._setGhostFloorOpactiy.bind(this);\n        var onFinished = this._leaveHoverMode.bind(this);\n        this._fadeAnim = avp.fadeValue(this._ghostFloorOpacity, 0.0, this.fadingTime, _onTimer, onFinished);\n      }\n    } }, { key: \"_moveToFloor\", value: function _moveToFloor(\n\n    floorIndex) {var _this2 = this;\n\n      this._currentFloor = floorIndex;\n\n      this._setMode(FloorRenderMode.Transition);\n\n      var floor = this._floors[floorIndex];\n\n      this._updateZLimits();\n\n      var minElevStart = this._floorSectionMin === undefined ? this._zMinAllModels : this._floorSectionMin;\n      var maxElevStart = this._floorSectionMax === undefined ? this._zMaxAllModels : this._floorSectionMax;\n      var minElevEnd = floor ? floor.zMin : this._zMinAllModels;\n      var maxElevEnd = floor ? floor.zMax : this._zMaxAllModels;\n\n      var updateCutPlanes = function updateCutPlanes(unitTime) {\n        var t = avp.smootherStep(unitTime);\n        var minElev = avp.lerp(minElevStart, minElevEnd, t);\n        var maxElev = avp.lerp(maxElevStart, maxElevEnd, t);\n\n        _this2._setFloorSection(minElev, maxElev);\n\n        // fade-out mouse over while animating\n        var blendPass = _this2._renderer.getBlendPass();\n        var uniform = blendPass.uniforms['highlightIntensity'];\n        uniform.value = Math.min(uniform.value, 1.0 - t);\n      };\n\n      var onAnimEnd = function onAnimEnd() {\n        // leave transition mode to hovering or off\n        var mode = _this2._hovering ? FloorRenderMode.Hovering : FloorRenderMode.Off;\n        _this2._setMode(mode);\n      };\n\n      // If another floor anim is in running, stop it first.\n      this._stopFloorAnim();\n\n      this._floorAnim = avp.fadeValue(0.0, 1.0, this.fadingTime, updateCutPlanes, onAnimEnd);\n    } }, { key: \"_selectFloor\", value: function _selectFloor(\n\n    floorIndex) {\n\n      // Make sure that a previous anim does not overwrite the cutplanes again.\n      this._stopFloorAnim();\n\n      this._currentFloor = floorIndex;\n\n      // Note that zMin/zMax may also be undefined if no floor is selected\n      var floor = this._floors[floorIndex];\n\n      // Set min/maxElev from floor or set both to undefined (for 'no floor selected')\n      var minElev = floor ? floor.zMin : undefined;\n      var maxElev = floor ? floor.zMax : undefined;\n\n      this._setFloorSection(minElev, maxElev);\n    } }, { key: \"_runFloorSelectorFilter\", value: function _runFloorSelectorFilter()\n\n    {\n      // Make sure all previously hidden objects are set to visible again.\n      this._floorSelectorFilter.clearFilter();\n\n      if (this._floorFilterData && this._currentFloor !== undefined) {\n        var floor = this._floors[this._currentFloor];\n        this._floorSelectorFilter.filter(this._floorFilterData, floor);\n      }\n    } }, { key: \"_runFloorSelectorFilterEventHandler\", value: function _runFloorSelectorFilterEventHandler(\n\n    event) {\n      var model = event.model;\n\n      if (!model.isObjectTreeLoaded()) {\n        return;\n      }\n      if (!(this._floorFilterData && this._currentFloor !== undefined)) {\n        // Handles the case when a level was deactivated while the model was not visible.\n        // When activating again the model, we need to make sure that the previously\n        // filtered elements are set to visible again.\n        this._floorSelectorFilter.clearFilter();\n        return;\n      }\n      this._runFloorSelectorFilter();\n    } }, { key: \"_runModelUnloadingEventHandler\", value: function _runModelUnloadingEventHandler(\n\n    event) {\n      if (this._floorFilterData && this._currentFloor !== undefined) {\n        this._floorSelectorFilter.unhideModel(event.model);\n      }\n    }\n\n    // Used in order to re-render a floor section.\n  }, { key: \"invalidateFloorSelection\", value: function invalidateFloorSelection(floorIndex) {\n      // Reselect current floor.\n      this._selectFloor(floorIndex);\n      // This is needed in order to filter unwanted planes from the cut area.\n      this._runFloorSelectorFilter();\n    } }, { key: \"floorData\", get: function get() {return this._floors;}, set: function set(floors) {// always reset the floor selector when floors data changes to avoid inconstancy\n      this.resetState();this._floors = Array.isArray(floors) ? floors : [];this.fireEvent({ type: FloorSelector.FLOOR_DATA_CHANGED, floorData: this._floors });} }, { key: \"floorFilterData\", get: function get() {return this._floorFilterData;}, set: function set(floorFilterData) {this._floorFilterData = floorFilterData;} }, { key: \"currentFloor\", get: function get() {return this._currentFloor;} }]);return FloorSelector;}();export { FloorSelector as default };\n\n\nFloorSelector.AllFloors = AllFloors;\nFloorSelector.NoFloor = NoFloor;\n\nFloorSelector.SELECTED_FLOOR_CHANGED = \"selectedFloorChanged\";\nFloorSelector.FLOOR_DATA_CHANGED = \"floorDataChanged\";\n\nnamespace.FloorSelector = FloorSelector;","'use strict';function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\n\nvar namespace = AutodeskNamespace('Autodesk.AEC');\n\n// The FloorSelectorFilter provides functionality to additionally apply object filtering\n// by dbIds on level selection.\n//\nvar\nFloorSelectorFilter = /*#__PURE__*/function () {\n\n  // @param {Viewer3D} viewer\n  function FloorSelectorFilter(viewer) {_classCallCheck(this, FloorSelectorFilter);\n    this._viewer = viewer;\n    // Contains all dbIds per model used to un-hide the objects whenever another level gets selected.\n    this._dbIdsToUnhide = new Map();\n    this._cache = {};\n  }\n\n  // Filter all elements by dbIds on level selection.\n  //  @param {Object}   floorFilterData   - A floor filter data object containing all dbIds per model and an optional level height factor.\n  //  @param {Object}   floor             - A floor.\n  _createClass(FloorSelectorFilter, [{ key: \"filter\", value: function filter(floorFilterData, floor) {var _this = this;\n      if (!floorFilterData) {\n        throw new Error('floorFilterData cannot be undefined.');\n      }\n      if (!(floorFilterData.modelsDbIds instanceof Map)) {\n        throw new Error('floorFilterData.modelsDbIds has to be a Map.');\n      }\n      if (!floor) {\n        throw new Error('floor cannot be undefined.');\n      }\n\n      // Get the level height factor and also do some basic number checks.\n      var levelHeightFactor = this._getLevelHeightFactor(floorFilterData.levelHeightFactor);\n\n      // All Floor and Ceiling db ids per model to hide.\n      var modelsDbIds = floorFilterData.modelsDbIds;\n\n      // Do nothing in case no db ids are set.\n      if (!this._hasModelDbIds(modelsDbIds)) {\n        return;\n      }\n\n      var minZ = floor.zMin;\n      var maxZ = floor.zMax;\n\n      // Calculate the new minZ/maxZ values of the level boundary used to spatially filter the Floor and\n      // Ceiling elements.\n      // 1. The lower boundary value (zMin) is moved up by the factor of the level height, because the Ceiling\n      //    elements we want to filter are located in the upper part of the level.\n      // 2. The upper boundary value (zMax) is moved up by 10% of the level height, because in some models\n      //    this helps to also remove floors which would be still shown otherwise.\n      var newMinZ = minZ + (maxZ - minZ) * levelHeightFactor;\n      var newMaxZ = maxZ + (maxZ - minZ) * 0.1;\n\n      // Setup cache for each floor.\n      if (!this._cache[floor.name]) {\n        this._cache[floor.name] = {};\n      }\n\n      var modelQueue = this._viewer.impl.modelQueue();\n      var models = modelQueue.getModels();var _loop2 = function _loop2(\n\n      m, l) {\n        var model = models[m];\n\n        if (!model.visibilityManager) {\n          console.warn(\"The VisibilityManager of the model with ID = \".concat(model.id, \" is not yet initialized.\"));\n          return \"break\";\n        }\n\n        // Try to get the db ids for a specific level and model from the cache.\n        if (_this._cache[floor.name][model.id]) {\n          var cachedDbIds = _this._cache[floor.name][model.id];\n          if (cachedDbIds.size > 0) {\n            _this.hideDbIds(model, cachedDbIds);\n          }\n          return \"continue\";\n        }\n\n        var instanceTree = model.getInstanceTree();\n        if (!instanceTree) {\n          console.warn(\"The instanceTree of the model with ID = \".concat(model.id, \" is not yet initialized.\"));\n          return \"continue\";\n        }\n\n        var dbIdsToHide = new Set();\n        var dbIds = modelsDbIds.get(model.id);\n        if (!dbIds) {\n          return \"continue\";\n        }\n\n        dbIds.forEach(function (dbId) {\n          var nodeBox = new Float32Array(6);\n          instanceTree.getNodeBox(dbId, nodeBox);\n\n          var nodeBoxMinZ = nodeBox[2];\n          var nodeBoxMaxZ = nodeBox[5];\n\n          if (nodeBoxMinZ >= newMinZ && nodeBoxMinZ <= newMaxZ ||\n          nodeBoxMaxZ >= newMinZ && nodeBoxMaxZ <= newMaxZ ||\n          nodeBoxMinZ <= newMinZ && nodeBoxMaxZ >= newMaxZ) {\n            dbIdsToHide.add(dbId);\n          }\n        });\n\n        if (dbIdsToHide.size > 0) {\n          _this.hideDbIds(model, dbIdsToHide);\n        }\n\n        _this._cache[floor.name][model.id] = dbIdsToHide;};_loop: for (var m = 0, l = models.length; m < l; m++) {var _ret = _loop2(m, l);switch (_ret) {case \"break\":break _loop;case \"continue\":continue;}\n      }\n    } }, { key: \"hideDbIds\", value: function hideDbIds(\n\n    model, dbIds) {\n      if (!model.visibilityManager) {\n        return;\n      }\n\n      dbIds.forEach(function (id) {\n        model.visibilityManager.setNodeOff(id, true);\n      });\n\n      // Collect all dbIds per model, so we can un-hide them later on again.\n      if (this._dbIdsToUnhide.has(model)) {\n        var _dbIds = this._dbIdsToUnhide.get(model);var _iterator = _createForOfIteratorHelper(\n        _dbIds),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var dbId = _step.value;\n            _dbIds.add(dbId);\n          }} catch (err) {_iterator.e(err);} finally {_iterator.f();}\n      } else {\n        this._dbIdsToUnhide.set(model, dbIds);\n      }\n    }\n\n    // Un-hides all objects (using the dbId) per model.\n  }, { key: \"clearFilter\", value: function clearFilter() {\n      if (this._dbIdsToUnhide.size === 0) {\n        return;\n      }\n\n      this._dbIdsToUnhide.forEach(function (dbIds, model) {\n        // Handles the case when the model is not visible and the level isolation is deactivated.\n        if (!model.visibilityManager) {\n          return;\n        }\n\n        dbIds.forEach(function (id) {\n          model.visibilityManager.setNodeOff(id, false);\n        });\n\n        // Only remove the model dbIds if they are successfully set to visible.\n        this._dbIdsToUnhide.delete(model);\n      }.bind(this));\n    }\n\n    // Un-hides only one model. It's all we can do, as the model.visibilityManager is null,\n    // that is we can not call setNodeOff function again\n  }, { key: \"unhideModel\", value: function unhideModel(model) {\n      this._dbIdsToUnhide.delete(model);\n    } }, { key: \"_hasModelDbIds\", value: function _hasModelDbIds(\n\n    modelsDbIds) {\n\n      if (modelsDbIds.size === 0) {\n        return false;\n      }var _iterator2 = _createForOfIteratorHelper(\n\n      modelsDbIds.values()),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var dbIds = _step2.value;\n          if (dbIds && dbIds.length > 0) {\n            return true;\n          }\n        }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}\n\n      return false;\n    } }, { key: \"_getLevelHeightFactor\", value: function _getLevelHeightFactor(\n\n    levelHeightFactor) {\n      if (levelHeightFactor === undefined) {\n        // Return default factor.\n        return 0.5;\n      }\n\n      if (typeof levelHeightFactor !== 'number') {\n        throw new Error('floorFilterData.levelHeightFactor has to be a number');\n      }\n      if (levelHeightFactor < 0 || levelHeightFactor >= 1) {\n        throw new Error('floorFilterData.levelHeightFactor has to be a number between 0-1.');\n      }\n\n      return levelHeightFactor;\n    }\n\n    // Hides all dbIds in a model that are currently expected to be hidden. \n  }, { key: \"reApplyFilter\", value: function reApplyFilter(model) {\n      var dbIds = this._dbIdsToUnhide.get(model);\n      var visMan = model.visibilityManager;\n      if (!dbIds || !visMan) {\n        return;\n      }\n\n      dbIds.forEach(function (id) {\n        visMan.setNodeOff(id, true);\n      });\n    } }, { key: \"isVisible\", value: function isVisible(\n\n    model, dbId) {\n      var dbIds = this._dbIdsToUnhide.get(model);\n      return !dbIds || !dbIds.has(dbId);\n    } }]);return FloorSelectorFilter;}();export { FloorSelectorFilter as default };\n\n\nnamespace.FloorSelectorFilter = FloorSelectorFilter;","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}} // A single Level.\n// Usually levels are being extracted from AecModelData - but can be generated from other sources (artificially created from viewports).\nvar Level =\nfunction Level(index, guid, name, zMin, zMax) {_classCallCheck(this, Level);\n  this.index = index;\n  this.name = name;\n  this.zMin = zMin;\n  this.zMax = zMax;\n  this.guid = guid;\n};export { Level as default };","import Level from './Level';\nimport AecData from '../common/AecModelData';\n\nfunction getProjectElevation(level) {\n  var ext = level.extension;\n\n  if (ext && ext.hasOwnProperty('projectElevation'))\n  return ext.projectElevation;\n\n  return level.elevation;\n}\n\nexport function transformLevelsByMatrix(levels, refPointTransformation) {\n\n  var v = new THREE.Vector3();\n  var transformByMatrix = function transformByMatrix(value) {\n    v.set(0, 0, value);\n    v.applyMatrix4(refPointTransformation);\n    return v.z;\n  };\n\n  levels.forEach(function (currentLevel) {\n    currentLevel.zMin = transformByMatrix(currentLevel.zMin);\n    currentLevel.zMax = transformByMatrix(currentLevel.zMax);\n  });\n}\n\n\n// transform is given as 12 floats\nexport function transformLevels(levels, refPointTransformation) {\n  if (!refPointTransformation)\n  return;\n\n  // get transform as THREE.Matrix4\n  var matrix = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(refPointTransformation);\n  transformLevelsByMatrix(levels, matrix);\n}\n\n//Explanation from design-collaboration repo:\n// Hint: the idea to move the level zMin value an inch down is to make sure that the\n// end-user can also see the bottom floor. Otherwise in some cases the floor would just\n// be cut-away by the floor selection. This value was defined after experimenting with\n// several models and maybe needs adjustment in the future.\nexport var zOffsetHack = 1 / 12;\n\nexport function aecModelDataToLevels(aecModelData, placementTf, modelTransform) {\n  // levels are sorted ascending\n\n  // we have to handle the building story flag of a Revit level\n  // filter out all Revit levels which do not have building story set to true\n  var filteredLevels = aecModelData.levels.filter(function (l) {\n    var ext = l.extension;\n\n    if (!ext)\n    return true;\n\n    //So.... if it has no buildingStory property, it's a building story...\n    if (!ext.hasOwnProperty('buildingStory'))\n    return true;\n\n    return ext.buildingStory;\n  });\n\n  var levels = [];\n\n  var count = filteredLevels.length;\n  filteredLevels.forEach(function (currentLevel, index) {\n\n    var nextElevation = undefined;\n    if (index + 1 < count) {\n      nextElevation = getProjectElevation(filteredLevels[index + 1]);\n    } else\n    {\n      // for the topmost floor, we must use its height to determine the next boundary\n      var topLevel = filteredLevels[filteredLevels.length - 1];\n      var topLevelElevation = getProjectElevation(topLevel);\n      nextElevation = topLevelElevation + topLevel.height;\n    }\n\n    levels.push(\n    new Level(\n    levels.length,\n    currentLevel.guid,\n    currentLevel.name,\n    getProjectElevation(currentLevel) - zOffsetHack, // zMin\n    nextElevation // zMax\n    ));\n\n  });\n\n  // If the model is known, use its attached transform. This variant works with any loadOptions. \n  if (placementTf) {\n    transformLevelsByMatrix(levels, placementTf);\n  } else {\n    // If the model is not known, we assume that no zOffset is applied. This is only\n    // true when using applyRefPoint=true and a gobalOffset with z=0.\n    transformLevels(levels, aecModelData.refPointTransformation);\n  }\n\n  if (modelTransform) {\n    transformLevelsByMatrix(levels, modelTransform);\n  }\n\n  return levels;\n}\n\nexport function chooseMainModel(viewer, ignoreAecModelData) {\n\n  var models = viewer.impl.modelQueue().getModels();\n  var mainModel = null;\n  var mainModelSize = -1;\n  models.forEach(function (model) {\n\n    if (model.is2d())\n    return;\n\n    var bubbleNode = model.getDocumentNode();\n\n    if (!bubbleNode)\n    return;\n\n    if (!ignoreAecModelData) {\n      var aecModelData = bubbleNode.getAecModelData();\n\n      if (!aecModelData)\n      return;\n    }\n\n    if (bubbleNode.data.size > mainModelSize) {\n      mainModel = model;\n      mainModelSize = bubbleNode.data.size;\n    } else if (!bubbleNode.data.size && mainModelSize === -1) {\n      mainModel = model;\n      mainModelSize = 0;\n    }\n  });\n  return mainModel;\n}\n\nexport function modelDataOccluders(viewer) {\n\n  var models = viewer.impl.modelQueue().getModels();\n\n  var occludersPerModel = new Map();\n\n  models.forEach(function (model) {\n\n    if (model.is2d())\n    return;\n\n    var bubbleNode = model.getDocumentNode();\n    if (!bubbleNode)\n    return;\n    var aecModelData = bubbleNode.getAecModelData();\n    if (!aecModelData)\n    return;\n\n    occludersPerModel.set(model.id, aecModelData.levelOccluderIds);\n  });\n\n  return { modelsDbIds: occludersPerModel };\n}","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nvar av = Autodesk.Viewing,avu = av.UI;\nvar namespace = AutodeskNamespace('Autodesk.AEC');\nvar myExtensionName = 'Autodesk.AEC.LevelsExtension';\n\nimport FloorSelector from './FloorSelector';\nimport { modelDataOccluders, aecModelDataToLevels, chooseMainModel } from './LevelUtils';\nimport { ListPanel, ListPanelEvents } from \"../ui/ListPanel\";\nimport AecData from '../common/AecModelData.js';\n\n// Options:\n//   @param {bool} [autoDetectAecModelData = true]\n//         Level selection requires data about existing floors. By default (true), these are extracted automatically:\n//          - For a single model, we get them by calling getAecModelData() on the document node.\n//          - If multiple models with aecModelData are visible, we choose the largest one to define the levels.\n//\n//         If set to false, an application can (and has to) call setAecModelData() explicitly instead.\n//  @param {bool} [ifcLevelsEnabled = false] - If enabled will try to extract levels for IFC models using heuristics.\nvar LevelsExtension = /*#__PURE__*/function (_av$Extension) {_inherits(LevelsExtension, _av$Extension);var _super = _createSuper(LevelsExtension);\n  function LevelsExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, LevelsExtension);\n    _this = _super.call(this, viewer, options);\n\n    _this.container = _this.options.panelUIContainers && _this.options.panelUIContainers.levelsPanel;\n\n    _this._onCameraMoved = _this._onCameraMoved.bind(_assertThisInitialized(_this));\n    _this.onItemMouseEnter = _this.onItemMouseEnter.bind(_assertThisInitialized(_this));\n    _this.onItemMouseLeave = _this.onItemMouseLeave.bind(_assertThisInitialized(_this));\n    _this.onItemSelected = _this.onItemSelected.bind(_assertThisInitialized(_this));\n    _this.updateFloorsData = _this.updateFloorsData.bind(_assertThisInitialized(_this));\n\n    _this.doNotCreateUI = options.doNotCreateUI;\n    _this._currentLevel = undefined;return _this;\n  }_createClass(LevelsExtension, [{ key: \"_onCameraMoved\", value: function _onCameraMoved()\n\n    {\n      var currentLevel = this._mapCameraToLevel();\n\n      if (!currentLevel)\n      return;\n\n      if (!this._currentLevel || currentLevel.guid !== this._currentLevel.guid) {\n        this._currentLevel = currentLevel;\n        this.viewer.dispatchEvent({ type: LevelsExtension.LEVEL_CHANGED, level: currentLevel });\n      }\n    } }, { key: \"_mapCameraToLevel\", value: function _mapCameraToLevel()\n\n    {\n      var floors = this.floorSelector.floorData;\n      if (!floors.length) {\n        return;\n      }\n\n      var currentElevation = this.viewer.impl.camera.position.z;\n\n      if (currentElevation < floors[0].zMin) {\n        return floors[0];\n      } else\n      if (currentElevation > floors[floors.length - 1].zMax) {\n        return floors[floors.length - 1];\n      } else\n      {\n        return floors.find(function (f) {return f.zMin <= currentElevation && f.zMax >= currentElevation;});\n      }\n    } }, { key: \"onToolbarCreated\", value: function onToolbarCreated()\n\n    {\n\n      if (this.container) {\n        //Add our button to the toolbar if host app did not ask to render UI in some other place\n        return;\n      }\n\n      // Add levelsButton to modelTools. \n      // We can safely assume toolbar to exis, because onToolbarCreated() is only called if \n      // 1. GuiViewer is used and 2. the toolbar is ready.\n      var toolbar = this.viewer.getToolbar();\n      var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);\n      if (modelTools && this.levelsButton) {\n        modelTools.addControl(this.levelsButton);\n      }\n    } }, { key: \"onItemMouseEnter\", value: function onItemMouseEnter(_ref)\n\n    {var item = _ref.item;\n      var levelIndex = item.index;\n\n      // Selecting an already selected level again will unselect => i.e. all Floors will be shown.\n      // Correspondingly, we trigger rollover highlighting for all floors when hovering over the selected level.\n      if (levelIndex === this.floorSelector.currentFloor) {\n        levelIndex = FloorSelector.AllFloors;\n      }\n\n      this.floorSelector.rollOverFloor(levelIndex);\n      this.hoveredFloor = levelIndex;\n    } }, { key: \"onItemMouseLeave\", value: function onItemMouseLeave(_ref2)\n\n    {var item = _ref2.item;\n      if (this.hoveredFloor === item.index) {\n        this.hoveredFloor = undefined;\n        this.floorSelector.rollOverFloor(FloorSelector.NoFloor);\n      }\n    } }, { key: \"onItemSelected\", value: function onItemSelected(_ref3)\n\n    {var item = _ref3.item;\n      // on item selected\n      var levelIndex = item.index !== this.floorSelector.currentFloor ? item.index : undefined;\n      this.floorSelector.selectFloor(levelIndex, true);\n    } }, { key: \"_createUI\", value: function _createUI()\n\n    {var _this2 = this;\n      if (this.doNotCreateUI) return;\n\n      this.levelsButton = new avu.Button(\"toolbar-levelsTool\");\n      this.levelsButton.setToolTip('Levels');\n      this.levelsButton.icon.innerHTML = createLevelsIcon();\n\n      var panelOptions = {\n        enableCheckmark: true // show checkmark at the end of selected items\n      };\n\n      this.levelsPanel = new ListPanel(this.container || this.viewer.container, 'LevelsPanel-' + this.viewer.id, 'Levels', panelOptions);\n      this.levelsPanel.setGlobalManager(this.globalManager);\n\n      if (!this.container) {\n        // This ensures that the Panel keeps visible within the viewer canvas on resize.\n        this.viewer.addPanel && this.viewer.addPanel(this.levelsPanel);\n      }\n\n\n      // Keep button-state consistent when pressing panel close\n      this.levelsPanel.addVisibilityListener(function (visible) {\n        _this2.levelsButton.setState(visible ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);\n      });\n\n      // allow client app to be notified on panel close\n      this.levelsPanel.closer.addEventListener('click', function () {\n        if (_this2.onPanelVisibilityToggled) {\n          _this2.onPanelVisibilityToggled(false);\n        }\n      });\n\n      this.levelsPanel.addEventListener(ListPanelEvents.ITEM_MOUSE_ENTER, this.onItemMouseEnter);\n\n      this.levelsPanel.addEventListener(ListPanelEvents.ITEM_MOUSE_LEAVE, this.onItemMouseLeave);\n\n      this.levelsPanel.addEventListener(ListPanelEvents.ITEM_SELECT, this.onItemSelected);\n\n      // Handle hovering over panel\n      this.levelsPanel.container.addEventListener(\"mouseenter\", function () {return _this2.floorSelector.enterHoverMode();});\n      this.levelsPanel.container.addEventListener(\"mouseleave\", function () {return _this2.floorSelector.exitHoverMode();});\n\n      // Keep selected item in-sync with selected Floor\n      this.floorSelector.addEventListener(\n      FloorSelector.SELECTED_FLOOR_CHANGED,\n      function () {return _this2.levelsPanel.updateItemStates();});\n\n\n      this.levelsPanel.setItemHandlers(\n      function (item) {return item.index === _this2.floorSelector.currentFloor;},\n      function (item) {return item.text;});\n\n\n      // Connect levelsButton\n      this.levelsButton.onClick = function () {\n        var visible = !_this2.levelsPanel.isVisible();\n        _this2.levelsPanel.setVisible(visible);\n\n        // allow client app to be notified\n        if (_this2.onPanelVisibilityToggled) {\n          _this2.onPanelVisibilityToggled(visible);\n        }\n      };\n    } }, { key: \"setAecModelData\", value: function setAecModelData(\n\n    aecModelData, model, isDataInWorldCoords) {\n\n      if (aecModelData !== this.aecModelData ||\n      model !== this.currentModel ||\n      isDataInWorldCoords !== this.isDataInWorldCoords)\n      {\n        this.aecModelData = aecModelData;\n        this.isDataInWorldCoords = isDataInWorldCoords;\n        this.currentModel = model;\n\n        this.updateFloorsData();\n\n        var levels = this.floorSelector.floorData;\n        var items = [];\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          items.push({\n            text: level.name,\n            index: i });\n\n        }\n\n        // list items in reverse order, because aecModelData levels are sorted by increasing z\n        items.reverse();\n        if (this.levelsPanel) {\n          this.levelsPanel.setItems(items);\n        }\n\n        this._updateOccluderData();\n      }\n    }\n\n    // By default, the transform applied to levelData is automatically from the currentModel.\n    // This function is only needed if you have to set aecModelData and apply a transform without knowing the model.\n    //  @param {Matrix4} transform - transform floorData to viewer coordinates (must include globalOffset)\n  }, { key: \"setFloorDataTransform\", value: function setFloorDataTransform(transform) {\n      this.floorDataTransform = transform;\n      this.updateFloorsData();\n    } }, { key: \"updateFloorsData\", value: function updateFloorsData()\n\n    {\n      // Backup currentFloor before changing floorData inner values.\n      // It's important to backup it here, because whenever we set floorData, it immediately calls `resetState`.\n      var currentFloor = this.floorSelector.currentFloor;\n\n      if (this.aecModelData) {\n        // If data is already in world coordinates, just use it as is.\n        if (this.isDataInWorldCoords) {\n          this.floorSelector.floorData = this.aecModelData;\n        } else {var _this$currentModel, _this$currentModel2;\n          // Otherwise, we need to apply model transform on the levels first.\n          //\n          // If placementTf is undefined, we use the refPointTransform of aecModelData.\n          // Note that this is correct when using applyRefPoint=true and a globalOffset with z=0\n          // for the model load options.\n          var placementTf = ((_this$currentModel = this.currentModel) === null || _this$currentModel === void 0 ? void 0 : _this$currentModel.getData().placementWithOffset) || this.floorDataTransform;\n          var modelTransform = (_this$currentModel2 = this.currentModel) === null || _this$currentModel2 === void 0 ? void 0 : _this$currentModel2.getModelTransform();\n\n          this.floorSelector.floorData = aecModelDataToLevels(this.aecModelData, placementTf, modelTransform);\n        }\n\n        // Invalidate section.\n        this.floorSelector.invalidateFloorSelection(currentFloor);\n      } else {\n        this.floorSelector.floorData = [];\n      }\n\n      // Since changing model z offset can cause the camera position (aka \"player\") to be outside / inside of a level,\n      // It's important to call _onCameraMoved here, so if a level has changed according to the new transform - it will trigger a LEVEL_CHANGED event.\n      this._onCameraMoved();\n    } }, { key: \"_updateOccluderData\", value: function _updateOccluderData()\n\n    {\n      // Make sure that occluder data is known if a main model is specified\n      var occludersPerModel = this.aecModelData ? modelDataOccluders(this.viewer) : undefined;\n      this.floorSelector.floorFilterData = occludersPerModel;\n    } }, { key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var _this3 = this;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (\n\n\n                  this.viewer.loadExtension('Autodesk.AEC.ViewportsExtension'));case 2:this.viewportsExtension = _context2.sent;\n\n                this.floorSelector = new FloorSelector(this.viewer);\n\n                this.updateFloorSelector = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var autoDetect, isDataInWorldCoords, model, bubbleNode, aecModelData, generatedLevels, is3d;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:if (\n                          _this3.floorSelector) {_context.next = 2;break;}return _context.abrupt(\"return\");case 2:\n\n\n\n                          // auto-detect main model if not disabled\n                          autoDetect = _this3.options.autoDetectAecModelData !== false;if (!\n                          autoDetect) {_context.next = 19;break;}\n                          isDataInWorldCoords = false;\n\n                          model = chooseMainModel(_this3.viewer, true); // Returns null when no model\n                          bubbleNode = model && model.getDocumentNode();\n                          aecModelData = bubbleNode && bubbleNode.getAecModelData(); // Returns null when no aec model data\n                          if (!(\n                          !aecModelData && model && model.getData().loadOptions.fileExt === 'ifc' && _this3.options.ifcLevelsEnabled)) {_context.next = 13;break;}\n                          // Set momentarily to undefined until async computation is finished. Helps differentiate when it's\n                          // still loading (undefined), from having no levels information (null)\n                          _this3.setAecModelData(undefined, model);_context.next = 12;return (\n                            AecData.computeAecModelDataForIfc(model));case 12:aecModelData = _context.sent;case 13:if (!(\n\n\n                          !aecModelData && model)) {_context.next = 18;break;}_context.next = 16;return (\n                            _this3.viewportsExtension.generateLevelsFromViewports(model.getDocumentNode()));case 16:generatedLevels = _context.sent;\n\n                          if (generatedLevels.length) {\n                            aecModelData = generatedLevels;\n\n                            isDataInWorldCoords = true;\n                          }case 18:\n\n\n                          _this3.setAecModelData(aecModelData, model, isDataInWorldCoords);case 19:\n\n\n                          _this3._updateOccluderData();\n\n                          // Make sure that cutplanes are disabled when in 2d views and reactivated in 3d\n                          // Todo: Check if we can move the MODEL_ADDED event at the end of addModel, so that we could simply use viewer.is2d here.\n                          is3d = _this3.viewer.getVisibleModels().some(function (model) {return model.is3d();});\n                          _this3.floorSelector.setEnabled(is3d);case 22:case \"end\":return _context.stop();}}}, _callee);}));\n\n\n                this.viewer.addEventListener(av.MODEL_ROOT_LOADED_EVENT, this.updateFloorSelector);\n                this.viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this.updateFloorSelector);\n                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.updateFloorSelector);\n                this.viewer.addEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, this.updateFloorsData);\n                this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this._onCameraMoved);\n                this.viewportsExtension.addEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this.updateFloorSelector);\n\n                this._createUI();\n                this.updateFloorSelector();return _context2.abrupt(\"return\",\n\n                true);case 14:case \"end\":return _context2.stop();}}}, _callee2, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"unload\", value: function unload()\n\n\n    {\n      if (!this.container) {\n        this.viewer.removePanel && this.viewer.removePanel(this.levelsPanel);\n      }\n      this.floorSelector.selectFloor(undefined, false);\n      this.levelsPanel = null;\n\n      if (this.updateFloorSelector) {\n        this.viewer.removeEventListener(av.MODEL_ROOT_LOADED_EVENT, this.updateFloorSelector);\n        this.viewer.removeEventListener(av.MODEL_UNLOADED_EVENT, this.updateFloorSelector);\n        this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.updateFloorSelector);\n        this.viewer.removeEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, this.updateFloorsData);\n        this.viewportsExtension.removeEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this.updateFloorSelector);\n        this.updateFloorSelector = null;\n      }\n\n      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this._onCameraMoved);\n      this._currentLevel = null;\n\n      this.floorSelector = null;\n\n      this.aecModelData = null;\n      this.currentModel = null;\n\n      return true;\n    }\n\n    /**\r\n       * Gets the extension state as a plain object. Invoked automatically by viewer.getState()\r\n       * @param {object} viewerState - Object to inject extension values.\r\n       */ }, { key: \"getState\", value: function getState(\n    viewerState) {\n      if (!this.viewer.model || this.viewer.model.is2d()) {\n        return;\n      }\n\n      var floor = this.floorSelector.currentFloor;\n      viewerState.floorGuid = floor ? this.floorSelector.floorData[floor].guid : null;\n    } }, { key: \"restoreState\",\n\n    /**\r\n                                 * Restores the extension state from a given object. Invoked automatically by viewer.restoreState()\r\n                                 * @param {object} viewerState - Viewer state.\r\n                                 * @param {boolean} immediate - Whether the new view is applied with (true) or without transition (false).\r\n                                 * @returns {boolean} True if restore operation was successful.\r\n                                 */value: function restoreState(\n    viewerState, immediate) {\n      // If floorGuid is undefined we should keep the extension as it is. (unlike null which means 'no levels') \n      if (viewerState.floorGuid === undefined) {\n        return;\n      }\n      if (viewerState.floorGuid) {\n        var floor = this.floorSelector.floorData.find(function (data) {return data.guid === viewerState.floorGuid;});\n\n        if (floor) {\n          this.floorSelector.selectFloor(floor.index, false);\n        }\n      } else {\n        this.floorSelector.selectFloor(FloorSelector.NoFloor, false);\n      }\n\n      return true;\n    } }, { key: \"getCurrentLevel\",\n\n    // Returns a floor object {index, name}\n    value: function getCurrentLevel() {\n      // If a level is selected, use that one and ignore camera z\n      var fs = this.floorSelector;\n      var level = fs.floorData[fs.currentFloor];\n      if (level) {\n        return level;\n      }\n\n      // No floor selected => determine based on camera z\n      return this._mapCameraToLevel();\n    }\n\n    // index must be a valid FloorIndex\n  }, { key: \"getZRange\", value: function getZRange(index) {\n      var floor = this.floorSelector && this.floorSelector.floorData[index];\n\n      // Cut everything above zMid of current floor\n      var zMax = floor.zMin + 0.5 * (floor.zMax - floor.zMin);\n\n      // Cut everything below zMid of the floor below\n      // (Cutting below zMin keeps stairs to lower floors visible)\n      var floorBelow = this.floorSelector.floorData[index - 1];\n      var zMin = floorBelow ? 0.5 * (floorBelow.zMin + floorBelow.zMax) : floor.zMin;\n\n      return { zMin: zMin, zMax: zMax };\n    } }]);return LevelsExtension;}(av.Extension);export { LevelsExtension as default };\n\n\nvar createLevelsIcon = function createLevelsIcon() {\n  return [\n  '<svg width=\"24\" height=\"24\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">',\n  '<g stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">',\n  '<path d=\"M4 8 L12 3 L 20 8 L12 13Z\"/>',\n  '<path d=\"M4 12 L12 17 L 20 12\"/>',\n  '<path d=\"M4 16 L12 21 L 20 16\"/>',\n  '</g>',\n  '</svg>'].\n  join('');\n};\n\nnamespace.LevelsExtension = LevelsExtension; // Makes it easier to get e.g. the version\n\nLevelsExtension.LEVEL_CHANGED = \"levelChanged\";\n\n// Register the extension with the extension manager.\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, LevelsExtension);","\nvar content = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./ListPanel.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./ListPanel.css\", function() {\n\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./ListPanel.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","\nvar av = Autodesk.Viewing;\nvar avu = Autodesk.Viewing.UI;\n\n\nexport var ListPanelEvents = {\n\n  /**\n                                * Fired when clicking on an item. (not fired when setting current item per code)\n                                *  @property {Object} item  - data item being selected.\n                                */\n  ITEM_SELECT: 'itemSelect',\n\n  /*\n                              * Fired when toggling item visibility\n                              *  @property {Object} item    - data item\n                              *  @property {bool}   visible - whether item was toggled on or off\n                              */\n  ITEM_VISIBILITY_CHANGED: 'itemVisibibilityChanged',\n\n  /**\n                                                       * @property {Object} item - data item being selected.\n                                                       */\n  ITEM_MOUSE_ENTER: 'itemMouseEnter',\n  ITEM_MOUSE_LEAVE: 'itemMouseLeave' };\n\n\nexport function ListPanel(parentContainer, id, title, options) {\n\n  avu.DockingPanel.call(this, parentContainer, id, title, options);\n\n  av.EventDispatcher.prototype.apply(this);\n\n  this.container.classList.add('list-panel');\n  this.container.dockRight = true;\n  this.createScrollContainer({ left: false, heightAdjustment: 65, marginTop: 0 });\n}\n\nListPanel.prototype = Object.create(avu.DockingPanel.prototype);\n\n// @param {Object[]} items - Array order defines display order top-down.\nListPanel.prototype.setItems = function (items) {\n\n  this.buttons = [];\n  this.items = items;\n\n  // remove old list\n  if (this.listDiv) {\n    this.scrollContainer.removeChild(this.listDiv);\n  }\n  var _document = this.getDocument();\n  this.listDiv = _document.createElement('div');\n  this.listDiv.classList.add('itemList');\n\n  this.scrollContainer.appendChild(this.listDiv);\n\n  var scope = this;\n\n  var createButton = function createButton(item) {\n\n    var itemText = scope._getItemText ? scope._getItemText(item) : '<no item text>';\n\n    var button = _document.createElement('div');\n    button.classList.add('listItem');\n    button.item = item;\n    button.setAttribute('title', itemText);\n\n    button.addEventListener('click', function () {\n      scope.fireEvent({\n        type: ListPanelEvents.ITEM_SELECT,\n        item: item });\n\n    });\n    button.addEventListener('mouseenter', function () {\n      scope.fireEvent({\n        type: ListPanelEvents.ITEM_MOUSE_ENTER,\n        item: item });\n\n      button.classList.add('hover');\n    });\n    button.addEventListener('mouseleave', function () {\n      scope.fireEvent({\n        type: ListPanelEvents.ITEM_MOUSE_LEAVE,\n        item: item });\n\n      button.classList.remove('hover');\n    });\n\n    var textSpan = _document.createElement('span');\n    textSpan.innerHTML = itemText;\n    textSpan.classList.add(\"text\");\n\n    // This container DIV is required to enable proper text fade-out for long texts.\n    var textContainerDiv = _document.createElement('div');\n    textContainerDiv.classList.add(\"textContainer\");\n    textContainerDiv.appendChild(textSpan);\n    button.appendChild(textContainerDiv);\n\n    // Optional: Enable warning symbol per item\n    if (scope.options.enableWarningSymbol) {\n      var warnSpan = _document.createElement('span');\n      warnSpan.classList.add(\"list-panel-item-warning\");\n      button.appendChild(warnSpan);\n      button.warnSpan = warnSpan;\n    }\n\n    // Optional: Show checkmark for selected items\n    if (scope.options.enableCheckmark) {\n      var checkSpan = _document.createElement('span');\n      checkSpan.classList.add(\"icon\");\n      button.appendChild(checkSpan);\n    }\n\n    // Optional: Show eye-symbol\n    if (scope.options.enableVisibilityToggle) {\n      var eyeSymbol = _document.createElement('div');\n      eyeSymbol.classList.add(\"visibility\");\n      button.appendChild(eyeSymbol);\n\n      eyeSymbol.addEventListener('click', function () {\n        var wasVisible = scope._isVisible ? scope._isVisible(button.item) : true;\n        scope.fireEvent({\n          type: ListPanelEvents.ITEM_VISIBILITY_CHANGED,\n          item: button.item,\n          visible: !wasVisible });\n\n        scope.updateItemStates();\n      });\n    }\n\n    return button;\n  };\n\n  for (var index = 0; index < items.length; index++) {\n\n    var item = items[index];\n    var button = createButton(item);\n\n    this.listDiv.appendChild(button);\n    this.buttons.push(button);\n  }\n\n  this.updateItemStates();\n};\n\n// Trigger mouse-over highlighting on item. \n//  @param {function} filter - gets an item\nListPanel.prototype.rollOverItem = function (filter) {\n  for (var i = 0; i < this.buttons.length; i++) {\n    var button = this.buttons[i];\n    if (filter(button.item)) {\n      button.classList.add('hover');\n    } else {\n      button.classList.remove('hover');\n    }\n  }\n};\n\nListPanel.prototype.updateItemStates = function () {\n\n  if (!this.buttons) {\n    return;\n  }\n  for (var i = 0; i < this.buttons.length; i++) {\n\n    // set/unset blue color for selected items and show optional checkmark\n    var button = this.buttons[i];\n    button.classList.remove(\"selected\");\n    if (this._isSelected && this._isSelected(button.item)) {\n      button.classList.add(\"selected\");\n    }\n\n    // set/unset warning symbol\n    if (this.options.enableWarningSymbol) {\n      var warnText = this._getWarningText && this._getWarningText(button.item);\n      button.warnSpan.style.visibility = warnText ? 'visible' : 'hidden';\n      button.warnSpan.setAttribute('title', warnText || '');\n    }\n\n    // set state of visibility toggle (eye symbol)\n    if (this.options.enableVisibilityToggle) {\n      button.classList.remove(\"dim\");\n      var isVisible = this._isVisible ? this._isVisible(button.item) : true;\n      if (!isVisible) {\n        button.classList.add('dim');\n      }\n    }\n  }\n};\n\n// Set functions to define how to handle each item\n//  @param {function(item)} isSelected       - takes a list item (see setItems) and returns true for 'selected state'\n//  @param {function(item)} getItemText      - returns the text to be displayed\n//  @param {function(item)} [getWarningText] - Optional: Display a warning symbol. Function defines tooltip text.\n//  @param {function(item)} [isVisible]      - Optional: State of visibility toggle. If set, an additional eye-symbol is shown to toggle visibility per item. \nListPanel.prototype.setItemHandlers = function (isSelected, getItemText, getWarningText, isVisible) {\n  this._isSelected = isSelected;\n  this._getItemText = getItemText;\n  this._getWarningText = getWarningText;\n  this._isVisible = isVisible;\n  this.updateItemStates();\n};\n\navu.ListPanelEvents = ListPanelEvents;\navu.ListPanel = ListPanel;","\n\nexport var DefaultTessParams = {\n  //How many forward iterations to use when approximating Bezier curves\n  //More iterations are needed in case the min_seg_len setting below is smaller\n  //relative to mesh size. However, the two numbers need to be tuned together\n  //so that NUM_ITERATIONS is enough to result in segment lengths desired.\n\n  //Note that those values are tuned for PDF rendering, where text characters\n  //are drawn one by one. If a long piece of text is drawn all at once, then\n  //its bounding box will be quite large, so the relative min_seg_len will also\n  //be too large and the characters will look coarse. In such cases, we will need\n  //to better estimate this by using e.g. the font height only.\n  numIterations: 100,\n\n  //What fraction of the bounding sbox should be the minimum length of\n  //a segment\n  minSegLenFraction: 0.05 };\n\n\nexport function SetTesselationParams(num_iterations, min_seg_len_fraction) {\n  if (num_iterations)\n  DefaultTessParams.numIterations = num_iterations;\n\n  if (min_seg_len_fraction)\n  DefaultTessParams.minSegLenFraction = min_seg_len_fraction;\n}\n\nfunction distance(x1, y1, x2, y2) {\n  return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nfunction adjustMaxdim(maxdim, segLength) {\n  if (maxdim > 4 * segLength && segLength > 0) {\n    var time = Math.sqrt(maxdim / segLength);\n    time = Math.min(4, time);\n    maxdim = segLength * time;\n  }\n  return maxdim;\n}\n\nexport function TesselateCubic(ctx, px1, py1, px2, py2, px3, py3, px4, py4, maxdim, tessParams, isFont)\n{\n  tessParams = tessParams || DefaultTessParams;\n\n  var aproximateLength = distance(px1, py1, px2, py2) + distance(px2, py2, px3, py3) + distance(px3, py3, px4, py4);\n\n  // maxdim is the size of the bounds of the path\n  // but for individual path, we need to use aproximateLength\n  // we need to balance both performance and visual effect\n  // so we leverage both value and try to balance it.\n  if (!isFont) {\n    maxdim = adjustMaxdim(maxdim, aproximateLength);\n  }\n\n  //we will base the max number of segments to use for approximation\n  //on the bounds of the full line buffer contents\n  //TODO: as an improvement we could take the bounds of this particular curve\n  //with respect to the full bounds of the line buffer data.\n  maxdim = maxdim || 1 / tessParams.minSegLenFraction;\n\n  //minimum length of tesselation segment\n  //set to 1/100 of the bounds\n  var minSegLen = maxdim * tessParams.minSegLenFraction;\n\n  //but for now we will iterate 100 times\n  var dt = 1.0 / tessParams.numIterations;\n\n  //double dt2 = dt*dt;\n  var dt3 = dt * dt * dt;\n\n  var pre1 = 3.0 * dt;\n  var pre2 = pre1 * dt;\n  var pre3 = pre2 + pre2;\n  var pre4 = 6.0 * dt3;\n\n  var temp1x = px1 - 2.0 * px2 + px3;\n  var temp1y = py1 - 2.0 * py2 + py3;\n  var temp2x = 3.0 * (px2 - px3) - px1 + px4;\n  var temp2y = 3.0 * (py2 - py3) - py1 + py4;\n\n  var fx = px1;\n  var fy = py1;\n  var dfx = (px2 - px1) * pre1 + temp1x * pre2 + temp2x * dt3;\n  var dfy = (py2 - py1) * pre1 + temp1y * pre2 + temp2y * dt3;\n  var ddfx = temp1x * pre3 + temp2x * pre4;\n  var ddfy = temp1y * pre3 + temp2y * pre4;\n  var dddfx = temp2x * pre4;\n  var dddfy = temp2y * pre4;\n\n  var error = 0.0;\n\n  // forward differencing loop\n  var tMax = 0 | 1.0 / dt - 0.5;\n  for (var t = 0; t < tMax; t++)\n  {\n    fx += dfx;\n    fy += dfy;\n    dfx += ddfx;\n    dfy += ddfy;\n    ddfy += dddfy;\n    ddfx += dddfx;\n\n    error += Math.sqrt(dfx * dfx + dfy * dfy);\n\n    if (error >= minSegLen) //add segment only if we have reached treshold length\n      {\n        // line to current\n        ctx.lineTo(fx, fy);\n        error = 0.0;\n      }\n  }\n\n  ctx.lineTo(px4, py4);\n}\n\nexport function TesselateQuad(ctx, px1, py1, px2, py2, px3, py3, maxdim, tessParams, isFont)\n{\n  tessParams = tessParams || DefaultTessParams;\n\n  var aproximateLength = distance(px1, py1, px2, py2) + distance(px2, py2, px3, py3);\n\n  // maxdim is the size of the bounds of the path\n  // but for individual path, we need to use aproximateLength\n  // we need to balance both performance and visual effect\n  // so we leverage both value and try to balance it.\n  if (!isFont) {\n    maxdim = adjustMaxdim(maxdim, aproximateLength);\n  }\n\n  //we will base the max number of segments to use for approximation\n  //on the bounds of the full line buffer contents\n  //TODO: as an improvement we could take the bounds of this particular curve\n  //with respect to the full bounds of the line buffer data.\n  maxdim = maxdim || 1 / tessParams.minSegLenFraction;\n\n  //minimum length of tesselation segment\n  //set to a fraction of the bbox of the entire path (value chosen to work well for text at reasonable font size)\n  var minSegLen = maxdim * tessParams.minSegLenFraction;\n\n  //but for now we will iterate 100 times\n  var dt = 1.0 / tessParams.numIterations;\n\n  var dt2 = dt * dt;\n\n  var ax = px1 - 2.0 * px2 + px3; //replace 2* by addition?\n  var ay = py1 - 2.0 * py2 + py3; //replace 2* by addition?\n\n  var bx = 2.0 * (px2 - px1);\n  var by = 2.0 * (py2 - py1);\n\n  var fx = px1;\n  var fy = py1;\n  var dfx = bx * dt + ax * dt2;\n  var dfy = by * dt + ay * dt2;\n  var ddfx = 2.0 * ax * dt2;\n  var ddfy = 2.0 * ay * dt2;\n\n  var error = 0.0;\n\n  //forward differencing loop\n  var tMax = 0 | 1.0 / dt - 0.5;\n  for (var t = 0; t < tMax; t++)\n  {\n    fx += dfx;\n    fy += dfy;\n    dfx += ddfx;\n    dfy += ddfy;\n\n    error += Math.sqrt(dfx * dfx + dfy * dfy);\n\n    if (error >= minSegLen) // how many pixels should each line be?)\n      {\n        ctx.lineTo(fx, fy);\n        error = 0.0;\n      }\n  }\n\n  ctx.lineTo(px3, py3);\n}\n\n// Cubic Bezier for single points. Note that TesselateCubic is faster by using deltas.\n// Result is returned as a new {x,y} or written to optionalTarget.\nexport function getCubeBezierPoint(t, px1, py1, px2, py2, px3, py3, px4, py4, optionalTarget) {\n\n  var result = optionalTarget || { x: x, y: y };\n\n  var k = 1 - t;\n\n  // Bernstein coefficients\n  var bp1 = k * k * k;\n  var bp2 = 3 * k * k * t;\n  var bp3 = 3 * k * t * t;\n  var bp4 = t * t * t;\n\n  result.x = bp1 * px1 + bp2 * px2 + bp3 * px3 + bp4 * px4;\n  result.y = bp1 * py1 + bp2 * py2 + bp3 * py3 + bp4 * py4;\n\n  return result;\n}","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport { Math2D } from './Math2D.js';\nimport { Svg } from './Svg.js';\nimport { computeLoopContainment } from './LoopContainment.js';\n\nvar nextShapeId = 1;\n\nvar av = Autodesk.Viewing;\n\nvar toColor = function toColor(r, g, b) {\n  return \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n};\n\nvar cloneVectorArray = function cloneVectorArray(src) {\n  return src.map(function (p) {return { x: p.x, y: p.y };});\n};\n\n// Default arc tessellation params that we use for area computations. (see Bezier.js)\n// We use smaller min segment length than for drawing, because the DefaultTessParams would cause too inaccurate measurements.\n// TODO: Replace by more accurate and faster analytic computation to replace brute-force tesselation completely.\nvar AreaTessParam = {\n  numIterations: 100,\n  minSegLenFraction: 0.01 };\n\n\nvar tmpVec3 = new THREE.Vector3();\nvar tmpVec3_2 = new THREE.Vector3();\nvar tmpBox2 = new THREE.Box2();\nvar tmpVec2 = new THREE.Vector2();\n\nexport var Style = /*#__PURE__*/function () {\n\n  /**\n                                              * Creates a new Style for the Edit 2D tools.\n                                              * @param {object} [params]           - various style values to overwrite the default style.\n                                              * @param {string} [params.color]     - sets the color for the line and fill area\n                                              * @param {number} [params.alpha]     - sets the alpha value for the line and fill area\n                                              * @param {string} [params.lineColor] - sets the color for the line\n                                              * @param {number} [params.lineAlpha] - sets the alpha value for the line\n                                              * @param {number} [params.lineWidth] - sets the line width for the line.\n                                              * @param {number} [params.lineStyle] - sets the style of the line\n                                              * @param {string} [params.fillColor] - sets the color for the fill area\n                                              * @param {number} [params.fillAlpha] - sets the alpha value for the fill area\n                                              */\n  function Style() {var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, Style);\n    this.lineColor = params.lineColor || params.color || \"rgb(0,0,128)\";\n    this.lineAlpha = params.lineAlpha !== undefined ? params.lineAlpha : params.alpha !== undefined ? params.alpha : 1.0;\n    this.lineWidth = params.lineWidth !== undefined ? params.lineWidth : 3.0;\n\n    this.fillColor = params.fillColor || params.color || \"rgb(0,0,128)\";\n    this.fillAlpha = params.fillAlpha !== undefined ? params.fillAlpha : params.alpha !== undefined ? params.alpha : 0.2;\n\n    // lineStyle is an index into a list of dash/dot patterns defined in See LineStyleDef.js.\n    // Examples:\n    //   0:  Solid line:    ______________\n    //   10: Dashes long:   __ __ __ __ __\n    //   11: Dashes short:  _ _ _ _ _ _ _\n    //   12: Dashes longer: ___ ___ ___ ___\n    //   16: Dots:          . . . . . . .\n    //   17: Dots dense:    ..............\n    //   18: Dots sparse:   .  .  .  .  .\n    this.lineStyle = params.lineStyle || 0;\n\n    // By default, we interpret line widths in screen-space\n    this.isScreenSpace = params.isScreenSpace !== undefined ? params.isScreenSpace : true;\n    this.compositeOperation = 'source-over';\n  }\n\n  // Components r,b,g are in [0,255]\n  _createClass(Style, [{ key: \"setFillColor\", value: function setFillColor(r, g, b) {\n      this.fillColor = toColor(r, g, b);\n    } }, { key: \"setLineColor\", value: function setLineColor(\n\n    r, g, b) {\n      this.lineColor = toColor(r, g, b);\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Style().copy(this);\n    } }, { key: \"copy\", value: function copy(\n\n    from) {\n      this.lineColor = from.lineColor;\n      this.lineAlpha = from.lineAlpha;\n      this.lineWidth = from.lineWidth;\n      this.fillColor = from.fillColor;\n      this.fillAlpha = from.fillAlpha;\n      this.lineStyle = from.lineStyle;\n      this.isScreenSpace = from.isScreenSpace;\n      this.compositeOperation = from.compositeOperation;\n      return this;\n    } }]);return Style;}();\n\n\nStyle.toColor = toColor;\n\nvar DefaultStyle = new Style();\n\n// Add all points to given bbox.\nvar addPointsToBBox = function addPointsToBBox(points, dstBox) {\n  for (var i = 0; i < points.length; i++) {\n    dstBox.expandByPoint(points[i]);\n  }\n};\n\nexport var Shape = /*#__PURE__*/function (_av$EventDispatcher) {_inherits(Shape, _av$EventDispatcher);var _super = _createSuper(Shape);\n  function Shape() {var _this;var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultStyle.clone();_classCallCheck(this, Shape);\n    _this = _super.call(this);\n\n    _this.style = style;\n\n    // assign unique id\n    _this.id = nextShapeId++;\n\n    _this.bbox = new THREE.Box2();\n    _this.bboxDirty = true;\n\n    // If false, it is skipped by EditLayer traversals\n    _this.visible = true;\n\n    // whether users can move this shape by clicking and dragging.\n    _this.movable = true;\n\n    // whether users can select this shape. If false, clicks on this shape will not select it, and by consequence it\n    // won't be editable either.\n    _this.selectable = true;\n\n    // Should be set by creator by something more descriptive.\n    _this.name = _this.id.toString();return _this;\n  }\n\n  // Must be provided by derivaties\n  _createClass(Shape, [{ key: \"draw\", value: function draw() /*ctx, overrideStyle*/{} }, { key: \"hitTest\", value: function hitTest()\n    /*x, y, hitRadius*/{} // hitRadius is a distance in layer-coords used for line feature hit-tests.\n  }, { key: \"move\", value: function move()\n    /*dx, dy*/{return this;}\n\n    // Apply a transform to each point. (assuming z=0)\n    // @param {Matrix4}\n  }, { key: \"applyMatrix4\", value: function applyMatrix4(matrix) {return this;} }, { key: \"clone\", value: function clone()\n\n    {\n      return new Shape().copy(this);\n    } }, { key: \"copy\", value: function copy(\n\n    from) {\n      this.style = from.style.clone();\n      return this;\n    } }, { key: \"computeBBox\", value: function computeBBox()\n\n    {\n      console.error(\"Must be implemented by derived class.\");\n    } }, { key: \"modified\", value: function modified()\n\n    {\n      this.bboxDirty = true;\n      this.fireEvent({ type: Shape.Events.MODIFIED });\n    } }, { key: \"updateBBox\", value: function updateBBox()\n\n    {\n      if (this.bboxDirty) {\n        this.computeBBox();\n        this.bboxDirty = false;\n      }\n    }\n\n    // Return bbox while making sure that it's up-to-date.\n  }, { key: \"getBBox\", value: function getBBox() {\n      this.updateBBox();\n      return this.bbox;\n    }\n\n    // @param {string}  svg - e.g. '<path d=\"M 13,4 L 14,4\"/>'\n  }, { key: \"toSVG\",\n\n\n\n    // Convert to SVG style string, e.g., '<path d=\"M 13,4 L 14,4\"/>'\n    // See Svg.toSvg() comment for options.\n    //\n    // Note: The digits param is deprecated and only exists for legacy reasons. \n    //       Set digits via options.digits instead.\n    value: function toSVG(options, digits) {\n      return Svg.toSvg(this, options, digits);\n    }\n\n    // Converts shape into a DOM element (usually a <path>).\n    //  @param {Object} \n    //  @param {bool}   [options.exportStyle=true]\n  }, { key: \"createSvgShape\", value: function createSvgShape(options) {\n      return Svg.toSvgElement(this, options);\n    } }, { key: \"setVisible\", value: function setVisible(\n\n    visible) {\n      this.visible = visible;\n    } }], [{ key: \"fromSVG\", value: function fromSVG(svg) {return Svg.fromSvg(svg);} }]);return Shape;}(av.EventDispatcher);\n\n\nShape.Events = {\n  MODIFIED: 'modified' };\n\n\nav.GlobalManagerMixin.call(Shape.prototype);\n\nexport var LoopType = {\n  Empty: 0, // Loop is empty or does not exist\n  Inner: 1,\n  Outer: 2,\n  Overlapping: 3 // Loop is intersecting itself or other loops\n};\n\n// Common base class for Polygons and Polylines\nexport var PolyBase = /*#__PURE__*/function (_Shape) {_inherits(PolyBase, _Shape);var _super2 = _createSuper(PolyBase);\n\n  function PolyBase() {var _this2;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, PolyBase);\n    _this2 = _super2.call(this, style);\n\n    // Array of Array of points, each represented as an object {x, y}\n    // By default, we start with a single loop/chain\n    _this2._loops = points ? [points] : [];\n\n    // Set by derived classes\n    _this2.isClosed = undefined;\n\n    // Computed on-demand: Provides extra information about how loops are nested.\n    _this2._loopInfos = null;return _this2;\n  }\n\n  // For backward compatibility\n  _createClass(PolyBase, [{ key: \"allocPoints\",\n\n\n\n\n\n\n\n\n    // acquire a number of additional points in the given loop. Each has initial coords (0,0)\n    value: function allocPoints(numPoints) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      for (var i = 0; i < numPoints; ++i) {\n        this.addPoint(0, 0, loopIndex);\n      }\n      return this;\n    } }, { key: \"isPolygon\", value: function isPolygon()\n\n    {return this.isClosed;} }, { key: \"isPolyline\", value: function isPolyline()\n    {return !this.isClosed;} }, { key: \"isPath\", value: function isPath()\n\n    {\n      return this instanceof Path;\n    } }, { key: \"addPoint\", value: function addPoint(\n\n    x, y) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // get or create loop\n      var loop = this._loops[loopIndex] || (this._loops[loopIndex] = []);\n\n      // add point to loop\n      var point = { x: x, y: y };\n      loop.push(point);\n      this.modified();\n      return point;\n    } }, { key: \"getPoint\", value: function getPoint(\n\n    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();\n\n      // Legacy fallback (deprecated): This can be removed as soon as no code\n      // is passing a target vector without a loop index\n      if (_typeof(loopIndex) === 'object') {\n        target = loopIndex;\n        loopIndex = 0;\n      }\n\n      return target.copy(this._loops[loopIndex][index]);\n    } }, { key: \"removePoint\", value: function removePoint(\n\n    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this._loops[loopIndex].splice(index, 1);\n    } }, { key: \"updatePoint\", value: function updatePoint(\n\n    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var p = this._loops[loopIndex][index];\n      p.x = x;\n      p.y = y;\n      this.modified();\n    } }, { key: \"insertPoint\", value: function insertPoint(\n\n    index, p) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this._loops[loopIndex].splice(index, 0, p);\n    } }, { key: \"getVertexCount\",\n\n\n\n\n\n\n\n\n\n\n\n    // Returns 0 if a loop is empty or does not exist.\n    value: function getVertexCount() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      // Array may not exist yet if no vertices were added to the loop yet.\n      var loop = this._loops[loopIndex];\n      return loop ? loop.length : 0;\n    }\n\n    // Reset back to a single empty loop\n  }, { key: \"clear\", value: function clear() {\n      this._loops = [];\n      this.modified();\n    }\n\n    // Enumerate all edges (a,b).\n    //  @param {function(a, b, ai, bi)} cb - For each edge, we trigger cb(a, b, ai, bi), where (a,b) are the points and (ai, bi) the indices of the edge.\n    //                                       If cb() returns true, the traversal stops.\n  }, { key: \"enumEdges\", value: function enumEdges(cb) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      // get edge count\n      var edgeCount = this.getEdgeCount(loopIndex);\n\n      // check for each edge whether p is close to it.\n      for (var i = 0; i < edgeCount; i++) {\n        // get indices\n        var ai = i;\n        var bi = this.nextIndex(i, loopIndex);\n\n        // get points\n        var a = this.getPoint(ai, loopIndex);\n        var b = this.getPoint(bi, loopIndex);\n\n        // pass all to cb\n        var stop = cb(a, b, ai, bi);\n\n        // allow early out\n        if (stop) {\n          return;\n        }\n      }\n    }\n\n    // Given a polyline or polygon, it checks if the position is close to any edge of the shape.\n    // If so, it returns the index of that edge, otherwise -1.\n    // All values are in layer coords.\n  }, { key: \"findEdgeIndex\", value: function findEdgeIndex(p, precision) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var edgeIndex = -1;\n\n      // Callback to find edge containing p\n      var findEdgeCb = function findEdgeCb(a, b, ai) {\n\n        // If edge contains p, store its edge index\n        var containsP = Math2D.isPointOnEdge(p, a, b, precision);\n        if (containsP) {\n          edgeIndex = ai;\n        }\n\n        // Stop on success\n        return containsP;\n      };\n      this.enumEdges(findEdgeCb, loopIndex);\n      return edgeIndex;\n    } }, { key: \"moveLoop\", value: function moveLoop(\n\n    dx, dy, loopIndex) {\n      var points = this._loops[loopIndex];\n      for (var i = 0; i < points.length; i++) {\n        points[i].x += dx;\n        points[i].y += dy;\n      }\n      this.modified();\n    } }, { key: \"move\", value: function move(\n\n    dx, dy) {\n      for (var l = 0; l < this.loopCount; l++) {\n        this.moveLoop(dx, dy, l);\n      }\n      return this;\n    }\n\n    // Note: Ellipse arcs only support simple transforms (translation, rotation, uniform scaling)\n    // @param {THREE.Matrix4}\n  }, { key: \"applyMatrix4\", value: function applyMatrix4(matrix) {\n\n      for (var l = 0; l < this.loopCount; l++) {\n        var points = this._loops[l];\n\n        for (var i = 0; i < points.length; i++) {\n          var p = points[i];\n\n          // set target to (x,y) * matrix\n          var transformPoint = function transformPoint(x, y, target) {\n            // convert to vec3, transform, and write back to target\n            var vec3 = tmpVec3.set(x, y, 0).applyMatrix4(matrix);\n            target.x = vec3.x;\n            target.y = vec3.y;\n            return target;\n          };\n\n          transformPoint(p.x, p.y, p);\n\n          // transform Bezier control points\n          if (this.isBezierArc(i, l)) {\n            var cp = transformPoint(p.cp1x, p.cp1y, tmpVec3);\n            p.cp1x = cp.x;\n            p.cp1y = cp.y;\n\n            cp = transformPoint(p.cp2x, p.cp2y, tmpVec3);\n            p.cp2x = cp.x;\n            p.cp2y = cp.y;\n          }\n\n          // Transform ellipse arcs\n          // Note: Currently, this only works for simple transforms (translate, rotate, uniform scale)\n          if (this.isEllipseArc(i, l)) {\n            p.ellipseArcParams.applyMatrix4(matrix);\n          }\n        }\n      }\n      this.modified();\n      return this;\n    }\n\n    // Copy a single loop from src poly and adds it to this one\n    //  @param {PolyBase} srcPoly\n    //  @param {number}   srcLoopIndex - must be a valid loopIndex of src\n    //  @param {number} [dstLoopIndex] Optional: index where to insert the new loop. By default, we use the first free loopIndex.\n  }, { key: \"addLoop\", value: function addLoop(srcPoly) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var dstLoopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      // copy loop points\n      var srcLoop = srcPoly._loops[srcLoopIndex];\n      var newLoop = cloneVectorArray(srcLoop);\n\n      // insert new loop\n      var newIndex;\n      if (dstLoopIndex === -1) {\n        // find a free loop index to store the new loop\n        newIndex = this.nextFreeLoop();\n        this._loops[newIndex] = newLoop;\n      } else {\n        // insert new loop at given index\n        newIndex = dstLoopIndex;\n        this._loops.splice(newIndex, 0, newLoop);\n      }\n      this.modified();\n\n      return newIndex;\n    }\n\n    // Removes any empty loops, so that any loop i for 0<i<this.loopCount contains points.\n  }, { key: \"cleanupLoops\", value: function cleanupLoops() {\n      this._loops = this._loops.filter(function (l) {return l && l.length > 0;});\n      this.modified();\n    } }, { key: \"copyGeometry\", value: function copyGeometry(\n\n    srcPoly) {\n      this.isClosed = srcPoly.isClosed;\n\n      // copy loops\n      this._loops = [];\n      for (var i = 0; i < srcPoly.loopCount; i++) {\n        this.addLoop(srcPoly, i);\n      }\n      return this;\n    } }, { key: \"copy\", value: function copy(\n\n    srcPoly) {\n      _get(_getPrototypeOf(PolyBase.prototype), \"copy\", this).call(this, srcPoly);\n      return this.copyGeometry(srcPoly);\n    } }, { key: \"computeBBox\", value: function computeBBox()\n\n    {\n      this.bbox.makeEmpty();\n      for (var i = 0; i < this.loopCount; i++) {\n        var loop = this._loops[i];\n        if (loop) {\n          addPointsToBBox(loop, this.bbox);\n        }\n      }\n      return this.bbox;\n    } }, { key: \"indexValid\", value: function indexValid(\n\n    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return index >= 0 && index < this.getVertexCount(loopIndex);\n    }\n\n    // Returns -1 if there is no next Index    \n  }, { key: \"nextIndex\", value: function nextIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Return -1 for invalid input\n      if (!this.indexValid(index, loopIndex)) {\n        return -1;\n      }\n\n      // Handle last vertex\n      var isLast = index === this.getVertexCount(loopIndex) - 1;\n      if (isLast) {\n        // If closed, restart. Otherwise, there is no next index.\n        return this.isClosed ? 0 : -1;\n      }\n\n      return index + 1;\n    }\n\n    // Returns -1 if there is no previous vertex index\n  }, { key: \"prevIndex\", value: function prevIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Return -1 for invalid input\n      if (!this.indexValid(index, loopIndex)) {\n        return -1;\n      }\n\n      // Handle first vertex\n      if (index === 0) {\n        // if closed, continue at end. Otherwise, there is no previous index.\n        var vertexCount = this.getVertexCount(loopIndex);\n        return this.isClosed ? vertexCount - 1 : -1;\n      }\n\n      return index - 1;\n    }\n\n    // Returns index of the edge ending at the given vertex or -1 if it does not exist.\n  }, { key: \"edgeBeforeVertex\", value: function edgeBeforeVertex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.prevIndex(index, loopIndex);\n    }\n\n    // Returns index of the edge starting at the given vertex.\n    // Returns -1 if index is the end vertex of a polyline.\n  }, { key: \"edgeAfterVertex\", value: function edgeAfterVertex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.edgeIndexValid(index, loopIndex) ? index : -1;\n    }\n\n    // Returns -1 if there is no previous edge.\n  }, { key: \"nextEdgeIndex\", value: function nextEdgeIndex(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Check edgeIndex validity\n      if (!this.edgeIndexValid(edgeIndex, loopIndex)) {\n        return -1;\n      }\n\n      // Return -1 for last polyline edge\n      if (!this.isClosed && edgeIndex === this.getEdgeCount(loopIndex) - 1) {\n        return -1;\n      }\n\n      return this.nextIndex(edgeIndex, loopIndex);\n    } }, { key: \"prevEdgeIndex\", value: function prevEdgeIndex(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Check edgeindex validity\n      if (!this.edgeIndexValid(edgeIndex, loopIndex)) {\n        return -1;\n      }\n\n      // Return -1 for first polyline edge\n      if (!this.isClosed && edgeIndex === 0) {\n        return -1;\n      }\n\n      return this.prevIndex(edgeIndex, loopIndex);\n    } }, { key: \"edgeIndexValid\", value: function edgeIndexValid(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var edgeCount = this.getEdgeCount(loopIndex);\n      return edgeIndex >= 0 && edgeIndex < edgeCount;\n    } }, { key: \"prevEdgeExists\", value: function prevEdgeExists(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var vertexCount = this.getVertexCount(loopIndex);\n      return this.edgeIndexValid(edgeIndex, loopIndex) && vertexCount > 2 && (edgeIndex > 0 || this.isClosed);\n    } }, { key: \"nextEdgeExists\", value: function nextEdgeExists(\n\n    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var vertexCount = this.getVertexCount(loopIndex);\n      var isLastEdge = edgeIndex === vertexCount - 2;\n      return this.edgeIndexValid(edgeIndex, loopIndex) && vertexCount > 2 && (!isLastEdge || this.isClosed);\n    }\n\n    // Copy start/end of an edge into outA, outB out params (Vector2).\n    // edgeIndex must be valid.\n  }, { key: \"getEdge\", value: function getEdge(edgeIndex, outA, outB) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var ia = edgeIndex;\n      var ib = this.nextIndex(edgeIndex, loopIndex);\n      this.getPoint(ia, loopIndex, outA);\n      this.getPoint(ib, loopIndex, outB);\n    } }, { key: \"getEdgeDirection\", value: function getEdgeDirection(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();\n      var ia = edgeIndex;\n      var ib = this.nextIndex(edgeIndex, loopIndex);\n      var loop = this._loops[loopIndex];\n      return Math2D.getEdgeDirection(loop[ia], loop[ib], target);\n    } }, { key: \"getEdgeLength\", value: function getEdgeLength(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var ia = edgeIndex;\n      var ib = this.nextIndex(edgeIndex, loopIndex);\n      var loop = this._loops[loopIndex];\n      var a = loop[ia];\n      var b = loop[ib];\n      return Math2D.getEdgeLength(a, b);\n    } }, { key: \"getEdgeCount\", value: function getEdgeCount()\n\n    {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var vertexCount = this.getVertexCount(loopIndex);\n      return this.isClosed ? vertexCount : vertexCount - 1;\n    }\n\n    // Return the summed edge length for Polygons and Polylines.\n    //\n    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space\n  }, { key: \"getLength\", value: function getLength(measureTransform) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var a = new THREE.Vector2();\n      var b = new THREE.Vector2();\n      var sum = 0.0;\n      for (var i = 0; i < this.getEdgeCount(loopIndex); i++) {\n        this.getEdge(i, a, b, loopIndex);\n\n        // apply optional measure transform\n        if (measureTransform) {\n          measureTransform.apply(a);\n          measureTransform.apply(b);\n        }\n\n        sum += a.distanceTo(b);\n      }\n      return sum;\n    }\n\n    // Set vertices from THREE.Box2\n  }, { key: \"fromBox2\", value: function fromBox2(box) {\n      this.addPoint(box.min.x, box.min.y);\n      this.addPoint(box.max.x, box.min.y);\n      this.addPoint(box.max.x, box.max.y);\n      this.addPoint(box.min.x, box.max.y);\n      return this;\n    }\n\n    // Returns a point along an edge. Note that the edge may be an arc for Paths.\n    //  @param {number} edgeIndex   - A valid edgeIndex\n    //  @param {number} t           - in [0,1]. t=0: startPoint, t=1: endPoint\n    //  @param {number} [loopIndex]\n    //  @param {Vector2} [target]  \n  }, { key: \"getPointOnEdge\", value: function getPointOnEdge(edgeIndex, t) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();\n\n      var loop = this._loops[loopIndex];\n      var p0 = loop[edgeIndex];\n      var p1 = loop[this.nextIndex(edgeIndex, loopIndex)];\n      return target.lerpVectors(p0, p1, t);\n    }\n\n    // Checks if outer loop is counterclockwise. For polylines that doesn't form a loop, \n    // we assume an additional edge from end to start.\n    // @returns {bool}\n  }, { key: \"isCCW\", value: function isCCW() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return Autodesk.Extensions.CompGeom.polygonArea(this._loops[loopIndex]) > 0;\n    }\n\n    // Return 2D edge normal\n  }, { key: \"getLeftEdgeNormal\", value: function getLeftEdgeNormal(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();\n\n      var points = this._loops[loopIndex];\n\n      // get start/end point of the edge\n      var vi1 = edgeIndex;\n      var vi2 = (edgeIndex + 1) % points.length;\n      var v1 = points[vi1];\n      var v2 = points[vi2];\n\n      // get edge direction\n      target.subVectors(v2, v1).normalize();\n\n      // rotate by 90 degrees\n      var tmp = target.x;\n      target.x = -target.y;\n      target.y = tmp;\n\n      return target;\n    }\n\n    // Get edge normal facing outside wrt. to the loop containing the edge. If the contour is not closed, we\n    // assume an additional connection between endpoint and startpoint to defined \"outside\".\n  }, { key: \"getOuterNormal\", value: function getOuterNormal(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();\n      var normal = this.getLeftEdgeNormal(edgeIndex, loopIndex, target);\n      return this.isCCW(loopIndex) ? normal.multiplyScalar(-1) : normal;\n    }\n\n    // Returns the first loopIndex >=0 that doesn't contain any points yet.\n    //  @param {number}\n  }, { key: \"nextFreeLoop\", value: function nextFreeLoop() {\n      var isFree = function isFree(l) {return !l || !l.length;};\n      var index = this._loops.findIndex(isFree);\n      return index >= 0 ? index : this.loopCount;\n    }\n\n    // Seaches all loops to find a vertex for which cb(vertexIndex, loopIndex) returns true.    \n    //  @{function(vertexIndex, loopIndex)=>bool} searchFilter   \n    //  @returns {Object|null}                    A {vertexIndex, loopIndex} pair on success. Otherwise null.\n  }, { key: \"findVertex\", value: function findVertex(searchFilter) {\n      for (var l = 0; l < this.loopCount; l++) {\n        var len = this.getVertexCount(l);\n        for (var i = 0; i < len; i++) {\n          if (searchFilter(i, l)) {\n            return {\n              vertexIndex: i,\n              loopIndex: l };\n\n          }\n        }\n      }\n      return null;\n    }\n\n    // Returns true if poly does not contain any (non-empty loops)\n  }, { key: \"empty\", value: function empty() {\n      return !this._loops.some(function (loop) {return loop && loop.length > 0;});\n    } }, { key: \"modified\", value: function modified()\n\n    {\n      _get(_getPrototypeOf(PolyBase.prototype), \"modified\", this).call(this);\n\n      // Loop containment may have changed\n      this._loopInfos = null;\n    }\n\n    // Returns true if the shape has overlapping loops\n  }, { key: \"isSelfIntersecting\", value: function isSelfIntersecting() {\n\n      // Todo: Currently, we only detect overlaps between different loops. We also\n      //       have to track self-intersections within a single loop.\n\n\n      // Check if we have multiple overlapping loops\n      var loopInfos = this._getLoopInfos();\n      return loopInfos && loopInfos.some(function (l) {return l.error;});\n    } }, { key: \"_getLoopInfos\", value: function _getLoopInfos()\n\n    {\n      // Loop infos are only needed for closed paths with 2 or more loops\n      if (!this.isClosed || this.loopCount < 1) {\n        return undefined;\n      }\n\n      // Reuse if already available\n      if (!this._loopInfos) {\n        this._loopInfos = computeLoopContainment(this);\n      }\n      return this._loopInfos;\n    }\n\n    // Only works for closed loops.\n  }, { key: \"getLoopType\", value: function getLoopType(loopIndex) {\n\n      if (!this.isClosed) {\n        return undefined;\n      }\n\n      if (!this.getVertexCount(loopIndex)) {\n        return LoopType.Empty;\n      }\n\n      // LoopInfo should always exist for closed non-empty loops\n      var infos = this._getLoopInfos();\n      var info = infos[loopIndex];\n\n      if (info.error) {\n        return LoopType.Overlapping;\n      }\n\n      // Even-odd-rule: Loops with even rank are outer ones.\n      return info.rank & 1 ? LoopType.Inner : LoopType.Outer;\n    }\n\n    // Get all loops (directly or indirectly) enclosed by the given one\n  }, { key: \"getChildLoops\", value: function getChildLoops(loopIndex) {\n      var infos = this._getLoopInfos();\n      var info = infos && infos[loopIndex];\n      return info ? info.containedLoops.slice() : [];\n    }\n\n    // Eliminiate all empty loops, so that loopCount matches the number of non-empty loops\n  }, { key: \"cleanupLoops\", value: function cleanupLoops() {\n      this._loops = this._loops.filter(function (l) {return l && l.length >= 0;});\n    }\n\n    // Returns all loops that are not enclosed by any other one. Only for closed shapes.\n  }, { key: \"getMainLoops\", value: function getMainLoops() {\n      var infos = this._getLoopInfos();\n      if (!infos) {\n        return [];\n      }\n\n      // Collect all rank-0 loops\n      var loops = [];\n      for (var i = 0; i < infos.length; i++) {\n        var info = infos[i];\n\n        // Skip empty or invalid loops\n        var type = this.getLoopType(i);\n        if (type !== LoopType.Outer) {\n          continue;\n        }\n\n        if (info.rank === 0) {\n          loops.push(i);\n        }\n      }\n      return loops;\n    }\n\n    // Remove loop. Remaining loop indices are shifted back by one \n  }, { key: \"removeLoop\", value: function removeLoop(loopIndex) {\n      this._loops.splice(loopIndex, 1);\n      this.modified();\n      return this;\n    }\n\n    // Remove multiple loop indices\n    // @param {number[]} \n  }, { key: \"removeLoops\", value: function removeLoops(loops) {\n      this._loops = this._loops.filter(function (l, i) {return !loops.includes(i);});\n    }\n\n    // Returns true if a point contains valid (i.e. finite) numbers.\n  }, { key: \"isPointFinite\", value: function isPointFinite(vertex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (!this.indexValid(vertex, loopIndex)) {\n        return false;\n      }\n\n      var points = this._loops[loopIndex];\n      var p = points[vertex];\n      return isFinite(p.x) && isFinite(p.y);\n    } }, { key: \"isLoopFinite\", value: function isLoopFinite(\n\n    loopIndex) {\n      var points = this._loops[loopIndex];\n      var count = points ? points.length : 0;\n      for (var i = 0; i < count; i++) {\n        if (!this.isPointFinite(i, loopIndex)) {\n          return false;\n        }\n      }\n      return true;\n    } }, { key: \"points\", get: function get() {// Create empty loop 0 if needed\n      return this._loops[0] || (this._loops[0] = []);} }, { key: \"loopCount\", get: function get() {return this._loops.length;} }, { key: \"length\", get: function get() {console.warn('poly.length is deprecated and will be removed. Please use poly.vertexCount property instead.');return this.points.length;} // for backwards compatibility\n  }, { key: \"vertexCount\", get: function get() {return this.points.length;} }]);return PolyBase;}(Shape);\n// Helper class to address a single vertex within a loop of a PolyBase.\n// Can also be used to address edges (by indexing its start vertex).\nexport var PolyIndex = /*#__PURE__*/function () {\n  function PolyIndex(_ref) {var _ref$vertex = _ref.vertex,vertex = _ref$vertex === void 0 ? 0 : _ref$vertex,_ref$loop = _ref.loop,loop = _ref$loop === void 0 ? 0 : _ref$loop;_classCallCheck(this, PolyIndex);\n    this.vertex = vertex;\n    this.loop = loop;\n  }_createClass(PolyIndex, [{ key: \"equals\", value: function equals(\n    v) {\n      return v && this.vertex === v.vertex && this.loop === v.loop;\n    } }]);return PolyIndex;}();\n\n\nexport var Polygon = /*#__PURE__*/function (_PolyBase) {_inherits(Polygon, _PolyBase);var _super3 = _createSuper(Polygon);\n\n  function Polygon() {var _this3;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polygon);\n    _this3 = _super3.call(this, points, style);\n    _this3.isClosed = true;return _this3;\n  }\n\n  // Draw Polygon into LmvCanvasContext\n  _createClass(Polygon, [{ key: \"draw\", value: function draw(ctx, overrideStyle) {\n      drawPath(ctx, this, overrideStyle);\n    }\n\n    // We use even-odd rule if a polygon has multiple loops: A point is considered inside if it\n    // is enclosed by an odd number of loops.\n  }, { key: \"hitTest\", value: function hitTest(x, y) {\n      if (!this.vertexCount) {\n        return false;\n      }\n\n      // Compute number of loops that enclose (x,y)\n      var rank = 0;\n      for (var l = 0; l < this.loopCount; l++) {\n        var loop = this._loops[l];\n        if (!loop) {\n          continue;\n        }\n\n        // set current loop as points\n        var cp = new Autodesk.Extensions.CompGeom.ComplexPolygon(loop);\n\n        // create dummy contour\n        // TODO: Consider generalizing pointInCountour() to make it usable for non-indexed polygons\n        var contour = [];\n        for (var i = 0; i < loop.length; i++) {\n          contour.push(i);\n        }\n\n        if (cp.pointInContour(x, y, contour)) {\n          rank++;\n        }\n      }\n\n      // Apply even-odd-rule\n      return Boolean(rank & 1);\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Polygon().copy(this);\n    }\n\n    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space\n  }, { key: \"getArea\", value: function getArea(measureTransform) {\n\n      if (!this.isClosed) {\n        return undefined;\n      }\n\n      // If there are multiple loops, we need loopInfos to distinguish inner and outer loops\n      var loopInfos = this._getLoopInfos();\n\n      var sumArea = 0;\n      for (var loopIndex = 0; loopIndex < this.loopCount; loopIndex++) {\n\n        // Skip degenerate loops\n        if (this.points.length < 3) {\n          continue;\n        }\n\n        // determine loop rank (number of other loops containing it)\n        // Note that loopInfos are null for single loops where we don't need them.\n        var loopInfo = loopInfos ? loopInfos[loopIndex] : null;\n        var rank = loopInfo ? loopInfo.rank : 0;\n\n        // Even-odd rule: Loops with odd rank are holes and contribute negatively\n        var sign = rank & 1 ? -1 : 1;\n\n        var loopArea = 0.0;\n        this.enumEdges(function (a, b) {\n          // apply optional transform\n          measureTransform && measureTransform.apply(a);\n          measureTransform && measureTransform.apply(b);\n\n          // sum up signed areas\n          loopArea += a.x * b.y - b.x * a.y;\n        }, loopIndex);\n        sumArea += sign * Math.abs(0.5 * loopArea);\n      }\n      return sumArea;\n    } }]);return Polygon;}(PolyBase);\n\n\nexport var Polyline = /*#__PURE__*/function (_PolyBase2) {_inherits(Polyline, _PolyBase2);var _super4 = _createSuper(Polyline);\n\n  function Polyline() {var _this4;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polyline);\n    _this4 = _super4.call(this, points, style);\n    _this4.isClosed = false;return _this4;\n  }_createClass(Polyline, [{ key: \"makeLine\", value: function makeLine()\n\n    {var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var x1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var y1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      if (this.vertexCount !== 2) {\n        this.clear();\n        this.addPoint(x0, y0);\n        this.addPoint(x1, y1);\n      } else {\n        this.updatePoint(0, x0, y0);\n        this.updatePoint(1, x1, y1);\n      }\n      return this;\n    }\n\n    // Draw Polyline into LmvCanvasContext\n  }, { key: \"draw\", value: function draw(ctx, overrideStyle) {\n      drawPath(ctx, this, overrideStyle);\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Polyline().copy(this);\n    }\n\n    // hitRadius is in layer-coords\n  }, { key: \"hitTest\", value: function hitTest(x, y, hitRadius) {\n      var edgeIndex = this.findEdgeIndex({ x: x, y: y }, hitRadius);\n      return edgeIndex !== -1;\n    } }]);return Polyline;}(PolyBase);\n\n\nexport var EdgeType = {\n  Line: 0, // Simple line segment\n  Bezier: 1, // Cubic Bezier Arc\n  Ellipse: 2 // Ellipse Arc\n};\n\n\n// Tmp objct for Ellipse Arcs. We need delayed initialization, \n// because Autodesk.Extensions.CompGeom might not be available yet at compile time.\nvar _tmpArc = null;\nvar getTmpArc = function getTmpArc() {\n  _tmpArc = _tmpArc || new Autodesk.Extensions.CompGeom.EllipseArc();\n  return _tmpArc;\n};\n\nvar tmpVec = new THREE.Vector2();\n\n// Helper function to run moveTo/lineTo/arcTo/closePath calls for a single loop of a path on a given context object.\n//  @param {Path2d|LmvCanvasContext|Object} ctx       - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)\n//  @param {Polyline|Polygon|Path}          path\n//  @param {number}                         loopIndex - must be a valid loop index in path\nvar runLoop = function runLoop(ctx, path, loopIndex) {\n\n  var points = path._loops[loopIndex];\n  if (!points || !points.length) {\n    return;\n  }\n\n  // Trying to fill paths with NaN or infinite numbers may cause hangs in clipper. So, we prevent those here.\n  if (!path.isLoopFinite(loopIndex)) {\n    console.warn(\"Skipped loop, because it contains Inf or NaN values. Shape ID: \".concat(path.id, \". LoopIndex: \").concat(loopIndex));\n    return;\n  }\n\n  ctx.moveTo(points[0].x, points[0].y);\n\n  var processSegment = function processSegment(pStart, pEnd, edgeIndex) {\n    switch (pStart.arcType) {\n      case EdgeType.Line:break;\n\n      case EdgeType.Bezier:{\n          ctx.bezierCurveTo(pStart.cp1x, pStart.cp1y, pStart.cp2x, pStart.cp2y, pEnd.x, pEnd.y);\n          return;\n        }\n\n      case EdgeType.Ellipse:{\n          var params = pStart.ellipseArcParams;\n          var arc = path.exportEllipseArc(edgeIndex, loopIndex, getTmpArc());\n\n          // ignore arcs with NaN values\n          if (!arc.isValid()) {\n            break;\n          }\n\n          if (ctx.ellipseArcTo) {\n            // Support SolidDef Path2D\n            ctx.ellipseArcTo(params.rx, params.ry, THREE.Math.degToRad(params.rotation), params.largeArcFlag, params.sweepFlag, pEnd.x, pEnd.y);\n          } else {\n            // For Autodesk.CompGeom (Path2D and LmvCanvasContext). Also compatible to CanvasContext and Path2D in HTML5.\n            ctx.ellipse(arc.cx, arc.cy, arc.rx, arc.ry, arc.rotation, arc.startAngle, arc.endAngle, arc.ccw);\n          }\n\n          return;\n        }}\n\n    ctx.lineTo(pEnd.x, pEnd.y);\n  };\n\n  for (var i = 1; i < points.length; i += 1) {\n    // The segment start point defines the type (line or arc)\n    var prev = points[i - 1];\n    var p = points[i];\n\n    processSegment(prev, p, i - 1);\n  }\n\n  if (path.isClosed) {\n    // add closing segment\n    var pLast = points[points.length - 1];\n    var pFirst = points[0];\n    processSegment(pLast, pFirst, points.length - 1);\n\n    ctx.closePath();\n  }\n};\n\n// Helper function to run moveTo/lineTo/arcTo/closePath calls on a given context object.\n//  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)\n//  @param {Polyline|Polygon|Path}          path\nexport var runPath = function runPath(ctx, path) {\n  for (var i = 0; i < path.loopCount; i++) {\n    runLoop(ctx, path, i);\n  }\n};\n\n// Draw Path to CanvasContext. Unified implementation for Path, Polyline, and Polygon\n//  @param {LmvCanvasContext}      ctx\n//  @param {Polyline|Polygon|Path} path\n//  @param {Style}                 [overrideStyle]\nvar drawPath = function drawPath(ctx, path, overrideStyle) {\n\n  if (!path.vertexCount) {\n    return;\n  }\n\n  var style = overrideStyle || path.style;\n  var c = ctx.canvasContext;\n  ctx.dbId = path.id;\n  ctx.lineStyle = style.lineStyle;\n  ctx.isScreenSpace = style.isScreenSpace;\n\n  var currentGlobalCompositeOp = c.globalCompositeOperation;\n  if (style.compositeOperation) {\n    c.globalCompositeOperation = style.compositeOperation;\n    // Make sure any previous shapes with a different blending are flushed first\n    ctx.flushBuffer(0, true);\n  }\n\n  ctx.beginPath();\n\n  // Run moveTo/lineTo/... commands on context\n  runPath(ctx, path);\n\n  // Draw fill for closed paths\n  if (path.isClosed) {\n    c.fillStyle = style.fillColor;\n    // Creates a gradient fill style.\n    if (style.fillColor.hasOwnProperty('colorStops')) {\n      var gradientData = ctx.createGradientData(style.fillColor);\n      var fillStyle = gradientData.getFillStyle(c);\n      c.fillStyle = fillStyle;\n    }\n    c.globalAlpha = style.fillAlpha;\n\n    ctx.fill();\n  }\n\n  // draw lines\n  c.strokeStyle = style.lineColor;\n  c.globalAlpha = style.lineAlpha;\n  c.lineWidth = style.lineWidth;\n\n  // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.\n  // For human eyes the line width is then the same width.\n  if (style.isScreenSpace) c.lineWidth *= window.devicePixelRatio;\n\n  ctx.stroke();\n\n  // restore default values\n  ctx.dbId = -1;\n  ctx.lineStyle = 0;\n  ctx.isScreenSpace = false;\n  c.globalCompositeOperation = currentGlobalCompositeOp;\n};\n\n// Extra params for cubic Bezier arc edges.\nvar BezierArcParams = /*#__PURE__*/function () {\n  function BezierArcParams() {_classCallCheck(this, BezierArcParams);\n    // control point 1 that defines start tangent\n    this.cp1x = 0;\n    this.cp1y = 0;\n\n    // control point 2 that defines end tangent\n    this.cp2x = 0;\n    this.cp2y = 0;\n  }_createClass(BezierArcParams, [{ key: \"copy\", value: function copy(\n\n    src) {\n      this.cp1x = src.cp1x;\n      this.cp1y = src.cp1y;\n      this.cp2x = src.cp2x;\n      this.cp2y = src.cp2y;\n      return this;\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new BezierArcParams().copy(this);\n    } }]);return BezierArcParams;}();\n\n\n// SVG compatible ellipse arc params\n// see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands\nexport var EllipseArcParams = /*#__PURE__*/function () {\n\n  function EllipseArcParams() {_classCallCheck(this, EllipseArcParams);\n    // {number} Radius along x-axis\n    this.rx = 0;\n\n    // {number} Radius along y-axis\n    this.ry = 0;\n\n    // {number} ccw rotation of x/y-axes in degrees\n    this.rotation = 0;\n\n    // {bool} whether to use shorter or longer path around ellipse.\n    this.largeArcFlag = false;\n\n    // {bool} Whether to go ccw (true) or cw (false) from startAngle. See SVG docs link above for details.\n    this.sweepFlag = false;\n  }_createClass(EllipseArcParams, [{ key: \"copy\", value: function copy(\n\n    src) {\n      this.rx = src.rx;\n      this.ry = src.ry;\n      this.rotation = src.rotation;\n      this.largeArcFlag = src.largeArcFlag;\n      this.sweepFlag = src.sweepFlag;\n      return this;\n    } }, { key: \"clone\", value: function clone()\n    {\n      return new EllipseArcParams().copy(this);\n    }\n\n    // @param {number} angle - counterclockwise in degrees\n  }, { key: \"rotate\", value: function rotate(angle) {\n\n      this.rotation += angle;\n\n      // Normalize angle to keep within [0,360]\n      this.rotation -= Math.trunc(this.rotation / 360) * 360;\n    } }, { key: \"scale\", value: function scale(\n\n    factor) {\n      this.rx *= factor;\n      this.ry *= factor;\n    }\n\n    // updates arc params according to a given transform.\n    // Note: Transforming ellipse arcs is currently only supported for \n    //       simple transforms like translation, rotation, and uniform scaling.\n  }, { key: \"applyMatrix4\", value: function applyMatrix4(matrix) {\n\n      // apply transform to x-axis direction\n      tmpVec3.set(1, 0, 0).applyMatrix4(matrix);\n      tmpVec3_2.set(0, 0, 0).applyMatrix4(matrix);\n      var axis = tmpVec3.sub(tmpVec3_2);\n\n      // obtain rotation angle and scale (assuming uniform scaling)\n      var rotAngle = THREE.Math.radToDeg(Math.atan2(axis.y, axis.x));\n      var scale = axis.length();\n\n      // update ellipse params\n      this.rotate(rotAngle);\n      this.scale(scale);\n\n      // If a transform changes the orientation, we have to invert sweepFlag and rotation param\n      if (Math2D.changesOrientation(matrix)) {\n        this.sweepFlag = !this.sweepFlag;\n        this.rotation = 360.0 - this.rotation;\n      }\n    } }]);return EllipseArcParams;}();\n\n\nexport var Path = /*#__PURE__*/function (_PolyBase3) {_inherits(Path, _PolyBase3);var _super5 = _createSuper(Path);\n\n  function Path(points) {var _this5;var isClosed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultStyle.clone();_classCallCheck(this, Path);\n    _this5 = _super5.call(this, points, style);\n\n    // If true, the path is automatically closed and can be filled.\n    _this5.isClosed = isClosed;return _this5;\n  }\n\n  // Updates ellipse arc of an edge if vertices of the edges are going to be modified   \n  // @param {number} edgeIndex   - must be valid. Edge vertices must be in state _before_ modification.\n  // @param {number} loopIndex   - must be valid. \n  // @param {Vector2} newA, newB - edge vertices after modification\n  _createClass(Path, [{ key: \"_updateEllipseArcParams\", value: function _updateEllipseArcParams(edgeIndex, loopIndex, newA, newB) {\n\n      var params = this._loops[loopIndex][edgeIndex].ellipseArcParams;\n\n      // compute angle by which the edge was rotated\n      var oldDir = this.getEdgeDirection(edgeIndex, loopIndex);\n      var newDir = Math2D.getEdgeDirection(newA, newB);\n      var dAngle = Math2D.angleBetweenDirections(newDir, oldDir);\n\n      params.rotate(THREE.Math.radToDeg(dAngle));\n\n      // get scale factor applied to the edge\n      var oldLength = this.getEdgeLength(edgeIndex, loopIndex);\n      var newLength = Math2D.distance2D(newA, newB); // also works for simple {x,y} pairs\n      var scale = newLength / oldLength;\n\n      // scale ellipse radii (if scaling is valid)\n      var scaleValid = isFinite(scale) && scale > 0; // zero-radii do not work\n      if (scaleValid) {\n        params.scale(scale);\n      }\n    } }, { key: \"updatePoint\", value: function updatePoint(\n\n    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n      var points = this._loops[loopIndex];\n      var p = points[index];\n\n      var pNew = tmpVec.set(x, y);\n\n      // If p is adjacent to a BezierArc segment, the tangent should keep the same after changing the position\n      // Therefore, we change the corresponding control points as well\n      var dx = x - p.x;\n      var dy = y - p.y;\n\n      // Control point for the start tangent of the arc segment starting at p\n      if (this.isBezierArc(index, loopIndex)) {\n        p.cp1x += dx;\n        p.cp1y += dy;\n      }\n\n      // Update ellipse arc starting at p\n      if (this.isEllipseArc(index, loopIndex)) {\n        // next point must exist if index is a valid ellipse-arc edge.\n        var nextIndex = this.nextIndex(index, loopIndex);\n        var pNext = points[nextIndex];\n        this._updateEllipseArcParams(index, loopIndex, pNew, pNext);\n      }\n\n      // Update arc params of segment ending at p\n      // Note: For polylines, this edge does not exist for index==0\n      var prevEdge = this.edgeBeforeVertex(index, loopIndex);\n      if (this.edgeIndexValid(prevEdge, loopIndex)) {\n\n        // get previous vertex\n        var pPrev = points[prevEdge];\n\n        // Update bezier control point\n        if (this.isBezierArc(prevEdge, loopIndex)) {\n          pPrev.cp2x += dx;\n          pPrev.cp2y += dy;\n        }\n\n        // Update ellipse arc\n        if (this.isEllipseArc(prevEdge, loopIndex)) {\n          this._updateEllipseArcParams(prevEdge, loopIndex, pPrev, pNew);\n        }\n      }\n\n      p.x = x;\n      p.y = y;\n      this.modified();\n    } }, { key: \"getEdgeType\", value: function getEdgeType(\n\n    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var type = this._loops[loopIndex][segmentIndex].arcType;\n      return type ? type : EdgeType.Line;\n    }\n\n    // Change segment into a cubic Bezier arc.\n    // First and last control point are already given by the vertex positions.    \n    //        \n    //  @param {number}             segmentIndex - must be in [0, this.getEdgeCount(loopIndex)]\n    //  @param {BezierArcParams}    params\n    //  @param {number} [loopIndex]\n  }, { key: \"setBezierArc\", value: function setBezierArc(segmentIndex, params) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      // Legacy support:\n      // If cp1x, cp2x etc. are enlisted individually, reshape params to expected form.\n      // It's a pain that JS doesn't have function overloads.\n      var isParamObj = _typeof(params) === 'object';\n      if (!isParamObj) {\n        params = {\n          cp1x: params,\n          cp1y: loopIndex,\n          cp2x: arguments.length <= 3 ? undefined : arguments[3],\n          cp2y: arguments.length <= 4 ? undefined : arguments[4] };\n\n        loopIndex = (arguments.length <= 5 ? undefined : arguments[5]) || 0;\n      }\n\n      var p = this._loops[loopIndex][segmentIndex];\n      p.arcType = EdgeType.Bezier;\n      BezierArcParams.prototype.copy.call(p, params);\n\n      this.modified();\n    } }, { key: \"getBezierArcParams\", value: function getBezierArcParams(\n\n    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BezierArcParams();\n      // Find params\n      var p = this._loops[loopIndex][segmentIndex];\n      var srcParams = p && p.arcType === EdgeType.Bezier && p;\n\n      // return a copy if found, otherwise undefined\n      return srcParams && target.copy(srcParams);\n    }\n\n    // Set ellipse arc segment. Parameters are the same as for SVG ellipse arcs.\n    // see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands\n    //\n    //  @param {number}   segmentIndex - must be in [0, this.getEdgeCount()]\n    //  @param {EllipseArcParams} arcParams \n  }, { key: \"setEllipseArc\", value: function setEllipseArc(segmentIndex, arcParams) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var p = this._loops[loopIndex][segmentIndex];\n\n      p.arcType = EdgeType.Ellipse;\n      p.ellipseArcParams = arcParams.clone();\n\n      this.modified();\n    }\n\n    // @param {number}           segmentIndex - must be a valid ellipse-arc edge\n    // @param {EllipseArcParams} target\n    // @returns {EllipseArcParams}\n  }, { key: \"getEllipseArcParams\", value: function getEllipseArcParams(segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new EllipseArcParams();\n\n      // Find params\n      var p = this._loops[loopIndex][segmentIndex];\n      var srcParams = p && p.arcType === EdgeType.Ellipse && p.ellipseArcParams;\n\n      // Return a copy if found, otherwise undefined.\n      return srcParams && target.copy(srcParams);\n    }\n\n    // Configures an EllipseArc curve to match with an ellipse-arc edge. This allows for sampling the arc.\n    //  @param {number}     edgeIndex     - must be an ellipse arc\n    //  @param {number}     [loopIndex=0] - loopIndex\n    //  @param {EllipseArc} [target]      - optional\n    //  @returns {EllipseArc}\n  }, { key: \"exportEllipseArc\", value: function exportEllipseArc(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new EllipseArc();\n\n      var points = this._loops[loopIndex];\n\n      // get start/end points\n      var nextIndex = this.nextIndex(edgeIndex, loopIndex);\n      var pStart = points[edgeIndex];\n      var pEnd = points[nextIndex];\n      var params = pStart.ellipseArcParams;\n\n      target.setFromSvgArc(\n      params.rx,\n      params.ry,\n      params.rotation,\n      params.largeArcFlag,\n      params.sweepFlag,\n      pStart,\n      pEnd);\n\n      return target;\n    } }, { key: \"isBezierArc\", value: function isBezierArc(\n\n    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.edgeIndexValid(segmentIndex, loopIndex) && this._loops[loopIndex][segmentIndex].arcType === EdgeType.Bezier;\n    } }, { key: \"isEllipseArc\", value: function isEllipseArc(\n\n    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.edgeIndexValid(segmentIndex, loopIndex) && this._loops[loopIndex][segmentIndex].arcType === EdgeType.Ellipse;\n    } }, { key: \"isArc\", value: function isArc(\n\n    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.isBezierArc(segmentIndex, loopIndex) || this.isEllipseArc(segmentIndex, loopIndex);\n    }\n\n    // Get tangent vector pointing from start vertex to control point 1 of an arc segment.\n    // Only allowed for Bezier arcs. Result is not normalized.\n    //  @param {number} segmentIndex - must be a valid index of an arc segment.\n    //  @returns {Vector2}\n  }, { key: \"getStartTangent\", value: function getStartTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var target = outTarget || new THREE.Vector2();\n      var p = this.points[segmentIndex];\n      target.x = p.cp1x - p.x;\n      target.y = p.cp1y - p.y;\n      return target;\n    }\n\n    // Get tangent vector pointing from end vertex to control point 2 of an arc segment.\n    //  @param {number} segmentIndex - must be a valid index of an arc segment.\n    //  @returns {Vector2}\n  }, { key: \"getEndTangent\", value: function getEndTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var target = outTarget || new THREE.Vector2();\n      var endVertex = this.nextIndex(segmentIndex);\n\n      // get start/end point of the segment\n      var pStart = this.points[segmentIndex];\n      var pEnd = this.points[endVertex];\n      target.x = pStart.cp2x - pEnd.x;\n      target.y = pStart.cp2y - pEnd.y;\n      return target;\n    }\n\n    //  @param {number} segmentIndex - must be a valid index of an arc segment.\n    //  @param {Vector2} tangent\n  }, { key: \"setStartTangent\", value: function setStartTangent(segmentIndex, tangent) {\n      var p = this.points[segmentIndex];\n      p.cp1x = p.x + tangent.x;\n      p.cp1y = p.y + tangent.y;\n      this.modified();\n    }\n\n    //  @param {number} segmentIndex - must be a valid index of an arc segment.\n    //  @param {Vector2} tangent\n  }, { key: \"setEndTangent\", value: function setEndTangent(segmentIndex, tangent) {\n      var p = this.points[segmentIndex];\n      var pEnd = this.points[this.nextIndex(segmentIndex)];\n      p.cp2x = pEnd.x + tangent.x;\n      p.cp2y = pEnd.y + tangent.y;\n      this.modified();\n    }\n\n    // Change Bezier or Ellipse arc back to simple line segment\n  }, { key: \"removeArc\", value: function removeArc(segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var p = this._loops[loopIndex][segmentIndex];\n\n      if (p.arcType === EdgeType.Bezier) {\n        p.cp1x = undefined;\n        p.cp1y = undefined;\n        p.cp2x = undefined;\n        p.cp2y = undefined;\n      }\n\n      if (p.ellipseArcParams) p.ellipseArcParams = undefined;\n\n      // reset type\n      p.arcType = EdgeType.Line;\n\n      this.modified();\n    }\n\n    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true\n    // @param {number} segmentIndex\n    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by\n    //                                  current vertex position\n    // @param {Vector2} [target]\n    // @param {number}  [loopIndex]\n  }, { key: \"getControlPoint\", value: function getControlPoint(segmentIndex, ctrlPointIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();\n      var p = this._loops[loopIndex][segmentIndex];\n\n      if (ctrlPointIndex === 1) {\n        target.x = p.cp1x;\n        target.y = p.cp1y;\n      } else {\n        target.x = p.cp2x;\n        target.y = p.cp2y;\n      }\n      return target;\n    }\n\n    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true\n    // @param {number} segmentIndex\n    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by\n    //                                  current vertex position\n  }, { key: \"updateControlPoint\", value: function updateControlPoint(segmentIndex, ctrlPoint, x, y) {var loopIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var p = this._loops[loopIndex][segmentIndex];\n      if (ctrlPoint === 1) {\n        p.cp1x = x;\n        p.cp1y = y;\n      } else {\n        p.cp2x = x;\n        p.cp2y = y;\n      }\n      this.modified();\n    }\n\n    // Draw Polygon into LmvCanvasContext\n  }, { key: \"draw\", value: function draw(ctx, overrideStyle) {\n      drawPath(ctx, this, overrideStyle);\n    }\n\n    // Sample path into a Polygon or Polyline.\n    //  @returns {Polygon|Polyline}\n  }, { key: \"toPoly\", value: function toPoly() {var _this6 = this;var tessParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Autodesk.Extensions.CompGeom.DefaultTessParams;\n\n      var poly = this.isClosed ? new Polygon() : new Polyline();var _loop = function _loop(\n      l) {\n\n        // Build up a polygon from path commands\n        var ctx = {\n          moveTo: function moveTo(x, y) {return poly.addPoint(x, y, l);},\n          lineTo: function lineTo(x, y) {return poly.addPoint(x, y, l);},\n          bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n\n            // get last added point. Note that it always exists, because runLoop() always starts with moveTo.\n            // so we know for sure that >=1 points were already added to this polygon loop.\n            var points = poly._loops[l];\n            var last = points[points.length - 1];\n\n            // compute bbox of the arc - which we use as an estimate for required accuracy\n            var arcBox = tmpBox2.makeEmpty();\n            arcBox.expandByPoint(last);\n            arcBox.expandByPoint(tmpVec2.set(x, y));\n            arcBox.expandByPoint(tmpVec2.set(cp1x, cp1y));\n            arcBox.expandByPoint(tmpVec2.set(cp2x, cp2y));\n            var sz = arcBox.size(tmpVec).length();\n\n            // sample arc into lineTo() segments\n            Autodesk.Extensions.CompGeom.TesselateCubic(ctx, last.x, last.y, cp1x, cp1y, cp2x, cp2y, x, y, sz, tessParams);\n          },\n          ellipse: function ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {\n\n            // use ellipse maxRadius a reference for required accuracy\n            var sz = Math.max(rx, ry);\n\n            // determine tesselation params                    \n            var maxSegments = tessParams.numIterations;\n            var minSegmentLength = tessParams.minSegLenFraction * sz;\n\n            // tesselate arc\n            var arc = getTmpArc().set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw);\n            arc.tesselate(ctx, maxSegments, minSegmentLength);\n          },\n          closePath: function closePath() {} // Polygon is closed anyway.\n        };\n        runLoop(ctx, _this6, l);};for (var l = 0; l < this.loopCount; l++) {_loop(l);\n      }\n      return poly;\n    } }, { key: \"computeBBox\", value: function computeBBox()\n\n    {\n      // Compute bbox of all vertices\n      _get(_getPrototypeOf(Path.prototype), \"computeBBox\", this).call(this);\n\n      // Consider Bezier arcs: By definition, Bezier curves are always bounded by the convex hull of their control\n      // points. Therefore, we can simply add the control points to the bbox.\n      //\n      // Note: The bboxes obtained by this simple approach are only guaranteed to contain the curve. But, they are not guaranteed to be minimal.\n      //       This is not a big issue for most uses (hitTest, drawing etc.). In case it becomes a problem anywhere, we need a better solution here, e.g.\n      //       https://stackoverflow.com/questions/24809978/calculating-the-bounding-box-of-cubic-bezier-curve\n      var cp = new THREE.Vector2();\n      for (var l = 0; l < this.loopCount; l++) {\n        for (var i = 0; i < this.getVertexCount(l); i++) {\n\n          if (this.isBezierArc(i, l)) {\n            // add control point 1\n            this.getControlPoint(i, 1, l, cp);\n            this.bbox.expandByPoint(cp);\n\n            // add control point 2\n            this.getControlPoint(i, 2, l, cp);\n            this.bbox.expandByPoint(cp);\n          } else\n          if (this.isEllipseArc(i, l)) {\n            var arc = this.exportEllipseArc(i, l, getTmpArc());\n            this.bbox.union(arc.computeBBox(tmpBox2));\n          }\n        }\n      }\n    } }, { key: \"hitTest\", value: function hitTest(\n\n    x, y, hitRadius) {\n      var poly = this.toPoly();\n      return poly.hitTest(x, y, hitRadius);\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Path().copy(this);\n    }\n\n    // @param {Path} srcPath\n    // @param {number} srcLoopIndex loop in srcPath to copy\n    // @param {number} [dstLoopIndex] Optional: index where to insert the new loop. By default, we use the first free loopIndex.\n  }, { key: \"addLoop\", value: function addLoop(srcPath) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var dstLoopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n      // If dstLoop is not set, it will be chosen by the super.addLoop().\n      dstLoopIndex = _get(_getPrototypeOf(Path.prototype), \"addLoop\", this).call(this, srcPath, srcLoopIndex, dstLoopIndex);\n\n      var srcPoints = srcPath._loops[srcLoopIndex];\n      var dstPoints = this._loops[dstLoopIndex];\n\n      // Copy extra information for arcs\n      for (var i = 0; i < srcPoints.length; i++) {\n        var type = srcPath.getEdgeType(i, srcLoopIndex);\n\n        // Line segments are fully handled by the base class already\n        if (type === EdgeType.Line) {\n          continue;\n        }\n\n        var src = srcPoints[i];\n        var dst = dstPoints[i];\n\n        dst.arcType = src.arcType;\n\n        switch (type) {\n          case EdgeType.Bezier:{\n              // copy control points\n              dst.cp1x = src.cp1x;\n              dst.cp1y = src.cp1y;\n              dst.cp2x = src.cp2x;\n              dst.cp2y = src.cp2y;\n              break;\n            }\n          case EdgeType.Ellipse:{\n              // copy arc params\n              dst.ellipseArcParams = src.ellipseArcParams && src.ellipseArcParams.clone();\n              break;\n            }}\n\n      }\n\n      this.modified();\n      return this;\n    } }, { key: \"moveLoop\", value: function moveLoop(\n\n    dx, dy, loopIndex) {\n      _get(_getPrototypeOf(Path.prototype), \"moveLoop\", this).call(this, dx, dy, loopIndex);\n\n      // Move affected control points as well\n      var points = this._loops[loopIndex];\n      for (var i = 0; i < points.length; i++) {\n        if (!this.isBezierArc(i, loopIndex)) {\n          continue;\n        }\n\n        var p = points[i];\n        p.cp1x += dx;\n        p.cp1y += dy;\n        p.cp2x += dx;\n        p.cp2y += dy;\n      }\n\n      // Note that for Ellipse arcs, it is sufficient to move start/end like for line segments.\n    } }, { key: \"getArea\", value: function getArea(\n\n    measureTransform) {\n      if (!this.isClosed) {\n        return undefined;\n      }\n\n      // Todo: If performance becomes an issue, this can be optimized by a less brute-force way.\n      var poly = this.toPoly(AreaTessParam);\n\n      // Since poly is just temporary, we can just share the loop infos to prevent poly.getArea()\n      // from computing them again.\n      poly._loopInfos = this._getLoopInfos();\n\n      return poly.getArea(measureTransform);\n    } }, { key: \"getLength\", value: function getLength(\n\n    measureTransform) {\n      var poly = this.toPoly();\n      return poly.getLength(measureTransform);\n    }\n\n    // Get point on segment. This refines the implementation \n    // of PolyBase by supporting arc segments.\n  }, { key: \"getPointOnEdge\", value: function getPointOnEdge(segmentIndex, t) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();\n\n      var points = this._loops[loopIndex];\n      var type = this.getEdgeType(segmentIndex, loopIndex);\n      switch (type) {\n        case EdgeType.Line:break;\n        case EdgeType.Bezier:{\n            // get segment start/end\n            var a = points[segmentIndex];\n            var b = points[this.nextIndex(segmentIndex)];\n\n            return Autodesk.Extensions.CompGeom.getCubeBezierPoint(t, a.x, a.y, a.cp1x, a.cp1y, a.cp2x, a.cp2y, b.x, b.y, target);\n          }\n        case EdgeType.Ellipse:{\n            var arc = this.exportEllipseArc(segmentIndex, loopIndex, getTmpArc());\n\n            // ignore arcs with NaN values\n            if (!arc.isValid()) {\n              break;\n            }\n            return arc.getPoint(t, target);\n          }\n        default:avp.logger.error('unexpected edge type');}\n\n\n      return _get(_getPrototypeOf(Path.prototype), \"getPointOnEdge\", this).call(this, segmentIndex, t, loopIndex, target);\n    }\n\n    // Run moveTo/lineTo/arcTo/closePath calls on a given context object.    \n    //  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)\n  }, { key: \"runPathCommands\", value: function runPathCommands(ctx) {\n      runPath(ctx, this);\n    }\n\n    // Returns false if all edges of all loops are line segments.\n  }, { key: \"hasArcs\", value: function hasArcs() {var _this7 = this;\n      var filter = function filter(vertexIndex, loopIndex) {return _this7.isArc(vertexIndex, loopIndex);};\n      return Boolean(this.findVertex(filter));\n    } }]);return Path;}(PolyBase);\n\n\n// Alias that can be used for Polyline/Polygon paths. Use only if you don't intend to change the isClosed prop during lifetime.\nexport var PolygonPath = /*#__PURE__*/function (_Path) {_inherits(PolygonPath, _Path);var _super6 = _createSuper(PolygonPath);\n  function PolygonPath(points, style) {_classCallCheck(this, PolygonPath);return _super6.call(this,\n    points, true, style);\n  }return PolygonPath;}(Path);\n;\n\nexport var PolylinePath = /*#__PURE__*/function (_Path2) {_inherits(PolylinePath, _Path2);var _super7 = _createSuper(PolylinePath);\n  function PolylinePath(points, style) {_classCallCheck(this, PolylinePath);return _super7.call(this,\n    points, false, style);\n  }return PolylinePath;}(Path);\n;\n\nexport var Circle = /*#__PURE__*/function (_Shape2) {_inherits(Circle, _Shape2);var _super8 = _createSuper(Circle);\n\n  // Note: The tessSegments parameter will be removed later when the implementation uses arcs from LineShader directly.\n  function Circle() {var _this8;var centerX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;var centerY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultStyle.clone();var tessSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;_classCallCheck(this, Circle);\n    _this8 = _super8.call(this, style);\n\n    _this8.polygon = new Polygon([], style);\n\n    // Force polygon.id to be the same, so that its geometry is associated with this Circle.\n    // This is a bit hacky, but can be removed as soon as we use native arcs for circle rendering.\n    _this8.polygon.id = _this8.id;\n\n    _this8.centerX = centerX;\n    _this8.centerY = centerY;\n    _this8.radius = radius;\n    _this8.tessSegments = tessSegments;\n\n    _this8.needsUpdate = true;return _this8;\n  }_createClass(Circle, [{ key: \"draw\", value: function draw(\n\n    ctx, overrideStyle) {\n\n      this.polygon.points.length = 0;\n\n      // angle delta in degrees\n      var stepSize = 360 / this.tessSegments;\n      for (var angle = 0; angle < 360; angle += stepSize) {\n\n        var a = angle * Math.PI / 180;\n        var x = this.radius * Math.cos(a);\n        var y = this.radius * Math.sin(a);\n\n        this.polygon.addPoint(this.centerX + x, this.centerY + y);\n      }\n\n      this.needsUpdate = false;\n\n      this.polygon.draw(ctx, overrideStyle);\n    } }, { key: \"setCenter\", value: function setCenter(\n\n    x, y) {\n      this.centerX = x;\n      this.centerY = y;\n      this.modified();\n    } }, { key: \"move\", value: function move(\n\n    dx, dy) {\n      this.centerX += dx;\n      this.centerY += dy;\n      this.modified();\n      return this;\n    } }, { key: \"hitTest\", value: function hitTest(\n\n    x, y) {\n      var dx = x - this.centerX;\n      var dy = y - this.centerY;\n      return dx * dx + dy * dy < this.radius * this.radius;\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Circle().copy(this);\n    } }, { key: \"copy\", value: function copy(\n\n    from) {\n      _get(_getPrototypeOf(Circle.prototype), \"copy\", this).call(this, from);\n      this.polygon = from.polygon.clone();\n      this.centerX = from.centerX;\n      this.centerY = from.centerY;\n      this.radius = from.radius;\n      this.tessSegments = from.tessSegments;\n      this.modified();\n      return this;\n    } }, { key: \"computeBBox\", value: function computeBBox()\n\n    {\n      this.bbox.min.set(this.centerX - this.radius, this.centerY - this.radius);\n      this.bbox.max.set(this.centerX + this.radius, this.centerY + this.radius);\n    } }]);return Circle;}(Shape);\n\n\nexport var ShapeWrapper = /*#__PURE__*/function (_Shape3) {_inherits(ShapeWrapper, _Shape3);var _super9 = _createSuper(ShapeWrapper);\n\n  // @param {Shape} shape - must not be null\n  function ShapeWrapper(shape) {var _this9;_classCallCheck(this, ShapeWrapper);\n    _this9 = _super9.call(this);\n    _this9.shape = shape;\n\n    Object.defineProperty(_assertThisInitialized(_this9), 'bbox', {\n      get: function get() {return _this9.shape.bbox;},\n      set: function set(bbox) {_this9.shape.bbox = bbox;} });\n\n\n    Object.defineProperty(_assertThisInitialized(_this9), 'id', {\n      get: function get() {return _this9.shape.id;},\n      set: function set(id) {_this9.shape.id = id;} });\n\n\n    Object.defineProperty(_assertThisInitialized(_this9), 'bboxDirty', {\n      get: function get() {return _this9.shape.bboxDirty;},\n      set: function set(dirty) {_this9.shape.bboxDirty = dirty;} });\n\n\n    Object.defineProperty(_assertThisInitialized(_this9), 'name', {\n      get: function get() {return _this9.shape.name;},\n      set: function set(name) {_this9.shape.name = name;} });return _this9;\n\n  }_createClass(ShapeWrapper, [{ key: \"draw\", value: function draw()\n\n    {var _this$shape;return (_this$shape = this.shape).draw.apply(_this$shape, arguments);} }, { key: \"hitTest\", value: function hitTest()\n    {var _this$shape2;return (_this$shape2 = this.shape).hitTest.apply(_this$shape2, arguments);} }, { key: \"move\", value: function move()\n    {var _this$shape3;return (_this$shape3 = this.shape).move.apply(_this$shape3, arguments);} }, { key: \"modified\", value: function modified()\n    {var _this$shape4;return (_this$shape4 = this.shape).modified.apply(_this$shape4, arguments);} }, { key: \"computeBBox\", value: function computeBBox()\n    {var _this$shape5;return (_this$shape5 = this.shape).computeBBox.apply(_this$shape5, arguments);} }, { key: \"updateBBox\", value: function updateBBox()\n    {var _this$shape6;return (_this$shape6 = this.shape).updateBBox.apply(_this$shape6, arguments);} }, { key: \"clone\", value: function clone()\n\n    {\n      return new ShapeWrapper(this.shape.clone());\n    } }, { key: \"copy\", value: function copy(\n\n    from) {\n      this.shape.copy(from.shape);\n    } }]);return ShapeWrapper;}(Shape);","function _readOnlyError(name) {throw new Error(\"\\\"\" + name + \"\\\" is read-only\");}function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}\nimport { SolidDefConvert } from './SolidDefConvert.js';\nimport { SketchRegionSolver, getRegionEdges, getBoundedRegionFaces, computeCurveCurveIntersections } from '@adsk/solid-definition';\n\n// Result values of classifySets\nvar SetContainment = {\n  Contains: 0, // A contains B (not vice versa)\n  IsContainedIn: 1, // B contains A (not vice versa)\n  Disjoint: 2, // No common elements\n  Overlapping: 3, // Intersecting, but not equal\n  Equal: 4 // Sets are identical\n};\n\n// @param {SketchRegionSolver} solver       - initialized with all edges of subject and cutLoop\n// @param {Edges[]}            loopEdges    - edges of the loop that we test against.\n// @returns {Face[]} subset of solver.getFaces(). All faces encludes by the loopEdges.\nexport var getFacesInsideLoop = function getFacesInsideLoop(solver, loopEdges) {\n\n  // Get all faces that we obtained by intersecting all edges against each other\n  var regionFaces = solver.getFaces();\n\n  // Get ordered array of loop edges within solver that correspond to the cutLoop\n  var cutRegionEdges = getRegionEdges(solver, loopEdges);\n\n  // Find all faces that are \n  return getBoundedRegionFaces(regionFaces, cutRegionEdges);\n};\n\n// Tolerance for self-intersection tests: If intersections are very close to a shared vertex, we ignore them.\n// Note that the tolerance is not in units but a fraction of an edge.\nvar Precision = 1.e-5;\n\n// Check whether a single loop has self-intersections\n// TODO: There is one edge case that we would not detect here: If a loop passes the same vertex multiple times.\nvar hasSelfIntersections = function hasSelfIntersections(loopEdges) {\n  for (var _i = 0; _i < loopEdges.length; _i++) {\n    var edge1 = loopEdges[_i];\n\n    // Check all subsequent edges.\n    for (var j = _i + 1; j < loopEdges.length; j++) {\n\n      // Check intersections of both edges\n      var edge2 = loopEdges[j];\n      var cuts = computeCurveCurveIntersections(edge1, edge2, false, true);\n\n      // Check if there are any intersections (except for shared vertices)\n      for (var _i2 = 0; _i2 < cuts.length; _i2++) {\n        var cut = cuts[_i2];\n\n        // Ignore intersections at a shared vertex\n        // Due to accuracy issues, the cut may also be just close to a vertex\n        var param1 = cut.cutInfo.param;\n        var param2 = cut.cutByInfo.param;\n\n        var range1 = edge1.getRange();\n        var range2 = edge2.getRange();\n\n        // Check if both parameters are very close to range start/end of an edge\n        var dist1 = Math.min(Math.abs(param1 - range1[0]), Math.abs(param1 - range1[1]));\n        var dist2 = Math.min(Math.abs(param2 - range2[0]), Math.abs(param2 - range2[1]));\n        var d = Math.max(dist1, dist2);\n\n        // If cut was not approximately equal to a shared vertex,\n        // consider it as a self-intersection.\n        if (d > Precision) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n// Given two sets of values, faces, each indexed by integer faceIds, this function checks how the sets are related.\nvar classifySets = function classifySets(A, B) {\n\n  // Track which kind of indices we found\n  var foundCommon = false; // >=0 elems are in both\n  var foundAOnly = false; // >=0 elems are only in set A\n  var foundBOnly = false; // >=0 elems are only in set B\n\n  var checkElems = function checkElems(elemIndex) {\n    var isInA = A.has(elemIndex);\n    var isInB = B.has(elemIndex);\n\n    if (isInA && isInB) foundCommon = true;else\n    if (isInA) foundAOnly = true;else\n    if (isInB) foundBOnly = true;\n  };var _iterator = _createForOfIteratorHelper(\n\n  A),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var elem = _step.value;\n      checkElems(elem);\n    }} catch (err) {_iterator.e(err);} finally {_iterator.f();}var _iterator2 = _createForOfIteratorHelper(\n\n  B),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var _elem = _step2.value;\n      checkElems(_elem);\n    }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}\n\n  if (!foundCommon) {\n    return SetContainment.Disjoint;\n  }\n\n  if (foundAOnly && !foundBOnly) {\n    return SetContainment.Contains;\n  }\n\n  if (foundBOnly && !foundAOnly) {\n    return SetContainment.IsContainedIn;\n  }\n\n  if (!foundAOnly && !foundBOnly) {\n    return SetContainment.Equal;\n  }\n\n  return SetContainment.Overlapping;\n};\n\n// Contains loop containment for a path\nexport var computeLoopContainment = function computeLoopContainment(path) {\n\n  // Convert to SolidDef Path\n  var pathSd = SolidDefConvert.toSolidDefPath(path);\n\n  // get path as wires\n  var wireBody = pathSd.getWireBody();\n  var wires = wireBody.getWires();\n\n  // get path as edge array\n  var edges = wireBody.getEdges();\n\n  // Init empty loop infos\n  var loopInfos = [];\n  for (var l = 0; l < wires.length; l++) {\n\n    // Get loop edges\n    var w = wires[l];\n    var loopEdges = w.getEdges();\n\n    loopInfos[l] = {\n      containedLoops: [],\n      rank: 0,\n\n      // Indicates if loop containment could not properly computed. \n      // This happens if \n      //   a) The loop has self-intersections\n      //   b) The loop is overlapping with another one\n      //   c) The loop is exactly matching with another one\n      error: hasSelfIntersections(loopEdges) // Initially, we detect only a)\n    };\n  }\n\n  // For only a single loop or less, we are done here.\n  if (wires.length < 2) {\n    return loopInfos;\n  }\n\n  // Feed them into solver to intersect them against each other and extract the resulting region faces.\n  var solver = new SketchRegionSolver();\n  solver.compute(edges);\n\n  // check which of the faces are within path and cutPath\n  var faces = solver.getFaces();\n\n  // attach arrayIndex to each face\n  faces.forEach(function (f, index) {return f.arrayIndex = index;});\n\n  // for each loop l, collect a set facesPerLoop[l] that contains the array indices of all enclosed faces.     \n  var facesPerLoop = [];var _loop = function _loop(\n  _l) {\n\n    // get edges of loop i\n    var w = wires[_l];\n    var loopEdges = w.getEdges();\n\n    // If a loop has self-intersections, just mark it as invalid and skip it\n    if (hasSelfIntersections(loopEdges)) {\n      loopInfos[_l].error = true;\n      facesPerLoop[_l] = new Set();\n      return \"continue\";\n    }\n\n    // get all faces within this loop\n    var enclosedFaceIds = new Set();\n    var faces = getFacesInsideLoop(solver, loopEdges);\n    faces.forEach(function (f) {\n      enclosedFaceIds.add(f.arrayIndex);\n    });\n\n    facesPerLoop[_l] = enclosedFaceIds;};for (var _l = 0; _l < wires.length; _l++) {var _ret = _loop(_l);if (_ret === \"continue\") continue;\n  }\n\n  // Use the faceId sets to derive which loop is contained in which other    \n  for (var a = 0; a < facesPerLoop.length; a++) {\n\n    // indices of all faces enclosed by loop a\n    var A = facesPerLoop[a];\n\n    for (var b = a + 1; b < facesPerLoop.length; b++) {\n      // indices of all faces enclosed by loop i\n      var B = facesPerLoop[b];\n\n      // Check set relation between A and B\n      var cont = classifySets(A, B);\n      switch (cont) {\n        case SetContainment.Disjoint:\n          // No common faces at all. E.g., for two holes.\n          continue;\n        case SetContainment.Contains:\n          loopInfos[a].containedLoops.push(b);\n          loopInfos[b].rank++;\n          break;\n        case SetContainment.IsContainedIn:\n          loopInfos[b].containedLoops.push(b);\n          loopInfos[a].rank++;\n          break;\n        default:\n          loopInfos[a].error = true;\n          loopInfos[b].error = true;}\n\n    }\n  }\n\n  // If the original paths contained empty loops, we may have to reindex the loopInfos,\n  // because empty loops will not produce a corresponding wire in the SolidDef representation.\n  if (wires.length !== path.loopCount) {\n    var reindexed = [];\n    var srcIndex = 0;\n    for (var _l2 = 0; _l2 < path.loopCount; _l2++) {\n      // Only non-empty loops get loopInfos\n      if (path.getVertexCount(_l2)) {\n        reindexed[i] = loopInfos[(_readOnlyError(\"srcIndex\"), srcIndex++)];\n      }\n    }\n    loopInfos = (_readOnlyError(\"loopInfos\"), reindexed);\n  }\n\n  return loopInfos;\n};","var tmpVec2d = new THREE.Vector2();\nvar tmpVec2d2 = new THREE.Vector2();\n\n// Collection of simple helper functions for 2D math functions.\n\n// Return normalized edge direction vector (b-a).normalized\nvar getEdgeDirection = function getEdgeDirection(a, b, target) {\n  target = target || new THREE.Vector2();\n\n  return target.copy(b).sub(a).normalize();\n};\n\nvar getEdgeCenter = function getEdgeCenter(a, b, target) {\n  target = target || new THREE.Vector2();\n\n  return target.set(0.5 * (a.x + b.x), 0.5 * (a.y + b.y));\n};\n\n// Get edge length. (a, b) can just be {x, y} pairs, i.e., not required to be THREE.Vector2\nvar getEdgeLength = function getEdgeLength(a, b) {\n  var dx = b.x - a.x;\n  var dy = b.y - a.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\n// Rotates direction vector p 90 degrees to the left. (in-place)\nvar turnLeft = function turnLeft(p) {\n  var tmp = p.x;\n  p.x = -p.y;\n  p.y = tmp;\n  return p;\n};\n\n// Projects a point p to a line. Works in-place\n//  @param {Vector2} p\n//  @param {Vector2} linePoint - point on the line\n//  @param {Vector2} lineDir   - line direction. Must be normalized\nvar projectToLine = function projectToLine(p, linePoint, lineDir) {\n\n  // dp = dot(p-linePoint, lineDir)\n  var dp = (p.x - linePoint.x) * lineDir.x + (p.y - linePoint.y) * lineDir.y;\n\n  // return linePoint + lineDir * dp\n  p.set(\n  linePoint.x + dp * lineDir.x,\n  linePoint.y + dp * lineDir.y);\n\n};\n\n// Get distance between the point p and a line given by point and direction.\n//  @param {Vector2} p\n//  @param {Vector2} linePoint - point on the line\n//  @param {Vector2} lineDir   - line direction. Must be normalized\nvar pointLineDistance = function () {\n  var pProj = new THREE.Vector2();\n  return function (p, linePoint, lineDir) {\n    projectToLine(pProj.copy(p), linePoint, lineDir);\n    return p.distanceTo(pProj);\n  };\n}();\n\n// Calculates the intersection point of both given lines\n// assumes that the lines are not parallel\n// see: http://www.paulbourke.net/geometry/pointlineplane/\nvar intersectLines = function intersectLines(linePoint1, lineDir1, linePoint2, lineDir2, outPoint) {\n\n  var denom = lineDir2.y * lineDir1.x - lineDir2.x * lineDir1.y;\n  if (Math.abs(denom) < 1.0e-8) {return false;}\n\n  // diff = linePoint1 - linePoint2\n  var diffX = linePoint1.x - linePoint2.x;\n  var diffY = linePoint1.y - linePoint2.y;\n\n  var u = lineDir2.x * diffY - lineDir2.y * diffX;\n\n  if (outPoint) {\n    outPoint.x = linePoint1.x + u / denom * lineDir1.x;\n    outPoint.y = linePoint1.y + u / denom * lineDir1.y;\n  }\n  return true;\n};\n\n// Rotate a vector p around origin or a given center. Works in-place.\n//  @param {Vector2} p\n//  @param {number}  angle in radians\n//  @param [Vector2] center \nvar rotateAround = function rotateAround(p, angle, center) {\n\n  var c = Math.cos(angle);\n  var s = Math.sin(angle);\n\n  if (center) {\n    p.sub(center);\n  }\n\n  var x = p.x;\n  var y = p.y;\n\n  p.x = x * c - y * s;\n  p.y = x * s + y * c;\n\n  if (center) {\n    p.add(center);\n  }\n  return p;\n};\n\n//  @param {Vector2} dir1, dir2           - No normalization required.\n//  @returns {number} result in [0, 2*Pi] - clockwise angle in radians that you have to apply to rotate dir2 into dir1.\nvar angleBetweenDirections = function angleBetweenDirections(dir1, dir2) {\n\n  // get angle formed with positive x-axis. \n  // angle1/2 are in [-Pi, Pi]\n  var angle1 = Math.atan2(dir1.y, dir1.x);\n  var angle2 = Math.atan2(dir2.y, dir2.x);\n\n  // Difference is in [-2*Pi, 2*Pi]\n  var angle = angle1 - angle2;\n\n  // Map result to [0, 2*Pi] range\n  if (angle < 0) angle += 2 * Math.PI;\n\n  return angle;\n};\n\n// see isPointOnEdge\nvar isPointOnLine = function isPointOnLine(p, a, b, precision) {\n  return isPointOnEdge(p, a, b, precision, false);\n};\n\n// Returns true if p lies close to the edge (p1, p2). \nvar isPointOnEdge = function isPointOnEdge(p, a, b, precision) {var checkInsideSegment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  // Compute edge length\n  var dx = b.x - a.x;\n  var dy = b.y - a.y;\n  var length = Math.sqrt(dx * dx + dy * dy);\n\n  var e = {\n    v1: a,\n    dx: dx,\n    dy: dy,\n    length: length,\n    length2: length * length };\n\n  return Autodesk.Extensions.CompGeom.pointOnLine(p.x, p.y, e, checkInsideSegment, precision);\n};\n\nvar pointDelta = function pointDelta(a, b) {var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var delta = { x: b.x - a.x, y: b.y - a.y };\n  if (digits)\n  {\n    var exp = Math.pow(10, digits);\n    delta.x = Math.round(delta.x * exp) / exp;\n    delta.y = Math.round(delta.y * exp) / exp;\n  }\n  if (!delta.x && !delta.y) {\n    return;\n  }\n  return delta;\n};\n\nvar edgeIsDegenerated = function edgeIsDegenerated(a, b) {var eps2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0e-10;\n  return a.distanceToSquared(b) < eps2;\n};\n\n// Compute target point resulting from mirroring point p\n// on the given center point c.\nvar mirrorPointOnPoint = function mirrorPointOnPoint(p, c) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  target = target || new THREE.Vector2();\n  target.x = c.x - (p.x - c.x);\n  target.y = c.y - (p.y - c.y);\n  return target;\n};\n\nvar fuzzyEqual = function fuzzyEqual(a, b, precision) {\n  return Math.abs(a - b) < precision;\n};\n\n// Checks if two lines are collinear.\n//  @param {Vector2} p1, dir1 - First line, given as point and normalized direction.\n//  @param {Vector2} p2, dir2 - Second line\n//  @param {number}  precision\n//  @returns {bool}\nvar collinear = function collinear(p1, dir1, p2, dir2, precision) {\n\n  // Directions must be either equal or opposite\n  var dirEqual = fuzzyEqual(dir1.x, dir2.x, precision) && fuzzyEqual(dir1.y, dir2.y, precision);\n  var dirOpposite = fuzzyEqual(dir1.x, -dir2.x, precision) && fuzzyEqual(dir1.y, -dir2.y, precision);\n  if (!dirEqual && !dirOpposite) {\n    return false;\n  }\n\n  // Directions are equal or opposite => Lines are collinear if and only if p2 is on line (p1, dir1).\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  var dot = dx * dir1.x + dy * dir1.y;\n  return Math.abs(dot) < precision;\n};\n\n// same as p1.distanceTo(p2), but working for any {x,y} object.\nvar distance2D = function distance2D(p1, p2) {\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\n// Checks if a matrix changes the orientation.\n//  @param {Matrix4} matrix\nvar changesOrientation = function changesOrientation(matrix) {\n  return matrix.determinant() < 0;\n};\n\n// Compute a matrix that transforms fromBox into toBox.\n//\n//  @param {Box2}    fromBox\n//  @param {Box2}    toBox\n//  @param {Object}  [options]\n//  @param {bool}    [options.flipY]           - include y-axis flip\n//  @param {bool}    [options.preserveAspect]  - force uniform scaling (m * fromBox might be smaller than toBox in one axis)\n//  @param {Matrix4} [target]\nvar getFitToBoxTransform = function getFitToBoxTransform(fromBox, toBox) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Matrix4();\n  var fromSize = fromBox.size(tmpVec2d);\n  var toSize = toBox.size(tmpVec2d2);\n\n  // compute scale   \n  var sx = toSize.x / fromSize.x;\n  var sy = toSize.y / fromSize.y;\n\n  // preserveAspect\n  if (options.preserveAspect) {\n    sx = Math.min(sx, sy);\n    sy = sx;\n  }\n\n  // anchor is the point of fromBox that will be mapped to toBox.min\n  var anchorX = fromBox.min.x;\n  var anchorY = fromBox.min.y;\n\n  // apply optional y-flip\n  if (options.flipY) {\n    sy *= -1;\n    anchorY = fromBox.max.y;\n  }\n\n  // compute translation: after scaling, anchor should move to toBox.min\n  var tx = -sx * anchorX + toBox.min.x;\n  var ty = -sy * anchorY + toBox.min.y;\n\n  // Create (scale + translate)-matrix.\n  var matrix = target.makeScale(sx, sy, 1.0);\n  matrix.elements[12] = tx;\n  matrix.elements[13] = ty;\n\n  return matrix;\n};\n\nexport var Math2D = {\n  getEdgeDirection: getEdgeDirection,\n  projectToLine: projectToLine,\n  pointLineDistance: pointLineDistance,\n  intersectLines: intersectLines,\n  rotateAround: rotateAround,\n  angleBetweenDirections: angleBetweenDirections,\n  getEdgeCenter: getEdgeCenter,\n  getEdgeLength: getEdgeLength,\n  turnLeft: turnLeft,\n  isPointOnEdge: isPointOnEdge,\n  isPointOnLine: isPointOnLine,\n  pointDelta: pointDelta,\n  edgeIsDegenerated: edgeIsDegenerated,\n  mirrorPointOnPoint: mirrorPointOnPoint,\n  fuzzyEqual: fuzzyEqual,\n  collinear: collinear,\n  distance2D: distance2D,\n  changesOrientation: changesOrientation,\n  getFitToBoxTransform: getFitToBoxTransform };","\nimport { EllipseArcParams, Path, PolygonPath, runPath } from './EditShapes.js';\n\nimport { Path2D, Coedge, GEOMETRY_TYPES } from '@adsk/solid-definition';\n\nvar tmpVec1 = new THREE.Vector3();\nvar tmpVec2 = new THREE.Vector3();\n\n// Convert SolidDef float-array to THREE-Vector3\nvar toVec3 = function toVec3(ar) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();\n  return target.set(ar[0], ar[1], ar[2]);\n};\n\n// Add (directed) edge segment to an Edit2D path. If path is non-empty, it is\n// assumed that it already ends at the start point of the new edge\n//  @param {Path}                     path         - Edit2D path\n//  @param {SolidDef.Coedge|SolidDef} ce           - Directed edge from SolidDef \n//  @param {number}                   loopIndex    - index of the loop in target path where we add the edge to\n//  @param {bool}                     lastLoopEdge - For the last edge in a loop, we only copy the arc params, but don't add the end vertex.\n//                                                   This is because Edit2D shapes do not repeat the start vertex at the end.\nvar addCoedge = function addCoedge(path, ce, loopIndex) {var lastLoopEdge = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  var vertexCount = path.getVertexCount(loopIndex);\n\n  // Add start vertex on first call\n  if (vertexCount == 0) {\n    var pStart = ce.getStartVertex().getPosition();\n    path.addPoint(pStart[0], pStart[1], loopIndex);\n  }\n\n  // Add end point - unless this is the last edge of a loop.\n  if (!lastLoopEdge) {\n    var pEnd = ce.getEndVertex().getPosition();\n    path.addPoint(pEnd[0], pEnd[1], loopIndex);\n  }\n\n  // This function works for Coedges as well as edges. If ce is already an edge, we just set e=ce.\n  var isCoedge = ce instanceof Coedge;\n  var e = isCoedge ? ce.getEdge() : ce;\n\n  // Determine whether the curve direction is flipped. For coedges, this may happen up to twice, because\n  // cedge as well as edge have their own isReversed flag.\n  var ceReversed = isCoedge ? ce.isReversed() : false;\n  var edgeReversed = e.isReversed();\n  var isReversed = ceReversed !== edgeReversed; // logical XOR (true if exactly one of both is reversed)\n\n  var type = e.getCurveType();\n\n  // For line segments, we are done\n  if (type === GEOMETRY_TYPES.LINE) {\n    return;\n  }\n\n  // convert curve parameters for new edge\n  var edgeIndex = Math.max(vertexCount - 1, 0);\n  var curve = e.getCurve();\n\n  // Bezier case\n  if (type === GEOMETRY_TYPES.BCURVE) {\n\n    // Note that we cannot simply copy the control points of the SolidDef bcurve. Reasons:\n    //  1. Coedge or edge may be reversed (which may invert the order of the control points)\n    //  2. The edge may not cover the whole curve, but only a part of it.\n    //\n    // Due to 2. we have to construct a new cubic Bezier here based start/end tangent of the edge.\n\n    // get params at edge start/end\n    var t0 = ce.t0();\n    var t1 = ce.t1();\n\n    // get start/end point\n    var _pStart = ce.evaluatePosition(t0);\n    var _pEnd = ce.evaluatePosition(t1);\n\n    // get start/end tangent\n    var tStart = ce.evaluateDt(t0);\n    var tEnd = ce.evaluateDt(t1);\n\n    // We are searching for a cubic Bezier B with the following properties:\n    //  - Its parameter domain is [0,1], i.e. B(0)=start vertex, B(1) is end vertex\n    //  - Tangents at start/end positions are the same as for the given edge.\n\n    // Note that changing from [t0, t1] to a larger parameter domain [0,1] scales down the tangent vectors accordingly.\n    var rangeScale = Math.abs(t1 - t0);\n    tStart[0] *= rangeScale;\n    tStart[1] *= rangeScale;\n    tEnd[0] *= rangeScale;\n    tEnd[1] *= rangeScale;\n\n    // The start tangent of a cubic bezier is 3 * (cp1-cp0). So, we can obtain cp1 from the start tangent.\n    // Same principle applies to cp2.\n    var cp1x = _pStart[0] + tStart[0] / 3;\n    var cp1y = _pStart[1] + tStart[1] / 3;\n    var cp2x = _pEnd[0] - tEnd[0] / 3;\n    var cp2y = _pEnd[1] - tEnd[1] / 3;\n\n    path.setBezierArc(edgeIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);\n    return;\n  }\n\n  // Ellipse arcs\n  if (type === GEOMETRY_TYPES.ELLIPSE) {\n\n    var params = new EllipseArcParams();\n    params.rx = curve.getMajorRadius();\n    params.ry = curve.getMinorRadius();\n\n    // compute axis rotation\n    var xAxis = curve.getMajorAxis();\n    var angle = Math.atan2(xAxis[1], xAxis[0]);\n    params.rotation = THREE.Math.radToDeg(angle);\n\n    // determine largeArc flag\n    // Note that the edge may only use a subset of the curve. \n    // So, it's essential to get the range from the directed edge.\n    var range = ce.getRange();\n    var startAngle = range[0];\n    var endAngle = range[1];\n    params.largeArcFlag = endAngle - startAngle > Math.PI; // Note that endAngle is always >startAngle\n\n    // determine sweep flag: Ellipse curves in SolidDef always run ccw (sweepFlag = true).\n    // But it may be inverted if the edge direction is flipped.\n    params.sweepFlag = !isReversed;\n\n    // Note: In Edit2D, the unrotated y-axis always points up. I.e. rotation=0 means xAxis = (1,0) and yAxis = (-1,0).\n    //       In SolidDef, the axes are more flexible. As long as we don't transform the curves arbitrarily, the ellipse\n    //       axes still form a 90 degree angle. However, the ellipse coordinate system may have opposite orientation.\n    //       If this happens, we have to invert the ellipse orientation.\n    var yAxis = curve.getMinorAxis();\n    var xDir = toVec3(xAxis, tmpVec1);\n    var yDir = toVec3(yAxis, tmpVec2);\n    var needsExtraFlip = xDir.cross(yDir).z < 0;\n    if (needsExtraFlip) {\n      params.sweepFlag = !params.sweepFlag;\n    }\n\n    path.setEllipseArc(edgeIndex, params, loopIndex);\n    return;\n  }\n\n  console.error(\"Unexpected curve type\");\n};\n\n// Creates an Edit2D Path loop from a given SoliDef loop. The loop is added to the target path.\n//  @param {SolidDef.Loop} loop\n//  @param {Path}          [target]\n//  @returns {Path}\nvar loopToShape = function loopToShape(loop) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PolygonPath();\n\n  // start new loop in target path\n  var loopIndex = target.nextFreeLoop();\n\n  // traverse coedges of the loop\n  var coedges = loop.getCoedges();\n  for (var i = 0; i < coedges.length; i++) {\n    var ce = coedges[i];\n\n    // for the last loopEdge, we only copy the arc param, but don't repeat the start vertex\n    var lastLoopEdge = i == coedges.length - 1;\n\n    // add next edge to target\n    addCoedge(target, ce, loopIndex, lastLoopEdge);\n  }\n\n  return target;\n};\n\n// Convert SolidDef face into one or more Edit2D Paths.\n// Todo: If we support multiple loops per Path, result will be a single Path\n//  @param {SolidDef.Face} face\n//  @param {Path}          [target]\n//  @returns {Path}\nvar faceToShape = function faceToShape(face) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PolygonPath();\n\n  // convert loops and collect them into target path\n  face.getLoops().forEach(function (l) {\n    target = loopToShape(l, target);\n  });\n  return target;\n};\n\n// Convert array of faces to array of shapes\nvar facesToShape = function facesToShape(faces) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PolygonPath();\n\n  faces.forEach(function (f) {\n    target = faceToShape(f, target);\n  });\n  return target;\n};\n\n// Convert SolidDef wire to an Edit2D Path.\n//\n// Note: This function only works for wires that don't branch and have already ordered edges.\n//       This is true for wires that we get from SolidDef.Path.\n//  @param {SolidDef.Wire} wire\nvar wireToShape = function wireToShape(wire) {\n\n  // create empty path\n  var path = new Path();\n  path.isClosed = wire.isClosed();\n\n  // add edges    \n  var edges = wire.getOrderedEdges().edges;\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var lastLoopEdge = wire.isClosed() && i == edges.length - 1;\n    addCoedge(path, edge, 0, lastLoopEdge);\n  }\n  return path;\n};\n\n// Convert SolidDef path to an array of shapes\nvar pathToShape = function pathToShape(path) {\n  var body = path.getWireBody();\n  var wires = body.getWires();\n\n  if (wires.length == 0) {\n    return new Path();\n  }\n\n  var result = wireToShape(wires[0]);\n\n  // convert additional loops (if any)\n  for (var i = 1; i < wires.length; i++) {\n    var wire = wires[i];\n    var tmp = wireToShape(wire);\n    result.addLoop(tmp, 0);\n  }\n\n  return result;\n};\n\n// Convert Edit2D Path to SolidDef Path2D\nvar toSolidDefPath = function toSolidDefPath(path) {\n  var path2D = new Path2D();\n  runPath(path2D, path);\n  return path2D;\n};\n\nexport var SolidDefConvert = {\n  addCoedge: addCoedge,\n  loopToShape: loopToShape,\n  faceToShape: faceToShape,\n  facesToShape: facesToShape,\n  wireToShape: wireToShape,\n  pathToShape: pathToShape,\n  toSolidDefPath: toSolidDefPath };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}import { Circle, PolyBase, Polygon, Polyline, Path, EdgeType, EllipseArcParams } from './EditShapes.js';\nimport { Math2D } from './Math2D.js';\nimport { getCubeBezierPoint } from '../CompGeom/bezier.js';\n\nvar domParser = null;\n\n// SVG (de)serialization for EditShapes\n\n// Url of XML-Namespace for SVG\nvar SvgNs = \"http://www.w3.org/2000/svg\";\n\nvar exp4 = Math.pow(10, 4);\nvar limitDigits = function limitDigits(value) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!value || digits === null) {\n    return value;\n  }\n  // like value.toFixed(), but removing trailing zeros\n  var exp = digits === 4 ? exp4 : Math.pow(10, digits);\n  return Math.round(value * exp) / exp;\n};\n\nvar domToCircle = function domToCircle(circleNode) {\n\n  if (!circleNode.hasAttributes || !circleNode.hasAttributes()) {\n    throw 'No attributes available on the <circle/> node';\n  }\n  var circle = new Circle();\n  for (var i = circleNode.attributes.length - 1; i >= 0; i--) {\n    var attr = circleNode.attributes[i];\n    switch (attr.name) {\n      case 'cx':\n        circle.centerX = parseFloat(attr.value);\n        break;\n      case 'cy':\n        circle.centerY = parseFloat(attr.value);\n        break;\n      case 'r':\n        circle.radius = parseFloat(attr.value);\n        break;}\n\n  }\n  return circle;\n};\n\nvar circleToSvg = function circleToSvg(circle) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;var stylePostFix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return \"<circle cx=\\\"\".concat(limitDigits(circle.centerX, digits), \"\\\" cy=\\\"\").concat(limitDigits(circle.centerY, digits), \"\\\" r=\\\"\").concat(limitDigits(circle.radius, digits)).concat(stylePostFix, \"\\\"/>\");\n};\n\nvar domToPath = function domToPath(pathNode) {\n\n  var d = pathNode.getAttribute('d');\n  if (!d) {\n    return;\n  }\n\n  return parsePath(d);\n};\n\n// For closed paths, remove last point of each loop if it is just a repetition of the start vertex.\nvar removeDuplicateLoopEndPoints = function removeDuplicateLoopEndPoints(path) {\n\n  // Bezier applied to the last point will create an additional point which is equal to the endpoint to close the path\n  // see Path.toSVGPath(). Path is always closed, therefore we can remove the duplicate end point.\n  if (path.isClosed) {\n    var pStart = new THREE.Vector2();\n    var pEnd = new THREE.Vector2();\n    var loopCount = path.loopCount;\n    for (var l = 0; l < loopCount; l++) {\n\n      // skip invalid loops\n      var lastIndex = path.getVertexCount(l) - 1;\n      if (lastIndex < 1) {\n        continue;\n      }\n\n      // get start/end\n      pStart = path.getPoint(0, l, pStart);\n      pEnd = path.getPoint(lastIndex, l, pEnd);\n\n      var delta = Math2D.pointDelta(pStart, pEnd, 0);\n      if (!delta) {\n        path.removePoint(lastIndex, l);\n      }\n\n    }\n  }\n};\n\nvar parsePath = function parsePath(svgPath) {\n  // split at all chars but keep the char using positive look ahead\n  // sample payload for path d = M 13.882,4.8592 L 14.6757,4.738 L 13.9668,4.4896 L 14.005,4.4896 C 15.3211,5.4567,14.79,3.1599,14.6624,4.155 L 13.9189,3.8945 L 13.9189,3.8 L 14.6234,3.7516 Z\n  // results into list with glyph with position array:\n  // ['M 13.882,4.8592', 'L 14.6757,4.738', 'L 13.9668,4.4896', 'L 14.005,4.4896', 'C 15.3211,5.4567,14.79,3.1599,14.6624,4.155', 'L 13.9189,3.8945', 'L 13.9189,3.8', 'L 14.6234,3.7516', 'Z']\n  var pointStrings = svgPath.split(/ (?=[a-zA-Z])/gi);\n  var validChars = \"MLHVCZA\";\n\n  // Reused per cycle\n  var ellipseParams = new EllipseArcParams();\n  var nextPoint = new THREE.Vector2();\n\n  // the current loop that we are adding edges to\n  var loopIndex = 0;\n\n  var path = new Path();\n\n  for (var i = 0; i < pointStrings.length; i++) {\n\n    // Check for unexpected characters\n    var pointString = pointStrings[i];\n    if (validChars.indexOf(pointString[0]) === -1) {\n      throw \"\\\"\".concat(pointString[0], \"\\\" is not a supported or invalid glyph: \").concat(pointString);\n    }\n\n    var segmentIndex = path.getVertexCount(loopIndex) - 1;\n\n    // Determine edge type, position, and extra params for arcs\n    var value = pointString.substring(1);\n    switch (pointString[0]) {\n      case 'M':\n        // start new loop\n        loopIndex = path.nextFreeLoop();\n      case 'L':\n        var coords = value.split(',');\n        nextPoint.x = parseFloat(coords[0]);\n        nextPoint.y = parseFloat(coords[1]);\n        break;\n      case 'H':\n        nextPoint.x = parseFloat(value);\n        break;\n      case 'V':\n        nextPoint.y = parseFloat(value);\n        break;\n      case 'C':\n\n        // tokenize params\n        var bezierCoords = value.split(',');\n\n        // get position\n        nextPoint.x = parseFloat(bezierCoords[4]);\n        nextPoint.y = parseFloat(bezierCoords[5]);\n\n        // get bezier params                \n        var cp1x = parseFloat(bezierCoords[0]);\n        var cp1y = parseFloat(bezierCoords[1]);\n        var cp2x = parseFloat(bezierCoords[2]);\n        var cp2y = parseFloat(bezierCoords[3]);\n\n        if (segmentIndex >= 0) {\n          path.setBezierArc(segmentIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);\n        } else {\n          console.error('SVG Parse error: Path is not expected to start with \"C\" command');\n        }\n        break;\n\n      case 'A':\n        // tokenize params\n        var src = value.split(',');\n\n        // get position\n        nextPoint.x = parseFloat(src[5]);\n        nextPoint.y = parseFloat(src[6]);\n\n        // read ellipse params.                \n        ellipseParams.rx = parseFloat(src[0]);\n        ellipseParams.ry = parseFloat(src[1]);\n        ellipseParams.rotation = parseFloat(src[2]);\n        ellipseParams.largeArcFlag = Boolean(parseFloat(src[3]));\n        ellipseParams.sweepFlag = Boolean(parseFloat(src[4]));\n\n        if (segmentIndex >= 0) {\n          path.setEllipseArc(segmentIndex, ellipseParams, loopIndex);\n        } else {\n          console.error('SVG Parse error: Path is not expected to start with \"A\" command');\n        }\n        break;\n      case 'Z':\n        // we are done\n        path.isClosed = true;\n        continue;}\n\n\n    // add next point\n    path.addPoint(nextPoint.x, nextPoint.y, loopIndex);\n  }\n\n  removeDuplicateLoopEndPoints(path);\n\n  return path;\n};\n\nvar pathToSvgPath = function pathToSvgPath(path) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!path.vertexCount) {\n    return [];\n  }\n\n  // Shortcut for restricting number of digits\n  var ld = function ld(num) {return limitDigits(num, digits);};\n\n  var svgPath = [];\n\n  // reused per loop cycle\n  var p = new THREE.Vector2();\n  var pPrev = new THREE.Vector2();\n  var params = new EllipseArcParams();\n  var cp1 = new THREE.Vector2();\n  var cp2 = new THREE.Vector2();\n\n  var loopCount = path.loopCount;\n  for (var l = 0; l < loopCount; l++) {\n\n    // Add M command for first vertex\n    var edgeCount = path.getEdgeCount(l);\n    if (edgeCount > 0) {\n      p = path.getPoint(0, l, p);\n      svgPath.push(\"M \".concat(ld(p.x), \",\").concat(ld(p.y)));\n    }\n\n    for (var i = 0; i < edgeCount; i++) {\n\n      // Vertex i is the end point of segment i-1, which defines edge type and arc params\n      var segmentIndex = i;\n      var edgeType = path.isPath() ? path.getEdgeType(segmentIndex, l) : EdgeType.Line;\n\n      // get next point. Note: If the path is closed, p will be the start vertex of the loop again.\n      var edgeEndVertex = path.nextIndex(segmentIndex, l);\n      p = path.getPoint(edgeEndVertex, l, p);\n\n      var value = '';\n      switch (edgeType) {\n\n        case EdgeType.Ellipse:\n          params = path.getEllipseArcParams(segmentIndex, l, params);\n\n          // Convert boolean flags to 1/0\n          var largeArc = params.largeArcFlag ? 1 : 0;\n          var sweep = params.sweepFlag ? 1 : 0;\n\n          value = \"A \".concat(params.rx, \",\").concat(params.ry, \",\").concat(params.rotation, \",\").concat(largeArc, \",\").concat(sweep, \",\").concat(p.x, \",\").concat(p.y);\n          break;\n\n        case EdgeType.Bezier:\n          cp1 = path.getControlPoint(segmentIndex, 1, l, cp1);\n          cp2 = path.getControlPoint(segmentIndex, 2, l, cp2);\n          value = \"C \".concat(ld(cp1.x, digits), \",\").concat(ld(cp1.y, digits), \",\").concat(ld(cp2.x, digits), \",\").concat(ld(cp2.y, digits), \",\").concat(ld(p.x, digits), \",\").concat(ld(p.y, digits));\n          break;\n\n        default:\n          {\n            // skip empty/duplicate points\n            pPrev = path.getPoint(i, l, pPrev);\n            var delta = Math2D.pointDelta(pPrev, p, digits);\n            if (!delta) {\n              continue;\n            }\n\n            if (Math.abs(delta.x) <= precision) {\n              value = \"V \".concat(ld(p.y));\n            } else if (Math.abs(delta.y) <= precision) {\n              value = \"H \".concat(ld(p.x));\n            } else {\n              value = \"L \".concat(ld(p.x), \",\").concat(ld(p.y));\n            }\n          }}\n\n\n      // For closed paths, the edge end vertex will be 0. Repeating the start vertex is only necessary if the\n      // last segment is an arc: Without repeating the start vertex at the loop end, we could not store the arc parameters in SVG.\n      var isRepeatedStartVertex = edgeEndVertex === 0;\n      if (isRepeatedStartVertex && edgeType === EdgeType.Line) {\n        // Last segment of the loop is a line. We don't need to repeat the start vertex in this case.\n        continue;\n      }\n\n      svgPath.push(value);\n    }\n\n    // For a closed path, repeat the end vertex. This is necessary to preserve arc params\n    if (path.isClosed) {\n      // close loop\n      svgPath.push('Z');\n    }\n  }\n\n  return svgPath;\n};\n\n// Extract dictionary of SVG style attributes from Edit2D style\n//  @param {Style} style\n//  @returns {Object}\nvar getSvgStyleAttributes = function getSvgStyleAttributes(style) {\n\n  var target = {};\n  target[\"stroke\"] = style.lineColor;\n  target[\"fill\"] = style.fillColor;\n  target[\"stroke-width\"] = style.lineWidth;\n\n  // omit opacities if they are 1 (default)\n  if (style.lineAlpha != 1) target[\"stroke-opacity\"] = style.lineAlpha;\n  if (style.fillAlpha != 1) target[\"fill-opacity\"] = style.fillAlpha;\n\n  return target;\n};\n\n// Converts the result of getSvgStyleAttributes to a string postfix. Since we append it\n// to other attributes, it contains a preceding space. \n// Example: ' stroke=\"rgb(0,0,0)\" fill=\"rgb(0,0,255)\" ... '\nvar getAttributePostFix = function getAttributePostFix(attribs) {\n  var str = '';\n  for (var key in attribs) {\n    str += \" \".concat(key, \"=\\\"\").concat(attribs[key], \"\\\"\");\n  }\n  return str;\n};\n\n// Apply all given attributes to a Dom Element\nvar applyAttributes = function applyAttributes(domElement, attribs) {\n  for (var key in attribs) {\n    domElement.setAttribute(key, attribs[key]);\n  }\n};\n\n// Converts a shape into a string describing an SVG path. Note that (for legacy reasons),\n// style attributes are only exported if specified in options.\n//\n// @param {Shape} shape\n// @param {Object} [options]\n// @param {number} [options.precision=0]       - accuracy for unifying duplicate points \n// @param {number} [options.digis=0]           - number of digits for number strings \n// @param {bool}   [options.exportStyle=false] - If true, we also export style attributes\n//\n// Note: We currently have to use function syntax, otherwise we cannot use 'arguments' for the legacy fallback below.\nvar toSvg = function toSvg(shape, options) {\n\n  var precision = options && options.precision || 0;\n  var digits = options && options.digits || null; // means no limitation of digits\n  var exportStyle = options && options.exportStyle || false;\n\n  // add style params if wanted\n  var stylePostfix = '';\n  if (exportStyle) {\n    var attribs = getSvgStyleAttributes(shape.style);\n    stylePostfix = getAttributePostFix(attribs);\n  }\n\n  // Legacy: Keep old code using that still passes precision/digits separately\n  // Todo: Remove this when checked with clients.\n  if (_typeof(options) !== 'object') {\n    if (typeof arguments[1] == 'number') precision = arguments[1];\n    if (typeof arguments[2] == 'number') digits = arguments[2];\n  }\n\n  if (shape instanceof Circle) {\n    return circleToSvg(shape, digits, stylePostfix);\n  }\n\n  if (!(shape instanceof PolyBase)) {\n    console.error('SVG serialization not supported for this shape: ', shape);\n    return;\n  }\n\n  // PolyBase and Path are translated to SVG Path\n  var path = pathToSvgPath(shape, precision, digits);\n\n  return \"<path d=\\\"\".concat(path.join(' '), \"\\\"\").concat(stylePostfix, \"/>\");\n};\n\n// see toSvg for options.\nvar createSvgShape = function createSvgShape(shape, options) {\n  var precision = options && options.precision || 0;\n  var digits = options && options.digits || 0;\n  var exportStyle = options && options.exportStyle || true;\n\n  // Todo: support circles and other shapes if anyone needs it.\n  if (!(shape instanceof PolyBase)) {\n    console.error('SVG serialization not supported for this shape: ', shape);\n    return;\n  }\n\n  var path = document.createElementNS(SvgNs, 'path');\n  path.setAttribute('d', pathToSvgPath(shape, precision, digits));\n\n  if (exportStyle) {\n    var attribs = getSvgStyleAttributes(shape.style);\n    applyAttributes(path, attribs);\n  }\n\n  return path;\n};\n\n// @param {string}  svg - e.g. '<path d=\"M 13.882,4.8592 L 14.6757,4.738\"/>'\nvar fromSvg = function fromSvg(svg) {\n  if (!svg) {\n    return;\n  }\n\n  // init on first use\n  domParser = domParser || new DOMParser();\n\n  var dom = domParser.parseFromString(svg, 'application/xml');\n\n  if (dom.childNodes.length !== 1) {\n    throw 'Function does only support svg with a single element: path, circle';\n  }\n  var node = dom.firstChild;\n  if (node.nodeName === 'circle') {\n    return domToCircle(node);\n  } else\n  if (node.nodeName === 'path') {\n    return domToPath(node);\n  }\n\n  throw \"Unsupported svg node type: \".concat(node.nodeName);\n};\n\n// Converts several shapes to an SVG element.\n//  @param {Object} [options]\n//  @param {Box2} [dstBox] - If specified, shapes can be rescaled to fit into a destination box for the given SVG.\n//  @param {Box2} [srcBox] - By default, srcBox is the union of all shapeBoxes. Shapes are uniformly rescaled from srcBox into dstBox.\n// see toSvg() for other options\nvar createSvgElement = function createSvgElement(shapes) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // get summed box of all shapes\n  var sumBox = new THREE.Box2();\n  shapes.forEach(function (shape) {return sumBox.union(shape.getBBox());});\n\n  var srcBox = options.srcBox || sumBox;\n  var dstBox = options.dstBox || sumBox;\n\n  // Note that we always have to swap y-axis, because the y-axis direction is flipped when \n  // converting 2D world coords in LMV to SVG.\n  var scaleOptions = {\n    preserveAspect: true,\n    flipY: true };\n\n  var tf = Math2D.getFitToBoxTransform(srcBox, dstBox, scaleOptions);\n\n  // get required size of svg\n  var width = dstBox.max.x - dstBox.min.x;\n  var height = dstBox.max.y - dstBox.min.y;\n\n  // create svg root element      \n  var svg = document.createElementNS(SvgNs, 'svg');\n  svg.setAttribute('height', width);\n  svg.setAttribute('width', height);\n\n  // rescale & convert each shape\n  shapes.forEach(function (shape) {\n    var scaledShape = shape.clone().applyMatrix4(tf);\n    var path = createSvgShape(scaledShape, options);\n    svg.appendChild(path);\n  });\n\n  return svg;\n};\n\nexport var Svg = {\n  toSvg: toSvg,\n  fromSvg: fromSvg,\n  createSvgShape: createSvgShape,\n  createSvgElement: createSvgElement };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);} /*!\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Copyright 2017 Autodesk, Inc. All rights reserved.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * This computer source code and related instructions and comments are the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * unpublished confidential and proprietary information of Autodesk, Inc.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * and are protected under applicable copyright and trade secret law. They\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * may not be disclosed to, copied or used by any third party without the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * prior written consent of Autodesk, Inc.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */\n!function (e, t) {\"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) && \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) ? exports[\"solid-definition\"] = t() : e.SolidDefinition = t();}(\"undefined\" != typeof self ? self : this, function () {return function (e) {var t = {};function r(n) {if (t[n]) return t[n].exports;var o = t[n] = { i: n, l: !1, exports: {} };return e[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports;}return r.m = e, r.c = t, r.d = function (e, t, n) {r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n });}, r.r = function (e) {\"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e, \"__esModule\", { value: !0 });}, r.t = function (e, t) {if (1 & t && (e = r(e)), 8 & t) return e;if (4 & t && \"object\" == _typeof(e) && e && e.__esModule) return e;var n = Object.create(null);if (r.r(n), Object.defineProperty(n, \"default\", { enumerable: !0, value: e }), 2 & t && \"string\" != typeof e) for (var o in e) {r.d(n, o, function (t) {return e[t];}.bind(null, o));}return n;}, r.n = function (e) {var t = e && e.__esModule ? function () {return e.default;} : function () {return e;};return r.d(t, \"a\", t), t;}, r.o = function (e, t) {return Object.prototype.hasOwnProperty.call(e, t);}, r.p = \"\", r(r.s = 86);}([function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = !1;\"undefined\" != typeof window && window.isJaguar && (t.isSceneComposerEnv = n = !0);var o = !1;n && (t.USE_LEGACY_LEIDS = o = window.isJaguar && window.isJaguar() || !!JSON.parse(localStorage.getItem(\"USE_LEGACY_LEIDS\"))), t.KERNEL_TOLERANCE = 1e-6, t.KERNEL_ANGULAR_TOLERANCE = 1e-10, t.PARAMETER_SPACE_TOLERANCE = 1e-10, t.SPLINE_TANGENT_HANDLE_SCALE = 1, t.SPLINE_DISTANCE_TOLERANCE = 1e-4, t.DEFAULT_CURVE_RESOLUTION = 64, t.isSceneComposerEnv = n, t.NO_ID = \"\", t.USE_LEGACY_LEIDS = o, t.TESSELLATION = { LINEAR_PRECISION: 1e-4, ANGULAR_PRECISION: 1e-5 }, t.GEOMETRY_TYPES = { POINT: 1, BCURVE: 2, CIRCLE: 3, ELLIPSE: 4, HAPCURVE: 5, LINE: 6, BSURFACE: 7, CONE: 8, CYLINDER: 9, ELLIPTICAL_CONE: 10, ELLIPTICAL_CYLINDER: 11, PLANE: 12, SPHERE: 13, TORUS: 14, toString: function toString(e) {switch (e) {case this.POINT:return \"Point\";case this.BCURVE:return \"BCurve\";case this.CIRCLE:return \"Circle\";case this.ELLIPSE:return \"Ellipse\";case this.HAPCURVE:return \"HapCurve\";case this.LINE:return \"Line\";case this.BSURFACE:return \"BSurface\";case this.CONE:return \"Cone\";case this.CYLINDER:return \"Cylinder\";case this.ELLIPTICAL_CONE:return \"EllipticalCone\";case this.ELLIPTICAL_CYLINDER:return \"EllipticalCylinder\";case this.PLANE:return \"Plane\";case this.SPHERE:return \"Sphere\";case this.TORUS:return \"Torus\";default:return \"unknown\";}} }, t.TOPOLOGY_TYPES = { VERTEX: 1, EDGE: 2, COEDGE: 3, LOOP: 4, FACE: 5, SHELL: 6, LUMP: 7, BODY: 8, WIRE: 9, WIREBODY: 10, toString: function toString(e) {switch (e) {case this.VERTEX:return \"Vertex\";case this.EDGE:return \"Edge\";case this.COEDGE:return \"Coedge\";case this.LOOP:return \"Loop\";case this.FACE:return \"Face\";case this.SHELL:return \"Shell\";case this.LUMP:return \"Lump\";case this.BODY:return \"Body\";case this.WIRE:return \"Wire\";case this.WIREBODY:return \"WireBody\";default:return \"unknown\";}} };}, function (e, t, r) {\"use strict\";r.r(t), r.d(t, \"Vector2\", function () {return s;}), r.d(t, \"Vector3\", function () {return c;}), r.d(t, \"Vector4\", function () {return l;}), r.d(t, \"Matrix22\", function () {return d;}), r.d(t, \"Matrix33\", function () {return p;}), r.d(t, \"Matrix44\", function () {return v;}), r.d(t, \"Quat\", function () {return y;}), r.d(t, \"ProjectionUtils\", function () {return m;}), r.d(t, \"FLOAT64_TOLERANCE\", function () {return n;}), r.d(t, \"FLOAT32_TOLERANCE\", function () {return o;});var n = 1e-12,o = 1e-6;var i = { createFloat32: function createFloat32() {var e = new Float32Array(2);return e[0] = 0, e[1] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(2);return e[0] = 0, e[1] = 0, e;}, createNumber: function createNumber() {return [0, 0];}, clone: function clone(e) {var t = new e.constructor(2);return t[0] = e[0], t[1] = e[1], t;}, createFloat32FromValues: function createFloat32FromValues(e, t) {var r = new Float32Array(2);return r[0] = e, r[1] = t, r;} };i.asFloat32 = i.createFloat32FromValues, i.createFloat64FromValues = function (e, t) {var r = new Float64Array(2);return r[0] = e, r[1] = t, r;}, i.asFloat64 = i.createFloat64FromValues, i.createNumberFromValues = function (e, t) {return [e, t];}, i.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e;}, i.set = function (e, t, r) {return e[0] = t, e[1] = r, e;}, i.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e;}, i.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e;}, i.sub = i.subtract, i.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e;}, i.mul = i.multiply, i.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e;}, i.div = i.divide, i.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e;}, i.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e;}, i.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e;}, i.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e;}, i.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e;}, i.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e;}, i.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e;}, i.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1];return Math.sqrt(r * r + n * n);}, i.dist = i.distance, i.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1];return r * r + n * n;}, i.sqrDist = i.squaredDistance, i.length = function (e) {var t = e[0],r = e[1];return Math.sqrt(t * t + r * r);}, i.len = i.length, i.squaredLength = function (e) {var t = e[0],r = e[1];return t * t + r * r;}, i.sqrLen = i.squaredLength, i.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e;}, i.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e;}, i.normalize = function (e, t) {var r = t[0],n = t[1],o = r * r + n * n;return o > 0 && (o = 1 / Math.sqrt(o), e[0] = t[0] * o, e[1] = t[1] * o), e;}, i.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1];}, i.cross = function (e, t, r) {var n = t[0] * r[1] - t[1] * r[0];return e[0] = e[1] = 0, e[2] = n, e;}, i.lerp = function (e, t, r, n) {var o = t[0],i = t[1];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e;}, i.random = function (e, t) {t = t || 1;var r = 2 * Math.random() * Math.PI;return e[0] = Math.cos(r) * t, e[1] = Math.sin(r) * t, e;}, i.transformMatrix22 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[2] * o, e[1] = r[1] * n + r[3] * o, e;}, i.transformMatrix33 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[3] * o + r[6], e[1] = r[1] * n + r[4] * o + r[7], e;}, i.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[4] * o + r[12], e[1] = r[1] * n + r[5] * o + r[13], e;}, i.angle = function (e, t) {var r = i.clone(e),n = i.clone(t);i.normalize(r, r), i.normalize(n, n);var o = i.dot(r, n),s = Math.abs(r[0] * n[1] - r[1] * n[0]);return Math.atan2(s, o);}, i.isParallel = function (e, t, r, o) {o = o || n, r = r || 0;var s = e[0] * t[1] - e[1] * t[0];return !(s * s > o * o * i.squaredLength(e) * i.squaredLength(t)) && (r > 0 ? i.dot(e, t) > 0 : !(r < 0) || i.dot(e, t) < 0);}, i.isOrthogonal = function (e, t, r) {r = r || n;var o = i.dot(e, t);return o * o <= r * r * i.squaredLength(e) * i.squaredLength(t);}, i.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \"]\";}, i.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1];}, i.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r;};var s = i,a = { createFloat32: function createFloat32() {var e = new Float32Array(3);return e[0] = 0, e[1] = 0, e[2] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(3);return e[0] = 0, e[1] = 0, e[2] = 0, e;}, createNumber: function createNumber() {return [0, 0, 0];}, clone: function clone(e) {var t = new e.constructor(3);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;}, createFloat32FromValues: function createFloat32FromValues(e, t, r) {var n = new Float32Array(3);return n[0] = e, n[1] = t, n[2] = r, n;} };a.asFloat32 = a.createFloat32FromValues, a.createFloat64FromValues = function (e, t, r) {var n = new Float64Array(3);return n[0] = e, n[1] = t, n[2] = r, n;}, a.asFloat64 = a.createFloat64FromValues, a.createNumberFromValues = function (e, t, r) {return [e, t, r];}, a.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;}, a.set = function (e, t, r, n) {return e[0] = t, e[1] = r, e[2] = n, e;}, a.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e;}, a.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e;}, a.sub = a.subtract, a.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e;}, a.mul = a.multiply, a.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e;}, a.div = a.divide, a.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e;}, a.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e;}, a.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e;}, a.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e;}, a.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e;}, a.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e;}, a.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e;}, a.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2];return Math.sqrt(r * r + n * n + o * o);}, a.dist = a.distance, a.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2];return r * r + n * n + o * o;}, a.sqrDist = a.squaredDistance, a.length = function (e) {var t = e[0],r = e[1],n = e[2];return Math.sqrt(t * t + r * r + n * n);}, a.len = a.length, a.squaredLength = function (e) {var t = e[0],r = e[1],n = e[2];return t * t + r * r + n * n;}, a.sqrLen = a.squaredLength, a.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e;}, a.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e;}, a.normalize = function (e, t) {var r = t[0],n = t[1],o = t[2],i = r * r + n * n + o * o;return i > 0 && (i = 1 / Math.sqrt(i), e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i), e;}, a.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];}, a.cross = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2];return e[0] = o * c - i * a, e[1] = i * s - n * c, e[2] = n * a - o * s, e;}, a.lerp = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e[2] = s + n * (r[2] - s), e;}, a.hermite = function (e, t, r, n, o, i) {var s = i * i,a = s * (2 * i - 3) + 1,c = s * (i - 2) + i,u = s * (i - 1),l = s * (3 - 2 * i);return e[0] = t[0] * a + r[0] * c + n[0] * u + o[0] * l, e[1] = t[1] * a + r[1] * c + n[1] * u + o[1] * l, e[2] = t[2] * a + r[2] * c + n[2] * u + o[2] * l, e;}, a.bezier = function (e, t, r, n, o, i) {var s = 1 - i,a = s * s,c = i * i,u = a * s,l = 3 * i * a,h = 3 * c * s,d = c * i;return e[0] = t[0] * u + r[0] * l + n[0] * h + o[0] * d, e[1] = t[1] * u + r[1] * l + n[1] * h + o[1] * d, e[2] = t[2] * u + r[2] * l + n[2] * h + o[2] * d, e;}, a.random = function (e, t) {t = t || 1;var r = 2 * Math.random() * Math.PI,n = 2 * Math.random() - 1,o = Math.sqrt(1 - n * n) * t;return e[0] = Math.cos(r) * o, e[1] = Math.sin(r) * o, e[2] = n * t, e;}, a.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = r[0] * n + r[4] * o + r[8] * i + r[12], e[1] = r[1] * n + r[5] * o + r[9] * i + r[13], e[2] = r[2] * n + r[6] * o + r[10] * i + r[14], e;}, a.transformAsDirectionMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = r[0] * n + r[4] * o + r[8] * i, e[1] = r[1] * n + r[5] * o + r[9] * i, e[2] = r[2] * n + r[6] * o + r[10] * i, e;}, a.transformMatrix33 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = n * r[0] + o * r[3] + i * r[6], e[1] = n * r[1] + o * r[4] + i * r[7], e[2] = n * r[2] + o * r[5] + i * r[8], e;}, a.transformQuat = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2],u = r[3],l = u * n + a * i - c * o,h = u * o + c * n - s * i,d = u * i + s * o - a * n,g = -s * n - a * o - c * i;return e[0] = l * u + g * -s + h * -c - d * -a, e[1] = h * u + g * -a + d * -s - l * -c, e[2] = d * u + g * -c + l * -a - h * -s, e;}, a.setFromMatrixScale = function (e, t) {var r = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),n = Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),o = Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);return e[0] = r, e[1] = n, e[2] = o, e;}, a.rotateX = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[0], i[1] = o[1] * Math.cos(n) - o[2] * Math.sin(n), i[2] = o[1] * Math.sin(n) + o[2] * Math.cos(n), e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.rotateY = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[2] * Math.sin(n) + o[0] * Math.cos(n), i[1] = o[1], i[2] = o[2] * Math.cos(n) - o[0] * Math.sin(n), e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.rotateZ = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[0] * Math.cos(n) - o[1] * Math.sin(n), i[1] = o[0] * Math.sin(n) + o[1] * Math.cos(n), i[2] = o[2], e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.angle = function (e, t) {var r = a.clone(e),n = a.clone(t);a.normalize(r, r), a.normalize(n, n);var o = a.dot(r, n),i = a.length(a.cross(r, r, n));return Math.atan2(i, o);}, a.isParallel = function (e, t, r, o) {o = o || n, r = r || 0;var i = a.createFloat64();return a.cross(i, e, t), !(a.squaredLength(i) > o * o * a.squaredLength(e) * a.squaredLength(t)) && (r > 0 ? a.dot(e, t) > 0 : !(r < 0) || a.dot(e, t) < 0);}, a.isOrthogonal = function (e, t, r) {r = r || n;var o = a.dot(e, t);return o * o <= r * r * a.squaredLength(e) * a.squaredLength(t);}, a.computeOrthogonal = function (e, t) {return t[0] * t[0] > t[2] * t[2] ? a.set(e, t[1], -t[0], 0) : a.set(e, 0, t[2], -t[1]), e;}, a.setEulerFromRotationMatrix = function (e, t, r) {var o = 1 - n;function i(e) {return Math.min(Math.max(e, -1), 1);}var s = t[0],a = t[4],c = t[8],u = t[1],l = t[5],h = t[9],d = t[2],g = t[6],p = t[10];return void 0 === r || \"XYZ\" === r ? (e[1] = Math.asin(i(c)), Math.abs(c) < o ? (e[0] = Math.atan2(-h, p), e[2] = Math.atan2(-a, s)) : (e[0] = Math.atan2(g, l), e[2] = 0)) : \"YXZ\" === r ? (e[0] = Math.asin(-i(h)), Math.abs(h) < o ? (e[1] = Math.atan2(c, p), e[2] = Math.atan2(u, l)) : (e[1] = Math.atan2(-d, s), e[2] = 0)) : \"ZXY\" === r ? (e[0] = Math.asin(i(g)), Math.abs(g) < o ? (e[1] = Math.atan2(-d, p), e[2] = Math.atan2(-a, l)) : (e[1] = 0, e[2] = Math.atan2(u, s))) : \"ZYX\" === r ? (e[1] = Math.asin(-i(d)), Math.abs(d) < o ? (e[0] = Math.atan2(g, p), e[2] = Math.atan2(u, s)) : (e[0] = 0, e[2] = Math.atan2(-a, l))) : \"YZX\" === r ? (e[2] = Math.asin(i(u)), Math.abs(u) < o ? (e[0] = Math.atan2(-h, l), e[1] = Math.atan2(-d, s)) : (e[0] = 0, e[1] = Math.atan2(c, p))) : \"XZY\" === r && (e[2] = Math.asin(-i(a)), Math.abs(a) < o ? (e[0] = Math.atan2(g, l), e[1] = Math.atan2(c, s)) : (e[0] = Math.atan2(-h, p), e[1] = 0)), e;}, a.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \"]\";}, a.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];}, a.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r;};var c = a,u = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;}, createNumber: function createNumber() {return [0, 0, 0, 0];}, clone: function clone(e) {var t = new e.constructor(4);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n) {var o = new Float32Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;} };u.asFloat32 = u.createFloat32FromValues, u.createFloat64FromValues = function (e, t, r, n) {var o = new Float64Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;}, u.asFloat64 = u.createFloat64FromValues, u.createNumberFromValues = function (e, t, r, n) {return [e, t, r, n];}, u.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;}, u.set = function (e, t, r, n, o) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e;}, u.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;}, u.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;}, u.sub = u.subtract, u.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e;}, u.mul = u.multiply, u.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e[3] = t[3] / r[3], e;}, u.div = u.divide, u.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e;}, u.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e;}, u.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e[3] = Math.min(t[3], r[3]), e;}, u.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e[3] = Math.max(t[3], r[3]), e;}, u.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e[3] = Math.round(t[3]), e;}, u.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;}, u.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;}, u.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2],i = t[3] - e[3];return Math.sqrt(r * r + n * n + o * o + i * i);}, u.dist = u.distance, u.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2],i = t[3] - e[3];return r * r + n * n + o * o + i * i;}, u.sqrDist = u.squaredDistance, u.length = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3];return Math.sqrt(t * t + r * r + n * n + o * o);}, u.len = u.length, u.squaredLength = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3];return t * t + r * r + n * n + o * o;}, u.sqrLen = u.squaredLength, u.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e;}, u.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e;}, u.normalize = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * r + n * n + o * o + i * i;return s > 0 && (s = 1 / Math.sqrt(s), e[0] = r * s, e[1] = n * s, e[2] = o * s, e[3] = i * s), e;}, u.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];}, u.lerp = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2],a = t[3];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e[2] = s + n * (r[2] - s), e[3] = a + n * (r[3] - a), e;}, u.random = function (e, t) {return t = t || 1, e[0] = Math.random(), e[1] = Math.random(), e[2] = Math.random(), e[3] = Math.random(), u.normalize(e, e), u.scale(e, e, t), e;}, u.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3];return e[0] = r[0] * n + r[4] * o + r[8] * i + r[12] * s, e[1] = r[1] * n + r[5] * o + r[9] * i + r[13] * s, e[2] = r[2] * n + r[6] * o + r[10] * i + r[14] * s, e[3] = r[3] * n + r[7] * o + r[11] * i + r[15] * s, e;}, u.transformQuat = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2],u = r[3],l = u * n + a * i - c * o,h = u * o + c * n - s * i,d = u * i + s * o - a * n,g = -s * n - a * o - c * i;return e[0] = l * u + g * -s + h * -c - d * -a, e[1] = h * u + g * -a + d * -s - l * -c, e[2] = d * u + g * -c + l * -a - h * -s, e[3] = t[3], e;}, u.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \"]\";}, u.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];}, u.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[2] - t[2]) <= r;};var l = u,h = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 1];}, clone: function clone(e) {var t = new e.constructor(9);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n) {var o = new Float32Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;} };h.asFloat32 = h.createFloat32FromValues, h.createFloat64FromValues = function (e, t, r, n) {var o = new Float64Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;}, h.asFloat64 = h.createFloat64FromValues, h.createNumberFromValues = function (e, t, r, n) {return [e, t, r, n];}, h.set = function (e, t, r, n, o) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e;}, h.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, h.transpose = function (e, t) {if (e === t) {var r = t[1];e[1] = t[2], e[2] = r;} else e[0] = t[0], e[1] = t[2], e[2] = t[1], e[3] = t[3];return e;}, h.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * i - o * n;return s ? (s = 1 / s, e[0] = i * s, e[1] = -n * s, e[2] = -o * s, e[3] = r * s, e) : null;}, h.determinant = function (e) {return e[0] * e[3] - e[2] * e[1];}, h.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1],u = r[2],l = r[3];return e[0] = n * a + i * c, e[1] = o * a + s * c, e[2] = n * u + i * l, e[3] = o * u + s * l, e;}, h.mul = h.multiply, h.scale = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1];return e[0] = n * a, e[1] = o * a, e[2] = i * c, e[3] = s * c, e;}, h.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \"]\";}, h.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;}, h.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;}, h.sub = h.subtract, h.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;}, h.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;}, h.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];}, h.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r;};var d = h,g = { createFloat32: function createFloat32() {var e = new Float32Array(9);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(9);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 0, 1, 0, 0, 0, 1];}, fromMatrix44: function fromMatrix44(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e;}, clone: function clone(e) {var t = new e.constructor(9);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n, o, i, s, a, c) {var u = new Float32Array(9);return u[0] = e, u[1] = t, u[2] = r, u[3] = n, u[4] = o, u[5] = i, u[6] = s, u[7] = a, u[8] = c, u;} };g.asFloat32 = g.createFloat32FromValues, g.createFloat64FromValues = function (e, t, r, n, o, i, s, a, c) {var u = new Float64Array(9);return u[0] = e, u[1] = t, u[2] = r, u[3] = n, u[4] = o, u[5] = i, u[6] = s, u[7] = a, u[8] = c, u;}, g.asFloat64 = g.createFloat64FromValues, g.createNumberFromValues = function (e, t, r, n, o, i, s, a, c) {return [e, t, r, n, o, i, s, a, c];}, g.set = function (e, t, r, n, o, i, s, a, c, u) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e[4] = i, e[5] = s, e[6] = a, e[7] = c, e[8] = u, e;}, g.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.transpose = function (e, t) {if (e === t) {var r = t[1],n = t[2],o = t[5];e[1] = t[3], e[2] = t[6], e[3] = r, e[5] = t[7], e[6] = n, e[7] = o;} else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];return e;}, g.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = l * s - a * u,d = -l * i + a * c,g = u * i - s * c,p = r * h + n * d + o * g;return p ? (p = 1 / p, e[0] = h * p, e[1] = (-l * n + o * u) * p, e[2] = (a * n - o * s) * p, e[3] = d * p, e[4] = (l * r - o * c) * p, e[5] = (-a * r + o * i) * p, e[6] = g * p, e[7] = (-u * r + n * c) * p, e[8] = (s * r - n * i) * p, e) : null;}, g.determinant = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3],i = e[4],s = e[5],a = e[6],c = e[7],u = e[8];return t * (u * i - s * c) + r * (-u * o + s * a) + n * (c * o - i * a);}, g.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = t[4],c = t[5],u = t[6],l = t[7],h = t[8],d = r[0],g = r[1],p = r[2],f = r[3],v = r[4],_ = r[5],y = r[6],m = r[7],E = r[8];return e[0] = d * n + g * s + p * u, e[1] = d * o + g * a + p * l, e[2] = d * i + g * c + p * h, e[3] = f * n + v * s + _ * u, e[4] = f * o + v * a + _ * l, e[5] = f * i + v * c + _ * h, e[6] = y * n + m * s + E * u, e[7] = y * o + m * a + E * l, e[8] = y * i + m * c + E * h, e;}, g.mul = g.multiply, g.fromTranslation = function (e, t) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e;}, g.fromRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = r, e[2] = 0, e[3] = -r, e[4] = n, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.fromScaling = function (e, t) {return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = t[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.fromQuat = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r + r,a = n + n,c = o + o,u = r * s,l = n * s,h = n * a,d = o * s,g = o * a,p = o * c,f = i * s,v = i * a,_ = i * c;return e[0] = 1 - h - p, e[3] = l - _, e[6] = d + v, e[1] = l + _, e[4] = 1 - u - p, e[7] = g - f, e[2] = d - v, e[5] = g + f, e[8] = 1 - u - h, e;}, g.normalFromMatrix44 = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = t[9],d = t[10],g = t[11],p = t[12],f = t[13],v = t[14],_ = t[15],y = r * a - n * s,m = r * c - o * s,E = r * u - i * s,x = n * c - o * a,R = n * u - i * a,A = o * u - i * c,P = l * f - h * p,V = l * v - d * p,T = l * _ - g * p,C = h * v - d * f,b = h * _ - g * f,L = d * _ - g * v,O = y * L - m * b + E * C + x * T - R * V + A * P;return O ? (O = 1 / O, e[0] = (a * L - c * b + u * C) * O, e[1] = (c * T - s * L - u * V) * O, e[2] = (s * b - a * T + u * P) * O, e[3] = (o * b - n * L - i * C) * O, e[4] = (r * L - o * T + i * V) * O, e[5] = (n * T - r * b - i * P) * O, e[6] = (f * A - v * R + _ * x) * O, e[7] = (v * E - p * A - _ * m) * O, e[8] = (p * R - f * E + _ * y) * O, e) : null;}, g.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \", \" + e[4] + \", \" + e[5] + \", \" + e[6] + \", \" + e[7] + \", \" + e[8] + \"]\";}, g.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e;}, g.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e;}, g.sub = g.subtract, g.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e;}, g.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e;}, g.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8];}, g.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r && Math.abs(e[4] - t[4]) <= r && Math.abs(e[5] - t[5]) <= r && Math.abs(e[6] - t[6]) <= r && Math.abs(e[7] - t[7]) <= r && Math.abs(e[8] - t[8]) <= r;};var p = g,f = { createFloat32: function createFloat32() {var e = new Float32Array(16);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(16);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];}, clone: function clone(e) {var t = new e.constructor(16);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {var v = new Float32Array(16);return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = o, v[5] = i, v[6] = s, v[7] = a, v[8] = c, v[9] = u, v[10] = l, v[11] = h, v[12] = d, v[13] = g, v[14] = p, v[15] = f, v;} };f.asFloat32 = f.createFloat32FromValues, f.createFloat64FromValues = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {var v = new Float64Array(16);return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = o, v[5] = i, v[6] = s, v[7] = a, v[8] = c, v[9] = u, v[10] = l, v[11] = h, v[12] = d, v[13] = g, v[14] = p, v[15] = f, v;}, f.asFloat64 = f.createFloat64FromValues, f.createNumberFromValues = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {return [e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f];}, f.set = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f, v) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e[4] = i, e[5] = s, e[6] = a, e[7] = c, e[8] = u, e[9] = l, e[10] = h, e[11] = d, e[12] = g, e[13] = p, e[14] = f, e[15] = v, e;}, f.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.transpose = function (e, t) {if (e === t) {var r = t[1],n = t[2],o = t[3],i = t[6],s = t[7],a = t[11];e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = r, e[6] = t[9], e[7] = t[13], e[8] = n, e[9] = i, e[11] = t[14], e[12] = o, e[13] = s, e[14] = a;} else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];return e;}, f.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = t[9],d = t[10],g = t[11],p = t[12],f = t[13],v = t[14],_ = t[15],y = r * a - n * s,m = r * c - o * s,E = r * u - i * s,x = n * c - o * a,R = n * u - i * a,A = o * u - i * c,P = l * f - h * p,V = l * v - d * p,T = l * _ - g * p,C = h * v - d * f,b = h * _ - g * f,L = d * _ - g * v,O = y * L - m * b + E * C + x * T - R * V + A * P;return O ? (O = 1 / O, e[0] = (a * L - c * b + u * C) * O, e[1] = (o * b - n * L - i * C) * O, e[2] = (f * A - v * R + _ * x) * O, e[3] = (d * R - h * A - g * x) * O, e[4] = (c * T - s * L - u * V) * O, e[5] = (r * L - o * T + i * V) * O, e[6] = (v * E - p * A - _ * m) * O, e[7] = (l * A - d * E + g * m) * O, e[8] = (s * b - a * T + u * P) * O, e[9] = (n * T - r * b - i * P) * O, e[10] = (p * R - f * E + _ * y) * O, e[11] = (h * E - l * R - g * y) * O, e[12] = (a * V - s * C - c * P) * O, e[13] = (r * C - n * V + o * P) * O, e[14] = (f * m - p * x - v * y) * O, e[15] = (l * x - h * m + d * y) * O, e) : null;}, f.determinant = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3],i = e[4],s = e[5],a = e[6],c = e[7],u = e[8],l = e[9],h = e[10],d = e[11],g = e[12],p = e[13],f = e[14],v = e[15];return (t * s - r * i) * (h * v - d * f) - (t * a - n * i) * (l * v - d * p) + (t * c - o * i) * (l * f - h * p) + (r * a - n * s) * (u * v - d * g) - (r * c - o * s) * (u * f - h * g) + (n * c - o * a) * (u * p - l * g);}, f.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = t[4],c = t[5],u = t[6],l = t[7],h = t[8],d = t[9],g = t[10],p = t[11],f = t[12],v = t[13],_ = t[14],y = t[15],m = r[0],E = r[1],x = r[2],R = r[3];return e[0] = m * n + E * a + x * h + R * f, e[1] = m * o + E * c + x * d + R * v, e[2] = m * i + E * u + x * g + R * _, e[3] = m * s + E * l + x * p + R * y, m = r[4], E = r[5], x = r[6], R = r[7], e[4] = m * n + E * a + x * h + R * f, e[5] = m * o + E * c + x * d + R * v, e[6] = m * i + E * u + x * g + R * _, e[7] = m * s + E * l + x * p + R * y, m = r[8], E = r[9], x = r[10], R = r[11], e[8] = m * n + E * a + x * h + R * f, e[9] = m * o + E * c + x * d + R * v, e[10] = m * i + E * u + x * g + R * _, e[11] = m * s + E * l + x * p + R * y, m = r[12], E = r[13], x = r[14], R = r[15], e[12] = m * n + E * a + x * h + R * f, e[13] = m * o + E * c + x * d + R * v, e[14] = m * i + E * u + x * g + R * _, e[15] = m * s + E * l + x * p + R * y, e;}, f.mul = f.multiply, f.fromTranslation = function (e, t) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e;}, f.fromScaling = function (e, t) {return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromRotation = function (e, t, r) {var o,i,s,a = r[0],c = r[1],u = r[2],l = Math.sqrt(a * a + c * c + u * u);return Math.abs(l) < n ? null : (a *= l = 1 / l, c *= l, u *= l, o = Math.sin(t), s = 1 - (i = Math.cos(t)), e[0] = a * a * s + i, e[1] = c * a * s + u * o, e[2] = u * a * s - c * o, e[3] = 0, e[4] = a * c * s - u * o, e[5] = c * c * s + i, e[6] = u * c * s + a * o, e[7] = 0, e[8] = a * u * s + c * o, e[9] = c * u * s - a * o, e[10] = u * u * s + i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e);}, f.fromXRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = r, e[7] = 0, e[8] = 0, e[9] = -r, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromYRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = 0, e[2] = -r, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = r, e[9] = 0, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromZRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = r, e[2] = 0, e[3] = 0, e[4] = -r, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromRotationTranslation = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = n + n,c = o + o,u = i + i,l = n * a,h = n * c,d = n * u,g = o * c,p = o * u,f = i * u,v = s * a,_ = s * c,y = s * u;return e[0] = 1 - (g + f), e[1] = h + y, e[2] = d - _, e[3] = 0, e[4] = h - y, e[5] = 1 - (l + f), e[6] = p + v, e[7] = 0, e[8] = d + _, e[9] = p - v, e[10] = 1 - (l + g), e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;}, f.getTranslation = function (e, t) {return e[0] = t[12], e[1] = t[13], e[2] = t[14], e;}, f.extractRotation = function (e, t) {var r = 1 / Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),n = 1 / Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),o = 1 / Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = 0, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = 0, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;}, f.getRotation = function (e, t) {var r = t[0] + t[5] + t[10],n = 0;return r > 0 ? (n = 2 * Math.sqrt(r + 1), e[3] = .25 * n, e[0] = (t[6] - t[9]) / n, e[1] = (t[8] - t[2]) / n, e[2] = (t[1] - t[4]) / n) : t[0] > t[5] && t[0] > t[10] ? (n = 2 * Math.sqrt(1 + t[0] - t[5] - t[10]), e[3] = (t[6] - t[9]) / n, e[0] = .25 * n, e[1] = (t[1] + t[4]) / n, e[2] = (t[8] + t[2]) / n) : t[5] > t[10] ? (n = 2 * Math.sqrt(1 + t[5] - t[0] - t[10]), e[3] = (t[8] - t[2]) / n, e[0] = (t[1] + t[4]) / n, e[1] = .25 * n, e[2] = (t[6] + t[9]) / n) : (n = 2 * Math.sqrt(1 + t[10] - t[0] - t[5]), e[3] = (t[1] - t[4]) / n, e[0] = (t[8] + t[2]) / n, e[1] = (t[6] + t[9]) / n, e[2] = .25 * n), e;}, f.fromRotationTranslationScale = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2],a = t[3],c = o + o,u = i + i,l = s + s,h = o * c,d = o * u,g = o * l,p = i * u,f = i * l,v = s * l,_ = a * c,y = a * u,m = a * l,E = n[0],x = n[1],R = n[2];return e[0] = (1 - (p + v)) * E, e[1] = (d + m) * E, e[2] = (g - y) * E, e[3] = 0, e[4] = (d - m) * x, e[5] = (1 - (h + v)) * x, e[6] = (f + _) * x, e[7] = 0, e[8] = (g + y) * R, e[9] = (f - _) * R, e[10] = (1 - (h + p)) * R, e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;}, f.fromRotationTranslationScaleOrigin = function (e, t, r, n, o) {var i = t[0],s = t[1],a = t[2],c = t[3],u = i + i,l = s + s,h = a + a,d = i * u,g = i * l,p = i * h,f = s * l,v = s * h,_ = a * h,y = c * u,m = c * l,E = c * h,x = n[0],R = n[1],A = n[2],P = o[0],V = o[1],T = o[2];return e[0] = (1 - (f + _)) * x, e[1] = (g + E) * x, e[2] = (p - m) * x, e[3] = 0, e[4] = (g - E) * R, e[5] = (1 - (d + _)) * R, e[6] = (v + y) * R, e[7] = 0, e[8] = (p + m) * A, e[9] = (v - y) * A, e[10] = (1 - (d + f)) * A, e[11] = 0, e[12] = r[0] + P - (e[0] * P + e[4] * V + e[8] * T), e[13] = r[1] + V - (e[1] * P + e[5] * V + e[9] * T), e[14] = r[2] + T - (e[2] * P + e[6] * V + e[10] * T), e[15] = 1, e;}, f.fromQuat = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r + r,a = n + n,c = o + o,u = r * s,l = n * s,h = n * a,d = o * s,g = o * a,p = o * c,f = i * s,v = i * a,_ = i * c;return e[0] = 1 - h - p, e[1] = l + _, e[2] = d - v, e[3] = 0, e[4] = l - _, e[5] = 1 - u - p, e[6] = g + f, e[7] = 0, e[8] = d + v, e[9] = g - f, e[10] = 1 - u - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.setRotationFromEuler = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = Math.cos(n),a = Math.sin(n),c = Math.cos(o),u = Math.sin(o),l = Math.cos(i),h = Math.sin(i);if (void 0 === r || \"XYZ\" === r) {var d = s * l,g = s * h,p = a * l,f = a * h;e[0] = c * l, e[4] = -c * h, e[8] = u, e[1] = g + p * u, e[5] = d - f * u, e[9] = -a * c, e[2] = f - d * u, e[6] = p + g * u, e[10] = s * c;} else if (\"YXZ\" === r) {var v = c * l,_ = c * h,y = u * l,m = u * h;e[0] = v + m * a, e[4] = y * a - _, e[8] = s * u, e[1] = s * h, e[5] = s * l, e[9] = -a, e[2] = _ * a - y, e[6] = m + v * a, e[10] = s * c;} else if (\"ZXY\" === r) v = c * l, _ = c * h, y = u * l, m = u * h, e[0] = v - m * a, e[4] = -s * h, e[8] = y + _ * a, e[1] = _ + y * a, e[5] = s * l, e[9] = m - v * a, e[2] = -s * u, e[6] = a, e[10] = s * c;else if (\"ZYX\" === r) d = s * l, g = s * h, p = a * l, f = a * h, e[0] = c * l, e[4] = p * u - g, e[8] = d * u + f, e[1] = c * h, e[5] = f * u + d, e[9] = g * u - p, e[2] = -u, e[6] = a * c, e[10] = s * c;else if (\"YZX\" === r) {var E = s * c,x = s * u,R = a * c,A = a * u;e[0] = c * l, e[4] = A - E * h, e[8] = R * h + x, e[1] = h, e[5] = s * l, e[9] = -a * l, e[2] = -u * l, e[6] = x * h + R, e[10] = E - A * h;} else \"XZY\" === r && (E = s * c, x = s * u, R = a * c, A = a * u, e[0] = c * l, e[4] = -h, e[8] = u * l, e[1] = E * h + A, e[5] = s * l, e[9] = x * h - R, e[2] = R * h - x, e[6] = a * l, e[10] = A * h + E);return e;}, f.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \", \" + e[4] + \", \" + e[5] + \", \" + e[6] + \", \" + e[7] + \", \" + e[8] + \", \" + e[9] + \", \" + e[10] + \", \" + e[11] + \", \" + e[12] + \", \" + e[13] + \", \" + e[14] + \", \" + e[15] + \"]\";}, f.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e[9] = t[9] + r[9], e[10] = t[10] + r[10], e[11] = t[11] + r[11], e[12] = t[12] + r[12], e[13] = t[13] + r[13], e[14] = t[14] + r[14], e[15] = t[15] + r[15], e;}, f.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e[9] = t[9] - r[9], e[10] = t[10] - r[10], e[11] = t[11] - r[11], e[12] = t[12] - r[12], e[13] = t[13] - r[13], e[14] = t[14] - r[14], e[15] = t[15] - r[15], e;}, f.sub = f.subtract, f.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12] * r, e[13] = t[13] * r, e[14] = t[14] * r, e[15] = t[15] * r, e;}, f.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e[9] = t[9] + r[9] * n, e[10] = t[10] + r[10] * n, e[11] = t[11] + r[11] * n, e[12] = t[12] + r[12] * n, e[13] = t[13] + r[13] * n, e[14] = t[14] + r[14] * n, e[15] = t[15] + r[15] * n, e;}, f.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];}, f.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r && Math.abs(e[4] - t[4]) <= r && Math.abs(e[5] - t[5]) <= r && Math.abs(e[6] - t[6]) <= r && Math.abs(e[7] - t[7]) <= r && Math.abs(e[8] - t[8]) <= r && Math.abs(e[9] - t[9]) <= r && Math.abs(e[10] - t[10]) <= r && Math.abs(e[11] - t[11]) <= r && Math.abs(e[12] - t[12]) <= r && Math.abs(e[13] - t[13]) <= r && Math.abs(e[14] - t[14]) <= r && Math.abs(e[15] - t[15]) <= r;};var v = f,_ = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createNumber: function createNumber() {return [0, 0, 0, 1];} };_.rotationTo = function () {var e = c.createFloat64(),t = c.createFloat64FromValues(1, 0, 0),r = c.createFloat64FromValues(0, 1, 0);return function (o, i, s) {var a = c.dot(i, s);return a < -1 + n ? (c.cross(e, t, i), c.length(e) < n && c.cross(e, r, i), c.normalize(e, e), _.setAxisAngle(o, e, Math.PI), o) : a > 1 - n ? (o[0] = 0, o[1] = 0, o[2] = 0, o[3] = 1, o) : (c.cross(e, i, s), o[0] = e[0], o[1] = e[1], o[2] = e[2], o[3] = 1 + a, _.normalize(o, o));};}(), _.setAxes = function () {var e = p.createFloat64();return function (t, r, n, o) {return e[0] = n[0], e[3] = n[1], e[6] = n[2], e[1] = o[0], e[4] = o[1], e[7] = o[2], e[2] = -r[0], e[5] = -r[1], e[8] = -r[2], _.normalize(t, _.fromMatrix33(t, e));};}(), _.clone = l.clone, _.createFloat32FromValues = l.createFloat32FromValues, _.createFloat64FromValues = l.createFloat64FromValues, _.createNumberFromValues = l.createNumberFromValues, _.asFloat32 = l.createFloat32FromValues, _.asFloat64 = l.createFloat64FromValues, _.copy = l.copy, _.set = l.set, _.identity = function (e) {return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, _.setAxisAngle = function (e, t, r) {r *= .5;var n = Math.sin(r);return e[0] = n * t[0], e[1] = n * t[1], e[2] = n * t[2], e[3] = Math.cos(r), e;}, _.getAxisAngle = function (e, t) {var r = 2 * Math.acos(t[3]),n = Math.sin(r / 2);return 0 !== n ? (e[0] = t[0] / n, e[1] = t[1] / n, e[2] = t[2] / n) : (e[0] = 1, e[1] = 0, e[2] = 0), r;}, _.add = l.add, _.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1],u = r[2],l = r[3];return e[0] = n * l + s * a + o * u - i * c, e[1] = o * l + s * c + i * a - n * u, e[2] = i * l + s * u + n * c - o * a, e[3] = s * l - n * a - o * c - i * u, e;}, _.mul = _.multiply, _.scale = l.scale, _.rotateX = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c + s * a, e[1] = o * c + i * a, e[2] = i * c - o * a, e[3] = s * c - n * a, e;}, _.rotateY = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c - i * a, e[1] = o * c + s * a, e[2] = i * c + n * a, e[3] = s * c - o * a, e;}, _.rotateZ = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c + o * a, e[1] = o * c - n * a, e[2] = i * c + s * a, e[3] = s * c - i * a, e;}, _.calculateW = function (e, t) {var r = t[0],n = t[1],o = t[2];return e[0] = r, e[1] = n, e[2] = o, e[3] = Math.sqrt(Math.abs(1 - r * r - n * n - o * o)), e;}, _.dot = l.dot, _.lerp = l.lerp, _.slerp = function (e, t, r, o) {var i,s,a,c,u,l = t[0],h = t[1],d = t[2],g = t[3],p = r[0],f = r[1],v = r[2],_ = r[3];return (s = l * p + h * f + d * v + g * _) < 0 && (s = -s, p = -p, f = -f, v = -v, _ = -_), 1 - s > n ? (i = Math.acos(s), a = Math.sin(i), c = Math.sin((1 - o) * i) / a, u = Math.sin(o * i) / a) : (c = 1 - o, u = o), e[0] = c * l + u * p, e[1] = c * h + u * f, e[2] = c * d + u * v, e[3] = c * g + u * _, e;}, _.sqlerp = function () {var e = _.createFloat64(),t = _.createFloat64();return function (r, n, o, i, s, a) {return _.slerp(e, n, s, a), _.slerp(t, o, i, a), _.slerp(r, e, t, 2 * a * (1 - a)), r;};}(), _.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * r + n * n + o * o + i * i,a = s ? 1 / s : 0;return e[0] = -r * a, e[1] = -n * a, e[2] = -o * a, e[3] = i * a, e;}, _.conjugate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e;}, _.length = l.length, _.len = _.length, _.squaredLength = l.squaredLength, _.sqrLen = _.squaredLength, _.normalize = l.normalize, _.fromMatrix33 = function (e, t) {var r,n = t[0] + t[4] + t[8];if (n > 0) r = Math.sqrt(n + 1), e[3] = .5 * r, r = .5 / r, e[0] = (t[5] - t[7]) * r, e[1] = (t[6] - t[2]) * r, e[2] = (t[1] - t[3]) * r;else {var o = 0;t[4] > t[0] && (o = 1), t[8] > t[3 * o + o] && (o = 2);var i = (o + 1) % 3,s = (o + 2) % 3;r = Math.sqrt(t[3 * o + o] - t[3 * i + i] - t[3 * s + s] + 1), e[o] = .5 * r, r = .5 / r, e[3] = (t[3 * i + s] - t[3 * s + i]) * r, e[i] = (t[3 * i + o] + t[3 * o + i]) * r, e[s] = (t[3 * s + o] + t[3 * o + s]) * r;}return e;}, _.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \"]\";}, _.exactEquals = l.exactEquals, _.equals = l.equals;var y = _,m = { frustum: function frustum(e, t, r, n, o, i, s) {var a = 1 / (r - t),c = 1 / (o - n),u = 1 / (i - s);return e[0] = 2 * i * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 2 * i * c, e[6] = 0, e[7] = 0, e[8] = (r + t) * a, e[9] = (o + n) * c, e[10] = (s + i) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = s * i * 2 * u, e[15] = 0, e;}, perspective: function perspective(e, t, r, n, o) {var i = 1 / Math.tan(t / 2),s = 1 / (n - o);return e[0] = i / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (o + n) * s, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = 2 * o * n * s, e[15] = 0, e;}, ortho: function ortho(e, t, r, n, o, i, s) {var a = 1 / (t - r),c = 1 / (n - o),u = 1 / (i - s);return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + r) * a, e[13] = (o + n) * c, e[14] = (s + i) * u, e[15] = 1, e;}, lookAt: function lookAt(e, t, r, o) {var i,s,a,c,u,l,h,d,g,p,f = t[0],_ = t[1],y = t[2],m = o[0],E = o[1],x = o[2],R = r[0],A = r[1],P = r[2];return Math.abs(f - R) < n && Math.abs(_ - A) < n && Math.abs(y - P) < n ? v.identity(e) : (h = f - R, d = _ - A, g = y - P, i = E * (g *= p = 1 / Math.sqrt(h * h + d * d + g * g)) - x * (d *= p), s = x * (h *= p) - m * g, a = m * d - E * h, (p = Math.sqrt(i * i + s * s + a * a)) ? (i *= p = 1 / p, s *= p, a *= p) : (i = 0, s = 0, a = 0), c = d * a - g * s, u = g * i - h * a, l = h * s - d * i, (p = Math.sqrt(c * c + u * u + l * l)) ? (c *= p = 1 / p, u *= p, l *= p) : (c = 0, u = 0, l = 0), e[0] = i, e[1] = c, e[2] = h, e[3] = 0, e[4] = s, e[5] = u, e[6] = d, e[7] = 0, e[8] = a, e[9] = l, e[10] = g, e[11] = 0, e[12] = -(i * f + s * _ + a * y), e[13] = -(c * f + u * _ + l * y), e[14] = -(h * f + d * _ + g * y), e[15] = 1, e);}, transformProjectionMatrix: function transformProjectionMatrix(e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[3] * n + r[7] * o + r[11] * i + r[15];return s = s || 1, e[0] = (r[0] * n + r[4] * o + r[8] * i + r[12]) / s, e[1] = (r[1] * n + r[5] * o + r[9] * i + r[13]) / s, e[2] = (r[2] * n + r[6] * o + r[10] * i + r[14]) / s, e;} };t.default = { Vector2: s, Vector3: c, Vector4: l, Matrix22: d, Matrix33: p, Matrix44: v, Quat: y, ProjectionUtils: m, FLOAT64_TOLERANCE: n, FLOAT32_TOLERANCE: o };}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = { assert: function assert(e, t) {if (!e) throw new Error(t);} };t.ConsoleUtils = n;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.definePlaneThroughPoints = t.getPlaneTransforms = t.limitRange = t.PI2 = t.sortedIndex = t.clamp = t.orient2D = t.signedDistanceTo2DLine = t.intersectIntervals = t.solveTwoEquationsTwoVariables = t.closestPointToTriangle = t.closestPointToPolyline = t.distancePointToLineSegment = t.projectPointToLineSegment = t.angleDifference = t.periodicDifference = t.minMaxCosSinFunc = t.convertToOtherPeriodicRange = t.adjustParameterToPeriodicRange = t.getShortestParametricRange = t.isParameterWithinPeriodicRange = t.normalizeSegmentsToPeriodicRange = t.normalizeParametricRange = t.normalizeParametricRangeToShiftedRange = t.normalizeParameterToShiftedRange = t.adjustAngleToRange = t.normalizeAngleRange = t.normalizeAngle = t.normalizeParameter = t.foldNearTo = t.foldAbove = t.fold = t.modulus = t.getSignedAngle = t.isPointInsidePolygon2D = t.binomialCoefficients = void 0;var n = r(1),o = r(0),i = r(2),s = 2 * Math.PI,a = [];!function () {for (var e = 0; e < 8; ++e) {a[e] = [1];for (var t = 1; t < e; ++t) {a[e][t] = a[e - 1][t - 1] + a[e - 1][t];}a[e][e] = 1;}}();var c = function c(e, t, r) {return Math.min(Math.max(t, e), r);},u = function u(e, t) {return e - t * Math.floor(e / t);},l = function l(e, t) {var r = e % t;return r < 0 ? r + t : r;},h = function h(e, t, r) {return l(e - t, r) + t;},d = function d(e, t) {return e < 0 ? t + e % t : e % t;},g = function g(e, t) {return d(e - t[0], t[1] - t[0]) + t[0];},p = function p(e, t) {i.ConsoleUtils.assert(e[1] >= e[0], \"normalizeParametricRange: in_range ends not in order.\");var r = e[1] - e[0],n = d(e[0], t);return [n, n + r];},f = function f(e, t, r, n, o) {if (!isFinite(r)) return e;var i = p(t, r),s = d(e, r),a = s + r;if (n = !!n, s >= i[0] && s <= i[1]) return t[0] + (s - i[0]);if (a >= i[0] && a <= i[1]) return t[0] + (a - i[0]);var c = Math.abs(i[0] - s),u = Math.abs(s - i[1]),l = Math.abs(i[0] - a),h = Math.abs(a - i[1]);return o ? Math.min(c, l) < Math.min(u, h) ? t[0] : t[1] : Math.min(c, u) > Math.min(l, h) && !n ? t[0] + (a - i[0]) : t[0] + (s - i[0]);},v = function v(e, t, r) {var n = Math.abs(e - t);return isFinite(r) && (n %= r) > r / 2 ? r - n : n;},_ = function _(e, t, r) {var i = n.Vector3.sub(n.Vector3.createFloat64(), t, e),s = n.Vector3.dot(i, i);if (s < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return 0;var a = n.Vector3.sub(n.Vector3.createFloat64(), r, e);return n.Vector3.dot(a, i) / s;};t.binomialCoefficients = a, t.isPointInsidePolygon2D = function (e, t) {for (var r = !1, n = t.length, o = 0, i = n - 2; o < n; o += 2) {t[o + 1] > e[1] != t[i + 1] > e[1] && e[0] < (t[i] - t[o]) * (e[1] - t[o + 1]) / (t[i + 1] - t[o + 1]) + t[o] && (r = !r), i = o;}return r;}, t.getSignedAngle = function (e, t) {var r = c(n.Vector2.dot(e, t), -1, 1),o = t[0] * e[1] - t[1] * e[0];return 0 === o ? .5 * Math.PI * (r - 1) : o < 0 ? -Math.acos(r) : Math.acos(r);}, t.modulus = u, t.fold = l, t.foldAbove = h, t.foldNearTo = function (e, t, r) {return h(e, t - r / 2, r);}, t.normalizeParameter = d, t.normalizeAngle = function (e) {return d(e, s);}, t.normalizeAngleRange = function (e) {return p(e, 2 * Math.PI);}, t.adjustAngleToRange = function (e, t) {return f(e, t, 2 * Math.PI);}, t.normalizeParameterToShiftedRange = g, t.normalizeParametricRangeToShiftedRange = function (e, t) {i.ConsoleUtils.assert(e[1] >= e[0], \"normalizeParametricRangeToShiftedRange: in_range ends not in order.\");var r = e[1] - e[0],n = g(e[0], t);return [n, n + r];}, t.normalizeParametricRange = p, t.normalizeSegmentsToPeriodicRange = function (e, t, r, n, i) {for (var s = void 0 !== n ? n : o.KERNEL_TOLERANCE, a = void 0 !== i ? i : t[1] - t[0], c = [], u = 0; u < e.length; u++) {var l = g(e[u][0], t),h = e[u][1] - e[u][0];if (h >= a) return [[t[0], t[1]]];var d = l + h;d < t[1] ? c.push([l, d]) : (c.push([l, t[1]]), c.push([t[0], d - t[1] + t[0]]));}var p = [];for (c.sort(function (e, t) {return e[0] - t[0];}), u = 0; u < c.length; u++) {for (var f = c[u]; u + 1 < c.length && c[u + 1][0] < f[1];) {f[1] = Math.max(f[1], c[u + 1][1]), u++;}(Math.abs(f[1] - f[0]) > s || !r) && p.push(f);}return p;}, t.isParameterWithinPeriodicRange = function (e, t, r, n) {var o = f(e, t, r);return n = n || 0, o > t[0] - n && o < t[1] + n;}, t.getShortestParametricRange = function (e, t, r) {if ((e = d(e, r)) > (t = d(t, r))) {var n = e;e = t, t = n;}return e - t + r < t - e ? [t, e + r] : [e, t];}, t.adjustParameterToPeriodicRange = f, t.convertToOtherPeriodicRange = function (e, t, r, n) {if (!isFinite(r)) return i.ConsoleUtils.assert(e[0] >= t[0] - n, \"The start of the input range doesn't lie in the target range.\"), i.ConsoleUtils.assert(e[1] <= t[1] + n, \"The input range doesn't lie within the target range.\"), e;if (n = n || 0, e[1] - e[0] >= r - n) return t[1] - t[0] < r - n && console.error(\"The input range is larger than the target range.\"), t;var o = f(e[0], t, r);i.ConsoleUtils.assert(o >= t[0] - n, \"The start of the input range doesn't lie in the target range.\");var s = o + e[1] - e[0];return i.ConsoleUtils.assert(s <= t[1] + n, \"The input range doesn't lie within the target range.\"), [o, s];}, t.minMaxCosSinFunc = function (e, t, r, n) {if (0 === e && 0 === t) return [r, r];var o,i = p(n, 2 * Math.PI),s = f(Math.atan(t / e), i, Math.PI, !0),a = [];for (o = 0; o < 3; ++o) {i[0] <= s && i[1] >= s && a.push(e * Math.cos(s) + t * Math.sin(s)), s += Math.PI;}if (n[1] - n[0] < 2 * Math.PI) for (o = 0; o < 2; o++) {a.push(e * Math.cos(n[o]) + t * Math.sin(n[o]));}return [Math.min.apply(null, a) + r, Math.max.apply(null, a) + r];}, t.periodicDifference = v, t.angleDifference = function (e, t) {return v(e, t, 2 * Math.PI);}, t.projectPointToLineSegment = _, t.distancePointToLineSegment = function (e, t, r, o) {var i = _(e, t, r);i = c(i, 0, 1);var s = o || n.Vector3.createFloat64();return n.Vector3.lerp(s, e, t, i), n.Vector3.distance(s, r);}, t.closestPointToPolyline = function (e, t, r, o, i) {for (var s = \"number\" == typeof t[0], a = s ? t.length / 3 : t.length, u = void 0, l = Number.POSITIVE_INFINITY, h = n.Vector3.createFloat64(), d = 0; d < a - 1; ++d) {var g = r ? r[d] : d,p = r ? r[d + 1] : d + 1,f = 0,v = 1;if (!(o && (o[0] > g && (f = (o[0] - g) / (p - g)), o[1] < p && (v = (o[1] - g) / (p - g)), v < f))) {var y, m;s ? (y = [t[3 * d], t[3 * d + 1], t[3 * d + 2]], m = [t[3 * d + 3], t[3 * d + 4], t[3 * d + 5]]) : (y = t[d], m = t[d + 1]);var E = _(y, m, e);E = c(E, f, v), n.Vector3.lerp(h, y, m, E);var x = n.Vector3.squaredDistance(h, e);x < l && (u = (1 - E) * g + E * p, l = x, i && n.Vector3.copy(i, h));}}return u;}, t.closestPointToTriangle = function (e, t, r, i, s) {var a,u,l = n.Vector3.sub(n.Vector3.createFloat64(), r, t),h = n.Vector3.sub(n.Vector3.createFloat64(), i, t),d = n.Vector3.sub(n.Vector3.createFloat64(), e, t),g = n.Vector3.squaredLength(l),p = n.Vector3.squaredLength(h),f = n.Vector3.dot(l, h),v = n.Vector3.dot(d, l),y = n.Vector3.dot(d, h);if (g < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && p < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = u = 0;else if (g < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = 0, u = c(y / p, 0, 1);else if (p < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = c(v / g, 0, 1), u = 0;else {var m = n.Matrix22.createFloat64FromValues(g, f, f, p);if (Math.abs(n.Matrix22.determinant(m)) > n.FLOAT64_TOLERANCE) {n.Matrix22.invert(m, m);var E = [v, y];n.Vector2.transformMatrix22(E, E, m), a = E[0], u = E[1];} else u = y / p, (a = v / g) <= 0 || u <= 0 ? (a = c(a, 0, 1), u = c(u, 0, 1)) : a < u ? (a = c(a, 0, 1), u = 0) : (a = 0, u = c(u, 0, 1));}if (a < 0 && y >= 0 && y <= p && (a = 0, u = y / p), u < 0 && v >= 0 && v <= g && (a = v / g, u = 0), a + u > 1) {var x = _(r, i, e);x >= 0 && x <= 1 && (a = 1 - x, u = x);}if (a < 0 || u < 0 || a + u > 1) {var R = n.Vector3.squaredLength(d),A = n.Vector3.squaredDistance(e, r),P = n.Vector3.squaredDistance(e, i);A <= R && A <= P ? (a = 1, u = 0) : P <= R && P <= A ? (a = 0, u = 1) : a = u = 0;}return s && (n.Vector3.scaleAndAdd(s, t, l, a), n.Vector3.scaleAndAdd(s, s, h, u)), { coordA: a, coordB: u };}, t.solveTwoEquationsTwoVariables = function (e) {var t = e[0][0],r = e[0][1],n = e[1][0],o = e[1][1],i = t * o - r * n;if (0 !== i) {var s = o * e[0][2] - r * e[1][2],a = -n * e[0][2] + t * e[1][2];return [s /= i, a /= i];}}, t.intersectIntervals = function (e, t, r) {r = r || 0;for (var n = [], o = 0; o < e.length; o++) {for (var i = 0; i < t.length; i++) {var s = Math.max(e[o][0], t[i][0]),a = Math.min(e[o][1], t[i][1]);a - r > s && (a > s ? n.push([s, a]) : n.push([a, a]));}}return n;}, t.signedDistanceTo2DLine = function (e, t, r) {var n = r[0] - e[0],o = r[1] - e[1];return t[1] * n - t[0] * o;}, t.orient2D = function (e, t, r) {var n = e[0] - r[0],o = t[0] - r[0],i = e[1] - r[1];return n * (t[1] - r[1]) - i * o;}, t.clamp = c, t.sortedIndex = function (e, t) {for (var r = 0, n = e.length; n > r;) {var o = Math.floor((r + n) / 2);t > e[o] ? r = o + 1 : n = o;}return n;}, t.PI2 = s, t.limitRange = function (e, t, r, o) {if (i.ConsoleUtils.assert(2 === t.length), i.ConsoleUtils.assert(t[0] <= t[1]), r) return t[1] - t[0] < o + n.FLOAT64_TOLERANCE ? [t[0], t[1]] : (console.warn(\"limitRange : in_limitRange length cannot be greater than in_period\"), [t[0], t[0] + o]);var s = Math.max(e[0], t[0]),a = Math.min(e[1], t[1]);return s > a && (s > a + n.FLOAT64_TOLERANCE && console.warn(\"limitRange : requested range must overlap in_oldRange\"), s = a = t[0] > e[1] ? e[1] : e[0]), [s, a];}, t.getPlaneTransforms = function (e) {var t,r,o = e.evaluateDu(0, 0),i = e.evaluateDv(0, 0),s = e.getOrigin();if (!n.Vector3.isParallel(o, [1, 0, 0], 1) || !n.Vector3.isParallel(i, [0, 1, 0], 1) || Math.abs(s[2]) > n.FLOAT64_TOLERANCE) {var a = e.evaluateNormal(0, 0);t = n.Matrix44.createFloat64FromValues(o[0], o[1], o[2], 0, i[0], i[1], i[2], 0, a[0], a[1], a[2], 0, s[0], s[1], s[2], 1), r = n.Matrix44.createFloat64(), n.Matrix44.invert(r, t);}return { uvToThreeSpace: t, threeSpaceToUV: r };}, t.definePlaneThroughPoints = function (e) {var t,r,i,s = [0, 0, 0],a = [0, 0, 0];if (!(e.length < 3)) {var c = [0, 0, 0];for (t = 0; t < e.length; ++t) {n.Vector3.add(c, c, e[t]);}n.Vector3.scale(c, c, 1 / e.length);var l = [0, 0, 0];r = 0;var h = 0,d = 0;for (t = 0; t < e.length; ++t) {(i = n.Vector3.squaredDistance(c, e[t])) > d && (d = i, h = t), (i /= 100) > r && (r = i, n.Vector3.sub(l, e[t], c));var g = (t + 1) % e.length;(i = n.Vector3.squaredDistance(e[t], e[g])) > r && (r = i, n.Vector3.sub(l, e[g], e[t]));}if (!(d < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE)) {n.Vector3.normalize(l, l);var p = [0, 0, 0];for (r = 0, t = 0; t < e.length; ++t) {n.Vector3.sub(s, e[t], c), n.Vector3.cross(s, s, l), (i = n.Vector3.squaredLength(s)) > r && (r = i, n.Vector3.copy(p, s));}if (!(r < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE)) {n.Vector3.normalize(p, p);var f = e[h],v = e[u(h - 1, e.length)],_ = e[u(h + 1, e.length)];n.Vector3.sub(s, v, f), n.Vector3.sub(a, _, f), n.Vector3.dot(n.Vector3.cross(a, a, s), p) < 0 && n.Vector3.negate(p, p);var y = [0, 0, 0];n.Vector3.cross(y, p, l), n.Vector3.normalize(y, y);var m = Number.POSITIVE_INFINITY,E = Number.NEGATIVE_INFINITY,x = Number.POSITIVE_INFINITY,R = Number.NEGATIVE_INFINITY;for (t = 0; t < e.length; ++t) {n.Vector3.sub(s, e[t], c);var A = n.Vector3.dot(s, l),P = n.Vector3.dot(s, y);m = Math.min(m, A), E = Math.max(E, A), x = Math.min(x, P), R = Math.max(R, P);}return { origin: c, normal: p, uAxis: l, vAxis: y, uRange: [m, E], vRange: [x, R] };}}}};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.BoundingBox = void 0;var n = r(1),o = r(0),i = function i(e, t) {this.min = e ? n.Vector3.createFloat64FromValues(e[0], e[1], e[2]) : n.Vector3.createFloat64FromValues(1 / 0, 1 / 0, 1 / 0), this.max = t ? n.Vector3.createFloat64FromValues(t[0], t[1], t[2]) : n.Vector3.createFloat64FromValues(-1 / 0, -1 / 0, -1 / 0);};i.prototype.toString = function () {return \"(x:\" + this.min[0] + \", y:\" + this.min[1] + \", z:\" + this.min[2] + \") -> (x:\" + this.max[0] + \", y:\" + this.max[1] + \", z:\" + this.max[2] + \")\";}, i.prototype.copy = function (e) {return n.Vector3.copy(this.min, e.min), n.Vector3.copy(this.max, e.max), this;}, i.prototype.clone = function () {return new i(this.min, this.max);}, i.prototype.getWidth = function (e) {var t = 0;return 0 <= e && e <= 2 ? (t = this.max[e] - this.min[e], isFinite(t) ? t : 0) : (console.error(\"wrong axis argument supplied to BoundingBox.getWidth(): \" + e), 0);}, i.prototype.getMaxMinAligned = function (e, t, r) {for (var o, s, a, c = this.getCorners(), u = [], l = [], h = [], d = 0; d < c.length; ++d) {o = n.Vector3.dot(c[d], e), s = n.Vector3.dot(c[d], t), a = n.Vector3.dot(c[d], r), u.push(o), l.push(s), h.push(a);}var g = Math.min.apply(void 0, u),p = Math.min.apply(void 0, l),f = Math.min.apply(void 0, h),v = Math.max.apply(void 0, u),_ = Math.max.apply(void 0, l),y = Math.max.apply(void 0, h);return new i([g, p, f], [v, _, y]);}, i.prototype.include = function (e) {return this.includeX(e.min[0], e.max[0]), this.includeY(e.min[1], e.max[1]), this.includeZ(e.min[2], e.max[2]), this;}, i.prototype.includeX = function (e, t) {return this.min[0] = Math.min(this.min[0], e), this.max[0] = Math.max(this.max[0], t), this;}, i.prototype.includeY = function (e, t) {return this.min[1] = Math.min(this.min[1], e), this.max[1] = Math.max(this.max[1], t), this;}, i.prototype.includeZ = function (e, t) {return this.min[2] = Math.min(this.min[2], e), this.max[2] = Math.max(this.max[2], t), this;}, i.prototype.includeSphere = function (e) {var t = e.getCenter(),r = e.getRadius();return this.includeX(t[0] - r, t[0] + r), this.includeY(t[1] - r, t[1] + r), this.includeZ(t[2] - r, t[2] + r), this;}, i.prototype.translate = function (e) {return n.Vector3.add(this.min, this.min, e), n.Vector3.add(this.max, this.max, e), this;}, i.prototype.getCorners = function () {var e = this.getDiagonal();return [n.Vector3.clone(this.min), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1] + e[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1], this.min[2] + e[2]), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1] + e[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1], this.min[2] + e[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1] + e[1], this.min[2] + e[2]), n.Vector3.clone(this.max)];}, i.prototype.transform = function (e) {if (!this.isEmpty()) {var t = this.getCorners();this.max[0] = -1 / 0, this.max[1] = -1 / 0, this.max[2] = -1 / 0, this.min[0] = 1 / 0, this.min[1] = 1 / 0, this.min[2] = 1 / 0;for (var r = 0; r < t.length; ++r) {n.Vector3.transformMatrix44(t[r], t[r], e), n.Vector3.max(this.max, this.max, t[r]), n.Vector3.min(this.min, this.min, t[r]);}}return this;}, i.prototype.includePointXYZ = function (e) {return this.includeX(e.x, e.x), this.includeY(e.y, e.y), this.includeZ(e.z, e.z), this;}, i.prototype.includePoint = function (e) {return this.includeX(e[0], e[0]), this.includeY(e[1], e[1]), this.includeZ(e[2], e[2]), this;}, i.prototype.getCenter = function () {var e = n.Vector3.createFloat64();return n.Vector3.add(e, this.min, this.max), n.Vector3.scale(e, e, .5), e;}, i.prototype.getDiagonal = function () {var e = n.Vector3.createFloat64();return n.Vector3.sub(e, this.max, this.min), e;}, i.prototype.isPointInside = function (e) {return !(e[0] < this.min[0] || e[0] > this.max[0] || e[1] < this.min[1] || e[1] > this.max[1] || e[2] < this.min[2] || e[2] > this.max[2]);}, i.prototype.isPointInsideWithTolerance = function (e, t) {return t || (t = o.KERNEL_TOLERANCE), !(e[0] < this.min[0] - t || e[0] > this.max[0] + t || e[1] < this.min[1] - t || e[1] > this.max[1] + t || e[2] < this.min[2] - t || e[2] > this.max[2] + t);}, i.prototype.intersects = function (e) {return !(e.min[0] > this.max[0] || e.max[0] < this.min[0] || e.min[1] > this.max[1] || e.max[1] < this.min[1] || e.min[2] > this.max[2] || e.max[2] < this.min[2]);}, i.prototype.intersectsWithTolerance = function (e, t) {return t || (t = o.KERNEL_TOLERANCE), !(e.min[0] > this.max[0] + t || e.max[0] < this.min[0] - t || e.min[1] > this.max[1] + t || e.max[1] < this.min[1] - t || e.min[2] > this.max[2] + t || e.max[2] < this.min[2] - t);}, i.prototype.isEmpty = function () {return this.max[0] < this.min[0] || this.max[1] < this.min[1] || this.max[2] < this.min[2];}, i.prototype.setEmpty = function () {return this.max[0] = -1 / 0, this.min[0] = 1 / 0, this.max[1] = -1 / 0, this.min[1] = 1 / 0, this.max[2] = -1 / 0, this.min[2] = 1 / 0, this;}, i.prototype.isBounded = function () {return isFinite(this.max[0]) && isFinite(this.max[1]) && isFinite(this.max[2]) && isFinite(this.min[0]) && isFinite(this.min[1]) && isFinite(this.min[2]);}, t.BoundingBox = i;}, function (e, t, r) {\"use strict\";var n,o,i = e.exports = r(10),s = r(61);i.codegen = r(99), i.fetch = r(100), i.path = r(101), i.fs = i.inquire(\"fs\"), i.toArray = function (e) {if (e) {for (var t = Object.keys(e), r = new Array(t.length), n = 0; n < t.length;) {r[n] = e[t[n++]];}return r;}return [];}, i.toObject = function (e) {for (var t = {}, r = 0; r < e.length;) {var n = e[r++],o = e[r++];void 0 !== o && (t[n] = o);}return t;};var a = /\\\\/g,c = /\"/g;i.isReserved = function (e) {return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(e);}, i.safeProp = function (e) {return !/^[$\\w_]+$/.test(e) || i.isReserved(e) ? '[\"' + e.replace(a, \"\\\\\\\\\").replace(c, '\\\\\"') + '\"]' : \".\" + e;}, i.ucFirst = function (e) {return e.charAt(0).toUpperCase() + e.substring(1);};var u = /_([a-z])/g;i.camelCase = function (e) {return e.substring(0, 1) + e.substring(1).replace(u, function (e, t) {return t.toUpperCase();});}, i.compareFieldsById = function (e, t) {return e.id - t.id;}, i.decorateType = function (e, t) {if (e.$type) return t && e.$type.name !== t && (i.decorateRoot.remove(e.$type), e.$type.name = t, i.decorateRoot.add(e.$type)), e.$type;n || (n = r(63));var o = new n(t || e.name);return i.decorateRoot.add(o), o.ctor = e, Object.defineProperty(e, \"$type\", { value: o, enumerable: !1 }), Object.defineProperty(e.prototype, \"$type\", { value: o, enumerable: !1 }), o;};var l = 0;i.decorateEnum = function (e) {if (e.$type) return e.$type;o || (o = r(11));var t = new o(\"Enum\" + l++, e);return i.decorateRoot.add(t), Object.defineProperty(e, \"$type\", { value: t, enumerable: !1 }), t;}, Object.defineProperty(i, \"decorateRoot\", { get: function get() {return s.decorated || (s.decorated = new (r(71))());} });}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Point = void 0;var n = r(1),o = r(43),i = r(4),s = r(0),a = function a(e) {o.BaseGeometry.call(this), this._position = n.Vector3.createFloat64(), e && n.Vector3.copy(this._position, e);};(a.prototype = Object.create(o.BaseGeometry.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.POINT;}, a.prototype.clone = function () {var e = new a();return e.copy(this), e;}, a.prototype.copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this.copyPosition(e.getPosition());}, a.prototype.getPosition = function () {return this._position;}, a.prototype.copyPosition = function (e) {n.Vector3.copy(this._position, e);}, a.prototype.setPosition = function (e, t, r) {n.Vector3.set(this._position, e, t, r);}, a.prototype.getBoundingBox = function () {var e = new i.BoundingBox();return e.includePoint(this.getPosition()), e;}, a.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._position, this._position, e);}, a.prototype.toObject = function () {return { position: this.vectorToObject(this._position) };}, t.Point = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Line = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(2),l = function l() {a.Curve.call(this), this._position = n.Vector3.createFloat64FromValues(0, 0, 0), this._direction = n.Vector3.createFloat64FromValues(1, 0, 0);};(l.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.LINE;}, l.prototype.set = function (e, t) {u.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.copy(this._position, e), n.Vector3.copy(this._direction, t);}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.tessellate = function (e, t) {var r = { positions: [], offsets: [], tolerance: 0 };r.offsets.push(0);var n = e[0];r.positions.push(this.evaluatePosition(n));for (var o = 1; o < e.length; ++o) {var i = e[o];r.positions.push(this.evaluatePosition(i)), r.offsets.push(r.positions.length - 1), n = i;}return r;}, l.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._position, e._position), n.Vector3.copy(this._direction, e._direction);}, l.prototype.getRangeUnlimited = function () {return [-1 / 0, 1 / 0];}, l.prototype.isPeriodicUnlimited = function () {return !1;}, l.prototype.isClosedUnlimited = function () {return !1;}, l.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(t, this._position, this._direction, e);}, l.prototype.evaluateDt = function (e) {return n.Vector3.clone(this._direction);}, l.prototype.tangentLength = function (e) {return n.Vector3.length(this._direction);}, l.prototype.getTangentCone = function (e) {var t = n.Vector3.createFloat64();return new i.TangentCone(n.Vector3.normalize(t, this.evaluateDt(0)), 0);}, l.prototype.getArcLength = function (e) {return void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited()), isFinite(e[0]) && isFinite(e[1]) ? (e[1] - e[0]) * n.Vector3.length(this._direction) : 1 / 0;}, l.prototype.getParameterFromArcLength = function (e, t) {if (void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited()), isFinite(t[0]) && isFinite(t[1])) {var r = t[0] + e / n.Vector3.length(this._direction);return (0, c.clamp)(r, t[0], t[1]);}return NaN;}, l.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = new o.BoundingBox();return isFinite(e[0]) && isFinite(e[1]) ? (t.includePoint(this.evaluatePosition(e[0])), t.includePoint(this.evaluatePosition(e[1]))) : (t.includePoint([1 / 0, 1 / 0, 1 / 0]), t.includePoint([-1 / 0, -1 / 0, -1 / 0])), t;}, l.prototype.closestToRayParam = function (e, t, r, o) {var i = n.Vector3.createFloat64();n.Vector3.sub(i, this._position, e);var s = n.Vector3.squaredLength(this._direction),a = n.Vector3.squaredLength(t),c = n.Vector3.dot(this._direction, t),u = n.Vector3.dot(i, this._direction),l = n.Vector3.dot(i, t),h = s * a - c * c,d = (c * l - a * u) / h,g = (c * u - s * l) / h;if (isFinite(d) && isFinite(g)) {if (r) if (d < r[0]) {if (d = r[0], void 0 !== o) {var p = this.evaluatePosition(r[0]),f = n.Vector3.createFloat64();n.Vector3.sub(f, p, e), g = n.Vector3.dot(f, t) / a;}} else if (d > r[1] && (d = r[1], void 0 !== o)) {var v = this.evaluatePosition(r[1]);f = n.Vector3.createFloat64(), n.Vector3.sub(f, v, e), g = n.Vector3.dot(f, t) / a;}if (void 0 !== o) {var _ = this.evaluatePosition(d),y = n.Vector3.createFloat64();if (n.Vector3.scaleAndAdd(y, e, t, g), n.Vector3.squaredDistance(_, y) > o * o) return;}return d;}}, l.prototype.setFromEndpoints = function (e, t) {u.ConsoleUtils.assert(n.Vector3.squaredDistance(e, t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._position = n.Vector3.clone(e), n.Vector3.normalize(this._direction, n.Vector3.sub(this._direction, t, e)), this.unlimitRange();}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._position, this._position, e), n.Vector3.transformAsDirectionMatrix44(this._direction, this._direction, e);}, l.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._position);var o = this._direction,i = n.Vector3.dot(r, o) / n.Vector3.squaredLength(o);return isFinite(t[0]) && isFinite(t[1]) ? (0, c.clamp)(i, t[0], t[1]) : i;}, l.prototype.suggestSplittingParam = function (e) {}, l.prototype.toObject = function () {return { position: this.vectorToObject(this._position), direction: this.vectorToObject(this._direction), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Line = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = !1,o = !1,i = {},s = { init3D: function init3D(e) {for (var t in n = !0, e) {\"function\" == typeof e[t] && (s[t] = e[t].bind(e));}}, setLevel: function setLevel(e, t) {var r = i[e];return i[e] = t, console.log(\"Debug of \" + e + \" set to level \" + t), r;}, level: function level(e) {if (!n) return 0;var t = i[e];return void 0 === t ? 0 : t;}, setConsoleWarnings: function setConsoleWarnings(e) {o = e;}, warn: function warn(e) {o && console.warn(e);} };t.DebugUtils = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.BaseTopology = void 0;var n = r(44),o = r(0),i = function i() {n.Base.call(this), this._attributes = [];};(i.prototype = Object.create(n.Base.prototype)).getTopologyType = function () {console.warn(\"BaseTopology.getTopologyType : abstract method invoked!\");}, i.prototype.getBoundingBox = function () {console.warn(\"BaseTopology.getBoundingBox : abstract method invoked!\");}, i.prototype.getBody = function () {console.warn(\"BaseTopology.getBody : abstract method invoked!\");}, i.prototype.collectFaces = function (e) {return console.warn(\"BaseTopology.collectFaces : abstract method invoked!\"), e || new Set();}, i.prototype.collectEdges = function (e) {return console.warn(\"BaseTopology.collectEdges : abstract method invoked!\"), e || new Set();}, i.prototype.collectVertices = function (e) {return console.warn(\"BaseTopology.collectVertices : abstract method invoked!\"), e || new Set();}, i.prototype.getAttributes = function () {return this._attributes;}, i.prototype.addAttribute = function (e) {this._attributes ? this._attributes.push(e) : this._attributes = [e], e.addTopology(this);}, i.prototype.removeAttribute = function (e) {var t = this._attributes.indexOf(e);return t > -1 && (this._attributes.splice(t, 1), e.removeTopology(this), !0);}, i.prototype.removeAllAttributes = function () {if (this._attributes) for (var _e2 = 0; _e2 < this._attributes.length; _e2++) {this.removeAttribute(this._attributes[_e2]);}}, i.prototype.isVertex = function () {return this.getTopologyType() === o.TOPOLOGY_TYPES.VERTEX;}, i.prototype.getFaces = function () {return Array.from(this.collectFaces());}, i.prototype.getEdges = function () {return Array.from(this.collectEdges());}, i.prototype.getVertices = function () {return Array.from(this.collectVertices());}, i.prototype.addAllToModelObject = function (e, t) {if (!e.topologies[this.getGuid()]) {var _t2 = {};_t2[o.TOPOLOGY_TYPES.toString(this.getTopologyType()).toLowerCase()] = this.toObject(), e.topologies[this.getGuid()] = _t2;}t.forEach(function (t) {null != t && (Array.isArray(t) ? t.forEach(function (t) {t.addToModelObject(e);}) : t.addToModelObject(e));});}, t.BaseTopology = i;}, function (e, t, r) {\"use strict\";(function (e) {var n = t;function o(e, t, r) {for (var n = Object.keys(t), o = 0; o < n.length; ++o) {void 0 !== e[n[o]] && r || (e[n[o]] = t[n[o]]);}return e;}function i(e) {function t(e, r) {if (!(this instanceof t)) return new t(e, r);Object.defineProperty(this, \"message\", { get: function get() {return e;} }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" }), r && o(this, r);}return (t.prototype = Object.create(Error.prototype)).constructor = t, Object.defineProperty(t.prototype, \"name\", { get: function get() {return e;} }), t.prototype.toString = function () {return this.name + \": \" + this.message;}, t;}n.asPromise = r(58), n.base64 = r(90), n.EventEmitter = r(91), n.float = r(92), n.inquire = r(59), n.utf8 = r(93), n.pool = r(94), n.LongBits = r(95), n.global = \"undefined\" != typeof window && window || void 0 !== e && e || \"undefined\" != typeof self && self || this, n.emptyArray = Object.freeze ? Object.freeze([]) : [], n.emptyObject = Object.freeze ? Object.freeze({}) : {}, n.isNode = Boolean(n.global.process && n.global.process.versions && n.global.process.versions.node), n.isInteger = Number.isInteger || function (e) {return \"number\" == typeof e && isFinite(e) && Math.floor(e) === e;}, n.isString = function (e) {return \"string\" == typeof e || e instanceof String;}, n.isObject = function (e) {return e && \"object\" == _typeof(e);}, n.isset = n.isSet = function (e, t) {var r = e[t];return !(null == r || !e.hasOwnProperty(t)) && (\"object\" != _typeof(r) || (Array.isArray(r) ? r.length : Object.keys(r).length) > 0);}, n.Buffer = function () {try {var e = n.inquire(\"buffer\").Buffer;return e.prototype.utf8Write ? e : null;} catch (e) {return null;}}(), n._Buffer_from = null, n._Buffer_allocUnsafe = null, n.newBuffer = function (e) {return \"number\" == typeof e ? n.Buffer ? n._Buffer_allocUnsafe(e) : new n.Array(e) : n.Buffer ? n._Buffer_from(e) : \"undefined\" == typeof Uint8Array ? e : new Uint8Array(e);}, n.Array = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, n.Long = n.global.dcodeIO && n.global.dcodeIO.Long || n.global.Long || n.inquire(\"long\"), n.key2Re = /^true|false|0|1$/, n.key32Re = /^-?(?:0|[1-9][0-9]*)$/, n.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, n.longToHash = function (e) {return e ? n.LongBits.from(e).toHash() : n.LongBits.zeroHash;}, n.longFromHash = function (e, t) {var r = n.LongBits.fromHash(e);return n.Long ? n.Long.fromBits(r.lo, r.hi, t) : r.toNumber(Boolean(t));}, n.merge = o, n.lcFirst = function (e) {return e.charAt(0).toLowerCase() + e.substring(1);}, n.newError = i, n.ProtocolError = i(\"ProtocolError\"), n.oneOfGetter = function (e) {for (var t = {}, r = 0; r < e.length; ++r) {t[e[r]] = 1;}return function () {for (var e = Object.keys(this), r = e.length - 1; r > -1; --r) {if (1 === t[e[r]] && void 0 !== this[e[r]] && null !== this[e[r]]) return e[r];}};}, n.oneOfSetter = function (e) {return function (t) {for (var r = 0; r < e.length; ++r) {e[r] !== t && delete this[e[r]];}};}, n.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }, n._configure = function () {var e = n.Buffer;e ? (n._Buffer_from = e.from !== Uint8Array.from && e.from || function (t, r) {return new e(t, r);}, n._Buffer_allocUnsafe = e.allocUnsafe || function (t) {return new e(t);}) : n._Buffer_from = n._Buffer_allocUnsafe = null;};}).call(this, r(57));}, function (e, t, r) {\"use strict\";e.exports = s;var n = r(21);((s.prototype = Object.create(n.prototype)).constructor = s).className = \"Enum\";var o = r(30),i = r(5);function s(e, t, r, o, i) {if (n.call(this, e, r), t && \"object\" != _typeof(t)) throw TypeError(\"values must be an object\");if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = o, this.comments = i || {}, this.reserved = void 0, t) for (var s = Object.keys(t), a = 0; a < s.length; ++a) {\"number\" == typeof t[s[a]] && (this.valuesById[this.values[s[a]] = t[s[a]]] = s[a]);}}s.fromJSON = function (e, t) {var r = new s(e, t.values, t.options, t.comment, t.comments);return r.reserved = t.reserved, r;}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject([\"options\", this.options, \"values\", this.values, \"reserved\", this.reserved && this.reserved.length ? this.reserved : void 0, \"comment\", t ? this.comment : void 0, \"comments\", t ? this.comments : void 0]);}, s.prototype.add = function (e, t, r) {if (!i.isString(e)) throw TypeError(\"name must be a string\");if (!i.isInteger(t)) throw TypeError(\"id must be an integer\");if (void 0 !== this.values[e]) throw Error(\"duplicate name '\" + e + \"' in \" + this);if (this.isReservedId(t)) throw Error(\"id \" + t + \" is reserved in \" + this);if (this.isReservedName(e)) throw Error(\"name '\" + e + \"' is reserved in \" + this);if (void 0 !== this.valuesById[t]) {if (!this.options || !this.options.allow_alias) throw Error(\"duplicate id \" + t + \" in \" + this);this.values[e] = t;} else this.valuesById[this.values[e] = t] = e;return this.comments[e] = r || null, this;}, s.prototype.remove = function (e) {if (!i.isString(e)) throw TypeError(\"name must be a string\");var t = this.values[e];if (null == t) throw Error(\"name '\" + e + \"' does not exist in \" + this);return delete this.valuesById[t], delete this.values[e], delete this.comments[e], this;}, s.prototype.isReservedId = function (e) {return o.isReservedId(this.reserved, e);}, s.prototype.isReservedName = function (e) {return o.isReservedName(this.reserved, e);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Surface = void 0;var n = r(1),o = r(43),i = r(0),s = r(3),a = function a() {o.BaseGeometry.call(this), this._subrangeU = [], this._subrangeV = [];};(a.prototype = Object.create(o.BaseGeometry.prototype)).copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this._subrangeU = e.isLimitedU() ? [e._subrangeU[0], e._subrangeU[1]] : [], this._subrangeV = e.isLimitedV() ? [e._subrangeV[0], e._subrangeV[1]] : [];}, a.prototype.isLimitedU = function () {return this._subrangeU.length > 0;}, a.prototype.isLimitedV = function () {return this._subrangeV.length > 0;}, a.prototype.getRangeU = function () {return this.isLimitedU() ? this._subrangeU : this.getRangeUnlimitedU();}, a.prototype.getRangeV = function () {return this.isLimitedV() ? this._subrangeV : this.getRangeUnlimitedV();}, a.prototype.getRangeUnlimitedU = function () {console.warn(\"Surface.getRangeUnlimitedU : abstract method invoked!\");}, a.prototype.getRangeUnlimitedV = function () {console.warn(\"Surface.getRangeUnlimitedV : abstract method invoked!\");}, a.prototype.limitRangeU = function (e) {var t = this.getRangeU();this._subrangeU = (0, s.limitRange)(t, e, this.isPeriodicU(), this.getPeriodU());}, a.prototype.limitRangeV = function (e) {var t = this.getRangeV();this._subrangeV = (0, s.limitRange)(t, e, this.isPeriodicV(), this.getPeriodV());}, a.prototype.unlimitRangeU = function () {this._subrangeU = [];}, a.prototype.unlimitRangeV = function () {this._subrangeV = [];}, a.prototype.isPeriodicU = function () {return this.isPeriodicUnlimitedU() && !this.isLimitedU();}, a.prototype.isPeriodicV = function () {return this.isPeriodicUnlimitedV() && !this.isLimitedV();}, a.prototype.isPeriodicUnlimitedU = function () {console.warn(\"Surface.isPeriodicUnlimitedU : abstract method invoked!\");}, a.prototype.isPeriodicUnlimitedV = function () {console.warn(\"Surface.isPeriodicUnlimitedV : abstract method invoked!\");}, a.prototype.getPeriodU = function () {return this.isLimitedU() ? void 0 : this.getPeriodUnlimitedU();}, a.prototype.getPeriodV = function () {return this.isLimitedV() ? void 0 : this.getPeriodUnlimitedV();}, a.prototype.getPeriodUnlimitedU = function () {if (this.isPeriodicUnlimitedU()) {var e = this.getRangeUnlimitedU();return e[1] - e[0];}}, a.prototype.getPeriodUnlimitedV = function () {if (this.isPeriodicUnlimitedV()) {var e = this.getRangeUnlimitedV();return e[1] - e[0];}}, a.prototype.isClosedU = function () {if (this.isClosedUnlimitedU()) {if (this.isLimitedU()) {var e = this.getRangeUnlimitedU(),t = e[1] - e[0];return this._subrangeU[1] - this._subrangeU[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, a.prototype.isClosedV = function () {if (this.isClosedUnlimitedV()) {if (this.isLimitedV()) {var e = this.getRangeUnlimitedV(),t = e[1] - e[0];return this._subrangeV[1] - this._subrangeV[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, a.prototype.isClosedUnlimitedU = function () {console.warn(\"Surface.isClosedUnlimitedU : abstract method invoked!\");}, a.prototype.isClosedUnlimitedV = function () {console.warn(\"Surface.isClosedUnlimitedV : abstract method invoked!\");}, a.prototype.evaluatePosition = function (e, t) {console.warn(\"Surface.evaluatePosition : abstract method invoked\");}, a.prototype.evaluateDu = function (e, t) {console.warn(\"Surface.evaluateDu : abstract method invoked\");}, a.prototype.evaluateDv = function (e, t) {console.warn(\"Surface.evaluateDv : abstract method invoked\");}, a.prototype.evaluateNormal = function (e, t) {var r = this.evaluateDu(e, t);return n.Vector3.cross(r, r, this.evaluateDv(e, t)), n.Vector3.normalize(r, r), r;}, a.prototype.closestParam = function (e) {console.warn(\"Surface.closestParam : abstract method invoked\");}, a.prototype.vParamLine = function (e) {console.warn(\"Surface.vParamLine : abstract method invoked, returning undefined\");}, a.prototype.uParamLine = function (e) {console.warn(\"Surface.uParamLine : abstract method invoked, returning undefined\");}, a.prototype.getBoundingBox = function (e, t) {console.warn(\"Surface.getBoundingBox : abstract method invoked, returning undefined\");}, a.prototype.transform = function (e) {console.warn(\"Surface.transform : abstract method invoked\");}, t.Surface = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Loop = void 0;var n = r(9),o = r(0),i = function i() {n.BaseTopology.call(this), this._coedges = [], this._face = void 0;};(i.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.LOOP;}, i.prototype.getFace = function () {return this._face;}, i.prototype.setFace = function (e) {this._face = e;}, i.prototype.getCoedges = function () {return this._coedges;}, i.prototype.setCoedges = function (e) {this._coedges = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._coedges[t] = e[t];}}, i.prototype.addCoedge = function (e) {this._coedges ? this._coedges.push(e) : this._coedges = [e], e.setLoop(this);}, i.prototype.addCoedges = function (e) {this._coedges || (this._coedges = []);for (var t = 0; t < e.length; ++t) {e[t].setLoop(this);}this._coedges = this._coedges.concat(e);}, i.prototype.removeCoedge = function (e) {var t = this._coedges.indexOf(e);return t > -1 && (this._coedges.splice(t, 1), e.getLoop() === this && e.setLoop(void 0), !0);}, i.prototype.getBody = function () {return this._face ? this._face.getBody() : void 0;}, i.prototype.collectFaces = function (e) {return e = e || new Set(), this._face && e.add(this._face), e;}, i.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._coedges.length; ++t) {this._coedges[t].collectEdges(e);}return e;}, i.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._coedges.length; ++t) {this._coedges[t].collectVertices(e);}return e;}, i.prototype.toString = function () {return \"Loop\";}, i.prototype.toObject = function () {return { coedges: this.refsToStrings(this._coedges), attributes: this.refsToStrings(this._attributes) };}, i.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._coedges, this._attributes]);}, t.Loop = i;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Circle = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(2),l = r(50),h = function h() {a.Curve.call(this), this._center = n.Vector3.createFloat64FromValues(0, 0, 0), this._normal = n.Vector3.createFloat64FromValues(0, 0, 1), this._xAxis = n.Vector3.createFloat64FromValues(1, 0, 0), this._yAxis = n.Vector3.createFloat64FromValues(0, 1, 0), this._radius = 1;};(h.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.CIRCLE;}, h.prototype.set = function (e, t, r) {u.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.squaredLength(r) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(t, r, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.copy(this._center, e), n.Vector3.normalize(this._normal, t), n.Vector3.normalize(this._xAxis, r), this._radius = n.Vector3.length(r), this._computeYAxis();}, h.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._normal, this._xAxis);}, h.prototype.clone = function () {var e = new h();return e.copy(this), e;}, h.prototype.getCenter = function () {return this._center;}, h.prototype.getNormal = function () {return this._normal;}, h.prototype.setNormal = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._normal !== e && (n.Vector3.normalize(this._normal, e), n.Vector3.isOrthogonal(this._xAxis, this._normal) || (n.Vector3.computeOrthogonal(this._xAxis, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis());}, h.prototype.getRadius = function () {return this._radius;}, h.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._radius = e;}, h.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, h.prototype.setOrigin = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(e, this._normal, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, h.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), this._radius = e._radius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._normal, e._normal);}, h.prototype.getRangeUnlimited = function () {return [-Math.PI, Math.PI];}, h.prototype.isPeriodicUnlimited = function () {return !0;}, h.prototype.isClosedUnlimited = function () {return !0;}, h.prototype._computeRadiusVector = function () {return n.Vector3.scale(n.Vector3.createFloat64(), this._xAxis, this._radius);}, h.prototype.tessellate = function (e, t) {t = t || s.TESSELLATION.LINEAR_PRECISION;var r = { positions: [], offsets: [], tolerance: 0 };r.offsets.push(0);for (var n = e[0], o = 1; o < e.length; ++o) {var i = e[o],a = l.CurveTessellator.getCircularArcRenderPoints(this, [n, i], t, 1 === o, r.positions);r.offsets.push(r.positions.length - 1), n = i, r.tolerance = Math.max(r.tolerance, a);}return r;}, h.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, Math.cos(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.sin(e) * this._radius), n.Vector3.add(t, t, this._center), t;}, h.prototype.evaluateDt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.sin(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.cos(e) * this._radius), t;}, h.prototype.evaluateDtt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.cos(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, -Math.sin(e) * this._radius), t;}, h.prototype.tangentLength = function (e) {return this.getRadius();}, h.prototype.getArcLength = function (e) {return void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited()), this.getRadius() * (e[1] - e[0]);}, h.prototype.getParameterFromArcLength = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = t[0] + e / this.getRadius();return (0, c.clamp)(r, t[0], t[1]);}, h.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = (0, c.minMaxCosSinFunc)(this._xAxis[0] * this._radius, this._yAxis[0] * this._radius, this._center[0], e),r = (0, c.minMaxCosSinFunc)(this._xAxis[1] * this._radius, this._yAxis[1] * this._radius, this._center[1], e),n = (0, c.minMaxCosSinFunc)(this._xAxis[2] * this._radius, this._yAxis[2] * this._radius, this._center[2], e),i = new o.BoundingBox();return i.min[0] = t[0], i.max[0] = t[1], i.min[1] = r[0], i.max[1] = r[1], i.min[2] = n[0], i.max[2] = n[1], i;}, h.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = .5 * (e[0] + e[1]),r = n.Vector3.createFloat64FromValues(0, 0, 0);n.Vector3.scaleAndAdd(r, r, this._xAxis, -Math.sin(t)), n.Vector3.scaleAndAdd(r, r, this._yAxis, Math.cos(t));var o = Math.min(Math.PI, .5 * (e[1] - e[0]));return new i.TangentCone(r, o);}, h.prototype.closestToRayParam = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, this._center, e);var i = n.Vector3.dot(o, this._normal) / n.Vector3.dot(t, this._normal);if (isFinite(i)) {var s = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(s, e, t, i), this.closestToPointParam(s, r);}}, h.prototype.getRadiusAndRangeFromEndpoints = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center);var i = n.Vector3.createFloat64();n.Vector3.sub(i, t, this._center);var a,u = .5 * (n.Vector3.length(o) + n.Vector3.length(i)),l = n.Vector3.dot(o, this._xAxis),h = n.Vector3.dot(o, this._yAxis),d = (0, c.normalizeAngle)(Math.atan2(h, l));if (e === t || n.Vector3.squaredDistance(e, t) < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) a = d + c.PI2;else {var g = n.Vector3.dot(i, this._xAxis),p = n.Vector3.dot(i, this._yAxis);if ((a = (0, c.normalizeAngle)(Math.atan2(p, g))) < d && (a += c.PI2), r) {var f = a;a = d, d = f - c.PI2;}}return { radius: u, range: [d, a] };}, h.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._center);var o,i = n.Vector3.dot(r, this._xAxis),a = n.Vector3.dot(r, this._yAxis);return o = i * i + a * a < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE ? .5 * Math.PI : Math.atan2(a, i), o = (0, c.foldNearTo)(o, .5 * (t[0] + t[1]), 2 * Math.PI), (0, c.clamp)(o, t[0], t[1]);}, h.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.scale(this._xAxis, this._xAxis, this._radius), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), this._radius = n.Vector3.length(this._xAxis), n.Vector3.normalize(this._normal, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis), this._computeYAxis();}, h.prototype.suggestSplittingParam = function (e) {}, h.prototype.toObject = function () {var e = this.evaluatePosition(0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), normal: this.vectorToObject(this._normal), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Circle = h;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Face = void 0;var n = r(1),o = r(9),i = r(0),s = r(8),a = function a(e) {o.BaseTopology.call(this), this._surface = e, this._reversed = !1, this._loops = [], this._shell = void 0;};(a.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.FACE;}, a.prototype.getSurfaceType = function () {return this._surface ? this._surface.getGeometryType() : void 0;}, a.prototype.clone = function () {var e = new a();return e._surface = this._surface ? this._surface.clone() : void 0, e._reversed = this._reversed, e.setLoops(this._loops), e._shell = this._shell, e._vertexUvData = void 0, e;}, a.prototype.getSurface = function () {return this._surface;}, a.prototype.setSurface = function (e) {this._surface = e;}, a.prototype.getShell = function () {return this._shell;}, a.prototype.setShell = function (e) {this._shell = e;}, a.prototype.getLoops = function () {return this._loops;}, a.prototype.setLoops = function (e) {this._loops = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._loops[t] = e[t];}}, a.prototype.addLoop = function (e) {this._loops ? this._loops.push(e) : this._loops = [e], e.setFace(this);}, a.prototype.addLoops = function (e) {this._loops || (this._loops = []);for (var t = 0; t < e.length; ++t) {e[t].setFace(this);}this._loops = this._loops.concat(e);}, a.prototype.removeLoop = function (e) {var t = this._loops.indexOf(e);return t > -1 && (this._loops.splice(t, 1), e.getFace() === this && e.setFace(void 0), !0);}, a.prototype.isReversed = function () {return this._reversed;}, a.prototype.setReversed = function (e) {this._reversed = e;}, a.prototype.getVertices = function () {return Array.from(this.collectVertices());}, a.prototype.evaluatePosition = function (e, t) {return this._surface.evaluatePosition(e, t);}, a.prototype.evaluateNormal = function (e, t) {var r = this._surface.evaluateNormal(e, t);return !0 === this.isReversed() && n.Vector3.negate(r, r), r;}, a.prototype.getBody = function () {return this._shell ? this._shell.getBody() : void 0;}, a.prototype.collectFaces = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._loops.length; ++t) {this._loops[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._loops.length; ++t) {this._loops[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {var e = this._surface.getRangeU(),t = this._surface.getRangeV();return isFinite(e[0]) && isFinite(e[1]) || (s.DebugUtils.warn(\"Face.getBoundingBox: Surface is unbounded in u.\"), e = [0, 1]), isFinite(t[0]) && isFinite(t[1]) || (s.DebugUtils.warn(\"Face.getBoundingBox: Surface is unbounded in v.\"), t = [0, 1]), this._surface.getBoundingBox(e, t);}, a.prototype.closestParam = function (e) {return this._surface.closestParam(e);}, a.prototype.isPlanarFace = function () {return this.getSurfaceType() === i.GEOMETRY_TYPES.PLANE;}, a.prototype.toObject = function () {return { loops: this.refsToStrings(this._loops), reversed: this._reversed, geometry: this.refToString(this._surface), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._loops, this._surface, this._attributes]);}, t.Face = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Vertex = void 0;var n = r(9),o = r(0),i = r(2),s = r(78),a = function a(e) {n.BaseTopology.call(this), this._point = e, this._precision = 0, this._edges = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.VERTEX;}, a.prototype.getPoint = function () {return this._point;}, a.prototype.setPoint = function (e) {this._point = e;}, a.prototype.getPrecision = function () {return this._precision;}, a.prototype.setPrecision = function (e) {i.ConsoleUtils.assert(e >= 0), this._precision = e;}, a.prototype.getEdges = function () {return this._edges;}, a.prototype.isAdjacentEdge = function (e) {return -1 !== this._edges.indexOf(e);}, a.prototype.getOtherEdge = function (e) {for (var t = 0; t < this._edges.length; t++) {var r = this._edges[t];if (r !== e) return r;}return null;}, a.prototype.getOtherEdges = function (e) {for (var t = [], r = 0; r < this._edges.length; r++) {var n = this._edges[r];n !== e && t.push(n);}return t;}, a.prototype.getAdjacentVertices = function () {for (var e = [], t = 0; t < this._edges.length; t++) {var r = this._edges[t].getOtherVertex(this);r !== this && e.indexOf(r) < 0 && e.push(r);}return e;}, a.prototype.getCommonEdges = function (e) {for (var t = [], r = 0; r < this._edges.length; r++) {var n = this._edges[r],o = n.getStartVertex(),i = n.getEndVertex();(o === this && i === e || i === this && o === e) && t.push(n);}return t;}, a.prototype.addEdge = function (e) {-1 === this._edges.indexOf(e) && this._edges.push(e);}, a.prototype.removeEdge = function (e) {var t = this._edges.indexOf(e);return t >= 0 && (this._edges.splice(t, 1), !0);}, a.prototype.getPosition = function () {return this._point.getPosition();}, a.prototype.getBody = function () {return this._edges.length > 0 ? this._edges[0].getBody() : void 0;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {this._edges[t].collectFaces(e);}return e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {e.add(this._edges[t]);}return e;}, a.prototype.collectVertices = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.getBoundingBox = function () {return this._point.getBoundingBox();}, a.prototype.toString = function () {return String(this._point.getPosition());}, a.prototype.getOrderedFaces = function () {var e = [],t = (0, s.getOrderedFacesOnVertex)(this);for (var _r = 0; _r < t.length; _r++) {t[_r].faces.forEach(function (t) {e.push(t);});}return e;}, a.prototype.toObject = function () {return { geometry: this.refToString(this._point), precision: this.getPrecision(), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._point, this._attributes]);}, t.Vertex = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.controlPointsFromHomogeneous = t.controlPointsToHomogeneous = t.getUniqueKnots = t.findKnotSpanAndMultiplicity = t.findKnotSpan = void 0;var n = r(0),o = r(2),i = function i(e, t) {var r = 0,n = t.length - 1;if (e <= t[r]) {for (; t[r] === t[r + 1] && r < n - 1;) {r += 1;}return r;}if (e >= t[n]) {for (; t[n] === t[n - 1] && n > r + 1;) {n -= 1;}return n - 1;}for (var o = Math.floor((r + n) / 2); e < t[o] || e >= t[o + 1];) {e < t[o] ? n = o : r = o, o = Math.floor((r + n) / 2);}return o;};t.findKnotSpan = i, t.findKnotSpanAndMultiplicity = function (e, t) {var r = n.PARAMETER_SPACE_TOLERANCE,o = i(e, t),s = 0,a = e,c = o;if (e < t[c] + r) for (a = t[c]; c >= 0 && Math.abs(t[c] - a) < r;) {--c, ++s;} else if (e > t[c + 1] - r) {for (a = t[++c]; c < t.length && Math.abs(t[c] - a) < r;) {++c, ++s;}a = c < t.length ? t[o = c - 1] : t[t.length - 1];}return { span: o, multiplicity: s, knot: a };}, t.getUniqueKnots = function (e) {for (var t = [e[0]], r = 1; r < e.length; ++r) {e[r] !== e[r - 1] && t.push(e[r]);}return t;}, t.controlPointsToHomogeneous = function (e, t) {o.ConsoleUtils.assert(e.length > 0 && e.length === 3 * t.length);for (var r = t.length, n = new Array(4 * r), i = 0; i < r; ++i) {var s = t[i];n[4 * i] = e[3 * i] * s, n[4 * i + 1] = e[3 * i + 1] * s, n[4 * i + 2] = e[3 * i + 2] * s, n[4 * i + 3] = s;}return n;}, t.controlPointsFromHomogeneous = function (e) {o.ConsoleUtils.assert(e.length > 0 && e.length % 4 == 0);for (var t = e.length / 4, r = new Array(3 * t), n = new Array(t), i = 0; i < t; ++i) {var s = e[4 * i + 3];r[3 * i] = e[4 * i] / s, r[3 * i + 1] = e[4 * i + 1] / s, r[3 * i + 2] = e[4 * i + 2] / s, n[i] = s;}return { P: r, w: n };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Plane = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(2),u = function u() {s.Surface.call(this), this._origin = n.Vector3.createFloat64(), this._normal = n.Vector3.createFloat64(), this._uAxis = n.Vector3.createFloat64(), this._vAxis = n.Vector3.createFloat64();};(u.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.PLANE;}, u.prototype.clone = function () {var e = new u();return e.copy(this), e;}, u.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), n.Vector3.copy(this._origin, e._origin), n.Vector3.copy(this._normal, e._normal), n.Vector3.copy(this._uAxis, e._uAxis), n.Vector3.copy(this._vAxis, e._vAxis);}, u.prototype._computeVAxis = function () {n.Vector3.cross(this._vAxis, this._normal, this._uAxis);}, u.prototype.set = function (e, t, r) {n.Vector3.copy(this._origin, e), c.ConsoleUtils.assert(n.Vector3.squaredLength(t) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._normal, t), void 0 === r || n.Vector3.squaredLength(r) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (n.Vector3.computeOrthogonal(this._uAxis, this._normal), n.Vector3.normalize(this._uAxis, this._uAxis)) : (c.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, t, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.copy(this._uAxis, r)), this._computeVAxis();}, u.prototype.getOrigin = function () {return this._origin;}, u.prototype.setOrigin = function (e) {n.Vector3.copy(this._origin, e);}, u.prototype.getNormal = function () {return this._normal;}, u.prototype.setNormal = function (e) {c.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._normal, e), (n.Vector3.squaredLength(this._uAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._uAxis, this._normal, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._uAxis, this._normal), n.Vector3.normalize(this._uAxis, this._uAxis)), this._computeVAxis();}, u.prototype.getUAxis = function () {return this._uAxis;}, u.prototype.setUAxis = function (e) {c.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.copy(this._uAxis, e), this._computeVAxis();}, u.prototype.evaluatePosition = function (e, t) {var r = n.Vector3.clone(this._origin);return n.Vector3.scaleAndAdd(r, r, this._uAxis, e), n.Vector3.scaleAndAdd(r, r, this._vAxis, t), r;}, u.prototype.evaluateNormal = function (e, t) {return n.Vector3.clone(this._normal);}, u.prototype.evaluateDu = function (e, t) {return n.Vector3.clone(this._uAxis);}, u.prototype.evaluateDv = function (e, t) {return n.Vector3.clone(this._vAxis);}, u.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();return n.Vector3.sub(t, e, this._origin), { u: n.Vector3.dot(t, this._uAxis) / n.Vector3.squaredLength(this._uAxis), v: n.Vector3.dot(t, this._vAxis) / n.Vector3.squaredLength(this._vAxis) };}, u.prototype.vParamLine = function (e) {var t = new a.Line();return t.set(this.evaluatePosition(e, 0), this._vAxis), t;}, u.prototype.uParamLine = function (e) {var t = new a.Line();return t.set(this.evaluatePosition(0, e), this._uAxis), t;}, u.prototype.getBoundingBox = function (e, t) {var r = new o.BoundingBox();return e && t ? (r.includePoint(this.evaluatePosition(e[0], t[0])), r.includePoint(this.evaluatePosition(e[0], t[1])), r.includePoint(this.evaluatePosition(e[1], t[1])), r.includePoint(this.evaluatePosition(e[1], t[0]))) : (r.includePoint([-1 / 0, -1 / 0, -1 / 0]), r.includePoint([1 / 0, 1 / 0, 1 / 0])), r;}, u.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._origin, this._origin, e), n.Vector3.transformAsDirectionMatrix44(this._uAxis, this._uAxis, e), n.Vector3.transformAsDirectionMatrix44(this._vAxis, this._vAxis, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.normalize(this._normal, this._normal);}, u.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, u.prototype.getRangeUnlimitedV = function () {return [-1 / 0, 1 / 0];}, u.prototype.isPeriodicUnlimitedU = function () {return !1;}, u.prototype.isPeriodicUnlimitedV = function () {return !1;}, u.prototype.isClosedUnlimitedU = function () {return !1;}, u.prototype.isClosedUnlimitedV = function () {return !1;}, u.prototype.toObject = function () {return { origin: this.vectorToObject(this._origin), normal: this.vectorToObject(this._normal), uAxis: this.vectorToObject(this._uAxis), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Plane = u;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.mergeConnectedFaces = t.mergeFaces = t.findConnectedFaces = t.findConnectedEdges = t.mergeCoincidentVertices = t.transformTopology = t.reverseFace = void 0;var n = r(1),o = r(0),i = r(13),s = r(2),a = function a(e) {e.setReversed(!e.isReversed());},c = function c(e, t) {var r = !1,n = !0,o = new Set();t && (void 0 !== t.inputFacesOnly && (r = t.inputFacesOnly), void 0 !== t.allowVertexConnections && (n = t.allowVertexConnections), void 0 !== t.barrierEdges && (o = new Set(t.barrierEdges)));var i = new Set(),s = new Set(e);function a(t) {s.delete(t), i.add(t), i.forEach(function (t) {var a = new Set();n ? t.collectVertices().forEach(function (e) {e.collectEdges(a);}) : (t.collectEdges(a), o.forEach(function (e) {a.delete(e);})), a.forEach(function (t) {for (var n = t.getCoedge(), o = n; o;) {if (o.getLoop()) {var a = o.getLoop().getFace();i.has(a) || r && !(e.indexOf(a) >= 0) || (i.add(a), s.delete(a));}(o = o.getPartner()) === n && (o = void 0);}});});}for (var c = []; s.size > 0;) {i.clear(), a(s.values().next().value), c.push(Array.from(i));}return c;},u = function u(e) {if (1 !== e.length) {var t = new Set();e.forEach(function (e) {e.collectEdges(t);});var r = new Set(),n = [];t.forEach(function (t) {var o = t.getCoedges(),i = o.map(function (t) {return e.indexOf(t.getFace()) >= 0;});if (2 === o.length && i[0] && i[1]) n.push(t);else for (var s = 0; s < o.length; s++) {i[s] && (r.add(o[s]), o[s].resetUVCurve());}});for (var o = []; r.size > 0;) {for (var a = [], c = r.values().next().value; c;) {a.push(c), r.delete(c);var u = c,l = void 0,h = 2 * c.getEndVertex().getEdges().length;do {if (u = u.getNext(), r.has(u)) {l = u;break;}u = u.getPartner();} while (u && u !== c && --h > 0);c = l;}s.ConsoleUtils.assert(a[0].getStartVertex() === a[a.length - 1].getEndVertex()), o.push(a);}n.forEach(function (e) {e.setStartVertex(null), e.setEndVertex(null);});var d = e[0];d.setLoops([]), o.forEach(function (e) {var t = new i.Loop();t.addCoedges(e), d.addLoop(t);});for (var g = 1; g < e.length; g++) {e[g].getShell() && e[g].getShell().removeFace(e[g]);}var p = d.getSurface();p.unlimitRangeU(), p.unlimitRangeV();}};t.reverseFace = function (e) {e.setReversed(!e.isReversed());for (var t = e.getLoops(), r = 0; r < t.length; ++r) {for (var n = t[r].getCoedges(), o = 0; o < n.length; ++o) {a(n[o]);}n.reverse();}}, t.transformTopology = function (e, t) {Array.isArray(e) || (e = [e]);for (var r = new Set(), n = new Set(), i = new Set(), s = 0; s < e.length; ++s) {var a = e[s],c = a.getTopologyType();a.collectVertices(r), c !== o.TOPOLOGY_TYPES.VERTEX && a.collectEdges(n), c !== o.TOPOLOGY_TYPES.VERTEX && c !== o.TOPOLOGY_TYPES.EDGE && c !== o.TOPOLOGY_TYPES.COEDGE && c !== o.TOPOLOGY_TYPES.LOOP && a.collectFaces(i);}r.forEach(function (e) {e.getPoint() && e.getPoint().transform(t);}), n.forEach(function (e) {e.getCurve() && e.getCurve().transform(t);}), i.forEach(function (e) {e.getSurface() && e.getSurface().transform(t);});}, t.mergeCoincidentVertices = function (e) {for (var t = o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE, r = [], i = 0; i < e.length; ++i) {var s,a = e[i],c = a.getStartVertex(),u = a.getEndVertex();for (s = 0; s < r.length && !(n.Vector3.squaredDistance(c.getPosition(), r[s].getPosition()) < t); ++s) {;}if (s === r.length ? r.push(c) : (r[s].setPrecision(Math.max(r[s].getPrecision(), c.getPrecision())), a.setStartVertex(r[s])), c !== u) for (s = 0; s < r.length && !(n.Vector3.squaredDistance(u.getPosition(), r[s].getPosition()) < t); ++s) {;}s === r.length ? r.push(u) : (r[s].setPrecision(Math.max(r[s].getPrecision(), u.getPrecision())), a.setEndVertex(r[s]));}}, t.findConnectedEdges = function (e, t) {for (var r = t || !1, n = [], o = new Set(), i = 0; i < e.length; ++i) {var s = e[i];if (!o.has(s)) {for (var a = [], c = [s], u = 0; u < c.length; ++u) {var l = c[u];o.has(l) || r && !(e.indexOf(l) >= 0) || (o.add(l), a.push(l), c = c.concat(l.getStartVertex().getEdges(), l.getEndVertex().getEdges()));}n.push(a);}}return n;}, t.findConnectedFaces = c, t.mergeFaces = u, t.mergeConnectedFaces = function (e) {var t = [];return c(e, { inputFacesOnly: !0, allowVertexConnections: !1 }).forEach(function (e) {u(e), t.push(e[0]);}), t;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Edge = void 0;var n = r(1),o = r(9),i = r(0),s = r(2),a = function a(e) {o.BaseTopology.call(this), this._curve = e, this._reversed = !1, this._vertices = [null, null], this._range = [0, 0], this._precision = 0, this._coedge = void 0, this._wire = void 0, this._tessellationPoints = [];};(a.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.EDGE;}, a.prototype.getCurveType = function () {return this._curve ? this._curve.getGeometryType() : void 0;}, a.prototype.clone = function () {var e = new a();return e._curve = this._curve ? this._curve.clone() : void 0, e._reversed = this._reversed, e._vertices[0] = this._vertices[0], e._vertices[1] = this._vertices[1], e._range[0] = this._range[0], e._range[1] = this._range[1], e._precision = this._precision, e._coedge = this._coedge, e._wire = this._wire, e._tessellationPoints = [], e;}, a.prototype.getCurve = function () {return this._curve;}, a.prototype.setCurve = function (e) {this._curve = e;}, a.prototype.getArcLength = function () {var e = this.getRange();return this.isReversed() && (e = [-e[1], -e[0]]), this._curve.getArcLength(e);}, a.prototype.getVertices = function () {return this._vertices;}, a.prototype.getVertex = function (e) {return s.ConsoleUtils.assert(0 === e || 1 === e), this._vertices[e];}, a.prototype.getStartVertex = function () {return this._vertices[0];}, a.prototype.getEndVertex = function () {return this._vertices[1];}, a.prototype.setCoedge = function (e) {this._coedge = e;}, a.prototype.getCoedge = function () {return this._coedge;}, a.prototype.getCoedges = function () {for (var e = [], t = this._coedge; t;) {e.push(t), (t = t.getPartner()) === this._coedge && (t = void 0);}return e;}, a.prototype.setWire = function (e) {this._wire = e;}, a.prototype.getWire = function () {return this._wire;}, a.prototype.getRange = function () {return this._range;}, a.prototype.setRange = function (e) {s.ConsoleUtils.assert(2 === e.length), this._range[0] = e[0], this._range[1] = e[1];}, a.prototype.t0 = function () {return this._range[0];}, a.prototype.sett0 = function (e) {this._range[0] = e;}, a.prototype.t1 = function () {return this._range[1];}, a.prototype.sett1 = function (e) {this._range[1] = e;}, a.prototype.isClosed = function () {return this._curve && this._vertices[0] && this._vertices[0] === this._vertices[1];}, a.prototype.getOtherVertex = function (e) {return s.ConsoleUtils.assert(this._vertices[0] === e || this._vertices[1] === e), this._vertices[0] === e ? this._vertices[1] : this._vertices[0];}, a.prototype.getCommonVertex = function (e) {var t = this.getStartVertex(),r = this.getEndVertex(),n = e.getStartVertex(),o = e.getEndVertex();return t === n || t === o ? t : r === n || r === o ? r : null;}, a.prototype.setVertex = function (e, t) {s.ConsoleUtils.assert(0 === e || 1 === e), t !== this._vertices[e] && (this._vertices[e] && this._vertices[0] !== this._vertices[1] && this._vertices[e].removeEdge(this), this._vertices[e] = t, t && this._vertices[e].addEdge(this));}, a.prototype.setStartVertex = function (e) {this.setVertex(0, e);}, a.prototype.setEndVertex = function (e) {this.setVertex(1, e);}, a.prototype.getCoedgeForFace = function (e) {for (var t = this._coedge; t;) {if (t.getFace() === e) return t;if ((t = t.getPartner()) === this._coedge) break;}}, a.prototype.getOtherFace = function (e) {var t = this.getCoedgeForFace(e);s.ConsoleUtils.assert(t);var r = t.getPartner();if (r && r !== t) return r.getFace();}, a.prototype.isReversed = function () {return this._reversed;}, a.prototype.setReversed = function (e) {this._reversed = e;}, a.prototype.getPrecision = function () {return this._precision;}, a.prototype.setPrecision = function (e) {s.ConsoleUtils.assert(e >= 0), this._precision = e;}, a.prototype.evaluatePosition = function (e) {return this.isReversed() && (e = -e), this._curve.evaluatePosition(e);}, a.prototype.evaluateDt = function (e) {this.isReversed() && (e = -e);var t = this._curve.evaluateDt(e);return this.isReversed() && n.Vector3.negate(t, t), t;}, a.prototype.evaluateCurvature = function (e, t) {return this.isReversed() && (e = -e), this._curve.evaluateCurvature(e, t);}, a.prototype.closestToPointParam = function (e, t) {if (this._curve) {var r = t || this.getRange();this.isReversed() && (r = [-r[1], -r[0]]);var n = this._curve.closestToPointParam(e, r);return this.isReversed() ? -n : n;}}, a.prototype.includesPoint = function (e) {var t = Math.max(this.getPrecision(), i.KERNEL_TOLERANCE),r = this.closestToPointParam(e),o = this.evaluatePosition(r);return n.Vector3.squaredDistance(o, e) < t * t;}, a.prototype.distanceToPoint = function (e) {var t = this.closestToPointParam(e),r = this.evaluatePosition(t);return n.Vector3.distance(r, e);}, a.prototype.tessellate = function (e, t) {var r, o;if (!1 === this.isReversed()) r = e || [this._range[0], this._range[1]];else if (e) {r = new Array(e.length);for (var i = 0; i < e.length; ++i) {r[i] = -e[e.length - 1 - i];}} else r = [-this._range[1], -this._range[0]];var s,a = this._curve.tessellate(r, t);if (this._tessellationPoints.length !== a.positions.length) for (this._tessellationPoints = new Array(a.positions.length), i = 0; i < a.positions.length; i++) {this._tessellationPoints[i] = n.Vector3.createFloat64();}if (!1 === this.isReversed()) for (s = a.offsets, o = 0; o < a.positions.length; ++o) {n.Vector3.copy(this._tessellationPoints[o], a.positions[o]);} else {for (o = 0; o < a.positions.length; ++o) {n.Vector3.copy(this._tessellationPoints[o], a.positions[a.positions.length - 1 - o]);}for (s = new Array(a.offsets.length), o = 0; o < a.offsets.length; ++o) {s[o] = a.positions.length - 1 - a.offsets[a.offsets.length - 1 - o];}}return { positions: this._tessellationPoints, offsets: s, tolerance: a.tolerance };}, a.prototype.getBody = function () {return s.ConsoleUtils.assert(void 0 === this._coedge || void 0 === this._wire), this._coedge ? this._coedge.getBody() : this._wire ? this._wire.getBody() : void 0;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = this._coedge; t;) {t.collectFaces(e), (t = t.getPartner()) === this._coedge && (t = void 0);}return e;}, a.prototype.collectEdges = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._vertices.length; ++t) {this._vertices[t] && e.add(this._vertices[t]);}return e;}, a.prototype.getBoundingBox = function () {var e = this.getRange();return !0 === this.isReversed() && (e = [-e[1], -e[0]]), this._curve.getBoundingBox(e);}, a.prototype.closestToRayParam = function (e, t, r) {var n = this.getRange();!0 === this.isReversed() && (n = [-n[1], -n[0]]);var o = this._curve.closestToRayParam(e, t, n, r);return !0 === this.isReversed() ? -o : o;}, a.prototype.toString = function () {return i.GEOMETRY_TYPES.toString(this.getCurveType()) + \" \" + String(this.getStartVertex()) + \" -> \" + String(this.getEndVertex());}, a.prototype.getLoops = function () {var e = this.getCoedges(),t = new Set();for (var _r2 = 0; _r2 < e.length; _r2++) {t.add(e[_r2].getLoop());}return Array.from(t);}, a.prototype.toObject = function () {return { vertex0: this.refToString(this._vertices[0]), vertex1: this.refToString(this._vertices[1]), precision: this._precision, range: this.rangeToObject(this._range, !0), reversed: this._reversed, geometry: this.refToString(this._curve), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._vertices[0], this._vertices[1], this._curve, this._attributes]);}, t.Edge = a;}, function (e, t, r) {\"use strict\";e.exports = i, i.className = \"ReflectionObject\";var n,o = r(5);function i(e, t) {if (!o.isString(e)) throw TypeError(\"name must be a string\");if (t && !o.isObject(t)) throw TypeError(\"options must be an object\");this.options = t, this.name = e, this.parent = null, this.resolved = !1, this.comment = null, this.filename = null;}Object.defineProperties(i.prototype, { root: { get: function get() {for (var e = this; null !== e.parent;) {e = e.parent;}return e;} }, fullName: { get: function get() {for (var e = [this.name], t = this.parent; t;) {e.unshift(t.name), t = t.parent;}return e.join(\".\");} } }), i.prototype.toJSON = function () {throw Error();}, i.prototype.onAdd = function (e) {this.parent && this.parent !== e && this.parent.remove(this), this.parent = e, this.resolved = !1;var t = e.root;t instanceof n && t._handleAdd(this);}, i.prototype.onRemove = function (e) {var t = e.root;t instanceof n && t._handleRemove(this), this.parent = null, this.resolved = !1;}, i.prototype.resolve = function () {return this.resolved || this.root instanceof n && (this.resolved = !0), this;}, i.prototype.getOption = function (e) {if (this.options) return this.options[e];}, i.prototype.setOption = function (e, t, r) {return r && this.options && void 0 !== this.options[e] || ((this.options || (this.options = {}))[e] = t), this;}, i.prototype.setOptions = function (e, t) {if (e) for (var r = Object.keys(e), n = 0; n < r.length; ++n) {this.setOption(r[n], e[r[n]], t);}return this;}, i.prototype.toString = function () {var e = this.constructor.className,t = this.fullName;return t.length ? e + \" \" + t : e;}, i._configure = function (e) {n = e;};}, function (e, t, r) {\"use strict\";e.exports = u;var n = r(21);((u.prototype = Object.create(n.prototype)).constructor = u).className = \"Field\";var o,i = r(11),s = r(31),a = r(5),c = /^required|optional|repeated$/;function u(e, t, r, o, i, u, l) {if (a.isObject(o) ? (l = i, u = o, o = i = void 0) : a.isObject(i) && (l = u, u = i, i = void 0), n.call(this, e, u), !a.isInteger(t) || t < 0) throw TypeError(\"id must be a non-negative integer\");if (!a.isString(r)) throw TypeError(\"type must be a string\");if (void 0 !== o && !c.test(o = o.toString().toLowerCase())) throw TypeError(\"rule must be a string rule\");if (void 0 !== i && !a.isString(i)) throw TypeError(\"extend must be a string\");this.rule = o && \"optional\" !== o ? o : void 0, this.type = r, this.id = t, this.extend = i || void 0, this.required = \"required\" === o, this.optional = !this.required, this.repeated = \"repeated\" === o, this.map = !1, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = !!a.Long && void 0 !== s.long[r], this.bytes = \"bytes\" === r, this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this.comment = l;}u.fromJSON = function (e, t) {return new u(e, t.id, t.type, t.rule, t.extend, t.options, t.comment);}, Object.defineProperty(u.prototype, \"packed\", { get: function get() {return null === this._packed && (this._packed = !1 !== this.getOption(\"packed\")), this._packed;} }), u.prototype.setOption = function (e, t, r) {return \"packed\" === e && (this._packed = null), n.prototype.setOption.call(this, e, t, r);}, u.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return a.toObject([\"rule\", \"optional\" !== this.rule && this.rule || void 0, \"type\", this.type, \"id\", this.id, \"extend\", this.extend, \"options\", this.options, \"comment\", t ? this.comment : void 0]);}, u.prototype.resolve = function () {if (this.resolved) return this;if (void 0 === (this.typeDefault = s.defaults[this.type]) && (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof o ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]), this.options && null != this.options.default && (this.typeDefault = this.options.default, this.resolvedType instanceof i && \"string\" == typeof this.typeDefault && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (!0 !== this.options.packed && (void 0 === this.options.packed || !this.resolvedType || this.resolvedType instanceof i) || delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long) this.typeDefault = a.Long.fromNumber(this.typeDefault, \"u\" === this.type.charAt(0)), Object.freeze && Object.freeze(this.typeDefault);else if (this.bytes && \"string\" == typeof this.typeDefault) {var e;a.base64.test(this.typeDefault) ? a.base64.decode(this.typeDefault, e = a.newBuffer(a.base64.length(this.typeDefault)), 0) : a.utf8.write(this.typeDefault, e = a.newBuffer(a.utf8.length(this.typeDefault)), 0), this.typeDefault = e;}return this.map ? this.defaultValue = a.emptyObject : this.repeated ? this.defaultValue = a.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof o && (this.parent.ctor.prototype[this.name] = this.defaultValue), n.prototype.resolve.call(this);}, u.d = function (e, t, r, n) {return \"function\" == typeof t ? t = a.decorateType(t).name : t && \"object\" == _typeof(t) && (t = a.decorateEnum(t).name), function (o, i) {a.decorateType(o.constructor).add(new u(i, e, t, r, { default: n }));};}, u._configure = function (e) {o = e;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Ellipse = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(35),l = r(2),h = r(50),d = function d() {a.Curve.call(this), this._center = n.Vector3.createFloat64FromValues(0, 0, 0), this._normal = n.Vector3.createFloat64FromValues(0, 0, 1), this._xAxis = n.Vector3.createFloat64FromValues(1, 0, 0), this._yAxis = n.Vector3.createFloat64FromValues(0, 1, 0), this._majorRadius = 0, this._minorRadius = 0, this._tessellationCache = new h.TessellationCache();};(d.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.ELLIPSE;}, d.prototype.set = function (e, t, r, o) {l.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.squaredLength(r) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.isOrthogonal(t, r, s.KERNEL_ANGULAR_TOLERANCE)), l.ConsoleUtils.assert(o > n.FLOAT64_TOLERANCE && o <= 1, \"Invalid radius ratio\"), n.Vector3.copy(this._center, e), n.Vector3.normalize(this._normal, t), n.Vector3.normalize(this._xAxis, r), this._majorRadius = n.Vector3.length(r), this._minorRadius = this._majorRadius * o, this._computeYAxis(), this._dirtyTessellation();}, d.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._normal, this._xAxis);}, d.prototype.getCenter = function () {return this._center;}, d.prototype.getNormal = function () {return this._normal;}, d.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e), this._dirtyTessellation();}, d.prototype.setNormal = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._normal !== e && (n.Vector3.normalize(this._normal, e), n.Vector3.isOrthogonal(this._xAxis, this._normal) || (n.Vector3.computeOrthogonal(this._xAxis, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis(), this._dirtyTessellation());}, d.prototype.setMajorAxis = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.isOrthogonal(e, this._normal, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, e), this._computeYAxis(), this._dirtyTessellation();}, d.prototype.getMajorAxis = function () {return this._xAxis;}, d.prototype.getMinorAxis = function () {return this._yAxis;}, d.prototype.clone = function () {var e = new d();return e.copy(this), e;}, d.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._normal, e._normal);}, d.prototype.getMajorRadius = function () {return this._majorRadius;}, d.prototype.getMinorRadius = function () {return this._minorRadius;}, d.prototype.setMajorRadius = function (e) {l.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._majorRadius = e, this._dirtyTessellation();}, d.prototype.setMinorRadius = function (e) {l.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._minorRadius = e, this._dirtyTessellation();}, d.prototype.getRangeUnlimited = function () {return [-Math.PI, Math.PI];}, d.prototype.isPeriodicUnlimited = function () {return !0;}, d.prototype.isClosedUnlimited = function () {return !0;}, d.prototype._dirtyTessellation = function () {this._tessellationCache.setDirty(!0);}, d.prototype._evaluateArcLengthIntegrand = function (e) {var t = this._majorRadius * Math.sin(e),r = this._minorRadius * Math.cos(e);return Math.sqrt(t * t + r * r);}, d.prototype.getArcLength = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());for (var t = e[0], r = 0; t < e[1] + s.PARAMETER_SPACE_TOLERANCE;) {for (var n = t, o = [this._evaluateArcLengthIntegrand(t)]; o.length < 5 && t < e[1] + s.PARAMETER_SPACE_TOLERANCE;) {t += .01, o.push(this._evaluateArcLengthIntegrand(t));}switch (n = t - n, o.length) {case 1:break;case 2:r += (o[0] + o[1]) * n / 2;break;case 3:r += (o[0] + 4 * o[1] + o[2]) * n / 6;break;case 4:r += (o[0] + 3 * o[1] + 3 * o[2] + o[3]) * n / 8;break;default:r += (7 * o[0] + 32 * o[1] + 12 * o[2] + 32 * o[3] + 7 * o[4]) * n / 90;}(n = t - e[1]) > s.PARAMETER_SPACE_TOLERANCE && (r -= this._evaluateArcLengthIntegrand(e[1]) * n);}return r;}, d.prototype.getParameterFromArcLength = function (e, t) {return void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited()), (0, u.invertIntegral1D)(this._evaluateArcLengthIntegrand.bind(this), e, t);}, d.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, Math.cos(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.sin(e) * this._minorRadius), n.Vector3.add(t, t, this._center), t;}, d.prototype.evaluateDt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.sin(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.cos(e) * this._minorRadius), t;}, d.prototype.evaluateDtt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.cos(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, -Math.sin(e) * this._minorRadius), t;}, d.prototype._getFullTessellation = function (e) {var t = [-Math.PI, -Math.PI / 2, 0, Math.PI / 2, Math.PI],r = h.CurveTessellator.getAdaptiveRenderPoints(this, e, [-Math.PI, Math.PI], t);return r.didRetessellate = !0, r;}, d.prototype.tessellate = function (e, t) {return t = t || s.TESSELLATION.LINEAR_PRECISION, this._tessellationCache.getTessellation(e, this, t, this._getFullTessellation.bind(this));}, d.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = (0, c.minMaxCosSinFunc)(this._xAxis[0] * this._majorRadius, this._yAxis[0] * this._minorRadius, this._center[0], e),r = (0, c.minMaxCosSinFunc)(this._xAxis[1] * this._majorRadius, this._yAxis[1] * this._minorRadius, this._center[1], e),n = (0, c.minMaxCosSinFunc)(this._xAxis[2] * this._majorRadius, this._yAxis[2] * this._minorRadius, this._center[2], e),i = new o.BoundingBox();return i.min[0] = t[0], i.max[0] = t[1], i.min[1] = r[0], i.max[1] = r[1], i.min[2] = n[0], i.max[2] = n[1], i;}, d.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this.evaluateDt(e[0]);n.Vector3.normalize(t, t);var r = this.evaluateDt(e[1]);n.Vector3.normalize(r, r);var o = n.Vector3.createFloat64(),a = n.Vector3.dot(t, r),u = n.Vector3.dot(n.Vector3.cross(o, t, r), this._normal),l = Math.atan2(u, a);l < 0 ? l += c.PI2 : e[1] - e[0] > c.PI2 - s.PARAMETER_SPACE_TOLERANCE && (l = c.PI2), l *= .5, a = Math.cos(l), u = Math.sin(l);var h = n.Vector3.clone(t);return n.Vector3.scale(h, h, a), n.Vector3.cross(o, this._normal, t), n.Vector3.scaleAndAdd(h, h, o, u), new i.TangentCone(h, l);}, d.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.scale(this._xAxis, this._xAxis, this._majorRadius), n.Vector3.scale(this._yAxis, this._yAxis, this._minorRadius), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), this._majorRadius = n.Vector3.length(this._xAxis), this._minorRadius = n.Vector3.length(this._yAxis), n.Vector3.normalize(this._normal, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis), this._computeYAxis(), this._dirtyTessellation();}, d.prototype.closestToRayParam = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, this._center, e);var i = n.Vector3.dot(o, this._normal) / n.Vector3.dot(t, this._normal);if (isFinite(i)) {var s = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(s, e, t, i), this.closestToPointParam(s, r);}}, d.prototype.isCircular = function () {return Math.abs(this._majorRadius - this._minorRadius) < s.KERNEL_TOLERANCE;}, d.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._center);var o = n.Vector3.dot(r, this._xAxis),i = n.Vector3.dot(r, this._yAxis);if (o * o + i * i < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) {var a = .5 * Math.PI;if (((a = (0, c.adjustParameterToPeriodicRange)(a, t, c.PI2)) < t[0] || a > t[1]) && (a = (0, c.adjustParameterToPeriodicRange)(.5 * -Math.PI, t, c.PI2)), a < t[0] || a > t[1]) {var l = this.evaluatePosition(t[0]),h = this.evaluatePosition(t[1]);a = n.Vector3.squaredDistance(this._center, l) < n.Vector3.squaredDistance(this._center, h) ? t[0] : t[1];}return a;}var d = this._majorRadius,g = this._minorRadius,p = Math.atan2(d * i, g * o),f = this.evaluatePosition(p);n.Vector3.sub(f, f, this._center), o * o + i * i < n.Vector3.squaredLength(f) && (p = (i < s.KERNEL_TOLERANCE ? -1 : 1) * Math.acos(o / d));var v,_ = n.FLOAT64_TOLERANCE,y = function y(t) {var r = this.evaluatePosition(t),n = this.evaluateDt(t),o = this.evaluateDtt(t),i = [r[0] - e[0], r[1] - e[1], r[2] - e[2]];return { val: 2 * (i[0] * n[0] + i[1] * n[1] + i[2] * n[2]), deriv: 2 * (i[0] * o[0] + i[1] * o[1] + i[2] * o[2] + (n[0] * n[0] + n[1] * n[1] + n[2] * n[2])) };},m = (0, u.newtonRaphson1D)(y.bind(this), void 0, p, _, 32);(m = (0, c.adjustParameterToPeriodicRange)(m, t, c.PI2)) < t[0] || m > t[1] ? (m = (0, u.newtonRaphson1D)(y.bind(this), void 0, -m, _, 32), v = (m = (0, c.adjustParameterToPeriodicRange)(m, t, c.PI2)) < t[0] || m > t[1] ? 1 / 0 : n.Vector3.squaredDistance(e, this.evaluatePosition(m))) : v = n.Vector3.squaredDistance(e, this.evaluatePosition(m));var E = n.Vector3.squaredDistance(e, this.evaluatePosition(t[0])),x = n.Vector3.squaredDistance(e, this.evaluatePosition(t[1]));return E < v && (v = E, m = t[0]), x < v && (m = t[1]), m;}, d.prototype.suggestSplittingParam = function (e) {}, d.prototype.toObject = function () {var e = this.evaluatePosition(0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), normal: this.vectorToObject(this._normal), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Ellipse = d;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Body = void 0;var n = r(9),o = r(0),i = r(4),s = r(19),a = function a() {n.BaseTopology.call(this), this._lumps = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.BODY;}, a.prototype.getLumps = function () {return this._lumps;}, a.prototype.setLumps = function (e) {this._lumps = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._lumps[t] = e[t];}}, a.prototype.addLump = function (e) {this._lumps ? this._lumps.push(e) : this._lumps = [e], e.setBody(this);}, a.prototype.addLumps = function (e) {this._lumps || (this._lumps = []);for (var t = 0; t < e.length; ++t) {e[t].setBody(this);}this._lumps = this._lumps.concat(e);}, a.prototype.removeLump = function (e) {var t = this._lumps.indexOf(e);return t > -1 && (this._lumps.splice(t, 1), e.getBody() === this && e.setBody(void 0), !0);}, a.prototype.getBody = function () {return this;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectFaces(e);}return e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._lumps.length; ++t) {e.include(this._lumps[t].getBoundingBox());}return e;}, a.prototype.transform = function (e) {(0, s.transformTopology)(this, e);}, a.prototype.toObject = function () {return { lumps: this.refsToStrings(this._lumps), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._lumps, this._attributes]);}, t.Body = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Lump = void 0;var n = r(9),o = r(0),i = r(4),s = function s() {n.BaseTopology.call(this), this._shells = [], this._body = void 0;};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.LUMP;}, s.prototype.getBody = function () {return this._body;}, s.prototype.setBody = function (e) {this._body = e;}, s.prototype.getShells = function () {return this._shells;}, s.prototype.setShells = function (e) {this._shells = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._shells[t] = e[t];}}, s.prototype.addShell = function (e) {this._shells ? this._shells.push(e) : this._shells = [e], e.setLump(this);}, s.prototype.addShells = function (e) {this._shells || (this._shells = []);for (var t = 0; t < e.length; ++t) {e[t].setLump(this);}this._shells = this._shells.concat(e);}, s.prototype.removeShell = function (e) {var t = this._shells.indexOf(e);return t > -1 && (this._shells.splice(t, 1), e.getLump() === this && e.setLump(void 0), !0);}, s.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectFaces(e);}return e;}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectEdges(e);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectVertices(e);}return e;}, s.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._shells.length; ++t) {e.include(this._shells[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return \"Lump\";}, s.prototype.toObject = function () {return { shells: this.refsToStrings(this._shells), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._shells, this._attributes]);}, t.Lump = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Shell = void 0;var n = r(9),o = r(0),i = r(4),s = function s() {n.BaseTopology.call(this), this._faces = [], this._lump = void 0;};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.SHELL;}, s.prototype.getLump = function () {return this._lump;}, s.prototype.setLump = function (e) {this._lump = e;}, s.prototype.getFaces = function () {return this._faces;}, s.prototype.setFaces = function (e) {this._faces = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._faces[t] = e[t];}}, s.prototype.addFace = function (e) {this._faces ? this._faces.push(e) : this._faces = [e], e.setShell(this);}, s.prototype.addFaces = function (e) {this._faces || (this._faces = []);for (var t = 0; t < e.length; ++t) {e[t].setShell(this);}this._faces = this._faces.concat(e);}, s.prototype.removeFace = function (e) {var t = this._faces.indexOf(e);return t > -1 && (this._faces.splice(t, 1), e.getShell() === this && e.setShell(void 0), !0);}, s.prototype.getBody = function () {return this._lump ? this._lump.getBody() : void 0;}, s.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {e.add(this._faces[t]);}return e;}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {this._faces[t].collectEdges(e);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {this._faces[t].collectVertices(e);}return e;}, s.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._faces.length; ++t) {e.include(this._faces[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return \"Shell\";}, s.prototype.toObject = function () {return { faces: this.refsToStrings(this._faces), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._faces, this._attributes]);}, t.Shell = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Coedge = void 0;var n = r(1),o = r(9),i = r(0),s = r(2),a = r(3),c = r(36),u = function u(e) {o.BaseTopology.call(this), this._reversed = !1, this._edge = e, this._loop = void 0, this._partner = void 0, this._uvCurve = void 0;};(u.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.COEDGE;}, u.prototype.getEdge = function () {return this._edge;}, u.prototype.getLoop = function () {return this._loop;}, u.prototype.getPartner = function () {return this._partner;}, u.prototype.setEdge = function (e) {this._edge = e;}, u.prototype.setLoop = function (e) {this._loop = e;}, u.prototype.setPartner = function (e) {this._partner = e;}, u.prototype.getStartVertex = function () {return this._reversed ? this._edge.getEndVertex() : this._edge.getStartVertex();}, u.prototype.getEndVertex = function () {return this._reversed ? this._edge.getStartVertex() : this._edge.getEndVertex();}, u.prototype.getFace = function () {return this._loop ? this._loop.getFace() : void 0;}, u.prototype.getNext = function () {if (this._loop) {var e = this._loop.getCoedges(),t = e.indexOf(this);return s.ConsoleUtils.assert(t >= 0), e[(t + 1) % e.length];}}, u.prototype.getPrevious = function () {if (this._loop) {var e = this._loop.getCoedges(),t = e.indexOf(this);return s.ConsoleUtils.assert(t >= 0), e[(0, a.modulus)(t - 1, e.length)];}}, u.prototype.isReversed = function () {return this._reversed;}, u.prototype.setReversed = function (e) {this._reversed = e;}, u.prototype.getRange = function () {if (this._edge) return this._reversed ? [-this._edge.t1(), -this._edge.t0()] : [this._edge.t0(), this._edge.t1()];}, u.prototype.t0 = function () {if (this._edge) return this._reversed ? -this._edge.t1() : this._edge.t0();}, u.prototype.t1 = function () {if (this._edge) return this._reversed ? -this._edge.t0() : this._edge.t1();}, u.prototype.evaluatePosition = function (e) {if (this._edge) return this.isReversed() && (e = -e), this._edge.evaluatePosition(e);}, u.prototype.evaluateDt = function (e) {if (this._edge) {this.isReversed() && (e = -e);var t = this._edge.evaluateDt(e);return this.isReversed() && n.Vector3.negate(t, t), t;}}, u.prototype.evaluateCurvature = function (e, t) {if (this._edge) return this.isReversed() && (e = -e), this._edge.evaluateCurvature(e, t);}, u.prototype.evaluateFaceUV = function (e) {var t = this.getFace();if (t) {var r = this.evaluatePosition(e);return t.closestParam(r);}}, u.prototype.evaluateInwardDirection = function (e) {var t = this.getFace();if (t) {var r = this.evaluateDt(e),o = this.evaluateFaceUV(e),i = t.evaluateNormal(o.u, o.v),s = [0, 0, 0];return n.Vector3.cross(s, i, r), n.Vector3.normalize(s, s), s;}}, u.prototype.getBoundingBox = function () {if (this._edge) return this._edge.getBoundingBox();}, u.prototype.generateUVCurve = function (e) {if (!this._uvCurve && this._edge) {var t = this._edge.getCurve();if (t && this._loop && this._loop.getFace()) {var r = this._loop.getFace().getSurface();r && r.getGeometryType() === i.GEOMETRY_TYPES.PLANE && (e || (e = (0, a.getPlaneTransforms)(r).threeSpaceToUV), e ? (this._uvCurve = t.clone(), this._uvCurve.transform(e)) : this._uvCurve = t);}}}, u.prototype.resetUVCurve = function () {this._uvCurve = void 0;}, u.prototype.uvAngleSubtended = function (e) {var t = this._loop.getFace().getSurface().closestParam(e),r = [t.u, t.v, 0];this.generateUVCurve(), s.ConsoleUtils.assert(this._uvCurve);var o = this.getRange(),u = 1;this.isReversed() !== this._edge.isReversed() && (o = [-o[1], -o[0]], u = -1), this._loop && this._loop.getFace() && this._loop.getFace().isReversed() && (u *= -1);var l = !1,h = this._uvCurve.getRange();this._uvCurve.isClosed() && o[1] - o[0] >= h[1] - h[0] - 2 * i.PARAMETER_SPACE_TOLERANCE && (l = !0);var d = this._uvCurve.evaluatePosition(o[0]),g = this._uvCurve.evaluatePosition(o[1]),p = n.Vector3.createFloat64();n.Vector3.sub(p, d, r), n.Vector3.normalize(p, p);var f = n.Vector3.createFloat64();n.Vector3.sub(f, g, r), n.Vector3.normalize(f, f);var v = (0, a.getSignedAngle)(p, f),_ = v < 0,y = !1,m = !1;switch (this._edge.getCurveType()) {case i.GEOMETRY_TYPES.LINE:break;case i.GEOMETRY_TYPES.CIRCLE:m = this._uvCurve.getNormal()[2] > 0, y = n.Vector3.distance(r, this._uvCurve.getCenter()) < this._uvCurve.getRadius(), l || (y = y && _ !== m);break;case i.GEOMETRY_TYPES.ELLIPSE:m = this._uvCurve.getNormal()[2] > 0;var E = n.Vector3.sub([0, 0, 0], r, this._uvCurve.getCenter()),x = n.Vector3.dot(E, this._uvCurve.getMajorAxis()) / this._uvCurve.getMajorRadius(),R = n.Vector3.dot(E, this._uvCurve.getMinorAxis()) / this._uvCurve.getMinorRadius();y = x * x + R * R <= 1, l || (y = y && _ !== m);break;case i.GEOMETRY_TYPES.BCURVE:this._uvCurve.isPlanarXY() || console.warn(\"Unsupported non-planar curve for uvAngleSubtended\");var A = [r[0], r[1]];y = c.SplineCurveHelper.isPointInsideSplineRegionXYPlanar3D(A, this._uvCurve, o), m = !0;break;default:throw new Error(\"Unsupported curve type for uvAngleSubtended\");}return l ? v = y ? 2 * Math.PI * (m ? -1 : 1) : 0 : y && (v < 0 ? v = 2 * Math.PI + v : v -= 2 * Math.PI), v * u;}, u.prototype.getBody = function () {return this._loop ? this._loop.getBody() : void 0;}, u.prototype.collectFaces = function (e) {return e = e || new Set(), this._loop && this._loop.collectFaces(e), e;}, u.prototype.collectEdges = function (e) {return e = e || new Set(), this._edge && e.add(this._edge), e;}, u.prototype.collectVertices = function (e) {return e = e || new Set(), this._edge && this._edge.collectVertices(e), e;}, u.prototype.toString = function () {return \"Coedge\";}, u.prototype.toObject = function () {return { edge: this.refToString(this._edge), partner: this.refToString(this._partner), reversed: this._reversed, attributes: this.refsToStrings(this._attributes) };}, u.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._edge, this._attributes]);}, t.Coedge = u;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.createShellsFromFaces = t.createWiresFromEdges = t.createEdgesFromCurves = t.createEdgeFromCurve = t.createLoopFromPolyline = t.createFaceFromPolyline = t.makeConeOrCylinderVParamLoop = t.createCoedgeOnEdge = t.createLineEdge = t.createLineEdgeBetweenVertices = void 0;var n = r(1),o = r(0),i = r(2),s = r(6),a = r(7),c = r(18),u = r(27),l = r(16),h = r(26),d = r(20),g = r(13),p = r(15),f = r(40),v = r(3),_ = r(19),y = function y(e, t) {var r = e.getPosition(),o = t.getPosition(),i = new a.Line();i.setFromEndpoints(r, o);var s = new d.Edge(i);return s.setRange([0, n.Vector3.distance(r, o)]), s.setStartVertex(e), s.setEndVertex(t), s;},m = function m(e) {var t = new u.Coedge();t.setEdge(e);var r = e.getCoedge();return r ? (i.ConsoleUtils.assert(!r.getPartner()), r.setPartner(t), t.setPartner(r), t.setReversed(!r.isReversed())) : e.setCoedge(t), t;},E = function E(e) {for (var t = e.length, r = new Array(t), n = 0; n < t; ++n) {r[n] = new l.Vertex(new s.Point(e[n]));}var o = new Array(t);for (n = 0; n < t; ++n) {var i = (n + 1) % t,a = y(r[n], r[i]);o[n] = m(a);}var c = new g.Loop();return c.addCoedges(o), c;},x = function x(e) {var t = new d.Edge(e),r = e.getRange();r[0] !== -1 / 0 && r[1] !== 1 / 0 ? (t.sett0(r[0]), t.sett1(r[1])) : (t.sett0(0), t.sett1(1));var n = t.evaluatePosition(t.t0());if (t.setStartVertex(new l.Vertex(new s.Point(n))), e.isClosed()) t.setEndVertex(t.getStartVertex());else {var o = t.evaluatePosition(t.t1());t.setEndVertex(new l.Vertex(new s.Point(o)));}return t;};t.createLineEdgeBetweenVertices = y, t.createLineEdge = function (e, t) {var r = new l.Vertex(new s.Point(e)),n = new l.Vertex(new s.Point(t));return y(r, n);}, t.createCoedgeOnEdge = m, t.makeConeOrCylinderVParamLoop = function (e, t) {i.ConsoleUtils.assert(e.getGeometryType() === o.GEOMETRY_TYPES.CYLINDER || e.getGeometryType() === o.GEOMETRY_TYPES.CONE || e.getGeometryType() === o.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER || e.getGeometryType() === o.GEOMETRY_TYPES.ELLIPTICAL_CONE), i.ConsoleUtils.assert(e.isPeriodicV());var r,n = new d.Edge(),a = e.vParamLine(t);a.getGeometryType() === o.GEOMETRY_TYPES.POINT ? r = a : (r = new s.Point(a.evaluatePosition(a.getRange()[0])), n.setCurve(a), n.setRange(a.getRange()));var c = new l.Vertex(r);n.setStartVertex(c), n.setEndVertex(c);var u = new g.Loop();return u.addCoedge(m(n)), u;}, t.createFaceFromPolyline = function (e) {var t = E(e),r = (0, v.definePlaneThroughPoints)(e),n = new c.Plane();n.set(r.origin, r.normal, r.uAxis), n.limitRangeU(r.uRange), n.limitRangeV(r.vRange);var o = new p.Face(n);return o.addLoop(t), o;}, t.createLoopFromPolyline = E, t.createEdgeFromCurve = x, t.createEdgesFromCurves = function (e) {for (var t = [], r = 0; r < e.length; ++r) {t.push(x(e[r]));}return (0, _.mergeCoincidentVertices)(t), t;}, t.createWiresFromEdges = function (e) {for (var t = (0, _.findConnectedEdges)(e), r = [], n = 0; n < t.length; ++n) {var o = new f.Wire();o.addEdges(t[n]), r.push(o);}return r;}, t.createShellsFromFaces = function (e) {for (var t = (0, _.findConnectedFaces)(e), r = new Array(t.length), n = 0; n < t.length; ++n) {var o = new h.Shell();o.addFaces(t[n]), r[n] = o;}return r;};}, function (e, t, r) {\"use strict\";r.r(t), function (e) {r.d(t, \"default\", function () {return _;}), r.d(t, \"VERSION\", function () {return y;}), r.d(t, \"iteratee\", function () {return x;}), r.d(t, \"restArguments\", function () {return A;}), r.d(t, \"each\", function () {return S;}), r.d(t, \"forEach\", function () {return S;}), r.d(t, \"map\", function () {return M;}), r.d(t, \"collect\", function () {return M;}), r.d(t, \"reduce\", function () {return N;}), r.d(t, \"foldl\", function () {return N;}), r.d(t, \"inject\", function () {return N;}), r.d(t, \"reduceRight\", function () {return F;}), r.d(t, \"foldr\", function () {return F;}), r.d(t, \"find\", function () {return I;}), r.d(t, \"detect\", function () {return I;}), r.d(t, \"filter\", function () {return D;}), r.d(t, \"select\", function () {return D;}), r.d(t, \"reject\", function () {return j;}), r.d(t, \"every\", function () {return B;}), r.d(t, \"all\", function () {return B;}), r.d(t, \"some\", function () {return U;}), r.d(t, \"any\", function () {return U;}), r.d(t, \"contains\", function () {return k;}), r.d(t, \"includes\", function () {return k;}), r.d(t, \"include\", function () {return k;}), r.d(t, \"invoke\", function () {return G;}), r.d(t, \"pluck\", function () {return z;}), r.d(t, \"where\", function () {return Y;}), r.d(t, \"findWhere\", function () {return K;}), r.d(t, \"max\", function () {return q;}), r.d(t, \"min\", function () {return W;}), r.d(t, \"shuffle\", function () {return H;}), r.d(t, \"sample\", function () {return X;}), r.d(t, \"sortBy\", function () {return J;}), r.d(t, \"groupBy\", function () {return Z;}), r.d(t, \"indexBy\", function () {return Q;}), r.d(t, \"countBy\", function () {return ee;}), r.d(t, \"toArray\", function () {return re;}), r.d(t, \"size\", function () {return ne;}), r.d(t, \"partition\", function () {return oe;}), r.d(t, \"first\", function () {return ie;}), r.d(t, \"head\", function () {return ie;}), r.d(t, \"take\", function () {return ie;}), r.d(t, \"initial\", function () {return se;}), r.d(t, \"last\", function () {return ae;}), r.d(t, \"rest\", function () {return ce;}), r.d(t, \"tail\", function () {return ce;}), r.d(t, \"drop\", function () {return ce;}), r.d(t, \"compact\", function () {return ue;}), r.d(t, \"flatten\", function () {return he;}), r.d(t, \"without\", function () {return de;}), r.d(t, \"uniq\", function () {return ge;}), r.d(t, \"unique\", function () {return ge;}), r.d(t, \"union\", function () {return pe;}), r.d(t, \"intersection\", function () {return fe;}), r.d(t, \"difference\", function () {return ve;}), r.d(t, \"unzip\", function () {return _e;}), r.d(t, \"zip\", function () {return ye;}), r.d(t, \"object\", function () {return me;}), r.d(t, \"findIndex\", function () {return xe;}), r.d(t, \"findLastIndex\", function () {return Re;}), r.d(t, \"sortedIndex\", function () {return Ae;}), r.d(t, \"indexOf\", function () {return Ve;}), r.d(t, \"lastIndexOf\", function () {return Te;}), r.d(t, \"range\", function () {return Ce;}), r.d(t, \"chunk\", function () {return be;}), r.d(t, \"bind\", function () {return Oe;}), r.d(t, \"partial\", function () {return Se;}), r.d(t, \"bindAll\", function () {return Me;}), r.d(t, \"memoize\", function () {return we;}), r.d(t, \"delay\", function () {return Ne;}), r.d(t, \"defer\", function () {return Fe;}), r.d(t, \"throttle\", function () {return Ie;}), r.d(t, \"debounce\", function () {return De;}), r.d(t, \"wrap\", function () {return je;}), r.d(t, \"negate\", function () {return Be;}), r.d(t, \"compose\", function () {return Ue;}), r.d(t, \"after\", function () {return ke;}), r.d(t, \"before\", function () {return Ge;}), r.d(t, \"once\", function () {return ze;}), r.d(t, \"keys\", function () {return We;}), r.d(t, \"allKeys\", function () {return He;}), r.d(t, \"values\", function () {return Xe;}), r.d(t, \"mapObject\", function () {return Je;}), r.d(t, \"pairs\", function () {return $e;}), r.d(t, \"invert\", function () {return Ze;}), r.d(t, \"functions\", function () {return Qe;}), r.d(t, \"methods\", function () {return Qe;}), r.d(t, \"extend\", function () {return tt;}), r.d(t, \"extendOwn\", function () {return rt;}), r.d(t, \"assign\", function () {return rt;}), r.d(t, \"findKey\", function () {return nt;}), r.d(t, \"pick\", function () {return it;}), r.d(t, \"omit\", function () {return st;}), r.d(t, \"defaults\", function () {return at;}), r.d(t, \"create\", function () {return ct;}), r.d(t, \"clone\", function () {return ut;}), r.d(t, \"tap\", function () {return lt;}), r.d(t, \"isMatch\", function () {return ht;}), r.d(t, \"isEqual\", function () {return dt;}), r.d(t, \"isEmpty\", function () {return gt;}), r.d(t, \"isElement\", function () {return pt;}), r.d(t, \"isArray\", function () {return vt;}), r.d(t, \"isObject\", function () {return _t;}), r.d(t, \"isArguments\", function () {return yt;}), r.d(t, \"isFunction\", function () {return mt;}), r.d(t, \"isString\", function () {return Et;}), r.d(t, \"isNumber\", function () {return xt;}), r.d(t, \"isDate\", function () {return Rt;}), r.d(t, \"isRegExp\", function () {return At;}), r.d(t, \"isError\", function () {return Pt;}), r.d(t, \"isSymbol\", function () {return Vt;}), r.d(t, \"isMap\", function () {return Tt;}), r.d(t, \"isWeakMap\", function () {return Ct;}), r.d(t, \"isSet\", function () {return bt;}), r.d(t, \"isWeakSet\", function () {return Lt;}), r.d(t, \"isFinite\", function () {return St;}), r.d(t, \"isNaN\", function () {return Mt;}), r.d(t, \"isBoolean\", function () {return wt;}), r.d(t, \"isNull\", function () {return Nt;}), r.d(t, \"isUndefined\", function () {return Ft;}), r.d(t, \"has\", function () {return It;}), r.d(t, \"identity\", function () {return Dt;}), r.d(t, \"constant\", function () {return jt;}), r.d(t, \"noop\", function () {return Bt;}), r.d(t, \"property\", function () {return Ut;}), r.d(t, \"propertyOf\", function () {return kt;}), r.d(t, \"matcher\", function () {return Gt;}), r.d(t, \"matches\", function () {return Gt;}), r.d(t, \"times\", function () {return zt;}), r.d(t, \"random\", function () {return Yt;}), r.d(t, \"now\", function () {return Kt;}), r.d(t, \"escape\", function () {return Xt;}), r.d(t, \"unescape\", function () {return Jt;}), r.d(t, \"result\", function () {return $t;}), r.d(t, \"uniqueId\", function () {return Qt;}), r.d(t, \"templateSettings\", function () {return er;}), r.d(t, \"template\", function () {return ir;}), r.d(t, \"chain\", function () {return sr;}), r.d(t, \"mixin\", function () {return cr;});var n = \"object\" == (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) && self.self === self && self || \"object\" == _typeof(e) && e.global === e && e || Function(\"return this\")() || {},o = Array.prototype,i = Object.prototype,s = \"undefined\" != typeof Symbol ? Symbol.prototype : null,a = o.push,c = o.slice,u = i.toString,l = i.hasOwnProperty,h = Array.isArray,d = Object.keys,g = Object.create,p = n.isNaN,f = n.isFinite,v = function v() {};function _(e) {return e instanceof _ ? e : this instanceof _ ? void (this._wrapped = e) : new _(e);}var y = _.VERSION = \"1.10.2\";function m(e, t, r) {if (void 0 === t) return e;switch (null == r ? 3 : r) {case 1:return function (r) {return e.call(t, r);};case 3:return function (r, n, o) {return e.call(t, r, n, o);};case 4:return function (r, n, o, i) {return e.call(t, r, n, o, i);};}return function () {return e.apply(t, arguments);};}function E(e, t, r) {return null == e ? Dt : mt(e) ? m(e, t, r) : _t(e) && !vt(e) ? Gt(e) : Ut(e);}function x(e, t) {return E(e, t, 1 / 0);}function R(e, t, r) {return _.iteratee !== x ? _.iteratee(e, t) : E(e, t, r);}function A(e, t) {return t = null == t ? e.length - 1 : +t, function () {for (var r = Math.max(arguments.length - t, 0), n = Array(r), o = 0; o < r; o++) {n[o] = arguments[o + t];}switch (t) {case 0:return e.call(this, n);case 1:return e.call(this, arguments[0], n);case 2:return e.call(this, arguments[0], arguments[1], n);}var i = Array(t + 1);for (o = 0; o < t; o++) {i[o] = arguments[o];}return i[t] = n, e.apply(this, i);};}function P(e) {if (!_t(e)) return {};if (g) return g(e);v.prototype = e;var t = new v();return v.prototype = null, t;}function V(e) {return function (t) {return null == t ? void 0 : t[e];};}function T(e, t) {return null != e && l.call(e, t);}function C(e, t) {for (var r = t.length, n = 0; n < r; n++) {if (null == e) return;e = e[t[n]];}return r ? e : void 0;}_.iteratee = x;var b = Math.pow(2, 53) - 1,L = V(\"length\");function O(e) {var t = L(e);return \"number\" == typeof t && t >= 0 && t <= b;}function S(e, t, r) {var n, o;if (t = m(t, r), O(e)) for (n = 0, o = e.length; n < o; n++) {t(e[n], n, e);} else {var i = We(e);for (n = 0, o = i.length; n < o; n++) {t(e[i[n]], i[n], e);}}return e;}function M(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = Array(o), s = 0; s < o; s++) {var a = n ? n[s] : s;i[s] = t(e[a], a, e);}return i;}function w(e) {return function (t, r, n, o) {var i = arguments.length >= 3;return function (t, r, n, o) {var i = !O(t) && We(t),s = (i || t).length,a = e > 0 ? 0 : s - 1;for (o || (n = t[i ? i[a] : a], a += e); a >= 0 && a < s; a += e) {var c = i ? i[a] : a;n = r(n, t[c], c, t);}return n;}(t, m(r, o, 4), n, i);};}var N = w(1),F = w(-1);function I(e, t, r) {var n = (O(e) ? xe : nt)(e, t, r);if (void 0 !== n && -1 !== n) return e[n];}function D(e, t, r) {var n = [];return t = R(t, r), S(e, function (e, r, o) {t(e, r, o) && n.push(e);}), n;}function j(e, t, r) {return D(e, Be(R(t)), r);}function B(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = 0; i < o; i++) {var s = n ? n[i] : i;if (!t(e[s], s, e)) return !1;}return !0;}function U(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = 0; i < o; i++) {var s = n ? n[i] : i;if (t(e[s], s, e)) return !0;}return !1;}function k(e, t, r, n) {return O(e) || (e = Xe(e)), (\"number\" != typeof r || n) && (r = 0), Ve(e, t, r) >= 0;}var G = A(function (e, t, r) {var n, o;return mt(t) ? o = t : vt(t) && (n = t.slice(0, -1), t = t[t.length - 1]), M(e, function (e) {var i = o;if (!i) {if (n && n.length && (e = C(e, n)), null == e) return;i = e[t];}return null == i ? i : i.apply(e, r);});});function z(e, t) {return M(e, Ut(t));}function Y(e, t) {return D(e, Gt(t));}function K(e, t) {return I(e, Gt(t));}function q(e, t, r) {var n,o,i = -1 / 0,s = -1 / 0;if (null == t || \"number\" == typeof t && \"object\" != _typeof(e[0]) && null != e) for (var a = 0, c = (e = O(e) ? e : Xe(e)).length; a < c; a++) {null != (n = e[a]) && n > i && (i = n);} else t = R(t, r), S(e, function (e, r, n) {((o = t(e, r, n)) > s || o === -1 / 0 && i === -1 / 0) && (i = e, s = o);});return i;}function W(e, t, r) {var n,o,i = 1 / 0,s = 1 / 0;if (null == t || \"number\" == typeof t && \"object\" != _typeof(e[0]) && null != e) for (var a = 0, c = (e = O(e) ? e : Xe(e)).length; a < c; a++) {null != (n = e[a]) && n < i && (i = n);} else t = R(t, r), S(e, function (e, r, n) {((o = t(e, r, n)) < s || o === 1 / 0 && i === 1 / 0) && (i = e, s = o);});return i;}function H(e) {return X(e, 1 / 0);}function X(e, t, r) {if (null == t || r) return O(e) || (e = Xe(e)), e[Yt(e.length - 1)];var n = O(e) ? ut(e) : Xe(e),o = L(n);t = Math.max(Math.min(t, o), 0);for (var i = o - 1, s = 0; s < t; s++) {var a = Yt(s, i),c = n[s];n[s] = n[a], n[a] = c;}return n.slice(0, t);}function J(e, t, r) {var n = 0;return t = R(t, r), z(M(e, function (e, r, o) {return { value: e, index: n++, criteria: t(e, r, o) };}).sort(function (e, t) {var r = e.criteria,n = t.criteria;if (r !== n) {if (r > n || void 0 === r) return 1;if (r < n || void 0 === n) return -1;}return e.index - t.index;}), \"value\");}function $(e, t) {return function (r, n, o) {var i = t ? [[], []] : {};return n = R(n, o), S(r, function (t, o) {var s = n(t, o, r);e(i, t, s);}), i;};}var Z = $(function (e, t, r) {T(e, r) ? e[r].push(t) : e[r] = [t];}),Q = $(function (e, t, r) {e[r] = t;}),ee = $(function (e, t, r) {T(e, r) ? e[r]++ : e[r] = 1;}),te = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;function re(e) {return e ? vt(e) ? c.call(e) : Et(e) ? e.match(te) : O(e) ? M(e, Dt) : Xe(e) : [];}function ne(e) {return null == e ? 0 : O(e) ? e.length : We(e).length;}var oe = $(function (e, t, r) {e[r ? 0 : 1].push(t);}, !0);function ie(e, t, r) {return null == e || e.length < 1 ? null == t ? void 0 : [] : null == t || r ? e[0] : se(e, e.length - t);}function se(e, t, r) {return c.call(e, 0, Math.max(0, e.length - (null == t || r ? 1 : t)));}function ae(e, t, r) {return null == e || e.length < 1 ? null == t ? void 0 : [] : null == t || r ? e[e.length - 1] : ce(e, Math.max(0, e.length - t));}function ce(e, t, r) {return c.call(e, null == t || r ? 1 : t);}function ue(e) {return D(e, Boolean);}function le(e, t, r, n) {for (var o = (n = n || []).length, i = 0, s = L(e); i < s; i++) {var a = e[i];if (O(a) && (vt(a) || yt(a))) {if (t) for (var c = 0, u = a.length; c < u;) {n[o++] = a[c++];} else le(a, t, r, n), o = n.length;} else r || (n[o++] = a);}return n;}function he(e, t) {return le(e, t, !1);}var de = A(function (e, t) {return ve(e, t);});function ge(e, t, r, n) {wt(t) || (n = r, r = t, t = !1), null != r && (r = R(r, n));for (var o = [], i = [], s = 0, a = L(e); s < a; s++) {var c = e[s],u = r ? r(c, s, e) : c;t && !r ? (s && i === u || o.push(c), i = u) : r ? k(i, u) || (i.push(u), o.push(c)) : k(o, c) || o.push(c);}return o;}var pe = A(function (e) {return ge(le(e, !0, !0));});function fe(e) {for (var t = [], r = arguments.length, n = 0, o = L(e); n < o; n++) {var i = e[n];if (!k(t, i)) {var s;for (s = 1; s < r && k(arguments[s], i); s++) {;}s === r && t.push(i);}}return t;}var ve = A(function (e, t) {return t = le(t, !0, !0), D(e, function (e) {return !k(t, e);});});function _e(e) {for (var t = e && q(e, L).length || 0, r = Array(t), n = 0; n < t; n++) {r[n] = z(e, n);}return r;}var ye = A(_e);function me(e, t) {for (var r = {}, n = 0, o = L(e); n < o; n++) {t ? r[e[n]] = t[n] : r[e[n][0]] = e[n][1];}return r;}function Ee(e) {return function (t, r, n) {r = R(r, n);for (var o = L(t), i = e > 0 ? 0 : o - 1; i >= 0 && i < o; i += e) {if (r(t[i], i, t)) return i;}return -1;};}var xe = Ee(1),Re = Ee(-1);function Ae(e, t, r, n) {for (var o = (r = R(r, n, 1))(t), i = 0, s = L(e); i < s;) {var a = Math.floor((i + s) / 2);r(e[a]) < o ? i = a + 1 : s = a;}return i;}function Pe(e, t, r) {return function (n, o, i) {var s = 0,a = L(n);if (\"number\" == typeof i) e > 0 ? s = i >= 0 ? i : Math.max(i + a, s) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1;else if (r && i && a) return n[i = r(n, o)] === o ? i : -1;if (o != o) return (i = t(c.call(n, s, a), Mt)) >= 0 ? i + s : -1;for (i = e > 0 ? s : a - 1; i >= 0 && i < a; i += e) {if (n[i] === o) return i;}return -1;};}var Ve = Pe(1, xe, Ae),Te = Pe(-1, Re);function Ce(e, t, r) {null == t && (t = e || 0, e = 0), r || (r = t < e ? -1 : 1);for (var n = Math.max(Math.ceil((t - e) / r), 0), o = Array(n), i = 0; i < n; i++, e += r) {o[i] = e;}return o;}function be(e, t) {if (null == t || t < 1) return [];for (var r = [], n = 0, o = e.length; n < o;) {r.push(c.call(e, n, n += t));}return r;}function Le(e, t, r, n, o) {if (!(n instanceof t)) return e.apply(r, o);var i = P(e.prototype),s = e.apply(i, o);return _t(s) ? s : i;}var Oe = A(function (e, t, r) {if (!mt(e)) throw new TypeError(\"Bind must be called on a function\");var n = A(function (o) {return Le(e, n, t, this, r.concat(o));});return n;}),Se = A(function (e, t) {var r = Se.placeholder,n = function n() {for (var o = 0, i = t.length, s = Array(i), a = 0; a < i; a++) {s[a] = t[a] === r ? arguments[o++] : t[a];}for (; o < arguments.length;) {s.push(arguments[o++]);}return Le(e, n, this, this, s);};return n;});Se.placeholder = _;var Me = A(function (e, t) {var r = (t = le(t, !1, !1)).length;if (r < 1) throw new Error(\"bindAll must be passed function names\");for (; r--;) {var n = t[r];e[n] = Oe(e[n], e);}});function we(e, t) {var r = function r(n) {var o = r.cache,i = \"\" + (t ? t.apply(this, arguments) : n);return T(o, i) || (o[i] = e.apply(this, arguments)), o[i];};return r.cache = {}, r;}var Ne = A(function (e, t, r) {return setTimeout(function () {return e.apply(null, r);}, t);}),Fe = Se(Ne, _, 1);function Ie(e, t, r) {var n,o,i,s,a = 0;r || (r = {});var c = function c() {a = !1 === r.leading ? 0 : Kt(), n = null, s = e.apply(o, i), n || (o = i = null);},u = function u() {var u = Kt();a || !1 !== r.leading || (a = u);var l = t - (u - a);return o = this, i = arguments, l <= 0 || l > t ? (n && (clearTimeout(n), n = null), a = u, s = e.apply(o, i), n || (o = i = null)) : n || !1 === r.trailing || (n = setTimeout(c, l)), s;};return u.cancel = function () {clearTimeout(n), a = 0, n = o = i = null;}, u;}function De(e, t, r) {var n,o,i = function i(t, r) {n = null, r && (o = e.apply(t, r));},s = A(function (s) {if (n && clearTimeout(n), r) {var a = !n;n = setTimeout(i, t), a && (o = e.apply(this, s));} else n = Ne(i, t, this, s);return o;});return s.cancel = function () {clearTimeout(n), n = null;}, s;}function je(e, t) {return Se(t, e);}function Be(e) {return function () {return !e.apply(this, arguments);};}function Ue() {var e = arguments,t = e.length - 1;return function () {for (var r = t, n = e[t].apply(this, arguments); r--;) {n = e[r].call(this, n);}return n;};}function ke(e, t) {return function () {if (--e < 1) return t.apply(this, arguments);};}function Ge(e, t) {var r;return function () {return --e > 0 && (r = t.apply(this, arguments)), e <= 1 && (t = null), r;};}var ze = Se(Ge, 2),Ye = !{ toString: null }.propertyIsEnumerable(\"toString\"),Ke = [\"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"];function qe(e, t) {var r = Ke.length,n = e.constructor,o = mt(n) && n.prototype || i,s = \"constructor\";for (T(e, s) && !k(t, s) && t.push(s); r--;) {(s = Ke[r]) in e && e[s] !== o[s] && !k(t, s) && t.push(s);}}function We(e) {if (!_t(e)) return [];if (d) return d(e);var t = [];for (var r in e) {T(e, r) && t.push(r);}return Ye && qe(e, t), t;}function He(e) {if (!_t(e)) return [];var t = [];for (var r in e) {t.push(r);}return Ye && qe(e, t), t;}function Xe(e) {for (var t = We(e), r = t.length, n = Array(r), o = 0; o < r; o++) {n[o] = e[t[o]];}return n;}function Je(e, t, r) {t = R(t, r);for (var n = We(e), o = n.length, i = {}, s = 0; s < o; s++) {var a = n[s];i[a] = t(e[a], a, e);}return i;}function $e(e) {for (var t = We(e), r = t.length, n = Array(r), o = 0; o < r; o++) {n[o] = [t[o], e[t[o]]];}return n;}function Ze(e) {for (var t = {}, r = We(e), n = 0, o = r.length; n < o; n++) {t[e[r[n]]] = r[n];}return t;}function Qe(e) {var t = [];for (var r in e) {mt(e[r]) && t.push(r);}return t.sort();}function et(e, t) {return function (r) {var n = arguments.length;if (t && (r = Object(r)), n < 2 || null == r) return r;for (var o = 1; o < n; o++) {for (var i = arguments[o], s = e(i), a = s.length, c = 0; c < a; c++) {var u = s[c];t && void 0 !== r[u] || (r[u] = i[u]);}}return r;};}var tt = et(He),rt = et(We);function nt(e, t, r) {t = R(t, r);for (var n, o = We(e), i = 0, s = o.length; i < s; i++) {if (t(e[n = o[i]], n, e)) return n;}}function ot(e, t, r) {return t in r;}var it = A(function (e, t) {var r = {},n = t[0];if (null == e) return r;mt(n) ? (t.length > 1 && (n = m(n, t[1])), t = He(e)) : (n = ot, t = le(t, !1, !1), e = Object(e));for (var o = 0, i = t.length; o < i; o++) {var s = t[o],a = e[s];n(a, s, e) && (r[s] = a);}return r;}),st = A(function (e, t) {var r,n = t[0];return mt(n) ? (n = Be(n), t.length > 1 && (r = t[1])) : (t = M(le(t, !1, !1), String), n = function n(e, r) {return !k(t, r);}), it(e, n, r);}),at = et(He, !0);function ct(e, t) {var r = P(e);return t && rt(r, t), r;}function ut(e) {return _t(e) ? vt(e) ? e.slice() : tt({}, e) : e;}function lt(e, t) {return t(e), e;}function ht(e, t) {var r = We(t),n = r.length;if (null == e) return !n;for (var o = Object(e), i = 0; i < n; i++) {var s = r[i];if (t[s] !== o[s] || !(s in o)) return !1;}return !0;}function dt(e, t) {return function e(t, r, n, o) {if (t === r) return 0 !== t || 1 / t == 1 / r;if (null == t || null == r) return !1;if (t != t) return r != r;var i = _typeof(t);return (\"function\" === i || \"object\" === i || \"object\" == _typeof(r)) && function (t, r, n, o) {t instanceof _ && (t = t._wrapped), r instanceof _ && (r = r._wrapped);var i = u.call(t);if (i !== u.call(r)) return !1;switch (i) {case \"[object RegExp]\":case \"[object String]\":return \"\" + t == \"\" + r;case \"[object Number]\":return +t != +t ? +r != +r : 0 == +t ? 1 / +t == 1 / r : +t == +r;case \"[object Date]\":case \"[object Boolean]\":return +t == +r;case \"[object Symbol]\":return s.valueOf.call(t) === s.valueOf.call(r);}var a = \"[object Array]\" === i;if (!a) {if (\"object\" != _typeof(t) || \"object\" != _typeof(r)) return !1;var c = t.constructor,l = r.constructor;if (c !== l && !(mt(c) && c instanceof c && mt(l) && l instanceof l) && \"constructor\" in t && \"constructor\" in r) return !1;}o = o || [];for (var h = (n = n || []).length; h--;) {if (n[h] === t) return o[h] === r;}if (n.push(t), o.push(r), a) {if ((h = t.length) !== r.length) return !1;for (; h--;) {if (!e(t[h], r[h], n, o)) return !1;}} else {var d,g = We(t);if (h = g.length, We(r).length !== h) return !1;for (; h--;) {if (!T(r, d = g[h]) || !e(t[d], r[d], n, o)) return !1;}}return n.pop(), o.pop(), !0;}(t, r, n, o);}(e, t);}function gt(e) {return null == e || (O(e) && (vt(e) || Et(e) || yt(e)) ? 0 === e.length : 0 === We(e).length);}function pt(e) {return !(!e || 1 !== e.nodeType);}function ft(e) {return function (t) {return u.call(t) === \"[object \" + e + \"]\";};}var vt = h || ft(\"Array\");function _t(e) {var t = _typeof(e);return \"function\" === t || \"object\" === t && !!e;}var yt = ft(\"Arguments\"),mt = ft(\"Function\"),Et = ft(\"String\"),xt = ft(\"Number\"),Rt = ft(\"Date\"),At = ft(\"RegExp\"),Pt = ft(\"Error\"),Vt = ft(\"Symbol\"),Tt = ft(\"Map\"),Ct = ft(\"WeakMap\"),bt = ft(\"Set\"),Lt = ft(\"WeakSet\");!function () {yt(arguments) || (yt = function yt(e) {return T(e, \"callee\");});}();var Ot = n.document && n.document.childNodes;function St(e) {return !Vt(e) && f(e) && !p(parseFloat(e));}function Mt(e) {return xt(e) && p(e);}function wt(e) {return !0 === e || !1 === e || \"[object Boolean]\" === u.call(e);}function Nt(e) {return null === e;}function Ft(e) {return void 0 === e;}function It(e, t) {if (!vt(t)) return T(e, t);for (var r = t.length, n = 0; n < r; n++) {var o = t[n];if (null == e || !l.call(e, o)) return !1;e = e[o];}return !!r;}function Dt(e) {return e;}function jt(e) {return function () {return e;};}function Bt() {}function Ut(e) {return vt(e) ? function (t) {return C(t, e);} : V(e);}function kt(e) {return null == e ? function () {} : function (t) {return vt(t) ? C(e, t) : e[t];};}function Gt(e) {return e = rt({}, e), function (t) {return ht(t, e);};}function zt(e, t, r) {var n = Array(Math.max(0, e));t = m(t, r, 1);for (var o = 0; o < e; o++) {n[o] = t(o);}return n;}function Yt(e, t) {return null == t && (t = e, e = 0), e + Math.floor(Math.random() * (t - e + 1));}\"object\" != (typeof Int8Array === \"undefined\" ? \"undefined\" : _typeof(Int8Array)) && \"function\" != typeof Ot && (mt = function mt(e) {return \"function\" == typeof e || !1;});var Kt = Date.now || function () {return new Date().getTime();},qt = { \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#x27;\", \"`\": \"&#x60;\" },Wt = Ze(qt);function Ht(e) {var t = function t(_t3) {return e[_t3];},r = \"(?:\" + We(e).join(\"|\") + \")\",n = RegExp(r),o = RegExp(r, \"g\");return function (e) {return e = null == e ? \"\" : \"\" + e, n.test(e) ? e.replace(o, t) : e;};}var Xt = Ht(qt),Jt = Ht(Wt);function $t(e, t, r) {vt(t) || (t = [t]);var n = t.length;if (!n) return mt(r) ? r.call(e) : r;for (var o = 0; o < n; o++) {var i = null == e ? void 0 : e[t[o]];void 0 === i && (i = r, o = n), e = mt(i) ? i.call(e) : i;}return e;}var Zt = 0;function Qt(e) {var t = ++Zt + \"\";return e ? e + t : t;}var er = _.templateSettings = { evaluate: /<%([\\s\\S]+?)%>/g, interpolate: /<%=([\\s\\S]+?)%>/g, escape: /<%-([\\s\\S]+?)%>/g },tr = /(.)^/,rr = { \"'\": \"'\", \"\\\\\": \"\\\\\", \"\\r\": \"r\", \"\\n\": \"n\", \"\\u2028\": \"u2028\", \"\\u2029\": \"u2029\" },nr = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g,or = function or(e) {return \"\\\\\" + rr[e];};function ir(e, t, r) {!t && r && (t = r), t = at({}, t, _.templateSettings);var n,o = RegExp([(t.escape || tr).source, (t.interpolate || tr).source, (t.evaluate || tr).source].join(\"|\") + \"|$\", \"g\"),i = 0,s = \"__p+='\";e.replace(o, function (t, r, n, o, a) {return s += e.slice(i, a).replace(nr, or), i = a + t.length, r ? s += \"'+\\n((__t=(\" + r + \"))==null?'':_.escape(__t))+\\n'\" : n ? s += \"'+\\n((__t=(\" + n + \"))==null?'':__t)+\\n'\" : o && (s += \"';\\n\" + o + \"\\n__p+='\"), t;}), s += \"';\\n\", t.variable || (s = \"with(obj||{}){\\n\" + s + \"}\\n\"), s = \"var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\\n\" + s + \"return __p;\\n\";try {n = new Function(t.variable || \"obj\", \"_\", s);} catch (e) {throw e.source = s, e;}var a = function a(e) {return n.call(this, e, _);},c = t.variable || \"obj\";return a.source = \"function(\" + c + \"){\\n\" + s + \"}\", a;}function sr(e) {var t = _(e);return t._chain = !0, t;}function ar(e, t) {return e._chain ? _(t).chain() : t;}function cr(e) {return S(Qe(e), function (t) {var r = _[t] = e[t];_.prototype[t] = function () {var e = [this._wrapped];return a.apply(e, arguments), ar(this, r.apply(_, e));};}), _;}S([\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"], function (e) {var t = o[e];_.prototype[e] = function () {var r = this._wrapped;return t.apply(r, arguments), \"shift\" !== e && \"splice\" !== e || 0 !== r.length || delete r[0], ar(this, r);};}), S([\"concat\", \"join\", \"slice\"], function (e) {var t = o[e];_.prototype[e] = function () {return ar(this, t.apply(this._wrapped, arguments));};}), _.prototype.value = function () {return this._wrapped;}, _.prototype.valueOf = _.prototype.toJSON = _.prototype.value, _.prototype.toString = function () {return String(this._wrapped);};}.call(this, r(57));}, function (e, t, r) {\"use strict\";e.exports = l;var n = r(21);((l.prototype = Object.create(n.prototype)).constructor = l).className = \"Namespace\";var o,i,s,a = r(22),c = r(5);function u(e, t) {if (e && e.length) {for (var r = {}, n = 0; n < e.length; ++n) {r[e[n].name] = e[n].toJSON(t);}return r;}}function l(e, t) {n.call(this, e, t), this.nested = void 0, this._nestedArray = null;}function h(e) {return e._nestedArray = null, e;}l.fromJSON = function (e, t) {return new l(e, t.options).addJSON(t.nested);}, l.arrayToJSON = u, l.isReservedId = function (e, t) {if (e) for (var r = 0; r < e.length; ++r) {if (\"string\" != typeof e[r] && e[r][0] <= t && e[r][1] >= t) return !0;}return !1;}, l.isReservedName = function (e, t) {if (e) for (var r = 0; r < e.length; ++r) {if (e[r] === t) return !0;}return !1;}, Object.defineProperty(l.prototype, \"nestedArray\", { get: function get() {return this._nestedArray || (this._nestedArray = c.toArray(this.nested));} }), l.prototype.toJSON = function (e) {return c.toObject([\"options\", this.options, \"nested\", u(this.nestedArray, e)]);}, l.prototype.addJSON = function (e) {if (e) for (var t, r = Object.keys(e), n = 0; n < r.length; ++n) {t = e[r[n]], this.add((void 0 !== t.fields ? o.fromJSON : void 0 !== t.values ? s.fromJSON : void 0 !== t.methods ? i.fromJSON : void 0 !== t.id ? a.fromJSON : l.fromJSON)(r[n], t));}return this;}, l.prototype.get = function (e) {return this.nested && this.nested[e] || null;}, l.prototype.getEnum = function (e) {if (this.nested && this.nested[e] instanceof s) return this.nested[e].values;throw Error(\"no such enum: \" + e);}, l.prototype.add = function (e) {if (!(e instanceof a && void 0 !== e.extend || e instanceof o || e instanceof s || e instanceof i || e instanceof l)) throw TypeError(\"object must be a valid nested object\");if (this.nested) {var t = this.get(e.name);if (t) {if (!(t instanceof l && e instanceof l) || t instanceof o || t instanceof i) throw Error(\"duplicate name '\" + e.name + \"' in \" + this);for (var r = t.nestedArray, n = 0; n < r.length; ++n) {e.add(r[n]);}this.remove(t), this.nested || (this.nested = {}), e.setOptions(t.options, !0);}} else this.nested = {};return this.nested[e.name] = e, e.onAdd(this), h(this);}, l.prototype.remove = function (e) {if (!(e instanceof n)) throw TypeError(\"object must be a ReflectionObject\");if (e.parent !== this) throw Error(e + \" is not a member of \" + this);return delete this.nested[e.name], Object.keys(this.nested).length || (this.nested = void 0), e.onRemove(this), h(this);}, l.prototype.define = function (e, t) {if (c.isString(e)) e = e.split(\".\");else if (!Array.isArray(e)) throw TypeError(\"illegal path\");if (e && e.length && \"\" === e[0]) throw Error(\"path must be relative\");for (var r = this; e.length > 0;) {var n = e.shift();if (r.nested && r.nested[n]) {if (!((r = r.nested[n]) instanceof l)) throw Error(\"path conflicts with non-namespace objects\");} else r.add(r = new l(n));}return t && r.addJSON(t), r;}, l.prototype.resolveAll = function () {for (var e = this.nestedArray, t = 0; t < e.length;) {e[t] instanceof l ? e[t++].resolveAll() : e[t++].resolve();}return this.resolve();}, l.prototype.lookup = function (e, t, r) {if (\"boolean\" == typeof t ? (r = t, t = void 0) : t && !Array.isArray(t) && (t = [t]), c.isString(e) && e.length) {if (\".\" === e) return this.root;e = e.split(\".\");} else if (!e.length) return this;if (\"\" === e[0]) return this.root.lookup(e.slice(1), t);var n = this.get(e[0]);if (n) {if (1 === e.length) {if (!t || t.indexOf(n.constructor) > -1) return n;} else if (n instanceof l && (n = n.lookup(e.slice(1), t, !0))) return n;} else for (var o = 0; o < this.nestedArray.length; ++o) {if (this._nestedArray[o] instanceof l && (n = this._nestedArray[o].lookup(e, t, !0))) return n;}return null === this.parent || r ? null : this.parent.lookup(e, t);}, l.prototype.lookupType = function (e) {var t = this.lookup(e, [o]);if (!t) throw Error(\"no such type: \" + e);return t;}, l.prototype.lookupEnum = function (e) {var t = this.lookup(e, [s]);if (!t) throw Error(\"no such Enum '\" + e + \"' in \" + this);return t;}, l.prototype.lookupTypeOrEnum = function (e) {var t = this.lookup(e, [o, s]);if (!t) throw Error(\"no such Type or Enum '\" + e + \"' in \" + this);return t;}, l.prototype.lookupService = function (e) {var t = this.lookup(e, [i]);if (!t) throw Error(\"no such Service '\" + e + \"' in \" + this);return t;}, l._configure = function (e, t, r) {o = e, i = t, s = r;};}, function (e, t, r) {\"use strict\";var n = t,o = r(5),i = [\"double\", \"float\", \"int32\", \"uint32\", \"sint32\", \"fixed32\", \"sfixed32\", \"int64\", \"uint64\", \"sint64\", \"fixed64\", \"sfixed64\", \"bool\", \"string\", \"bytes\"];function s(e, t) {var r = 0,n = {};for (t |= 0; r < e.length;) {n[i[r + t]] = e[r++];}return n;}n.basic = s([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), n.defaults = s([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, !1, \"\", o.emptyArray, null]), n.long = s([0, 0, 0, 1, 1], 7), n.mapKey = s([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), n.packed = s([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]);}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Curve = void 0;var n = r(1),o = r(43),i = r(0),s = r(3),a = r(2),c = function c() {o.BaseGeometry.call(this), this._subrange = [];};(c.prototype = Object.create(o.BaseGeometry.prototype)).copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this._subrange = e.isLimited() ? [e._subrange[0], e._subrange[1]] : [];}, c.prototype.isLimited = function () {return this._subrange.length > 0;}, c.prototype.getRange = function () {return this.isLimited() ? this._subrange : this.getRangeUnlimited();}, c.prototype.getRangeUnlimited = function () {console.warn(\"Curve.getRangeUnlimited : abstract method invoked!\");}, c.prototype.limitRange = function (e) {this._subrange = (0, s.limitRange)(this.getRange(), e, this.isPeriodic(), this.getPeriod());}, c.prototype.unlimitRange = function () {this._subrange = [];}, c.prototype.isPeriodic = function () {return this.isPeriodicUnlimited() && !this.isLimited();}, c.prototype.isPeriodicUnlimited = function () {console.warn(\"Curve.isPeriodicUnlimited : abstract method invoked!\");}, c.prototype.getPeriod = function () {return this.isLimited() ? void 0 : this.getPeriodUnlimited();}, c.prototype.getPeriodUnlimited = function () {if (this.isPeriodicUnlimited()) {var e = this.getRangeUnlimited();return e[1] - e[0];}}, c.prototype.isClosed = function () {if (this.isClosedUnlimited()) {if (this.isLimited()) {var e = this.getRangeUnlimited(),t = e[1] - e[0];return this._subrange[1] - this._subrange[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, c.prototype.isClosedUnlimited = function () {console.warn(\"Curve.isClosedUnlimited : abstract method invoked!\");}, c.prototype._restrictRangeToUnlimited = function (e) {a.ConsoleUtils.assert(2 === e.length), a.ConsoleUtils.assert(e[0] <= e[1]);var t = this.getRangeUnlimited(),r = [];if (this.isPeriodicUnlimited()) {var o = t[1] - t[0];if (e[1] - e[0] > o - i.PARAMETER_SPACE_TOLERANCE) r.push([t[0], t[1]]);else {var c = (0, s.foldAbove)(e[0], t[0], o) - e[0];r.push([e[0] + c, e[1] + c]), r[0][1] > t[1] + i.PARAMETER_SPACE_TOLERANCE && (r.push([t[0], r[0][1] - o]), r[0][1] = t[1]);}} else {var u = Math.max(e[0], t[0]),l = Math.min(e[1], t[1]);u > t[1] ? u < t[1] + n.FLOAT64_TOLERANCE && r.push([t[1], t[1]]) : l < t[0] ? l > t[0] - n.FLOAT64_TOLERANCE && r.push([t[0], t[0]]) : r.push([u, l]);}return r;}, c.prototype.transform = function (e) {console.warn(\"Curve.transform : abstract method invoked! Doing nothing.\");}, c.prototype.evaluatePosition = function (e) {console.warn(\"Curve.evaluatePosition : abstract method invoked! Returning undefined.\");}, c.prototype.evaluateDt = function (e) {console.warn(\"Curve.evaluateDt : abstract method invoked! Returning undefined.\");}, c.prototype.evaluateCurvature = function (e, t) {var r = this.evaluateDt(e),o = this.evaluateDt(e + i.KERNEL_TOLERANCE);n.Vector3.sub(o, o, r);var s = n.Vector3.createFloat64();n.Vector3.scale(s, o, 1 / i.KERNEL_TOLERANCE), t && (n.Vector3.copy(t, s), n.Vector3.normalize(t, t));var a = n.Vector3.squaredLength(r);return n.Vector3.cross(s, r, s), n.Vector3.length(s) / Math.pow(a, 1.5);}, c.prototype.tangentLength = function (e) {return n.Vector3.length(this.evaluateDt(e));}, c.prototype.suggestSplittingParam = function (e) {console.warn(\"Curve.suggestSplittingParam : abstract method invoked! Returning undefined.\");}, c.prototype.getTangentCone = function (e) {console.warn(\"Curve.getTangentCone : abstract method invoked! Returning undefined.\");}, c.prototype.closestToRayParam = function (e, t, r) {console.warn(\"Curve.closestToRayParam : abstract method invoked! Returning undefined.\");}, c.prototype.closestToPointParam = function (e, t) {console.warn(\"Curve.closestToPointParam : abstract method invoked! Returning undefined.\");}, c.prototype.getArcLength = function (e) {console.warn(\"Curve.getArcLength : abstract method invoked!\");}, c.prototype.getParameterFromArcLength = function (e, t) {console.warn(\"Curve.getParameterFromArcLength : abstract method invoked!\");}, c.prototype.getBoundingBox = function (e) {console.warn(\"Curve.getBoundingBox : abstract method invoked! Returning undefined.\");}, c.prototype.tessellate = function (e, t) {console.warn(\"Curve.tessellate : abstract method invoked! Returning undefined.\");}, t.Curve = c;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.BCurve = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(7),u = r(3),l = r(35),h = r(2),d = r(8),g = r(50),p = r(36),f = r(17),v = r(37),_ = r(102),y = r(73),m = function m() {a.Curve.call(this), this._controlPoints = [], this._weights = [], this._degree = 0, this._knots = [], this._isRational = void 0, this._isPeriodic = void 0, this._isClosed = void 0, this._isPlanarXY = void 0, this._discretizationCache = void 0, this._segments = void 0, this._hasDirtySegments = !0, this._isDirtyControlPoint = [], this._tessellationCache = new g.TessellationCache();};(m.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.BCURVE;}, m.prototype.clone = function () {var e = new m();return e.copy(this), e;}, m.prototype.getControlPointsVector3 = function () {for (var e = new Array(this._controlPoints.length / 3), t = 0; t < this._controlPoints.length / 3; t++) {e[t] = n.Vector3.createFloat64FromValues(this._controlPoints[3 * t], this._controlPoints[3 * t + 1], this._controlPoints[3 * t + 2]);}return e;}, m.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), this._isRational = e._isRational, this._weights = e._weights.slice(0), this._degree = e._degree, this._knots = e._knots.slice(0), this._isPeriodic = e._isPeriodic, this._isClosed = e._isClosed, this._weights = e._weights.slice(0), this._controlPoints = e._controlPoints.slice(0), this._isPlanarXY = e._isPlanarXY, this._hasDirtySegments = !0, this._tessellationCache.reset();}, m.prototype.set = function (e, t, r, o) {this.dirtyCurveRepresentation(), this._weights = Array.prototype.slice.call(t), this._degree = r;var i = 0;if (this._isRational = !1, this._weights.length !== t.length) {this._weights = Array.prototype.slice.call(t);var s = this._weights[0];for (i = 1; i < this._weights.length; ++i) {if (Math.abs(this._weights[i] - s) > n.FLOAT64_TOLERANCE) {this._isRational = !0;break;}}} else for (s = this._weights[0], i = 1; i < this._weights.length; ++i) {this._weights[i] = t[i], Math.abs(this._weights[i] - s) > n.FLOAT64_TOLERANCE && (this._isRational = !0);}if (this._knots.length !== o.length) this._knots = Array.prototype.slice.call(o);else for (i = 0; i < this._knots.length; ++i) {this._knots[i] = o[i];}var a = e.length / 3;if (0 === this._weights.length) for (this._weights = new Array(a), i = 0; i < a; ++i) {this._weights[i] = 1;}if (this._controlPoints.length !== e.length) this._controlPoints = Array.prototype.slice.call(e);else for (i = 0; i < e.length; ++i) {this._controlPoints[i] = e[i];}this._isDirtyControlPoint.length !== a && (this._isDirtyControlPoint = new Array(a)), this._isDirtyControlPoint.fill(!1);}, m.prototype.dirtyCurveRepresentation = function () {this._isPlanarXY = void 0, this._isRational = void 0, this._isClosed = void 0, this._isPeriodic = void 0, this._discretizationCache = void 0, this._hasDirtySegments = !0, this._tessellationCache.setDirty(!0);}, m.prototype.hasDirtyTessellation = function () {return this._tessellationCache.isDirty();}, m.prototype.getTessellationCacheTolerance = function () {return this._tessellationCache.getTolerance();}, m.prototype.weightedControlPoints = function () {for (var e = [], t = 0; t < this._controlPoints.length / 3; ++t) {var r = this._weights[t];e.push(this._controlPoints[3 * t] * r, this._controlPoints[3 * t + 1] * r, this._controlPoints[3 * t + 2] * r, r);}return e;}, m.prototype.getControlPoints = function () {return this._controlPoints;}, m.prototype._findChangedControlPoints = function (e) {var t = e.length === this._controlPoints.length;t || (this._isDirtyControlPoint = new Array(e.length / 3), this._isDirtyControlPoint.fill(!0));for (var r = 0; r < e.length / 3; ++r) {if (t) {var n = e[3 * r] - this._controlPoints[3 * r],o = e[3 * r + 1] - this._controlPoints[3 * r + 1],i = e[3 * r + 2] - this._controlPoints[3 * r + 2];n * n + o * o + i * i > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE && (this._isDirtyControlPoint[r] = !0);} else this._isDirtyControlPoint[r] = !0;}}, m.prototype.setControlPoints = function (e) {this._findChangedControlPoints(e), this._controlPoints = e, this.dirtyCurveRepresentation();}, m.prototype.copyControlPoints = function (e) {if (this._findChangedControlPoints(e), e !== this._controlPoints) {this._controlPoints.length = e.length;for (var t = 0; t < e.length; ++t) {this._controlPoints[t] = e[t];}}this.dirtyCurveRepresentation();}, m.prototype.transform = function (e) {for (var t = [], r = n.Vector3.createFloat64(), o = 0; o < this._controlPoints.length; o += 3) {n.Vector3.set(r, this._controlPoints[o], this._controlPoints[o + 1], this._controlPoints[o + 2]), n.Vector3.transformMatrix44(r, r, e), t.push(r[0], r[1], r[2]);}this.setControlPoints(t);}, m.prototype.getControlPointPosition = function (e) {return n.Vector3.createFloat64FromValues(this._controlPoints[3 * e], this._controlPoints[3 * e + 1], this._controlPoints[3 * e + 2]);}, m.prototype.extendBBoxFromControlPoints = function (e) {for (var t = n.Vector3.createFloat64(), r = 0; r < this._controlPoints.length; r += 3) {n.Vector3.set(t, this._controlPoints[r], this._controlPoints[r + 1], this._controlPoints[r + 2]), e.includePoint(t);}}, m.prototype.setControlPointPosition = function (e, t, r, n) {this._controlPoints[3 * e] = t, this._controlPoints[3 * e + 1] = r, this._controlPoints[3 * e + 2] = n, this._isDirtyControlPoint[e] = !0, this.dirtyCurveRepresentation();}, m.prototype.getWeights = function () {return this._weights;}, m.prototype.setWeights = function (e) {this._weights = e, this.dirtyCurveRepresentation();}, m.prototype.getKnotVector = function () {return this._knots;}, m.prototype.setKnotVector = function (e) {this._knots = e, this.dirtyCurveRepresentation();}, m.prototype.getDegree = function () {return this._degree;}, m.prototype.isRational = function () {if (void 0 === this._isRational && (this._isRational = !1, this._weights)) for (var e = this._weights[0], t = 0; t < this._weights.length; ++t) {if (Math.abs(this._weights[t] - e) > n.FLOAT64_TOLERANCE) return this._isRational = !0, !0;}return this._isRational;}, m.prototype.isSimpleBezier = function () {return this._knots.length === 2 * this._degree + 2;}, m.prototype.getNumControlPoints = function () {return this._controlPoints.length / 3;}, m.prototype.getTessellationCache = function () {return this._tessellationCache.getCache();}, m.prototype.getEvaluationCache = function () {return void 0 === this._discretizationCache && this.evaluate(), this._discretizationCache;}, m.prototype.getRangeUnlimited = function () {return [this._knots[0], this._knots[this._knots.length - 1]];}, m.prototype.isPeriodicUnlimited = function () {return this._checkClosure(), this._isPeriodic;}, m.prototype.isClosedUnlimited = function () {return this._checkClosure(), this._isClosed;}, m.prototype._checkClosure = function () {if (void 0 === this._isClosed || void 0 === this._isPeriodic) {this._isClosed = this._isPeriodic = !1;var e = this.getRangeUnlimited(),t = this.evaluatePosition(e[0]),r = this.evaluatePosition(e[1]);if (n.Vector3.equals(t, r, s.KERNEL_TOLERANCE)) {this._isClosed = !0;var o = this.evaluateDt(e[0]),i = this.evaluateDt(e[1]);n.Vector3.isParallel(o, i, 1, s.KERNEL_ANGULAR_TOLERANCE) && (this._isPeriodic = !0);}}}, m.prototype.getBezierSegments = function () {return this._decomposeCurve(), this.isSimpleBezier() ? [this] : this._segments;}, m.prototype.isPlanarXY = function () {if (void 0 === this._isPlanarXY) {var e = s.SPLINE_DISTANCE_TOLERANCE;this._isPlanarXY = !0;for (var t = 1 / 0, r = -1 / 0, n = 2; n < this._controlPoints.length; n += 3) {t = Math.min(t, this._controlPoints[n]), r = Math.max(r, this._controlPoints[n]);}Math.abs(r - t) > 2 * e && (this._isPlanarXY = !1);}return this._isPlanarXY;}, m.prototype.getBezierSegmentsInRange = function (e, t) {for (var r = this.getBezierSegments(), n = e || this._knots[0], o = t || this._knots[this._knots.length - 1], i = [], s = 0; s < r.length; ++s) {var a = r[s].getKnotVector();n <= a[a.length - 1] && a[0] >= o && i.push(r[s]);}return i;}, m.prototype.getApproxParameterSpaceTolerance = function () {if (12 === this.getControlPoints().length) return p.SplineCurveHelper.getApproxBezierParameterSpaceTolerance(this.getBoundingBox(), s.KERNEL_TOLERANCE);this._decomposeCurve();for (var e = 0, t = 0; t < this._segments.size(); ++t) {e += p.SplineCurveHelper.getApproxBezierParameterSpaceTolerance(this._segments[t].getBoundingBox(), s.KERNEL_TOLERANCE);}return e;}, m.prototype.getArcLength = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());for (var t = this._restrictRangeToUnlimited(e), r = 0, o = this.getBezierSegments(), i = 0; i < o.length; ++i) {for (var a = o[i], c = a.getRangeUnlimited(), u = 0; u < t.length; ++u) {var h = [Math.max(c[0], t[u][0]), Math.min(c[1], t[u][1])];h[1] - h[0] > s.PARAMETER_SPACE_TOLERANCE && (r += (0, l.integrateFunction1D)(function (e) {return n.Vector3.length(a.evaluateDt(e));}, h));}}return r;}, m.prototype.getParameterFromArcLength = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = this;return (0, l.invertIntegral1D)(function (e) {return n.Vector3.length(r.evaluateDt(e));}, e, t);}, m.prototype._decomposeCurve = function () {if (this._hasDirtySegments) if (this._hasDirtySegments = !1, this.isSimpleBezier()) this._segments = void 0;else {var e;this._isDirtyControlPoint.length === this.getNumControlPoints() ? e = (0, _.decomposeBCurveFlags)(this.getKnotVector(), this._isDirtyControlPoint) : (this._isDirtyControlPoint = new Array(this.getNumControlPoints()), (e = new Array(this.getNumControlPoints())).fill(!0)), this._isDirtyControlPoint.fill(!1);var t = (0, _.decomposeBCurveToBezier)(this._knots, this._controlPoints, this.isRational() ? this._weights : void 0);this._segments && this._segments.length === t.P.length || (this._segments = []);for (var r = 0; r < t.P.length; ++r) {void 0 === this._segments[r] && (this._segments[r] = new m(), e[r] = !0), e[r] && this._segments[r].set(t.P[r], t.w ? t.w[r] : new Array(2 * this._degree + 2).fill(1), this._degree, t.U[r]);}}}, m.prototype.evaluatePosition = function (e) {this.isPeriodicUnlimited() && (e = (0, u.normalizeParameterToShiftedRange)(e, [this._knots[0], this._knots[this._knots.length - 1]]));var t = this.isRational() ? this._weights : void 0;return (0, v.evaluateBCurvePoint)(e, this._degree, this._knots, this._controlPoints, t);}, m.prototype.evaluateDt = function (e) {this.isPeriodicUnlimited() && (e = (0, u.normalizeParameterToShiftedRange)(e, [this._knots[0], this._knots[this._knots.length - 1]]));var t = this.isRational() ? this._weights : void 0;return (0, v.evaluateBCurveDerivs)(e, 1, this._degree, this._knots, this._controlPoints, t)[1];}, m.prototype.closestToRayParam = function (e, t, r, o) {if (!(this._controlPoints.length < 9)) {if (this.isPlanarXY()) {var i = t[2],a = n.Vector3.createFloat64();if (Math.abs(i) < s.KERNEL_ANGULAR_TOLERANCE) n.Vector3.copy(a, e);else {var c = (this._controlPoints[2] - e[2]) / i;n.Vector3.add(a, n.Vector3.scale(a, t, c), e);}return this.closestToPointParam(a);}d.DebugUtils.warn(\"BCurve.closestToRayParam() only defined for planar curves\");}}, m.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());for (var r = this._restrictRangeToUnlimited(t), o = n.FLOAT64_TOLERANCE, i = this.getBezierSegments(), s = (0, y.closestBCurveSegments)(e, i, void 0, r), a = Number.POSITIVE_INFINITY, c = void 0, l = 0; l < s.length; ++l) {if (!(s[l].minDistSqr > a)) for (var h = i[s[l].index], d = h.getRangeUnlimited(), g = 0; g < r.length; ++g) {var p = [Math.max(d[0], r[g][0]), Math.min(d[1], r[g][1])];if (!(p[1] - p[0] <= n.FLOAT64_TOLERANCE)) {var f = h.getEvaluationCache(),v = (0, u.closestPointToPolyline)(e, f.points, f.offset, p),_ = (0, y.relaxBCurveToPerpendicular)(this._knots, this._controlPoints, this.isRational() ? this._weights : void 0, e, v, p, o, 32),m = h.evaluatePosition(_),E = n.Vector3.squaredDistance(m, e);E < a && (a = E, c = _);var x = h.evaluatePosition(p[0]),R = n.Vector3.squaredDistance(x, e);R < a && (a = R, c = p[0]);var A = h.evaluatePosition(p[1]),P = n.Vector3.squaredDistance(A, e);P < a && (a = P, c = p[1]);}}}return this.isPeriodicUnlimited() && (c = (0, u.foldNearTo)(c, .5 * (t[0] + t[1]), this.getPeriodUnlimited())), c;}, m.prototype.evaluate = function () {var e = this.getBezierSegments();if (e[0] === this) void 0 === this._discretizationCache && (this._discretizationCache = p.SplineCurveHelper.evaluateCurve(this.getDegree(), this.getKnotVector(), this.getControlPoints(), this.getWeights(), !0));else for (var t = 0; t < e.length; ++t) {var r = e[t];void 0 === r._discretizationCache && (r._discretizationCache = p.SplineCurveHelper.evaluateCurve(r.getDegree(), r.getKnotVector(), r.getControlPoints(), r.getWeights(), !0));}}, m.prototype._getFullTessellation = function (e) {var t,r,o = this.getBezierSegments(),i = 0,s = !1;if (o[0] === this) {s = !0;var a = g.CurveTessellator.getAdaptiveRenderPoints(this, e, this.getRangeUnlimited());t = a.positions, r = a.params, i = Math.max(i, a.tolerance);} else {t = [], r = [];for (var c = 0; c < o.length; ++c) {var u = o[c];if (u.hasDirtyTessellation() || u.getTessellationCacheTolerance() > e + n.FLOAT64_TOLERANCE) {s = !0;var l = g.CurveTessellator.getAdaptiveRenderPoints(u, e, u.getRangeUnlimited());u._tessellationCache.setCache(l), i = Math.max(i, l.tolerance);}u._tessellationCache && (0 === c ? (t.push.apply(t, u._tessellationCache.getCache().positions), r.push.apply(r, u._tessellationCache.getCache().params)) : (t.push.apply(t, u._tessellationCache.getCache().positions.slice(1)), r.push.apply(r, u._tessellationCache.getCache().params.slice(1))));}}return { positions: t, params: r, didRetessellate: s, tolerance: i };}, m.prototype.tessellate = function (e, t) {return t = t || s.TESSELLATION.LINEAR_PRECISION, this._tessellationCache.getTessellation(e, this, t, this._getFullTessellation.bind(this));}, m.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this._restrictRangeToUnlimited(e),r = new o.BoundingBox(),n = this.getRangeUnlimited();if (t[0][0] < n[0] + s.PARAMETER_SPACE_TOLERANCE && t[0][1] > n[1] - s.PARAMETER_SPACE_TOLERANCE) this.extendBBoxFromControlPoints(r);else for (var i = this.getBezierSegments(), a = 0; a < t.length; a++) {for (var c = 0; c < i.length; c++) {var u = i[c];(u = u._getSubset(t[a][0], t[a][1])) && u.extendBBoxFromControlPoints(r);}}return r;}, m.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this.evaluatePosition(e[0]),r = this.evaluatePosition(e[1]);n.Vector3.sub(r, r, t), n.Vector3.squaredLength(r) < .01 * s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE && (r = this.evaluateDt(.5 * (e[0] + e[1]))), n.Vector3.normalize(r, r);for (var o = new i.TangentCone(r, 0), a = this._restrictRangeToUnlimited(e), c = n.Vector3.createFloat64FromValues(0, 0, 0), u = this.getBezierSegments(), l = 0; l < a.length; l++) {for (var h = 0; h < u.length; h++) {var d = u[h];if (d = d._getSubset(a[l][0], a[l][1])) for (var g = d._controlPoints, p = 0; p < g.length - 3; p += 3) {c[0] = g[p + 3] - g[p], c[1] = g[p + 4] - g[p + 1], c[2] = g[p + 5] - g[p + 2], n.Vector3.dot(c, r) >= 0 ? o.includeVector(c) : o.angle = Math.PI;}}}return o;}, m.prototype._getSubset = function (e, t) {var r;if (this.isPeriodicUnlimited()) return t - e > this.getPeriodUnlimited() - s.PARAMETER_SPACE_TOLERANCE ? this : ((r = this.clone())._periodicTrimToParams(e, t), r);var n = this.getRangeUnlimited();return e > n[1] - s.PARAMETER_SPACE_TOLERANCE || t < n[0] + s.PARAMETER_SPACE_TOLERANCE ? void 0 : e < n[0] + s.PARAMETER_SPACE_TOLERANCE && t > n[1] - s.PARAMETER_SPACE_TOLERANCE ? this : (r = this.clone(), e > n[0] + s.PARAMETER_SPACE_TOLERANCE && r.trimToParam(!0, e), t < n[1] - s.PARAMETER_SPACE_TOLERANCE && r.trimToParam(!1, t), r);}, m.prototype._periodicTrimToParams = function (e, t) {h.ConsoleUtils.assert(this._isPeriodic);var r = this.getRangeUnlimited(),n = (0, u.normalizeParametricRangeToShiftedRange)([e, t], r);if (n[1] > r[1]) this._isClosed = this._isPeriodic = !1, this.trimToParam(!0, n[1] - (r[1] - r[0]), void 0), this.trimToParam(!1, n[0], void 0);else {var o,i,s = this.getControlPoints(),a = this.getKnotVector(),c = this.getWeights(),l = this.getDegree(),d = this.getPeriodUnlimited(),g = [],f = a.slice(),v = a.slice(),_ = [];for (i = 0; i < s.length / 3; ++i) {g[4 * i + 0] = s[3 * i + 0] * c[i], g[4 * i + 1] = s[3 * i + 1] * c[i], g[4 * i + 2] = s[3 * i + 2] * c[i], g[4 * i + 3] = c[i];}for (o = g.slice(), p.SplineCurveHelper.extractCurveSegment(l, n[1], r[1], f, g), p.SplineCurveHelper.extractCurveSegment(l, r[0], n[0], v, o), i = 0; i < v.length; ++i) {v[i] = v[i] + d;}p.SplineCurveHelper.joinCurves(l, f, g, v, o);var y = g.length / 4,m = [];for (_.length = y, m.length = 3 * y, i = 0; i < y; ++i) {var E = g[4 * i + 3];m[3 * i] = g[4 * i] / E, m[3 * i + 1] = g[4 * i + 1] / E, m[3 * i + 2] = g[4 * i + 2] / E, _[i] = E;}this.set(m, _, l, f), this._isClosed = this._isPeriodic = !1;}}, m.prototype.trimToParam = function (e, t, r) {if (this.isPeriodicUnlimited()) return h.ConsoleUtils.assert(void 0 !== r), void this._periodicTrimToParams(t, r);var n,o,i = this.getControlPoints(),s = this.getKnotVector(),a = this.getWeights(),c = this.getDegree(),u = [];for (n = 0; n < i.length / 3; ++n) {u[4 * n + 0] = i[3 * n + 0] * a[n], u[4 * n + 1] = i[3 * n + 1] * a[n], u[4 * n + 2] = i[3 * n + 2] * a[n], u[4 * n + 3] = a[n];}var l = [],d = 0,g = p.SplineCurveHelper.insertKnot(c, s, u, t, c),v = (0, f.findKnotSpan)(t, g.U);for (e ? (g.U.splice(0, v - c + 1, t), o = g.U.length - c - 1, d = 4 * (g.Pw.length / 4 - o)) : (g.U.splice(v + 1, g.U.length, t), o = g.U.length - c - 1), u.length = 3 * o, l.length = o, n = 0; n < o; ++n) {var _ = g.Pw[4 * n + 3 + d];u[3 * n] = g.Pw[4 * n + 0 + d] / _, u[3 * n + 1] = g.Pw[4 * n + 1 + d] / _, u[3 * n + 2] = g.Pw[4 * n + 2 + d] / _, l[n] = _;}this.set(u, l, c, g.U);}, m.prototype.addControlPoint = function (e, t) {var r = this.getControlPoints(),o = this.getNumControlPoints(),i = this.getKnotVector(),a = this.getWeights(),u = this.getDegree(),l = this.getControlPointPosition(e),h = this.getControlPointPosition(e + 1),d = new c.Line();d.setFromEndpoints(l, h);var g = d.closestToPointParam(t),f = d.evaluatePosition(g),v = n.Vector3.distance(f, l),_ = n.Vector3.distance(f, h),y = a[e] * v + a[e + 1] * _;if (Math.abs(y) < s.KERNEL_TOLERANCE) console.warn(\"numerical error in addControlPoints -- coincident control points / negative weights?\");else {for (var m = a[e] * v / y, E = i[e + 1] + m * (i[e + u + 1] - i[e + 1]), x = [], R = 0; R < r.length / 3; ++R) {x[4 * R] = r[3 * R] * a[R], x[4 * R + 1] = r[3 * R + 1] * a[R], x[4 * R + 2] = r[3 * R + 2] * a[R], x[4 * R + 3] = a[R];}var A = p.SplineCurveHelper.findKnotMultiplicity(E, i),P = p.SplineCurveHelper.insertKnot(u, i, x, E, A + 1),V = [];for (x.length = 3 * (o + 1), V.length = o + 1, R = 0; R <= o; ++R) {var T = P.Pw[4 * R + 3];x[3 * R] = P.Pw[4 * R] / T, x[3 * R + 1] = P.Pw[4 * R + 1] / T, x[3 * R + 2] = P.Pw[4 * R + 2] / T, V[R] = T;}this.set(x, V, u, P.U);}}, m.prototype.addControlPointOnCurve = function (e) {for (var t = this.getNumControlPoints(), r = Number.MAX_VALUE, o = -1, i = n.Vector3.createFloat64FromValues(0, 0, 0), s = n.Vector3.createFloat64FromValues(0, 0, 0), a = 0; a < t - 1; ++a) {i[0] = this._controlPoints[3 * a + 0], i[1] = this._controlPoints[3 * a + 1], s[0] = this._controlPoints[3 * a + 3], s[1] = this._controlPoints[3 * a + 4];var c = (0, u.distancePointToLineSegment)(i, s, e);c < r && (r = c, o = a);}-1 !== o && this.addControlPoint(o, e);}, m.prototype.makePeriodic = function () {if (!this.isPeriodicUnlimited()) {for (var e = this.getControlPoints(), t = this.getKnotVector(), r = this.getWeights(), n = this.getDegree(), o = [], i = 0; i < e.length / 3; ++i) {o[4 * i] = e[3 * i] * r[i], o[4 * i + 1] = e[3 * i + 1] * r[i], o[4 * i + 2] = e[3 * i + 2] * r[i], o[4 * i + 3] = r[i];}var s = t.slice();p.SplineCurveHelper.makePeriodic(n, s, o);var a = [],c = [],u = o.length / 4;for (a.length = u, c.length = 3 * u, i = 0; i < u; ++i) {var l = o[4 * i + 3];c[3 * i] = o[4 * i] / l, c[3 * i + 1] = o[4 * i + 1] / l, c[3 * i + 2] = o[4 * i + 2] / l, a[i] = l;}this.set(c, a, n, s), this._isClosed = this._isPeriodic = !0;}}, m.prototype.suggestSplittingParam = function (e) {var t,r = this.getKnotVector(),n = .5 * (e[0] + e[1]),o = (0, u.sortedIndex)(r, n);if (0 === o) t = r[o];else if (o === r.length) t = r[o - 1];else {var i = r[o - 1],s = r[o];t = n - i < s - n ? i : s;}return t >= e[0] && t <= e[1] ? t : void 0;}, m.prototype.toObject = function () {return { degree: this._degree, knots: this._knots, controlPoints: this._controlPoints, weights: this._weights, range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.BCurve = m;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.TangentCone = void 0;var n = r(1),o = r(0),i = r(3),s = function s(e, t) {this.set(e, t);};s.prototype.set = function (e, t) {void 0 === e || void 0 === t ? (this.axis = void 0, this.angle = void 0) : (this.axis = n.Vector3.clone(e), this.angle = t);}, s.prototype.toString = function () {return this.isDegenerate() ? \"degenerate\" : \"(x:\" + this.axis[0] + \", y:\" + this.axis[1] + \", z:\" + this.axis[2] + \", radians:\" + this.angle + \")\";}, s.prototype.copy = function (e) {return e.isDegenerate() ? (this.axis = void 0, this.angle = void 0) : (this.axis = n.Vector3.clone(e.axis), this.angle = e.angle), this;}, s.prototype.clone = function () {return new s(this.axis, this.angle);}, s.prototype.isDegenerate = function () {return void 0 === this.axis || void 0 === this.angle;}, s.prototype.includeVector = function (e) {if (n.Vector3.squaredLength(e) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return this;if (this.isDegenerate()) return this.axis || (this.axis = n.Vector3.createFloat64()), n.Vector3.normalize(this.axis, e), this.angle = 0, this;var t = n.Vector3.dot(this.axis, e) / n.Vector3.length(e);t = (0, i.clamp)(t, -1, 1);var r = Math.acos(t);return this.angle = Math.max(this.angle, r), this;}, s.prototype.includeCone = function (e) {if (e.isDegenerate()) return this;if (this.isDegenerate()) return this.copy(e);var t = n.Vector3.dot(this.axis, e.axis),r = Math.acos((0, i.clamp)(t, -1, 1));if (this.angle >= e.angle + r) return this;if (e.angle >= this.angle + r) return this.copy(e);if (r > Math.PI - o.KERNEL_ANGULAR_TOLERANCE) return this.angle = Math.PI, this;var s = (this.angle + e.angle + r) / 2;if (s >= Math.PI) return this.angle = Math.PI, this;var a = Math.sin(s - e.angle),c = Math.sin(s - this.angle);return n.Vector3.scale(this.axis, this.axis, a), n.Vector3.scaleAndAdd(this.axis, this.axis, e.axis, c), n.Vector3.normalize(this.axis, this.axis), this.angle = s, this;}, s.prototype.contains = function (e, t) {if (t = \"number\" == typeof t ? t : o.KERNEL_ANGULAR_TOLERANCE, !this.isDegenerate()) return n.Vector3.squaredLength(e) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE || n.Vector3.angle(this.axis, e) < this.angle + t;}, t.TangentCone = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.invertIntegral1D = t.integrateFunction1D = t.newtonRaphson1D = void 0;var n = r(0),o = r(3),i = r(8),s = function () {var e = [.9914553711208126, .9491079123427585, .8648644233597691, .7415311855993945, .5860872354676911, .4058451513773972, .20778495500789848, 0],t = [.022935322010529224, .06309209262997856, .10479001032225019, .14065325971552592, .1690047266392679, .19035057806478542, .20443294007529889, .20948214108472782],r = [.1294849661688697, .27970539148927664, .3818300505051189, .4179591836734694];return function (o, a, c) {var u = function (n, o, i) {for (var s = .5 * (o + i), a = .5 * (i - o), c = n(s), u = c * t[7], l = c * r[3], h = 0; h < 7; ++h) {var d = a * e[h],g = n(s - d) + n(s + d);u += g * t[h], h % 2 == 1 && (l += g * r[Math.floor(h / 2)]);}var p = 200 * Math.abs(u - l) * a;return { length: u * a, error: p *= Math.sqrt(p) };}(o, a[0], a[1]);if (void 0 === c) c = 0;else if (c > 8) return i.DebugUtils.warn(\"Max depth reached in integrateFunction1D!\"), u.length;if (u.error > n.KERNEL_TOLERANCE) {var l = .5 * (a[0] + a[1]);return s(o, [a[0], l], c + 1) + s(o, [l, a[1]], c + 1);}return u.length;};}();t.newtonRaphson1D = function (e, t, r, n, s) {var a,c = r;t && (c = (0, o.clamp)(c, t[0], t[1]));var u = 0;do {++u;var l = e(c),h = c - l.val / l.deriv;t && (h = (0, o.clamp)(h, t[0], t[1])), a = Math.abs(h - c), c = h;} while (a > n && u < s);return u >= s && i.DebugUtils.warn(\"Maximum number of iterations reached. Something wrong is going on here !!!\"), c;}, t.integrateFunction1D = s, t.invertIntegral1D = function (e, t, r) {var i = n.KERNEL_TOLERANCE,a = s(e, r);if (t < i) return r[0];if (t > a - i) return r[1];for (var c = r[0], u = r[1], l = t; u - c > n.PARAMETER_SPACE_TOLERANCE;) {var h = l / a,d = c + (h = (0, o.clamp)(h, .01, .99)) * (u - c),g = s(e, [c, d]),p = a - (g = (0, o.clamp)(g, 0, a));if (Math.abs(l - g) < i) return d;g > l ? (u = d, a = g) : (c = d, l -= g, a = p);}return .5 * (c + u);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SplineCurveHelper = void 0;var n = r(1),o = r(0),i = r(3),s = r(8),a = r(17),c = r(37),u = r(72),l = function l() {};l.getApproxBezierParameterSpaceTolerance = function (e, t) {var r = e.getDiagonal(),i = 2 * t / n.Vector3.length(r);return i < .01 * o.PARAMETER_SPACE_TOLERANCE ? .01 * o.PARAMETER_SPACE_TOLERANCE : i;}, l.solve_cubic_uniqueRoots = function (e, t) {var r = e[2] * e[2] - 3 * e[1],n = e[2] * (2 * e[2] * e[2] - 9 * e[1]) + 27 * e[0];if (0 === n && 0 === r) return t[0] = -e[2] / 3, 1;if (n * n / 4 < r * r * r) {var o = -2 * Math.sqrt(r),i = Math.acos(-n / (r * o));return t[0] = (o * Math.cos(i / 3) - e[2]) / 3, t[1] = (o * Math.cos((i + 2 * Math.PI) / 3) - e[2]) / 3, t[2] = (o * Math.cos((i - 2 * Math.PI) / 3) - e[2]) / 3, 3;}var s = Math.pow(Math.abs(n) / 2 + Math.sqrt(n * n / 4 - r * r * r), 1 / 3) / 3;return n > 0 && (s = -s), t[0] = s + r / (9 * s) - e[2] / 3, 1;};var h = function h(e, t, r) {return 6 * ((1 - r) * (e[6 + t] - 2 * e[3 + t] + e[t]) + r * (e[9 + t] - 2 * e[6 + t] + e[3 + t]));},d = function d(e, t) {return 6 * (e[9 + t] - e[t] + 3 * (e[3 + t] - e[6 + t]));},g = function g(e, t) {var r = new Array(3);!function (e, t, r) {r[0] = 3 * (e[3 + t] - e[t]), r[1] = 6 * (e[t] + e[6 + t] - 2 * e[3 + t]), r[2] = 3 * (e[9 + t] - e[t] + 3 * (e[3 + t] - e[6 + t]));}(e, t, r);var n,o = new Array(2),i = function (e, t) {var r = e[1] * e[1] - 4 * e[2] * e[0];if (r < 0) return 0;if (0 === r) return t[0] = -.5 * e[1] / e[2], 1;var n = e[1] > 0 ? -.5 * (e[1] + Math.sqrt(r)) : -.5 * (e[1] - Math.sqrt(r));return t[0] = n / e[2], t[1] = e[0] / n, 2;}(r, o);2 === i && o[0] > o[1] && (n = o[0], o[0] = o[1], o[1] = n);for (var s = [], a = 0; a < i; a++) {o[a] > 0 && o[a] < 1 && ((n = Math.abs(h(e, t, o[a])) < 1e-12) ? (n = Math.abs(d(e, t)) < 1e-12) && s.push(o[a]) : s.push(o[a]));}return s;},p = function p(e, t, r) {return e + t[0] + t[1] * r + t[2] * r * r + t[3] * r * r * r;};l.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D = function (e, t, r, n) {var i = new Float64Array(4),s = new Float64Array(4);i[0] = t[0] - e[0], i[1] = 3 * (t[3] - t[0]), i[2] = 3 * (t[0] + t[6] - 2 * t[3]), i[3] = t[9] - t[0] + 3 * (t[3] - t[6]), s[0] = t[1] - e[1], s[1] = 3 * (t[4] - t[1]), s[2] = 3 * (t[1] + t[7] - 2 * t[4]), s[3] = t[10] - t[1] + 3 * (t[4] - t[7]);var a,c = s;if (Math.abs(c[3]) > 1e-4) c[0] /= c[3], c[1] /= c[3], c[2] /= c[3], c[3] = 1, a = this.solve_cubic_uniqueRoots(c, r);else {var l = [].slice.call(c).reverse();0 === l[0] && (l = l.slice(1));var h = (0, u.getRealPolynomialRoots)(l);a = h.length;for (var d = 0; d < a; d++) {r[d] = h[d];}}if (1 === a) return (f = r[0]) < 0 || f > 1 ? 0 : (r[0] = p(e[0], i, f), 1);d = 0;for (var g = 0; g < a; ++g) {(f = r[g]) >= 0 && f <= 1 && (r[d] = p(e[0], i, f), ++d);}if (void 0 !== n) {var f, v;if (Math.abs(s[3]) < 1e-12) Math.abs(s[2]) < 1e-12 ? v = -1 : (f = -s[1] / (2 * s[2]), v = 0);else {var _ = 2 / 3 * s[2] / s[3];v = _ * _ / 4 - 1 / 3 * s[1] / s[3], f = -_ / 2;}if (0 === v) {if (f < 0 || f > 1) {var y = p(e[0], s, 0),m = p(e[0], s, 1);Math.abs(y) > Math.abs(m) ? n.push([p(e[0], i, 0), y]) : n.push([p(e[0], i, 1), m]);} else n.push([p(e[0], i, f), p(e[0], s, f)]);} else if (v > 0) {for (g = 0; g < 2; g++) {(f = -_ / 2 + (0 === g ? -1 : 1) * Math.sqrt(v)) < -o.PARAMETER_SPACE_TOLERANCE || f > 1 + o.PARAMETER_SPACE_TOLERANCE || (f = Math.max(Math.min(1, f), 0), n.push([p(e[0], i, f), p(e[0], s, f)]));}if (n.length > 1 && n[0][0] > n[1][0]) {var E = n[0];n[0] = n[1], n[1] = E;}}}return d;}, l.isPointInsideSplineRegionXYPlanar3D = function (e, t, r) {var o,s,a = new Float64Array(3),c = t.getBezierSegments();if (t.isRational() || !c || 3 !== t.getDegree()) {for (var u = t.tessellate().positions, l = new Float64Array(2 * u.length), h = 0; h < u.length; ++h) {l[2 * h] = u[h].x, l[2 * h + 1] = u[h].y;}return (0, i.isPointInsidePolygon2D)(e, l);}var d,g = 0,p = n.Vector3.createFloat64();for (h = 0; h < c.length; ++h) {s = c[h].getControlPoints(), o = this.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D(e, s, a);for (var f = 0; f < o; ++f) {n.Vector3.set(p, a[f], e[1], 0), (d = t.closestToPointParam(p)) >= r[0] && d <= r[1] && a[f] > e[0] && ++g;}}var v = t.evaluatePosition(r[0]),_ = t.evaluatePosition(r[1]),y = n.Vector3.createFloat64();n.Vector3.normalize(y, n.Vector3.sub(y, _, v)), y[1] < 0 && n.Vector3.negate(y, y);var m = n.Vector2.createFloat64FromValues(e[0], e[1]);return (0, i.signedDistanceTo2DLine)(v, y, m) <= 0 && e[1] >= Math.min(v[1], _[1]) && e[1] <= Math.max(v[1], _[1]) && ++g, 1 & g;}, l.insertKnot = function (e, t, r, n, o) {var i,s,c,u = [],l = [],h = [],d = r.length / 4,g = d + e + 1,p = (0, a.findKnotSpanAndMultiplicity)(n, t),f = o - p.multiplicity;if (f < 1) return { U: u = t.slice(), Pw: l = r.slice() };for (i = 0; i <= p.span; ++i) {u[i] = t[i];}for (i = 1; i <= f; ++i) {u[p.span + i] = n;}for (i = p.span + 1; i < g; ++i) {u[i + f] = t[i];}for (i = 0; i <= p.span - e; ++i) {for (s = 0; s < 4; ++s) {l[4 * i + s] = r[4 * i + s];}}for (i = p.span - p.multiplicity; i < d; ++i) {for (s = 0; s < 4; ++s) {l[4 * (i + f) + s] = r[4 * i + s];}}for (i = 0; i <= e - p.multiplicity; ++i) {for (s = 0; s < 4; ++s) {h[4 * i + s] = r[4 * (p.span - e + i) + s];}}for (var v = 1; v <= f; ++v) {for (c = p.span - e + v, i = 0; i <= e - v - p.multiplicity; ++i) {var _ = (n - t[c + i]) / (t[i + p.span + 1] - t[c + i]);for (s = 0; s < 4; ++s) {h[4 * i + s] = h[4 * (i + 1) + s] * _ + h[4 * i + s] * (1 - _);}}for (s = 0; s < 4; ++s) {l[4 * c + s] = h[s], l[4 * (p.span + f - v - p.multiplicity) + s] = h[4 * (e - v - p.multiplicity) + s];}}for (i = c + 1; i < p.span - p.multiplicity; ++i) {for (s = 0; s < 4; ++s) {l[4 * i + s] = h[4 * (i - c) + s];}}return { U: u, Pw: l };}, l.refineKnotVector = function (e, t, r, n) {var i,s,c = [],u = [],l = r.length / 4 - 1,h = n.length - 1,d = l + e + 1,g = (0, a.findKnotSpan)(n[0], t),p = (0, a.findKnotSpan)(n[h], t) + 1;for (i = 0; i <= g - e; ++i) {for (s = 0; s < 4; ++s) {u[4 * i + s] = r[4 * i + s];}}for (i = p - 1; i <= l; ++i) {for (s = 0; s < 4; ++s) {u[4 * (i + h + 1) + s] = r[4 * i + s];}}for (i = 0; i <= g; ++i) {c[i] = t[i];}for (i = p + e; i <= d; ++i) {c[i + h + 1] = t[i];}var f = p + e - 1,v = p + e + h;for (i = h; i >= 0; --i) {for (; n[i] <= t[f] && f > g;) {for (s = 0; s < 4; ++s) {u[4 * (v - e - 1) + s] = r[4 * (f - e - 1) + s];}c[v] = t[f], --v, --f;}for (s = 0; s < 4; ++s) {u[4 * (v - e - 1) + 1] = u[4 * (v - e) + s];}for (var _ = 1; _ <= e; ++_) {var y = v - e + _,m = c[v + _] - n[i];if (Math.abs(m) < o.KERNEL_TOLERANCE) for (s = 0; s < 4; ++s) {u[4 * (y - 1) + s] = u[4 * y + s];} else for (m /= c[v + _] - t[f - e + _], s = 0; s < 4; ++s) {u[4 * (y - 1) + s] = u[4 * (y - 1) + s] * m + u[4 * y + s] * (1 - m);}}c[v] = n[i], --v;}return { U: c, Pw: u };};var f = function f(e, t, r, o) {var s = (0, i.projectPointToLineSegment)(t, r, e);return o && (s = (0, i.clamp)(s, 0, 1)), n.Vector3.lerp(n.Vector3.createFloat64(), t, r, s);};l.validControlPolygon = function (e) {for (var t = e.length / 3, r = e.length, o = n.Vector3.createFloat64(), i = n.Vector3.createFloat64(), s = n.Vector3.createFloat64(), a = 3, c = 1; c < t - 1; ++c) {n.Vector3.set(o, e[a], e[a + 1], e[a + 2]), n.Vector3.set(i, e[a - 3], e[a - 2], e[a - 1]), n.Vector3.set(s, e[a + 3], e[a + 4], e[a + 5]);var u = f(o, i, s, !1);if (n.Vector3.sub(o, o, u), c < t / 2 ? n.Vector3.sub(i, [e[r - 3], e[r - 2], e[r - 1]], u) : n.Vector3.sub(i, [e[0], e[1], e[2]], u), n.Vector3.dot(o, i) > 0) return !1;a += 3;}return !0;};var v = function v(e) {if (e) for (var t = 0; t < e.length; ++t) {if (Math.abs(e[t] - 1) > n.FLOAT64_TOLERANCE) return !0;}return !1;},_ = function () {var e = new Float64Array(4),t = new Float64Array(4),r = new Float64Array(4),n = new Float64Array(16);return function (o, i, s, a, c) {var u,l,h,d,g,p,f = 1 - s;if (e[0] = f * f * f, e[1] = 3 * s * f * f, e[2] = 3 * s * s * f, e[3] = s * s * s, t[0] = -3 * f * f, t[1] = 3 * (s - 1) * (3 * s - 1), t[2] = 3 * s * (2 - 3 * s), t[3] = 3 * s * s, r[0] = 6 * f, r[1] = 6 * (3 * s - 2), r[2] = 6 * (1 - 3 * s), r[3] = 6 * s, void 0 === c ? v(i) : c) {for (var _ = 0; _ < 4; ++_) {n[4 * _ + a] = o[3 * _ + a] * i[_], n[4 * _ + 3] = i[_];}for (u = n[a] * e[0], l = n[a] * t[0], h = n[a] * r[0], _ = 1; _ < 4; ++_) {u += n[4 * _ + a] * e[_], l += n[4 * _ + a] * t[_], h += n[4 * _ + a] * r[_];}for (d = n[3] * e[0], g = n[3] * t[0], p = n[3] * r[0], _ = 1; _ < 4; ++_) {d += n[4 * _ + 3] * e[_], g += n[4 * _ + 3] * t[_], p += n[4 * _ + 3] * r[_];}u /= d, l /= g, h /= p;} else for (u = o[a] * e[0], l = o[a] * t[0], h = o[a] * r[0], _ = 1; _ < 4; ++_) {u += o[3 * _ + a] * e[_], l += o[3 * _ + a] * t[_], h += o[3 * _ + a] * r[_];}return [u, l, h];};}(),y = function y(e, t, r, n) {var o = n;o[0] = r[0] - t[0], o[1] = r[1] - t[1];var i = o[0] * o[0] + o[1] * o[1],s = (e[0] - t[0]) * o[0] + (e[1] - t[1]) * o[1];if (0 === i || s <= 0) n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = 0;else if (s > i) n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = 1;else {var a = s / i;n[0] = t[0] + a * o[0] - e[0], n[1] = t[1] + a * o[1] - e[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = a;}},m = function m(e, t, r, n) {var o = n;o[0] = r[0] - t[0], o[1] = r[1] - t[1], o[2] = r[2] - t[2];var i = o[0] * o[0] + o[1] * o[1] + o[2] * o[2],s = (e[0] - t[0]) * o[0] + (e[1] - t[1]) * o[1] + (e[2] - t[2]) * o[2];if (0 === i || s <= 0) n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[1] * n[1], n[0] = 0;else if (s > i) n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[2] = e[2] - r[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[1] * n[1], n[0] = 1;else {var a = s / i;n[0] = t[0] + a * o[0] - e[0], n[1] = t[1] + a * o[1] - e[1], n[2] = t[2] + a * o[2] - e[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[2] * n[2], n[0] = a;}};l.closestStartPoint = function () {var e,t,r,n,o = new Float64Array(3),i = new Float64Array(3),s = new Float64Array(3),a = new Float64Array(2);return function (c, u, l, h) {if (l) for (a[0] = 0, a[1] = 1 / 0, r = u.points.length, n = 0; n < r - 3; n += 3) {o[0] = u.points[n], o[1] = u.points[n + 1], i[0] = u.points[n + 3], i[1] = u.points[n + 4], y(c, o, i, s), s[1] < a[1] && (e = n / 3, t = (1 - s[0]) * u.offset[e] + s[0] * u.offset[e + 1], (!h || t >= h[0] && t <= h[1]) && (a[0] = t, a[1] = s[1]));} else for (a[1] = 1 / 0, r = u.points.length, n = 0; n < r - 3; n += 3) {o[0] = u.points[n], o[1] = u.points[n + 1], o[2] = u.points[n + 2], i[0] = u.points[n + 3], i[1] = u.points[n + 4], i[2] = u.points[n + 5], m(c, o, i, s), s[1] < a[1] && (e = n / 3, t = (1 - s[0]) * u.offset[e] + s[0] * u.offset[e + 1], (!h || t >= h[0] && t <= h[1]) && (a[0] = t, a[1] = s[1]));}return a[0];};}(), l.extremalParams = function (e, t) {if (3 !== e.getDegree()) return s.DebugUtils.warn(\"SplineCurveHelper.extremalParams called with non-degree 3 curve\"), [];var r,i,a = e.getBezierSegments(),c = [];for (r = 0; r < a.length; ++r) {var u = a[r].getControlPoints(),h = a[r].getWeights(),d = a[r].getKnotVector(),g = l.extremalParamsXYPlanarBezierCurve(u, h, t),p = [];for (i = 0; i < g.length; i++) {p.push(d[0] * (1 - g[i]) + d[d.length - 1] * g[i]);}c.push(p);}var f = [];for (r = 0; r < a.length; ++r) {if (f = f.concat(c[r]), r < a.length - 1 || e.isPeriodicUnlimited()) {var v = a[r],_ = a[(r + 1) % a.length],y = c[r],m = c[(r + 1) % a.length],E = v.getRangeUnlimited()[1],x = _.getRangeUnlimited()[0],R = 0 === y.length || E - y[y.length - 1] > o.PARAMETER_SPACE_TOLERANCE,A = 0 === m.length || m[0] - x > o.PARAMETER_SPACE_TOLERANCE;if (R && A) {var P = v.evaluateDt(E)[t],V = _.evaluateDt(x)[t];(Math.abs(P) < n.FLOAT64_TOLERANCE || Math.abs(V) < n.FLOAT64_TOLERANCE || Math.sign(P) !== Math.sign(V)) && f.push(E);}}}return f;}, l.extremalParamsXYPlanarBezierCurve = function (e, t, r, n, o) {var i = v(t);if (!i) return g(e, r);for (var s, a, c = n || 16, u = o || 1e-12, l = [], h = void 0, d = 0; d < 8; d++) {if (a = _(e, t, d / 7, r, i), void 0 !== h && Math.sign(a[1]) !== h) {var p = (d - 1 + Math.abs(s) / (Math.abs(a[1]) + Math.abs(s))) / 7;l.push(p);}h = Math.sign(a[1]), s = a[1];}0 === l.length && (l[0] = 0 + u, l[1] = 1 - u), l.length > 2 && console.error(\"More than two roots in the second derivative of a cubic polynomial. This should not happen.\");var f,y,m,E = [],x = [];for (d = 0; d < l.length; d++) {var R = 0;do {++R, m = 0 !== (a = _(e, t, l[d], r, i))[2] ? l[d] - a[1] / a[2] : l[d], f = Math.abs(a[1]), y = Math.abs(l[d] - m), l[d] = m;} while ((f > u || y > 1e-6) && R < c);E[d] = f, x[d] = a[2];}for (d = 0; d < l.length; d++) {if (l[d] < 0 || l[d] > 1 || E[d] > u) l.splice(d, 1), d--;else if (Math.abs(x[d]) < 1e-6) {var A = (_(e, t, l[d] + 5e-7, r, i)[2] - _(e, t, l[d] - 5e-7, r, i)[2]) / 1e-6;Math.abs(A) > 1e-6 && (l.splice(d, 1), d--);}}if (2 === l.length) {if (Math.abs(l[0] - l[1]) < 1e-6) {var P = E[0] / (E[0] + E[1]);return [l[0] * (1 - P) + l[1] * P];}return l;}return l;}, l.evaluateNURBSCurvePointWithFactors = function (e, t, r, n, o, i) {var s,u,l,h = (0, a.findKnotSpan)(o, t),d = (0, c.evaluateBasisFunctions)(h, o, e, t),g = new Float64Array(3),p = 0,f = 3 * (h - e);for (i.rangeMin = h - e, i.rangeMax = h, u = 0; u <= e; ++u) {for (s = n[h - e + u] * d[u], i.factors[u] = s, l = 0; l < 3; ++l) {g[l] += r[f + l] * s;}p += s, f += 3;}for (u = 0; u < 3; ++u) {g[u] /= p;}for (u = 0; u <= e; ++u) {i.factors[u] /= p;}return g;};var E = function E(e, t, r, o, i, s, a, u, h, d, g, p, v) {var _ = .5 * (r + i),y = (0, c.evaluateBCurvePoint)(_, e, t, a, h ? u : void 0);if (p > v) g.push({ offset: _, point: y });else {var m = f(y, o, s, !1),x = n.Vector3.squaredDistance(s, o),R = n.Vector3.squaredDistance(m, y);l.validControlPolygon(a) && R < d * x ? g.push({ offset: _, point: y }) : (E(e, t, r, o, _, y, a, u, h, d, g, p + 1, v), E(e, t, _, y, i, s, a, u, h, d, g, p + 1, v));}};l.renderNURBSCurve = function (e, t, r, i, s, a, u, l) {var h = a || o.DEFAULT_CURVE_RESOLUTION,d = u || [t[0], t[t.length - 1]];l = void 0 === l || l;var g,p = v(i);if (s) {var f,_,y = [];f = (0, c.evaluateBCurvePoint)(d[0], e, t, r, p ? i : void 0), _ = (0, c.evaluateBCurvePoint)(d[1], e, t, r, p ? i : void 0), y.push({ offset: d[0], point: f }), E(e, t, d[0], f, d[1], _, r, i, p, o.SPLINE_DISTANCE_TOLERANCE, y, 0, 4), y.push({ offset: d[1], point: _ }), g = new Array(4 * y.length);for (var m = l ? 0 : 1, x = l ? 0 : 1; x < y.length; x++) {g[m] = y[x].point[0], g[m + 1] = y[x].point[1], g[m + 2] = y[x].point[2], g[m + 3] = y[x].offset, m += 4;}} else {for (var R = 0, A = 3; A < r.length; A += 3) {R += n.Vector3.distance([r[A - 3], r[A - 2], r[A - 1]], [r[A], r[A + 1], r[A + 2]]);}for (h = 10 * Math.round(R), l ? (A = 0, g = new Float32Array(3 * h)) : (A = 1, g = new Float32Array(3 * (h - 1))); A < h; ++A) {var P,V = d[0] + (d[1] - d[0]) * A / (h - 1);P = (0, c.evaluateBCurvePoint)(V, e, t, r, p ? i : void 0);for (var T = 3 * A, C = 0; C < 3; ++C) {g[T + C] = P[C];}}}return g;}, l.evaluateCurve = function (e, t, r, n, i, s) {if (i) {var a = (0, c.evaluateBCurvePoint)(t[0], e, t, r, n),u = (0, c.evaluateBCurvePoint)(t[t.length - 1], e, t, r, n),l = [];l.push({ offset: t[0], point: a }), E(e, t, t[0], a, t[t.length - 1], u, r, n, !0, o.SPLINE_DISTANCE_TOLERANCE, l, 0, 3), l.push({ offset: t[t.length - 1], point: u });for (var h = [], d = [], g = 0; g < l.length; ++g) {h.push(l[g].offset), d.push(l[g].point[0], l[g].point[1], l[g].point[2]);}} else {var p = s || .01,f = t[0],v = 0;h = [], d = [];do {var _ = (0, c.evaluateBCurvePoint)(f, e, t, r, n);for (h[v] = f, g = 0; g < 3; ++g) {d[3 * v + g] = _[g];}++v, f += p;} while (f <= t[t.length - 1]);}return { offset: h, points: d };};var x = function x(e, t, r) {var n = new Float64Array(2);n[0] = r[0] - t[0], n[1] = r[1] - t[1];var o = n[0] * n[0] + n[1] * n[1];if (0 === o) return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[0] * n[0] + n[1] * n[1];var i = (e[0] - t[0]) * n[0] + (e[1] - t[1]) * n[1];return i < 0 ? (n[0] = e[0] - t[0], n[1] = e[1] - t[1]) : i > o ? (n[0] = e[0] - r[0], n[1] = e[1] - r[1]) : (i /= o, n[0] = t[0] + i * n[0] - e[0], n[1] = t[1] + i * n[1] - e[1]), n[0] * n[0] + n[1] * n[1];},R = function R(e, t) {var r,n = !1,o = t.length;r = 0;for (var i = o - 3; r < o; r += 3) {t[r + 1] > e[1] != t[i + 1] > e[1] && e[0] < (t[i] - t[r]) * (e[1] - t[r + 1]) / (t[i + 1] - t[r + 1]) + t[r] && (n = !n), i = r;}return n;},A = function A(e, t) {for (var r, n = new Float64Array(2), o = Number.NEGATIVE_INFINITY, i = 0; i < t.length; i += 3) {n[0] = t[i] - e[0], n[1] = t[i + 1] - e[1], (r = n[0] * n[0] + n[1] * n[1]) > o && (o = r);}return o;},P = function P(e, t, r) {for (var n, o = t.length, i = new Float64Array(2), s = new Float64Array(2), a = Number.POSITIVE_INFINITY, c = 0; c < o - 3; c += 3) {i[0] = t[c], i[1] = t[c + 1], s[0] = t[c + 3], s[1] = t[c + 4], (n = x(e, i, s)) < a && (a = n);}return void 0 !== r && r && (i[0] = t[o - 3], i[1] = t[o - 2], s[0] = t[0], s[1] = t[1], (n = x(e, i, s)) < a && (a = n)), a;};l.closestSegmentsXYPlanar = function (e, t, r, n) {for (var o = Number.POSITIVE_INFINITY, i = [], s = 0; s < t.length; ++s) {var a,c = t[s],u = c.getRangeUnlimited();if (n) {a = !1;for (var l = 0; l < n.length; ++l) {if (u[1] >= n[l][0] && u[0] <= n[l][1]) {a = !0;break;}}} else a = !0;if (a) {var h,d,g = r ? r[s] : 0,p = c.getControlPoints();R(e, p) ? h = 0 : (h = P(e, p, !0), h = Math.max(0, h - g)), h <= o && (d = A(e, p) + g, i.push({ index: s, minDistSqr: h, maxDistSqr: d }), d < o && (o = d));}}var f = [];for (s = 0; s < i.length; ++s) {i[s].minDistSqr <= o && f.push(i[s]);}return f.sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), f;}, l.findKnotMultiplicity = function (e, t) {for (var r = 0, n = 0; n < t.length; ++n) {if (t[n] > e + 1e-8) return r;Math.abs(t[n] - e) < 1e-8 && r++;}return r;}, l.unclampCurve = function (e, t, r, n) {var o,i,s,a,c,u = r.length / 4 - 1,l = n || 1;for (o = 0; o < e - 1; ++o) {for (t[e - o - 1] = t[e - o] - (t[u - o + 1] - t[u - o]) * l, s = e - 1, i = o; i >= 0; --i) {for (a = (t[e] - t[s]) / (t[e + i + 1] - t[s]), c = 0; c < 4; ++c) {r[4 * i + c] = (r[4 * i + c] - a * r[4 * (i + 1) + c]) / (1 - a);}s -= 1;}}for (t[0] = t[1] - (t[u - e + 2] - t[u - e + 1]) * l, o = 0; o < e - 1; ++o) {for (t[u + o + 2] = t[u + o + 1] + (t[e + o + 1] - t[e + o]) * l, i = o; i >= 0; --i) {for (a = (t[u + 1] - t[u - i]) / (t[u - i + o + 2] - t[u - i]), c = 0; c < 4; ++c) {r[4 * (u - i) + c] = (r[4 * (u - i) + c] - (1 - a) * r[4 * (u - i - 1) + c]) / a;}}}t[u + e + 1] = t[u + e] + (t[2 * e] - t[2 * e - 1]) * l;}, l.extractCurveSegment = function (e, t, r, n, o) {var i = this.insertKnot(e, n, o, t, e);i = this.insertKnot(e, i.U, i.Pw, r, e);var s,c = (0, a.findKnotSpan)(t, i.U);for (n.length = i.U.length - (c - e), n[0] = t, s = 1; s < n.length; ++s) {n[s] = i.U[s + c - e];}var u = n.length - e - 1,l = 4 * (i.Pw.length / 4 - u);for (o.length = i.Pw.length - l, s = 0; s < o.length; ++s) {o[s] = i.Pw[s + l];}c = (0, a.findKnotSpan)(r, n), n.length = c + 1, n.push(r), o.length = 4 * (n.length - e - 1);};var V = function V(e, t, r, n) {for (var o = 0, i = 0; i < 4; ++i) {o += (e[t + i] - r[n + i]) * (e[t + i] - r[n + i]);}return Math.sqrt(o);};l.removeKnot = function (e, t, r, n, i) {if (t <= n[0] || t >= n[n.length - 1]) return 0;var s,c,u,l,h,d = [],g = e + 1,p = (0, a.findKnotSpanAndMultiplicity)(t, n);if (p.multiplicity < 1) return 0;for (var f, v, _, y, m = (2 * p.span - p.multiplicity - e) / 2, E = o.KERNEL_TOLERANCE, x = p.span - p.multiplicity, R = p.span - e, A = !1, P = [0, 0, 0, 0], T = 0; T < r; ++T) {for (f = R - 1, h = 0; h < 4; ++h) {d[0 + h] = i[4 * f + h], d[4 * (x + 1 - f) + h] = i[4 * (x + 1) + h];}for (s = R, c = x, u = 1, l = x - f, A = !1; c - s > T;) {for (v = (t - n[s]) / (n[s + g + T] - n[s]), _ = (t - n[c - T]) / (n[c + g] - n[c - T]), h = 0; h < 4; ++h) {d[4 * u + h] = (i[4 * s + h] - (1 - v) * d[4 * (u - 1) + h]) / v, d[4 * l + h] = (i[4 * c + h] - _ * d[4 * (l + 1) + h]) / (1 - _);}++s, ++u, --c, --l;}if (c - s < T) V(d, 4 * (u - 1), d, 4 * (l + 1)) <= E && (A = !0);else {for (v = (t - n[s]) / (n[s + g + T] - n[s]), h = 0; h < 4; ++h) {P[h] = v * d[4 * (u + T + 1) + h] + (1 - v) * d[4 * (u - 1) + h];}V(i, 4 * s, P, 0) <= E && (A = !0);}if (!A) break;for (s = R, c = x; c - s > T;) {for (h = 0; h < 4; ++h) {i[4 * s + h] = d[4 * (s - f) + h], i[4 * c + h] = d[4 * (c - f) + h];}++s, --c;}--R, ++x;}if (0 === T) return 0;for (y = p.span + 1; y < n.length; ++y) {n[y - T] = n[y];}for (n.length = n.length - T, s = c = m, y = 1; y < T; ++y) {y % 2 == 1 ? s += 1 : c -= 1;}for (y = s + 1; y < i.length / 4; ++y) {for (h = 0; h < 4; ++h) {i[4 * c + h] = i[4 * y + h];}c += 1;}return i.length = i.length - 4 * T, T;}, l.joinCurves = function (e, t, r, n, o) {var i,s = t[t.length - 1];for (t.length = t.length - 1, i = e + 1; i < n.length; ++i) {t.push(n[i]);}for (i = 4; i < o.length; ++i) {r.push(o[i]);}var a = this.removeKnot(e, s, e - 1, t, r);a !== e - 1 && console.warn(\"Failed knot removal, only removed seam knot \" + a + \" times.\");}, l.clampCurve = function (e, t, r) {var n = t[e],o = t[t.length - e - 1];this.extractCurveSegment(e, n, o, t, r);}, l.makePeriodic = function (e, t, r) {var n,o,i = function (e, t, r) {var n,o,i,s = 0;for (n = 1; n < r.length / 4; ++n) {for (i = 0, o = 0; o < 3; ++o) {i += (r[4 * n + o] - r[4 * (n - 1) + o]) * (r[4 * n + o] - r[4 * (n - 1) + o]);}s += Math.sqrt(i);}for (i = 0, o = 0; o < 3; ++o) {i += (r[o] - r[r.length - 4 + o]) * (r[o] - r[r.length - 4 + o]);}var a = Math.sqrt(i),c = (t[t.length - 1] - t[0]) / s,u = r.length / 4 - 1,l = t.slice();for (n = 0; n < e - 1; ++n) {l[e - n - 1] = l[e - n] - (l[u - n + 1] - l[u - n]), l[u + n + 2] = l[u + n + 1] + (l[e + n + 1] - l[e + n]);}var h = l[1] - (l[u - e + 2] - l[u - e + 1]),d = l[u + e] + (l[2 * e] - l[2 * e - 1]);return c / ((t[0] - h + d - t[t.length - 1]) / a);}(e, t, r);this.unclampCurve(e, t, r, i);var s = t.length;for (n = e - 1; n >= 0; --n) {t[s - n] = t[s - n - 1] + (t[e - (n - 1)] - t[e - n]);}var a = r.length / 4;for (r.length = 4 * a + 4 * e, t.length = s + e, n = 0; n < e; ++n) {for (o = 0; o < 4; ++o) {r[4 * (a + n) + o] = r[4 * n + o];}t[s + n] = t[s + n - 1] + (t[e + n + 1] - t[e + n]);}this.clampCurve(e, t, r);}, t.SplineCurveHelper = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.evaluateBCurveDerivs = t.evaluateBCurvePoint = t.evaluateBasisDerivatives = t.evaluateBasisFunctions = void 0;var n = r(1),o = r(3),i = r(17),s = function () {var e = null,t = null;return function (r, n, o, i) {(null === e || e.length < o + 1) && (e = new Float64Array(o + 1), t = new Float64Array(o + 1));var s = new Float64Array(o + 1);s[0] = 1;for (var a = 1; a <= o; ++a) {e[a] = n - i[r + 1 - a], t[a] = i[r + a] - n;for (var c = 0, u = 0; u < a; ++u) {var l = s[u] / (t[u + 1] + e[a - u]);s[u] = c + t[u + 1] * l, c = e[a - u] * l;}s[a] = c;}return s;};}(),a = function () {var e = null,t = null,r = null,n = null;return function (o, i, s, a, c, u) {var l, h, d;if (null === t || t.length < s + 1) {for (e = [new Float64Array(s + 1), new Float64Array(s + 1)], t = new Array(s + 1), l = 0; l < s + 1; ++l) {t[l] = new Float64Array(s + 1);}r = new Float64Array(s + 1), n = new Float64Array(s + 1);}if (!u) for (u = new Array(a + 1), l = 0; l <= a; ++l) {u[l] = new Float64Array(s + 1);}for (t[0][0] = 1, l = 1; l <= s; ++l) {r[l] = i - c[o + 1 - l], n[l] = c[o + l] - i;var g = 0;for (d = 0; d < l; ++d) {t[l][d] = n[d + 1] + r[l - d];var p = t[d][l - 1] / t[l][d];t[d][l] = g + n[d + 1] * p, g = r[l - d] * p;}t[l][l] = g;}for (l = 0; l <= s; ++l) {u[0][l] = t[l][s];}for (d = 0; d <= s; ++d) {var f = 0,v = 1;for (e[0][0] = 1, h = 1; h <= a; ++h) {var _,y = 0,m = d - h,E = s - h;for (d >= h && (e[v][0] = e[f][0] / t[E + 1][m], y = e[v][0] * t[m][E]), _ = d - 1 <= E ? h - 1 : s - d, l = m >= -1 ? 1 : -m; l <= _; ++l) {e[v][l] = (e[f][l] - e[f][l - 1]) / t[E + 1][m + l], y += e[v][l] * t[m + l][E];}d <= E && (e[v][h] = -e[f][h - 1] / t[E + 1][d], y += e[v][h] * t[d][E]), u[h][d] = y, l = f, f = v, v = l;}}for (d = s, h = 1; h <= a; ++h) {for (l = 0; l <= s; ++l) {u[h][l] *= d;}d *= s - h;}return u;};}(),c = function () {var e = null,t = null;return function (r, s, c, u, l, h) {var d, g, p;if (null === e || e.length < c + 1) {for (e = new Array(c + 1), d = 0; d <= c; ++d) {e[d] = new Float64Array(c + 1);}t = new Float64Array(c + 1);}var f = Math.min(s, c),v = h && h.length > 0,_ = (0, i.findKnotSpan)(r, u);a(_, r, c, f, u, e);var y = new Array(s + 1);for (d = 0; d <= s; ++d) {y[d] = n.Vector3.createFloat64();}for (g = 0; g <= f; ++g) {var m = 3 * (_ - c);if (v) for (t[g] = 0, d = 0; d <= c; ++d) {p = h[_ - c + d] * e[g][d], y[g][0] += l[m] * p, y[g][1] += l[m + 1] * p, y[g][2] += l[m + 2] * p, t[g] += p, m += 3;} else for (d = 0; d <= c; ++d) {p = e[g][d], y[g][0] += l[m] * p, y[g][1] += l[m + 1] * p, y[g][2] += l[m + 2] * p, m += 3;}}if (v) for (g = 0; g <= f; ++g) {var E = y[g];for (d = 1; d <= g; ++d) {p = -o.binomialCoefficients[g][d] * t[d], n.Vector3.scaleAndAdd(E, E, y[g - d], p);}n.Vector3.scale(E, E, 1 / t[0]);}return y;};}();t.evaluateBasisFunctions = s, t.evaluateBasisDerivatives = a, t.evaluateBCurvePoint = function (e, t, r, o, a) {var c,u,l = (0, i.findKnotSpan)(e, r),h = s(l, e, t, r),d = a && a.length > 0,g = n.Vector3.createFloat64(),p = 0,f = 3 * (l - t);if (d) {for (c = 0; c <= t; ++c) {u = a[l - t + c] * h[c], g[0] += o[f] * u, g[1] += o[f + 1] * u, g[2] += o[f + 2] * u, p += u, f += 3;}n.Vector3.scale(g, g, 1 / p);} else for (c = 0; c <= t; ++c) {u = h[c], g[0] += o[f] * u, g[1] += o[f + 1] * u, g[2] += o[f + 2] * u, f += 3;}return g;}, t.evaluateBCurveDerivs = c;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Cylinder = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.CYLINDER;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t, u.ConsoleUtils.assert(n.Vector3.squaredLength(r) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, r), void 0 !== o && n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, o, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, o)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._uScale = s || 1, u.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, l.prototype.getRadius = function () {return this._radius;}, l.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.getUScale = function () {return this._uScale;}, l.prototype.setUScale = function (e) {u.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, l.prototype.evaluatePosition = function (e, t) {var r = this._radius * Math.cos(t),o = this._radius * Math.sin(t),i = this._uScale * e,s = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(s, s, this._xAxis, r), n.Vector3.scaleAndAdd(s, s, this._yAxis, o), n.Vector3.scaleAndAdd(s, s, this._zAxis, i), s;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.cos(t),o = Math.sin(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.evaluateDu = function (e, t) {var r = n.Vector3.createFloat64();return n.Vector3.scale(r, this._zAxis, this._uScale), r;}, l.prototype.evaluateDv = function (e, t) {var r = -this._radius * Math.sin(t),o = this._radius * Math.cos(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._xAxis),o = n.Vector3.dot(t, this._yAxis),s = n.Vector3.dot(t, this._zAxis) / this._uScale,a = 0;return r * r + o * o > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE && (a = Math.atan2(o, r)), { u: s, v: a };}, l.prototype.vParamLine = function (e) {var t = new c.Circle(),r = n.Vector3.clone(this._center),o = e * this._uScale;n.Vector3.scaleAndAdd(r, r, this._zAxis, o);var i = n.Vector3.clone(this._xAxis);n.Vector3.scale(i, i, this._radius);var s = n.Vector3.clone(this._zAxis);return n.Vector3.negate(s, s), t.set(r, s, i), t;}, l.prototype.uParamLine = function (e) {var t = new a.Line(),r = n.Vector3.clone(this._center),o = this._radius * Math.cos(e),i = this._radius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, l.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Cylinder = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.EllipticalCylinder = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(23),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s) {n.Vector3.copy(this._center, e), this._majorRadius = n.Vector3.length(t), u.ConsoleUtils.assert(this._majorRadius > i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, t), u.ConsoleUtils.assert(r <= 1), this._minorRadius = r * this._majorRadius, u.ConsoleUtils.assert(this._minorRadius > i.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, t, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._zAxis, o), this._uScale = s || 1, u.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, l.prototype.getMajorRadius = function () {return this._majorRadius;}, l.prototype.setMajorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._majorRadius = e;}, l.prototype.getMinorRadius = function () {return this._minorRadius;}, l.prototype.setMinorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._minorRadius = e;}, l.prototype.getMajorAxis = function () {return this._xAxis;}, l.prototype.setMajorAxis = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), this._computeYAxis();}, l.prototype.getUScale = function () {return this._uScale;}, l.prototype.setUScale = function (e) {u.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, l.prototype.evaluatePosition = function (e, t) {var r = this._majorRadius * Math.cos(t),o = this._minorRadius * Math.sin(t),i = this._uScale * e,s = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(s, s, this._xAxis, r), n.Vector3.scaleAndAdd(s, s, this._yAxis, o), n.Vector3.scaleAndAdd(s, s, this._zAxis, i), s;}, l.prototype.evaluateNormal = function (e, t) {var r = this._minorRadius * Math.cos(t),o = this._majorRadius * Math.sin(t),i = Math.sqrt(r * r + o * o),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, r / i), n.Vector3.scaleAndAdd(s, s, this._yAxis, o / i), s;}, l.prototype.evaluateDu = function (e, t) {var r = n.Vector3.createFloat64();return n.Vector3.scale(r, this._zAxis, this._uScale), r;}, l.prototype.evaluateDv = function (e, t) {var r = -this._majorRadius * Math.sin(t),o = this._minorRadius * Math.cos(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._zAxis) / this._uScale;return { u: r, v: this.vParamLine(r).closestToPointParam(e) };}, l.prototype.vParamLine = function (e) {var t = new c.Ellipse(),r = n.Vector3.clone(this._center),o = e * this._uScale;n.Vector3.scaleAndAdd(r, r, this._zAxis, o);var i = n.Vector3.clone(this._xAxis);n.Vector3.scale(i, i, this._majorRadius);var s = n.Vector3.clone(this._zAxis);return n.Vector3.negate(s, s), t.set(r, s, i, this._minorRadius / this._majorRadius), t;}, l.prototype.uParamLine = function (e) {var t = new a.Line(),r = n.Vector3.clone(this._center),o = this._majorRadius * Math.cos(e),i = this._minorRadius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, l.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.EllipticalCylinder = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Wire = void 0;var n = r(9),o = r(4),i = r(0),s = function s() {n.BaseTopology.call(this), this._wireBody = void 0, this._edges = [];};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.WIRE;}, s.prototype.getWireBody = function () {return this._wireBody;}, s.prototype.setWireBody = function (e) {this._wireBody = e;}, s.prototype.getEdges = function () {return this._edges;}, s.prototype.setEdges = function (e) {this._edges = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._edges[t] = e[t];}}, s.prototype.addEdge = function (e) {this._edges ? this._edges.push(e) : this._edges = [e], e.setWire(this), e.setCoedge(void 0);}, s.prototype.addEdges = function (e) {this._edges || (this._edges = []);for (var t = 0; t < e.length; ++t) {e[t].setWire(this), e[t].setCoedge(void 0);}this._edges = this._edges.concat(e);}, s.prototype.removeEdge = function (e) {var t = this._edges.indexOf(e);return t > -1 && (this._edges.splice(t, 1), e.getWire() === this && e.setWire(void 0), !0);}, s.prototype.getBody = function () {return this._wireBody;}, s.prototype.collectFaces = function (e) {return e || new Set();}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {e.add(this._edges[t]);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {this._edges[t].collectVertices(e);}return e;}, s.prototype.isBranched = function () {for (var e = 0; e < this._edges.length; ++e) {var t = this._edges[e],r = t.getStartVertex(),n = t.getEndVertex();if (r === n && r.getOtherEdge(t)) return !0;if (r.getEdges().length > 2 || n.getEdges().length > 2) return !0;}return !1;}, s.prototype.getOrderedEdges = function () {if (0 === this._edges.length) return { edges: [], start: void 0, end: void 0 };var e = [];e.push(this._edges[0]);for (var t = new Set(this._edges.slice(1)), r = e[0].getStartVertex(), n = e[0].getEndVertex(); t.size > 0;) {var o = t.size;if (t.forEach(function (o) {o.getEndVertex() === r ? (e.unshift(o), r = o.getStartVertex(), t.delete(o)) : o.getStartVertex() === r ? (e.unshift(o), r = o.getEndVertex(), t.delete(o)) : o.getEndVertex() === n ? (e.push(o), n = o.getStartVertex(), t.delete(o)) : o.getStartVertex() === n && (e.push(o), n = o.getEndVertex(), t.delete(o));}), o === t.size) {console.warn(\"Wire is disconnected or branching.\");break;}}return { edges: e, start: r, end: n };}, s.prototype.isClosed = function () {if (1 === this._edges.length) return this._edges[0].getStartVertex() === this._edges[0].getEndVertex();for (var e = this._edges[0], t = void 0, r = 0; r < this._edges.length; ++r) {var n,o = e.getStartVertex(),i = e.getEndVertex();if (o === i || 2 !== o.getEdges().length || 2 !== i.getEdges().length) return !1;if (t && o.getOtherEdge(e) !== t) {if (i.getOtherEdge(e) !== t) return !1;n = o.getOtherEdge(e);} else n = i.getOtherEdge(e);t = e, e = n;}return e === this._edges[0];}, s.prototype.getBoundingBox = function () {for (var e = new o.BoundingBox(), t = 0; t < this._edges.length; ++t) {e.include(this._edges[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return \"Wire\";}, s.prototype.toObject = function () {return { edges: this.refsToStrings(this._edges), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._edges, this._attributes]);}, t.Wire = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.ProgenitorMap = void 0;var n = r(0),o = r(2),i = function i() {this._newToOldMap = new Map(), this._oldToNewMap = new Map(), this._labelMap = new Map();};i.prototype.addEntry = function (e, t, r) {t = Array.from(new Set(t)), o.ConsoleUtils.assert(!this._newToOldMap.has(e)), this._newToOldMap.set(e, t), r && this._labelMap.set(e, r);for (var n = 0; n < t.length; n++) {var i = t[n],s = this._oldToNewMap.get(i);s ? s.indexOf(e) < 0 && s.push(e) : this._oldToNewMap.set(i, [e]);}}, i.prototype.hasEntry = function (e) {return this._newToOldMap.has(e);}, i.prototype.removeEntry = function (e) {var t = this._newToOldMap.get(e);if (t) {this._newToOldMap.delete(e), this._labelMap.delete(e);for (var r = 0; r < t.length; r++) {var n = this._oldToNewMap.get(t[r]),i = n.indexOf(e);o.ConsoleUtils.assert(i >= 0), n.splice(i, 1), 0 === n.length && this._oldToNewMap.delete(t[r]);}}}, i.prototype.size = function () {return this._newToOldMap.size;}, i.prototype.getProgenitors = function (e) {return this._newToOldMap.get(e);}, i.prototype.getDescendants = function (e) {return this._oldToNewMap.get(e) || [];}, i.prototype.getLabel = function (e) {return this._labelMap.get(e) || \"\";}, i.prototype.getAllNewTopology = function () {return Array.from(this._newToOldMap.keys());}, i.prototype.getAllOldTopology = function () {return Array.from(this._oldToNewMap.keys());}, i.prototype.clear = function () {this._newToOldMap.clear(), this._oldToNewMap.clear(), this._labelMap.clear();}, i.prototype.mergeMaps = function (e) {var t = new i(),r = new Set(this._newToOldMap.keys());return e._newToOldMap.keys().forEach(function (e) {r.add(e);}), r.forEach(function (r) {var n = this.getProgenitors(r) || [],o = e.getProgenitors(r) || [],i = this.getLabel(r) || e.getLabel(r);t.addEntry(r, n.concat(o), i);}), t;}, i.prototype.collapseMaps = function (e, t) {var r = !1,n = !1;t && (void 0 !== t.keepIntermediates && (r = t.keepIntermediates), void 0 !== t.keepAllDescendants && (n = t.keepAllDescendants));var o = new i(),s = void 0;return n && (s = new Set(e._newToOldMap.keys())), this._newToOldMap.forEach(function (t, i) {for (var a = new Set(), c = 0; c < t.length; c++) {var u = t[c],l = e.getProgenitors(u);l && l.length > 0 ? (l.forEach(function (e) {a.add(e);}), r && a.add(u)) : a.add(u), n && s.delete(u);}o.addEntry(i, Array.from(a));}), n && s.forEach(function (t) {var r = e.getProgenitors(t);o.hasEntry(t) && (r = r.concat(o.getProgenitors(t)), o.removeEntry(t)), o.addEntry(t, r);}), o;}, i.prototype.toString = function () {for (var e = \"ProgenitorMap:\\n\", t = this.getAllNewTopology(), r = 0; r < t.length; r++) {var o = t[r];e += n.TOPOLOGY_TYPES.toString(o.getTopologyType()) + \":\" + o.getGuid();var i = this.getLabel(o);i && (e += \" '\" + i + \"'\"), e += \" -> [ \";for (var s = this.getProgenitors(o), a = 0; a < s.length; a++) {a > 0 && (e += \", \"), e += n.TOPOLOGY_TYPES.toString(s[a].getTopologyType()) + \":\" + s[a].getGuid();}e += \" ]\\n\";}return e;}, t.ProgenitorMap = i;}, function (e, t, r) {\"use strict\";r.r(t), r.d(t, \"default\", function () {return i;}), r.d(t, \"VERSION\", function () {return n.VERSION;}), r.d(t, \"iteratee\", function () {return n.iteratee;}), r.d(t, \"restArguments\", function () {return n.restArguments;}), r.d(t, \"each\", function () {return n.each;}), r.d(t, \"forEach\", function () {return n.forEach;}), r.d(t, \"map\", function () {return n.map;}), r.d(t, \"collect\", function () {return n.collect;}), r.d(t, \"reduce\", function () {return n.reduce;}), r.d(t, \"foldl\", function () {return n.foldl;}), r.d(t, \"inject\", function () {return n.inject;}), r.d(t, \"reduceRight\", function () {return n.reduceRight;}), r.d(t, \"foldr\", function () {return n.foldr;}), r.d(t, \"find\", function () {return n.find;}), r.d(t, \"detect\", function () {return n.detect;}), r.d(t, \"filter\", function () {return n.filter;}), r.d(t, \"select\", function () {return n.select;}), r.d(t, \"reject\", function () {return n.reject;}), r.d(t, \"every\", function () {return n.every;}), r.d(t, \"all\", function () {return n.all;}), r.d(t, \"some\", function () {return n.some;}), r.d(t, \"any\", function () {return n.any;}), r.d(t, \"contains\", function () {return n.contains;}), r.d(t, \"includes\", function () {return n.includes;}), r.d(t, \"include\", function () {return n.include;}), r.d(t, \"invoke\", function () {return n.invoke;}), r.d(t, \"pluck\", function () {return n.pluck;}), r.d(t, \"where\", function () {return n.where;}), r.d(t, \"findWhere\", function () {return n.findWhere;}), r.d(t, \"max\", function () {return n.max;}), r.d(t, \"min\", function () {return n.min;}), r.d(t, \"shuffle\", function () {return n.shuffle;}), r.d(t, \"sample\", function () {return n.sample;}), r.d(t, \"sortBy\", function () {return n.sortBy;}), r.d(t, \"groupBy\", function () {return n.groupBy;}), r.d(t, \"indexBy\", function () {return n.indexBy;}), r.d(t, \"countBy\", function () {return n.countBy;}), r.d(t, \"toArray\", function () {return n.toArray;}), r.d(t, \"size\", function () {return n.size;}), r.d(t, \"partition\", function () {return n.partition;}), r.d(t, \"first\", function () {return n.first;}), r.d(t, \"head\", function () {return n.head;}), r.d(t, \"take\", function () {return n.take;}), r.d(t, \"initial\", function () {return n.initial;}), r.d(t, \"last\", function () {return n.last;}), r.d(t, \"rest\", function () {return n.rest;}), r.d(t, \"tail\", function () {return n.tail;}), r.d(t, \"drop\", function () {return n.drop;}), r.d(t, \"compact\", function () {return n.compact;}), r.d(t, \"flatten\", function () {return n.flatten;}), r.d(t, \"without\", function () {return n.without;}), r.d(t, \"uniq\", function () {return n.uniq;}), r.d(t, \"unique\", function () {return n.unique;}), r.d(t, \"union\", function () {return n.union;}), r.d(t, \"intersection\", function () {return n.intersection;}), r.d(t, \"difference\", function () {return n.difference;}), r.d(t, \"unzip\", function () {return n.unzip;}), r.d(t, \"zip\", function () {return n.zip;}), r.d(t, \"object\", function () {return n.object;}), r.d(t, \"findIndex\", function () {return n.findIndex;}), r.d(t, \"findLastIndex\", function () {return n.findLastIndex;}), r.d(t, \"sortedIndex\", function () {return n.sortedIndex;}), r.d(t, \"indexOf\", function () {return n.indexOf;}), r.d(t, \"lastIndexOf\", function () {return n.lastIndexOf;}), r.d(t, \"range\", function () {return n.range;}), r.d(t, \"chunk\", function () {return n.chunk;}), r.d(t, \"bind\", function () {return n.bind;}), r.d(t, \"partial\", function () {return n.partial;}), r.d(t, \"bindAll\", function () {return n.bindAll;}), r.d(t, \"memoize\", function () {return n.memoize;}), r.d(t, \"delay\", function () {return n.delay;}), r.d(t, \"defer\", function () {return n.defer;}), r.d(t, \"throttle\", function () {return n.throttle;}), r.d(t, \"debounce\", function () {return n.debounce;}), r.d(t, \"wrap\", function () {return n.wrap;}), r.d(t, \"negate\", function () {return n.negate;}), r.d(t, \"compose\", function () {return n.compose;}), r.d(t, \"after\", function () {return n.after;}), r.d(t, \"before\", function () {return n.before;}), r.d(t, \"once\", function () {return n.once;}), r.d(t, \"keys\", function () {return n.keys;}), r.d(t, \"allKeys\", function () {return n.allKeys;}), r.d(t, \"values\", function () {return n.values;}), r.d(t, \"mapObject\", function () {return n.mapObject;}), r.d(t, \"pairs\", function () {return n.pairs;}), r.d(t, \"invert\", function () {return n.invert;}), r.d(t, \"functions\", function () {return n.functions;}), r.d(t, \"methods\", function () {return n.methods;}), r.d(t, \"extend\", function () {return n.extend;}), r.d(t, \"extendOwn\", function () {return n.extendOwn;}), r.d(t, \"assign\", function () {return n.assign;}), r.d(t, \"findKey\", function () {return n.findKey;}), r.d(t, \"pick\", function () {return n.pick;}), r.d(t, \"omit\", function () {return n.omit;}), r.d(t, \"defaults\", function () {return n.defaults;}), r.d(t, \"create\", function () {return n.create;}), r.d(t, \"clone\", function () {return n.clone;}), r.d(t, \"tap\", function () {return n.tap;}), r.d(t, \"isMatch\", function () {return n.isMatch;}), r.d(t, \"isEqual\", function () {return n.isEqual;}), r.d(t, \"isEmpty\", function () {return n.isEmpty;}), r.d(t, \"isElement\", function () {return n.isElement;}), r.d(t, \"isArray\", function () {return n.isArray;}), r.d(t, \"isObject\", function () {return n.isObject;}), r.d(t, \"isArguments\", function () {return n.isArguments;}), r.d(t, \"isFunction\", function () {return n.isFunction;}), r.d(t, \"isString\", function () {return n.isString;}), r.d(t, \"isNumber\", function () {return n.isNumber;}), r.d(t, \"isDate\", function () {return n.isDate;}), r.d(t, \"isRegExp\", function () {return n.isRegExp;}), r.d(t, \"isError\", function () {return n.isError;}), r.d(t, \"isSymbol\", function () {return n.isSymbol;}), r.d(t, \"isMap\", function () {return n.isMap;}), r.d(t, \"isWeakMap\", function () {return n.isWeakMap;}), r.d(t, \"isSet\", function () {return n.isSet;}), r.d(t, \"isWeakSet\", function () {return n.isWeakSet;}), r.d(t, \"isFinite\", function () {return n.isFinite;}), r.d(t, \"isNaN\", function () {return n.isNaN;}), r.d(t, \"isBoolean\", function () {return n.isBoolean;}), r.d(t, \"isNull\", function () {return n.isNull;}), r.d(t, \"isUndefined\", function () {return n.isUndefined;}), r.d(t, \"has\", function () {return n.has;}), r.d(t, \"identity\", function () {return n.identity;}), r.d(t, \"constant\", function () {return n.constant;}), r.d(t, \"noop\", function () {return n.noop;}), r.d(t, \"property\", function () {return n.property;}), r.d(t, \"propertyOf\", function () {return n.propertyOf;}), r.d(t, \"matcher\", function () {return n.matcher;}), r.d(t, \"matches\", function () {return n.matches;}), r.d(t, \"times\", function () {return n.times;}), r.d(t, \"random\", function () {return n.random;}), r.d(t, \"now\", function () {return n.now;}), r.d(t, \"escape\", function () {return n.escape;}), r.d(t, \"unescape\", function () {return n.unescape;}), r.d(t, \"result\", function () {return n.result;}), r.d(t, \"uniqueId\", function () {return n.uniqueId;}), r.d(t, \"templateSettings\", function () {return n.templateSettings;}), r.d(t, \"template\", function () {return n.template;}), r.d(t, \"chain\", function () {return n.chain;}), r.d(t, \"mixin\", function () {return n.mixin;});var n = r(29),o = Object(n.mixin)(n);o._ = o;var i = o;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.BaseGeometry = void 0;var n = r(44),o = r(0),i = function i() {n.Base.call(this);};(i.prototype = Object.create(n.Base.prototype)).getGeometryType = function () {console.warn(\"BaseGeometry.getGeometryType : abstract method invoked!\");}, i.prototype.clone = function () {console.warn(\"BaseGeometry.clone : abstract method invoked\");}, i.prototype.copy = function (e) {this._guid = \"\";}, i.prototype.addToModelObject = function (e) {if (!e.geometries[this.getGuid()]) {var _t4 = {};_t4[o.GEOMETRY_TYPES.toString(this.getGeometryType()).toLowerCase()] = this.toObject(), e.geometries[this.getGuid()] = _t4;}}, t.BaseGeometry = i;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Base = void 0;var n = r(56);var o = r(45).Autodesk.lookup(\"SolidDef.paramrange_1_0_0.typeEnum\");var i = function i() {this._guid = \"\";};i.prototype.setGuid = function (e) {this._guid = e;}, i.prototype.getGuid = function () {return this._guid || (this._guid = (0, n.generateGUID)()), this._guid;}, i.prototype.refsToStrings = function (e) {if (e) {var _t5 = new Array(e.length);for (var _r3 = 0; _r3 < e.length; ++_r3) {_t5[_r3] = e[_r3].getGuid();}return _t5;}return [];}, i.prototype.refToString = function (e) {return e ? e.getGuid() : \"\";}, i.prototype.toObject = function () {return console.warn(\"Base.toObject : abstract method invoked!\"), {};}, i.prototype.vectorToObject = function (e) {return { x: e[0], y: e[1], z: e[2] };}, i.prototype.rangeToObject = function (e, t) {var r = 1,n = 0;t && void 0 !== e && 2 === e.length && isFinite(e[0]) && isFinite(e[1]) && (r = e[0], n = e[1]);var i = r <= n ? \"finite\" : \"infinite\";return { low: r, high: n, type: o.values[i] };}, i.prototype.addToModelObject = function (e) {console.warn(\"Base.addToModelObject : abstract method invoked!\");}, t.Base = i;}, function (e, t, r) {\"use strict\";var n = r(87),o = (n.roots.default || (n.roots.default = new n.Root())).addJSON({ Autodesk: { nested: { SolidDef: { nested: { SolidDef_grpc: { methods: {} }, point3d_1_0_0: { fields: { x: { type: \"double\", id: 1 }, y: { type: \"double\", id: 2 }, z: { type: \"double\", id: 3 } } }, vector3d_1_0_0: { fields: { x: { type: \"double\", id: 1 }, y: { type: \"double\", id: 2 }, z: { type: \"double\", id: 3 } } }, geometry_1_0_0: { fields: {} }, geometry_1_0_0_Type: { oneofs: { geometry: { oneof: [\"point\", \"bsurface\", \"cone\", \"cylinder\", \"ellipticalcone\", \"ellipticalcylinder\", \"plane\", \"sphere\", \"surface\", \"torus\", \"bcurve\", \"circle\", \"curve\", \"ellipse\", \"line\"] } }, fields: { point: { type: \"point_1_0_0\", id: 1 }, bsurface: { type: \"bsurface_1_0_0\", id: 2 }, cone: { type: \"cone_1_0_0\", id: 3 }, cylinder: { type: \"cylinder_1_0_0\", id: 4 }, ellipticalcone: { type: \"ellipticalcone_1_0_0\", id: 5 }, ellipticalcylinder: { type: \"ellipticalcylinder_1_0_0\", id: 6 }, plane: { type: \"plane_1_0_0\", id: 7 }, sphere: { type: \"sphere_1_0_0\", id: 8 }, surface: { type: \"surface_1_0_0\", id: 9 }, torus: { type: \"torus_1_0_0\", id: 10 }, bcurve: { type: \"bcurve_1_0_0\", id: 11 }, circle: { type: \"circle_1_0_0\", id: 12 }, curve: { type: \"curve_1_0_0\", id: 13 }, ellipse: { type: \"ellipse_1_0_0\", id: 14 }, line: { type: \"line_1_0_0\", id: 15 } } }, paramrange_1_0_0: { fields: { low: { type: \"double\", id: 1 }, high: { type: \"double\", id: 2 }, type: { type: \"typeEnum\", id: 3 } }, nested: { typeEnum: { values: { infinite: 0, finite: 1, boundBelow: 2, boundAbove: 3 } } } }, point_1_0_0: { fields: { position: { type: \"point3d_1_0_0\", id: 1 } } }, bsurface_1_0_0: { fields: { uDegree: { type: \"uint32\", id: 1 }, vDegree: { type: \"uint32\", id: 2 }, uKnots: { rule: \"repeated\", type: \"double\", id: 3 }, vKnots: { rule: \"repeated\", type: \"double\", id: 4 }, controlPoints: { rule: \"repeated\", type: \"double\", id: 5 }, weights: { rule: \"repeated\", type: \"double\", id: 6 }, uRange: { type: \"paramrange_1_0_0\", id: 7 }, vRange: { type: \"paramrange_1_0_0\", id: 8 } } }, cone_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, axis: { type: \"vector3d_1_0_0\", id: 2 }, radius: { type: \"vector3d_1_0_0\", id: 3 }, angle: { type: \"double\", id: 4 }, uCoordScale: { type: \"double\", id: 5 }, uRange: { type: \"paramrange_1_0_0\", id: 6 }, vRange: { type: \"paramrange_1_0_0\", id: 7 } } }, cylinder_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, axis: { type: \"vector3d_1_0_0\", id: 2 }, radius: { type: \"vector3d_1_0_0\", id: 3 }, uCoordScale: { type: \"double\", id: 4 }, uRange: { type: \"paramrange_1_0_0\", id: 5 }, vRange: { type: \"paramrange_1_0_0\", id: 6 } } }, ellipticalcone_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, axis: { type: \"vector3d_1_0_0\", id: 2 }, majorRadius: { type: \"vector3d_1_0_0\", id: 3 }, radiusRatio: { type: \"double\", id: 4 }, angle: { type: \"double\", id: 5 }, uCoordScale: { type: \"double\", id: 6 }, uRange: { type: \"paramrange_1_0_0\", id: 7 }, vRange: { type: \"paramrange_1_0_0\", id: 8 } } }, ellipticalcylinder_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, axis: { type: \"vector3d_1_0_0\", id: 2 }, majorRadius: { type: \"vector3d_1_0_0\", id: 3 }, radiusRatio: { type: \"double\", id: 4 }, uCoordScale: { type: \"double\", id: 5 }, uRange: { type: \"paramrange_1_0_0\", id: 6 }, vRange: { type: \"paramrange_1_0_0\", id: 7 } } }, plane_1_0_0: { fields: { origin: { type: \"point3d_1_0_0\", id: 1 }, normal: { type: \"vector3d_1_0_0\", id: 2 }, uAxis: { type: \"vector3d_1_0_0\", id: 3 }, uRange: { type: \"paramrange_1_0_0\", id: 4 }, vRange: { type: \"paramrange_1_0_0\", id: 5 } } }, sphere_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, radius: { type: \"vector3d_1_0_0\", id: 2 }, axis: { type: \"vector3d_1_0_0\", id: 3 }, uRange: { type: \"paramrange_1_0_0\", id: 4 }, vRange: { type: \"paramrange_1_0_0\", id: 5 } } }, surface_1_0_0: { fields: { uRange: { type: \"paramrange_1_0_0\", id: 1 }, vRange: { type: \"paramrange_1_0_0\", id: 2 } } }, surface_1_0_0_Type: { oneofs: { surface: { oneof: [\"bsurface\", \"cone\", \"cylinder\", \"ellipticalcone\", \"ellipticalcylinder\", \"plane\", \"sphere\", \"torus\"] } }, fields: { bsurface: { type: \"bsurface_1_0_0\", id: 1 }, cone: { type: \"cone_1_0_0\", id: 2 }, cylinder: { type: \"cylinder_1_0_0\", id: 3 }, ellipticalcone: { type: \"ellipticalcone_1_0_0\", id: 4 }, ellipticalcylinder: { type: \"ellipticalcylinder_1_0_0\", id: 5 }, plane: { type: \"plane_1_0_0\", id: 6 }, sphere: { type: \"sphere_1_0_0\", id: 7 }, torus: { type: \"torus_1_0_0\", id: 8 } } }, torus_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, axis: { type: \"vector3d_1_0_0\", id: 2 }, majorRadius: { type: \"double\", id: 3 }, minorRadius: { type: \"double\", id: 4 }, coordAxis: { type: \"vector3d_1_0_0\", id: 5 }, lemon: { type: \"bool\", id: 6 }, uRange: { type: \"paramrange_1_0_0\", id: 7 }, vRange: { type: \"paramrange_1_0_0\", id: 8 } } }, bcurve_1_0_0: { fields: { degree: { type: \"uint32\", id: 1 }, knots: { rule: \"repeated\", type: \"double\", id: 2 }, controlPoints: { rule: \"repeated\", type: \"double\", id: 3 }, weights: { rule: \"repeated\", type: \"double\", id: 4 }, range: { type: \"paramrange_1_0_0\", id: 5 } } }, circle_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, normal: { type: \"vector3d_1_0_0\", id: 2 }, radius: { type: \"vector3d_1_0_0\", id: 3 }, range: { type: \"paramrange_1_0_0\", id: 4 } } }, curve_1_0_0: { fields: { range: { type: \"paramrange_1_0_0\", id: 1 } } }, curve_1_0_0_Type: { oneofs: { curve: { oneof: [\"bcurve\", \"circle\", \"ellipse\", \"line\"] } }, fields: { bcurve: { type: \"bcurve_1_0_0\", id: 1 }, circle: { type: \"circle_1_0_0\", id: 2 }, ellipse: { type: \"ellipse_1_0_0\", id: 3 }, line: { type: \"line_1_0_0\", id: 4 } } }, ellipse_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, normal: { type: \"vector3d_1_0_0\", id: 2 }, majorRadius: { type: \"vector3d_1_0_0\", id: 3 }, radiusRatio: { type: \"double\", id: 4 }, range: { type: \"paramrange_1_0_0\", id: 5 } } }, line_1_0_0: { fields: { position: { type: \"point3d_1_0_0\", id: 1 }, direction: { type: \"vector3d_1_0_0\", id: 2 }, range: { type: \"paramrange_1_0_0\", id: 3 } } }, attribute_1_0_0: { fields: {} }, attribute_1_0_0_Type: { oneofs: { attribute: { oneof: [\"nmiattribute\", \"nmiattributearr\", \"nmiattributestr\", \"textattribute\"] } }, fields: { nmiattribute: { type: \"nmiattribute_1_0_0\", id: 1 }, nmiattributearr: { type: \"nmiattributearr_1_0_0\", id: 4 }, nmiattributestr: { type: \"nmiattributestr_1_0_0\", id: 2 }, textattribute: { type: \"textattribute_1_0_0\", id: 3 } } }, body_1_0_0: { fields: { lumps: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, coedge_1_0_0: { fields: { edge: { type: \"string\", id: 1 }, partner: { type: \"string\", id: 2 }, reversed: { type: \"bool\", id: 3 }, attributes: { rule: \"repeated\", type: \"string\", id: 4 } } }, edge_1_0_0: { fields: { vertex0: { type: \"string\", id: 1 }, vertex1: { type: \"string\", id: 2 }, precision: { type: \"double\", id: 3 }, range: { type: \"paramrange_1_0_0\", id: 4 }, reversed: { type: \"bool\", id: 5 }, geometry: { type: \"string\", id: 6 }, attributes: { rule: \"repeated\", type: \"string\", id: 7 } } }, face_1_0_0: { fields: { loops: { rule: \"repeated\", type: \"string\", id: 1 }, reversed: { type: \"bool\", id: 2 }, geometry: { type: \"string\", id: 3 }, attributes: { rule: \"repeated\", type: \"string\", id: 4 } } }, loop_1_0_0: { fields: { coedges: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, lump_1_0_0: { fields: { shells: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, model_1_0_0: { fields: { geometries: { keyType: \"string\", type: \"geometry_1_0_0_Type\", id: 1 }, topologies: { keyType: \"string\", type: \"topology_1_0_0_Type\", id: 2 }, attributes: { keyType: \"string\", type: \"attribute_1_0_0_Type\", id: 3 } } }, shell_1_0_0: { fields: { faces: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, topology_1_0_0: { fields: { attributes: { rule: \"repeated\", type: \"string\", id: 1 } } }, topology_1_0_0_Type: { oneofs: { topology: { oneof: [\"body\", \"coedge\", \"edge\", \"face\", \"loop\", \"lump\", \"shell\", \"vertex\", \"wire\", \"wirebody\"] } }, fields: { body: { type: \"body_1_0_0\", id: 1 }, coedge: { type: \"coedge_1_0_0\", id: 2 }, edge: { type: \"edge_1_0_0\", id: 3 }, face: { type: \"face_1_0_0\", id: 4 }, loop: { type: \"loop_1_0_0\", id: 5 }, lump: { type: \"lump_1_0_0\", id: 6 }, shell: { type: \"shell_1_0_0\", id: 7 }, vertex: { type: \"vertex_1_0_0\", id: 8 }, wire: { type: \"wire_1_0_0\", id: 9 }, wirebody: { type: \"wirebody_1_0_0\", id: 10 } } }, vertex_1_0_0: { fields: { precision: { type: \"double\", id: 1 }, geometry: { type: \"string\", id: 2 }, attributes: { rule: \"repeated\", type: \"string\", id: 3 } } }, wire_1_0_0: { fields: { edges: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, wirebody_1_0_0: { fields: { wires: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, nmiattribute_1_0_0: { fields: { primaryId: { type: \"uint64\", id: 1 }, secondaryId: { type: \"int64\", id: 2 }, approachId: { type: \"int64\", id: 3 }, operationIds: { rule: \"repeated\", type: \"int64\", id: 4 } } }, nmiattributearr_1_0_0: { fields: { tagInfo: { rule: \"repeated\", type: \"nmiattributestr_1_0_0\", id: 1 } } }, nmiattributestr_1_0_0: { fields: { primaryId: { type: \"string\", id: 1 }, secondaryId: { type: \"string\", id: 2 }, approachId: { type: \"string\", id: 3 }, operationIds: { rule: \"repeated\", type: \"string\", id: 4 } } }, textattribute_1_0_0: { fields: { text: { type: \"string\", id: 1 } } }, entity: { oneofs: { entity: { oneof: [\"point3d\", \"vector3d\", \"geometry\", \"paramrange\", \"point\", \"bsurface\", \"cone\", \"cylinder\", \"ellipticalcone\", \"ellipticalcylinder\", \"plane\", \"sphere\", \"surface\", \"torus\", \"bcurve\", \"circle\", \"curve\", \"ellipse\", \"line\", \"attribute\", \"body\", \"coedge\", \"edge\", \"face\", \"loop\", \"lump\", \"model\", \"shell\", \"topology\", \"vertex\", \"wire\", \"wirebody\", \"nmiattribute\", \"nmiattributearr\", \"nmiattributestr\", \"textattribute\"] } }, fields: { id: { type: \"string\", id: 1 }, point3d: { type: \"point3d_1_0_0\", id: 2 }, vector3d: { type: \"vector3d_1_0_0\", id: 3 }, geometry: { type: \"geometry_1_0_0\", id: 4 }, paramrange: { type: \"paramrange_1_0_0\", id: 5 }, point: { type: \"point_1_0_0\", id: 6 }, bsurface: { type: \"bsurface_1_0_0\", id: 7 }, cone: { type: \"cone_1_0_0\", id: 8 }, cylinder: { type: \"cylinder_1_0_0\", id: 9 }, ellipticalcone: { type: \"ellipticalcone_1_0_0\", id: 10 }, ellipticalcylinder: { type: \"ellipticalcylinder_1_0_0\", id: 11 }, plane: { type: \"plane_1_0_0\", id: 12 }, sphere: { type: \"sphere_1_0_0\", id: 13 }, surface: { type: \"surface_1_0_0\", id: 14 }, torus: { type: \"torus_1_0_0\", id: 15 }, bcurve: { type: \"bcurve_1_0_0\", id: 16 }, circle: { type: \"circle_1_0_0\", id: 17 }, curve: { type: \"curve_1_0_0\", id: 18 }, ellipse: { type: \"ellipse_1_0_0\", id: 19 }, line: { type: \"line_1_0_0\", id: 20 }, attribute: { type: \"attribute_1_0_0\", id: 21 }, body: { type: \"body_1_0_0\", id: 22 }, coedge: { type: \"coedge_1_0_0\", id: 23 }, edge: { type: \"edge_1_0_0\", id: 24 }, face: { type: \"face_1_0_0\", id: 25 }, loop: { type: \"loop_1_0_0\", id: 26 }, lump: { type: \"lump_1_0_0\", id: 27 }, model: { type: \"model_1_0_0\", id: 28 }, shell: { type: \"shell_1_0_0\", id: 29 }, topology: { type: \"topology_1_0_0\", id: 30 }, vertex: { type: \"vertex_1_0_0\", id: 31 }, wire: { type: \"wire_1_0_0\", id: 32 }, wirebody: { type: \"wirebody_1_0_0\", id: 33 }, nmiattribute: { type: \"nmiattribute_1_0_0\", id: 34 }, nmiattributearr: { type: \"nmiattributearr_1_0_0\", id: 37 }, nmiattributestr: { type: \"nmiattributestr_1_0_0\", id: 35 }, textattribute: { type: \"textattribute_1_0_0\", id: 36 } } } } } } } });e.exports = o;}, function (e, t, r) {\"use strict\";e.exports = l;var n,o = r(10),i = o.LongBits,s = o.base64,a = o.utf8;function c(e, t, r) {this.fn = e, this.len = t, this.next = void 0, this.val = r;}function u() {}function l() {this.len = 0, this.head = new c(u, 0, 0), this.tail = this.head, this.states = null;}function h(e, t, r) {t[r] = 255 & e;}function d(e, t) {this.len = e, this.next = void 0, this.val = t;}function g(e, t, r) {for (; e.hi;) {t[r++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;}for (; e.lo > 127;) {t[r++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;}t[r++] = e.lo;}function p(e, t, r) {t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;}l.create = o.Buffer ? function () {return (l.create = function () {return new n();})();} : function () {return new l();}, l.alloc = function (e) {return new o.Array(e);}, o.Array !== Array && (l.alloc = o.pool(l.alloc, o.Array.prototype.subarray)), l.prototype._push = function (e, t, r) {return this.tail = this.tail.next = new c(e, t, r), this.len += t, this;}, d.prototype = Object.create(c.prototype), d.prototype.fn = function (e, t, r) {for (; e > 127;) {t[r++] = 127 & e | 128, e >>>= 7;}t[r] = e;}, l.prototype.uint32 = function (e) {return this.len += (this.tail = this.tail.next = new d((e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;}, l.prototype.int32 = function (e) {return e < 0 ? this._push(g, 10, i.fromNumber(e)) : this.uint32(e);}, l.prototype.sint32 = function (e) {return this.uint32((e << 1 ^ e >> 31) >>> 0);}, l.prototype.uint64 = function (e) {var t = i.from(e);return this._push(g, t.length(), t);}, l.prototype.int64 = l.prototype.uint64, l.prototype.sint64 = function (e) {var t = i.from(e).zzEncode();return this._push(g, t.length(), t);}, l.prototype.bool = function (e) {return this._push(h, 1, e ? 1 : 0);}, l.prototype.fixed32 = function (e) {return this._push(p, 4, e >>> 0);}, l.prototype.sfixed32 = l.prototype.fixed32, l.prototype.fixed64 = function (e) {var t = i.from(e);return this._push(p, 4, t.lo)._push(p, 4, t.hi);}, l.prototype.sfixed64 = l.prototype.fixed64, l.prototype.float = function (e) {return this._push(o.float.writeFloatLE, 4, e);}, l.prototype.double = function (e) {return this._push(o.float.writeDoubleLE, 8, e);};var f = o.Array.prototype.set ? function (e, t, r) {t.set(e, r);} : function (e, t, r) {for (var n = 0; n < e.length; ++n) {t[r + n] = e[n];}};l.prototype.bytes = function (e) {var t = e.length >>> 0;if (!t) return this._push(h, 1, 0);if (o.isString(e)) {var r = l.alloc(t = s.length(e));s.decode(e, r, 0), e = r;}return this.uint32(t)._push(f, t, e);}, l.prototype.string = function (e) {var t = a.length(e);return t ? this.uint32(t)._push(a.write, t, e) : this._push(h, 1, 0);}, l.prototype.fork = function () {return this.states = new function (e) {this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;}(this), this.head = this.tail = new c(u, 0, 0), this.len = 0, this;}, l.prototype.reset = function () {return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new c(u, 0, 0), this.len = 0), this;}, l.prototype.ldelim = function () {var e = this.head,t = this.tail,r = this.len;return this.reset().uint32(r), r && (this.tail.next = e.next, this.tail = t, this.len += r), this;}, l.prototype.finish = function () {for (var e = this.head.next, t = this.constructor.alloc(this.len), r = 0; e;) {e.fn(e.val, t, r), r += e.len, e = e.next;}return t;}, l._configure = function (e) {n = e;};}, function (e, t, r) {\"use strict\";e.exports = c;var n,o = r(10),i = o.LongBits,s = o.utf8;function a(e, t) {return RangeError(\"index out of range: \" + e.pos + \" + \" + (t || 1) + \" > \" + e.len);}function c(e) {this.buf = e, this.pos = 0, this.len = e.length;}var u = \"undefined\" != typeof Uint8Array ? function (e) {if (e instanceof Uint8Array || Array.isArray(e)) return new c(e);throw Error(\"illegal buffer\");} : function (e) {if (Array.isArray(e)) return new c(e);throw Error(\"illegal buffer\");};function l() {var e = new i(0, 0),t = 0;if (!(this.len - this.pos > 4)) {for (; t < 3; ++t) {if (this.pos >= this.len) throw a(this);if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;}return e.lo = (e.lo | (127 & this.buf[this.pos++]) << 7 * t) >>> 0, e;}for (; t < 4; ++t) {if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;}if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e.hi = (e.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e;if (t = 0, this.len - this.pos > 4) {for (; t < 5; ++t) {if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;}} else for (; t < 5; ++t) {if (this.pos >= this.len) throw a(this);if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;}throw Error(\"invalid varint encoding\");}function h(e, t) {return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;}function d() {if (this.pos + 8 > this.len) throw a(this, 8);return new i(h(this.buf, this.pos += 4), h(this.buf, this.pos += 4));}c.create = o.Buffer ? function (e) {return (c.create = function (e) {return o.Buffer.isBuffer(e) ? new n(e) : u(e);})(e);} : u, c.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, c.prototype.uint32 = function () {var e = 4294967295;return function () {if (e = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return e;if ((this.pos += 5) > this.len) throw this.pos = this.len, a(this, 10);return e;};}(), c.prototype.int32 = function () {return 0 | this.uint32();}, c.prototype.sint32 = function () {var e = this.uint32();return e >>> 1 ^ -(1 & e) | 0;}, c.prototype.bool = function () {return 0 !== this.uint32();}, c.prototype.fixed32 = function () {if (this.pos + 4 > this.len) throw a(this, 4);return h(this.buf, this.pos += 4);}, c.prototype.sfixed32 = function () {if (this.pos + 4 > this.len) throw a(this, 4);return 0 | h(this.buf, this.pos += 4);}, c.prototype.float = function () {if (this.pos + 4 > this.len) throw a(this, 4);var e = o.float.readFloatLE(this.buf, this.pos);return this.pos += 4, e;}, c.prototype.double = function () {if (this.pos + 8 > this.len) throw a(this, 4);var e = o.float.readDoubleLE(this.buf, this.pos);return this.pos += 8, e;}, c.prototype.bytes = function () {var e = this.uint32(),t = this.pos,r = this.pos + e;if (r > this.len) throw a(this, e);return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t, r) : t === r ? new this.buf.constructor(0) : this._slice.call(this.buf, t, r);}, c.prototype.string = function () {var e = this.bytes();return s.read(e, 0, e.length);}, c.prototype.skip = function (e) {if (\"number\" == typeof e) {if (this.pos + e > this.len) throw a(this, e);this.pos += e;} else do {if (this.pos >= this.len) throw a(this);} while (128 & this.buf[this.pos++]);return this;}, c.prototype.skipType = function (e) {switch (e) {case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for (; 4 != (e = 7 & this.uint32());) {this.skipType(e);}break;case 5:this.skip(4);break;default:throw Error(\"invalid wire type \" + e + \" at offset \" + this.pos);}return this;}, c._configure = function (e) {n = e;var t = o.Long ? \"toLong\" : \"toNumber\";o.merge(c.prototype, { int64: function int64() {return l.call(this)[t](!1);}, uint64: function uint64() {return l.call(this)[t](!0);}, sint64: function sint64() {return l.call(this).zzDecode()[t](!1);}, fixed64: function fixed64() {return d.call(this)[t](!0);}, sfixed64: function sfixed64() {return d.call(this)[t](!1);} });};}, function (e, t, r) {\"use strict\";e.exports = s;var n = r(21);((s.prototype = Object.create(n.prototype)).constructor = s).className = \"OneOf\";var o = r(22),i = r(5);function s(e, t, r, o) {if (Array.isArray(t) || (r = t, t = void 0), n.call(this, e, r), void 0 !== t && !Array.isArray(t)) throw TypeError(\"fieldNames must be an Array\");this.oneof = t || [], this.fieldsArray = [], this.comment = o;}function a(e) {if (e.parent) for (var t = 0; t < e.fieldsArray.length; ++t) {e.fieldsArray[t].parent || e.parent.add(e.fieldsArray[t]);}}s.fromJSON = function (e, t) {return new s(e, t.oneof, t.options, t.comment);}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject([\"options\", this.options, \"oneof\", this.oneof, \"comment\", t ? this.comment : void 0]);}, s.prototype.add = function (e) {if (!(e instanceof o)) throw TypeError(\"field must be a Field\");return e.parent && e.parent !== this.parent && e.parent.remove(e), this.oneof.push(e.name), this.fieldsArray.push(e), e.partOf = this, a(this), this;}, s.prototype.remove = function (e) {if (!(e instanceof o)) throw TypeError(\"field must be a Field\");var t = this.fieldsArray.indexOf(e);if (t < 0) throw Error(e + \" is not a member of \" + this);return this.fieldsArray.splice(t, 1), (t = this.oneof.indexOf(e.name)) > -1 && this.oneof.splice(t, 1), e.partOf = null, this;}, s.prototype.onAdd = function (e) {n.prototype.onAdd.call(this, e);for (var t = 0; t < this.oneof.length; ++t) {var r = e.get(this.oneof[t]);r && !r.partOf && (r.partOf = this, this.fieldsArray.push(r));}a(this);}, s.prototype.onRemove = function (e) {for (var t, r = 0; r < this.fieldsArray.length; ++r) {(t = this.fieldsArray[r]).parent && t.parent.remove(t);}n.prototype.onRemove.call(this, e);}, s.d = function () {for (var e = new Array(arguments.length), t = 0; t < arguments.length;) {e[t] = arguments[t++];}return function (t, r) {i.decorateType(t.constructor).add(new s(r, e)), Object.defineProperty(t, r, { get: i.oneOfGetter(e), set: i.oneOfSetter(e) });};};}, function (e, t, r) {\"use strict\";e.exports = o;var n = r(10);function o(e) {if (e) for (var t = Object.keys(e), r = 0; r < t.length; ++r) {this[t[r]] = e[t[r]];}}o.create = function (e) {return this.$type.create(e);}, o.encode = function (e, t) {return this.$type.encode(e, t);}, o.encodeDelimited = function (e, t) {return this.$type.encodeDelimited(e, t);}, o.decode = function (e) {return this.$type.decode(e);}, o.decodeDelimited = function (e) {return this.$type.decodeDelimited(e);}, o.verify = function (e) {return this.$type.verify(e);}, o.fromObject = function (e) {return this.$type.fromObject(e);}, o.toObject = function (e, t) {return this.$type.toObject(e, t);}, o.prototype.toJSON = function () {return this.$type.toObject(this, n.toJSONOptions);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.TessellationCache = t.CurveTessellator = void 0;var n = r(1),o = r(0),i = r(3),s = r(8),a = { getCircularArcRenderPoints: function getCircularArcRenderPoints(e, t, r, n, o) {var i = e.getRadius(),s = 2 * Math.acos((i - r) / i),a = t[1] - t[0],c = Math.ceil(a / s),u = 0;for (!1 === n && u++; u <= c; ++u) {var l = u / c,h = t[0] * (1 - l) + t[1] * l;o.push(e.evaluatePosition(h));}return i * (1 - Math.cos(a / c * .5));}, getAdaptiveRenderPoints: function getAdaptiveRenderPoints(e, t, r, i) {for (var a = t || .001, c = a * a, u = [], l = [], h = n.Vector3.createFloat64(), d = 0, g = function g(t, r, i, a, p) {var f = i - t,v = .5 * (t + i),_ = e.evaluatePosition(v);n.Vector3.scaleAndAdd(h, [0, 0, 0], r, .5), n.Vector3.scaleAndAdd(h, h, a, .5);var y = n.Vector3.squaredDistance(h, _);if (p > 64) s.DebugUtils.warn(\"Max recursion depth reach in getAdaptiveRenderPoints\");else if (f > 10 * o.PARAMETER_SPACE_TOLERANCE && y > c) return g(t, r, v, _, p + 1), void g(v, _, i, a, p + 1);d = Math.max(d, y), u.push(r), l.push(t);}, p = i || function (e, t, r) {for (var n = new Array(7), o = t, i = (r - t) / 6, s = 0; s < 7; s++) {var a = o;s > 0 && s < 6 && (a += Math.sin(s) * i * .1), n[s] = a, o += i;}return n;}(0, r[0], r[1]), f = 0; f < p.length - 1; ++f) {var v = p[f],_ = p[f + 1],y = e.evaluatePosition(v),m = e.evaluatePosition(_);g(v, y, _, m, 0), f === p.length - 2 && (u.push(m), l.push(_));}return { positions: u, params: l, tolerance: Math.sqrt(d) };} },c = function c() {this._hasDirtyTessellation = !0, this._tessellationCache = void 0, this._trimmedTessellationCache = { positions: void 0, offsets: void 0, transitions: [1, -1] };};c.prototype.setDirty = function (e) {this._hasDirtyTessellation = e;}, c.prototype.isDirty = function () {return this._hasDirtyTessellation;}, c.prototype.reset = function () {this._hasDirtyTessellation = !0, this._tessellationCache = void 0, this._trimmedTessellationCache = { positions: void 0, offsets: void 0, transitions: [1, -1] };}, c.prototype.setCache = function (e) {this._tessellationCache = e, this._hasDirtyTessellation = !1;}, c.prototype.getCache = function () {return this._tessellationCache;}, c.prototype.getTolerance = function () {if (this._tessellationCache) return this._tessellationCache.tolerance;}, c.prototype.getTessellation = function (e, t, r, s) {var a = !1;if (!1 === this._hasDirtyTessellation && this._tessellationCache.tolerance > r + n.FLOAT64_TOLERANCE && (this._hasDirtyTessellation = !0), this._hasDirtyTessellation) {this._hasDirtyTessellation = !1;var c = s(r);this._tessellationCache = { positions: c.positions, params: c.params, tolerance: c.tolerance }, a = c.didRetessellate;}var u = [e[0], e[e.length - 1]],l = 0,h = t.getRangeUnlimited();t.isPeriodicUnlimited() && (l = (u = (0, i.normalizeParametricRangeToShiftedRange)(u, h))[0] - e[0]);var d = this._trimmedTessellationCache,g = d.transitions[0] - u[0],p = d.transitions[d.transitions.length - 1] - u[1],f = g * g + p * p < n.FLOAT64_TOLERANCE;if (f && e.length > 2) {f = d.transitions.length === e.length;for (var v = 1; f && v < e.length - 1; ++v) {f = d.transitions[v - 1] === e[v - 1] + l;}}if (!f || a) {var _;for (d.transitions.length = e.length, _ = 0; _ < e.length; ++_) {d.transitions[_] = e[_] + l;}d.positions = [t.evaluatePosition(e[0])], d.offsets = [0];var y,m,E = 1,x = u[0];for (_ = 1; _ < e.length; _++) {var R = e[_] + l;for (m = 0; m < this._tessellationCache.positions.length; m++) {if ((y = this._tessellationCache.params[m]) > x + o.PARAMETER_SPACE_TOLERANCE) {if (y >= R - o.PARAMETER_SPACE_TOLERANCE) break;n.Vector3.sqrDist(d.positions[E - 1], this._tessellationCache.positions[m]) > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (d.positions[E++] = n.Vector3.clone(this._tessellationCache.positions[m]));}}if (t.isPeriodicUnlimited() && R > h[1]) for (m = 1; m < this._tessellationCache.positions.length && (y = this._tessellationCache.params[m]) < R - (h[1] - h[0]) - o.PARAMETER_SPACE_TOLERANCE; m++) {n.Vector3.sqrDist(d.positions[E - 1], this._tessellationCache.positions[m]) > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (d.positions[E++] = n.Vector3.clone(this._tessellationCache.positions[m]));}var A = t.evaluatePosition(R);n.Vector3.sqrDist(d.positions[E - 1], A) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && E > d.offsets[d.offsets.length - 1] + 1 && E--, d.positions[E++] = A, d.offsets.push(d.positions.length - 1), x = R;}}return { positions: d.positions, offsets: d.offsets, tolerance: this._tessellationCache.tolerance };}, t.CurveTessellator = a, t.TessellationCache = c;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Cone = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(6),c = r(7),u = r(14),l = r(2),h = function h() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._angle = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(h.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.CONE;}, h.prototype.clone = function () {var e = new h();return e.copy(this), e;}, h.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, this._angle = e._angle, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, h.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, h.prototype.set = function (e, t, r, o, s, a) {n.Vector3.copy(this._center, e), l.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t, l.ConsoleUtils.assert(n.Vector3.squaredLength(r) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, r), l.ConsoleUtils.assert(Math.abs(o) < Math.PI / 2), this._angle = o, void 0 !== s && n.Vector3.squaredLength(s) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (l.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, s, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, s)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._uScale = a || 1, l.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, h.prototype.getRadius = function () {return this._radius;}, h.prototype.setRadius = function (e) {l.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, h.prototype.getCenter = function () {return this._center;}, h.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, h.prototype.getAxisDir = function () {return this._zAxis;}, h.prototype.setAxisDir = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, h.prototype.getUvOriginDir = function () {return this._xAxis;}, h.prototype.setUvOriginDir = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, h.prototype.getUScale = function () {return this._uScale;}, h.prototype.setUScale = function (e) {l.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, h.prototype.getAngle = function () {return this._angle;}, h.prototype.setAngle = function (e) {l.ConsoleUtils.assert(Math.abs(e) < Math.PI / 2 - i.KERNEL_ANGULAR_TOLERANCE), this._angle = e;}, h.prototype.isCylinder = function () {return Math.abs(this._angle) < i.KERNEL_ANGULAR_TOLERANCE;}, h.prototype.getApexParam = function () {return this.isCylinder() ? void 0 : -this._radius / (this._uScale * Math.sin(this._angle));}, h.prototype.getApexPosition = function () {if (!this.isCylinder()) {var e = -this._radius / Math.tan(this._angle),t = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(t, t, this._zAxis, e), t;}}, h.prototype.evaluatePosition = function (e, t) {var r = this._radius + e * this._uScale * Math.sin(this._angle),o = r * Math.cos(t),i = r * Math.sin(t),s = e * this._uScale * Math.cos(this._angle),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, h.prototype.evaluateNormal = function (e, t) {var r = Math.sin(this._angle),o = Math.cos(this._angle),i = o * Math.cos(t),s = o * Math.sin(t),a = -r,c = n.Vector3.createFloat64();return n.Vector3.scale(c, this._xAxis, i), n.Vector3.scaleAndAdd(c, c, this._yAxis, s), n.Vector3.scaleAndAdd(c, c, this._zAxis, a), c;}, h.prototype.evaluateDu = function (e, t) {var r = this._uScale * Math.sin(this._angle),o = r * Math.cos(t),i = r * Math.sin(t),s = this._uScale * Math.cos(this._angle),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, h.prototype.evaluateDv = function (e, t) {var r = this._radius + e * this._uScale * Math.sin(this._angle),o = -r * Math.sin(t),i = r * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, h.prototype.closestParam = function (e) {var t = Math.sin(this._angle),r = Math.cos(this._angle),o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center);var s = n.Vector3.dot(o, this._xAxis),a = n.Vector3.dot(o, this._yAxis),c = n.Vector3.dot(o, this._zAxis),u = Math.sqrt(s * s + a * a),l = this.getApexParam();if (void 0 !== l) {var h = l * this._uScale * r;(h > 0 && c > h || h < 0 && c < h) && (s = -s, a = -a, u = -u);}return { u: ((u - this._radius) * t + c * r) / this._uScale, v: Math.abs(u) > i.KERNEL_TOLERANCE ? Math.atan2(a, s) : 0 };}, h.prototype.vParamLine = function (e) {var t = this._radius + e * this._uScale * Math.sin(this._angle);if (Math.abs(t) > i.KERNEL_TOLERANCE) {var r = new u.Circle(),o = n.Vector3.clone(this._center),s = e * this._uScale * Math.cos(this._angle);n.Vector3.scaleAndAdd(o, o, this._zAxis, s);var c = n.Vector3.clone(this._xAxis);n.Vector3.scale(c, c, t);var l = n.Vector3.clone(this._zAxis);return n.Vector3.negate(l, l), r.set(o, l, c), r;}return new a.Point(this.getApexPosition());}, h.prototype.uParamLine = function (e) {var t = new c.Line(),r = n.Vector3.clone(this._center),o = this._radius * Math.cos(e),i = this._radius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, h.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, h.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, h.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, h.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, h.prototype.isPeriodicUnlimitedU = function () {return !1;}, h.prototype.isPeriodicUnlimitedV = function () {return !0;}, h.prototype.isClosedUnlimitedU = function () {return !1;}, h.prototype.isClosedUnlimitedV = function () {return !0;}, h.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), angle: this.getAngle(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Cone = h;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.EllipticalCone = void 0;var n = r(1),o = r(4),i = r(35),s = r(0),a = r(12),c = r(6),u = r(7),l = r(23),h = r(2),d = function d() {a.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._angle = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(d.prototype = Object.create(a.Surface.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.ELLIPTICAL_CONE;}, d.prototype.clone = function () {var e = new d();return e.copy(this), e;}, d.prototype.copy = function (e) {a.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._angle = e._angle, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, d.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, d.prototype.set = function (e, t, r, o, i, a) {n.Vector3.copy(this._center, e), this._majorRadius = n.Vector3.length(t), h.ConsoleUtils.assert(this._majorRadius > s.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, t), h.ConsoleUtils.assert(r <= 1), this._minorRadius = r * this._majorRadius, h.ConsoleUtils.assert(this._minorRadius > s.KERNEL_TOLERANCE), h.ConsoleUtils.assert(n.Vector3.squaredLength(o) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), h.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, t, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._zAxis, o), h.ConsoleUtils.assert(Math.abs(i) < Math.PI / 2), this._angle = i, this._uScale = a || 1, h.ConsoleUtils.assert(this._uScale > s.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, d.prototype.getMajorRadius = function () {return this._majorRadius;}, d.prototype.setMajorRadius = function (e) {h.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._majorRadius = e;}, d.prototype.getMinorRadius = function () {return this._minorRadius;}, d.prototype.setMinorRadius = function (e) {h.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._minorRadius = e;}, d.prototype.getMajorAxis = function () {return this._xAxis;}, d.prototype.setMajorAxis = function (e) {h.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, d.prototype.getCenter = function () {return this._center;}, d.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, d.prototype.getAxisDir = function () {return this._zAxis;}, d.prototype.setAxisDir = function (e) {h.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), this._computeYAxis();}, d.prototype.getUScale = function () {return this._uScale;}, d.prototype.setUScale = function (e) {h.ConsoleUtils.assert(e > s.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, d.prototype.getAngle = function () {return this._angle;}, d.prototype.setAngle = function (e) {h.ConsoleUtils.assert(Math.abs(e) < Math.PI / 2 - s.KERNEL_ANGULAR_TOLERANCE), this._angle = e;}, d.prototype.isCylinder = function () {return Math.abs(this._angle) < s.KERNEL_ANGULAR_TOLERANCE;}, d.prototype.getApexParam = function () {return this.isCylinder() ? void 0 : -this._majorRadius / (this._uScale * Math.sin(this._angle));}, d.prototype.getApexPosition = function () {if (!this.isCylinder()) {var e = -this._majorRadius / Math.tan(this._angle),t = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(t, t, this._zAxis, e), t;}}, d.prototype.evaluatePosition = function (e, t) {var r = 1 + e * this._uScale * Math.sin(this._angle) / this._majorRadius,o = r * this._majorRadius * Math.cos(t),i = r * this._minorRadius * Math.sin(t),s = e * this._uScale * Math.cos(this._angle),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, d.prototype.evaluateNormal = function (e, t) {var r = Math.cos(this._angle),o = r * this._minorRadius * Math.cos(t),i = r * this._majorRadius * Math.sin(t),s = -Math.sin(this._angle) * this._minorRadius,a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), n.Vector3.normalize(a, a), a;}, d.prototype.evaluateDu = function (e, t) {var r = this._uScale * Math.sin(this._angle) / this._majorRadius,o = r * this._majorRadius * Math.cos(t),i = r * this._minorRadius * Math.sin(t),s = this._uScale * Math.cos(this._angle),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, d.prototype.evaluateDv = function (e, t) {var r = 1 + e * this._uScale * Math.sin(this._angle) / this._majorRadius,o = -r * this._majorRadius * Math.sin(t),i = r * this._minorRadius * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, d.prototype.closestParam = function (e) {var t, r;if (this.isCylinder()) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center), t = n.Vector3.dot(o, this._zAxis) / this._uScale, r = this.vParamLine(t).closestToPointParam(e);} else {var a = n.Vector3.createFloat64();n.Vector3.sub(a, e, this.getApexPosition());var c = n.Vector3.dot(a, this._xAxis),u = n.Vector3.dot(a, this._yAxis),l = n.Vector3.dot(a, this._zAxis),h = this._uScale * Math.sin(this._angle),d = h * this._minorRadius / this._majorRadius,g = this._uScale * Math.cos(this._angle),p = this._majorRadius / h,f = function (e, t, r, o, a, c) {if (o * o + a * a + c * c < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) return { u: 0, v: 0 };var u = n.FLOAT64_TOLERANCE,l = c * e >= 0 ? 1 : -1,h = (o * l >= 0 ? .25 : .75) * (a * l >= 0 ? 1 : -1),d = h * Math.PI,g = [(h - .25) * Math.PI, (h + .25) * Math.PI],p = (0, i.newtonRaphson1D)(function (n) {var i = Math.sin(n),s = Math.cos(n),u = e * (t * t + r * r) * o,l = t * (e * e + r * r) * a,h = r * (e * e - t * t) * c;return { val: u * i - l * s - h * i * s, deriv: u * s + l * i - h * (s * s - i * i) };}, g, d, u, 32),f = e * Math.cos(p),v = t * Math.sin(p);return { u: (f * o + v * a + r * c) / (f * f + v * v + r * r), v: p };}(h, d, g, c, u, l);t = f.u - p, r = f.v;}return { u: t, v: r };}, d.prototype.vParamLine = function (e) {var t = this._majorRadius + e * this._uScale * Math.sin(this._angle);if (Math.abs(t) > s.KERNEL_TOLERANCE) {var r = new l.Ellipse(),o = n.Vector3.clone(this._center),i = e * this._uScale * Math.cos(this._angle);n.Vector3.scaleAndAdd(o, o, this._zAxis, i);var a = n.Vector3.clone(this._xAxis);n.Vector3.scale(a, a, t);var u = n.Vector3.clone(this._zAxis);return n.Vector3.negate(u, u), r.set(o, u, a, this._minorRadius / this._majorRadius), r;}return new c.Point(this.getApexPosition());}, d.prototype.uParamLine = function (e) {var t = new u.Line(),r = n.Vector3.clone(this._center),o = this._majorRadius * Math.cos(e),i = this._minorRadius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, d.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, d.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, d.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, d.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, d.prototype.isPeriodicUnlimitedU = function () {return !1;}, d.prototype.isPeriodicUnlimitedV = function () {return !0;}, d.prototype.isClosedUnlimitedU = function () {return !1;}, d.prototype.isClosedUnlimitedV = function () {return !0;}, d.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), angle: this.getAngle(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.EllipticalCone = d;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.BSurface = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(33),c = r(3),u = r(76),l = r(103),h = r(104),d = r(105),g = r(77),p = r(2),f = function f() {s.Surface.call(this), this._uDegree = 0, this._vDegree = 0, this._uKnots = [], this._vKnots = [], this._controlPoints = [], this._weights = [], this._isClosedU = void 0, this._isClosedV = void 0, this._isPeriodicU = void 0, this._isPeriodicV = void 0, this._patches = void 0;};(f.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.BSURFACE;}, f.prototype.clone = function () {var e = new f();return e.copy(this), e;}, f.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._uDegree = e._uDegree, this._vDegree = e._vDegree, this._uKnots = e._uKnots.slice(0), this._vKnots = e._vKnots.slice(0), this._controlPoints = e._controlPoints.slice(0), this._weights = e._weights.slice(0), this._clearCaches();}, f.prototype.set = function (e, t, r, n, o, i) {p.ConsoleUtils.assert(e >= 1), this._uDegree = e, p.ConsoleUtils.assert(t >= 1), this._vDegree = t, p.ConsoleUtils.assert(r.length >= 2 * (e + 1)), this._uKnots = Array.prototype.slice.call(r), p.ConsoleUtils.assert(n.length >= 2 * (t + 1)), this._vKnots = Array.prototype.slice.call(n);var s = r.length - e - 1,a = n.length - t - 1;p.ConsoleUtils.assert(o.length === 3 * s * a), this._controlPoints = Array.prototype.slice.call(o), i && i.length > 0 ? (p.ConsoleUtils.assert(i.length === s * a), this._weights = Array.prototype.slice.call(i)) : this._weights = [], this._clearCaches();}, f.prototype.getDegreeU = function () {return this._uDegree;}, f.prototype.getDegreeV = function () {return this._vDegree;}, f.prototype.setDegreeU = function (e) {p.ConsoleUtils.assert(e >= 1), this._uDegree = e, this._clearCaches();}, f.prototype.setDegreeV = function (e) {p.ConsoleUtils.assert(e >= 1), this._vDegree = e, this._clearCaches();}, f.prototype.getNumKnotsU = function () {return this._uKnots.length;}, f.prototype.getNumKnotsV = function () {return this._vKnots.length;}, f.prototype.getKnotsU = function () {return this._uKnots;}, f.prototype.getKnotsV = function () {return this._vKnots;}, f.prototype.setKnotsU = function (e) {this._uKnots = e, this._clearCaches();}, f.prototype.setKnotsV = function (e) {this._vKnots = e, this._clearCaches();}, f.prototype.getNumControlPointsU = function () {return this._uKnots.length - this._uDegree - 1;}, f.prototype.getNumControlPointsV = function () {return this._vKnots.length - this._vDegree - 1;}, f.prototype.getControlPoints = function () {return this._controlPoints;}, f.prototype.setControlPoints = function (e) {this._controlPoints = e, this._clearCaches();}, f.prototype.getWeights = function () {return this._weights;}, f.prototype.setWeights = function (e) {e && e.length > 0 ? this._weights = e : this._weights = [], this._clearCaches();}, f.prototype.isRational = function () {return this._weights.length > 0;}, f.prototype.evaluate = function (e, t, r, n, o) {p.ConsoleUtils.assert(r >= 0), this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV()));var i = (0, u.evaluateBSurfaceDerivs)(e, t, Math.min(r, 3), this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),s = { pos: i[0][0] };return r >= 1 && (s.du = i[1][0], s.dv = i[0][1]), r >= 2 && (s.duu = i[2][0], s.duv = i[1][1], s.dvv = i[0][2]), r >= 3 && (s.duuu = i[3][0], s.duuv = i[2][1], s.duvv = i[1][2], s.dvvv = i[0][3]), s;}, f.prototype.evaluatePosition = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfacePoint)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);}, f.prototype.evaluateNormal = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), s.Surface.prototype.evaluateNormal.call(this, e, t);}, f.prototype.evaluateDu = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfaceDerivs)(e, t, 1, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights)[1][0];}, f.prototype.evaluateDv = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfaceDerivs)(e, t, 1, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights)[0][1];}, f.prototype.insertKnotU = function (e, t) {var r = (0, l.insertBSurfaceKnotU)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._uKnots = r.uknots, this._controlPoints = r.P, this._weights = r.weights || [], this._clearCaches();}, f.prototype.insertKnotV = function (e, t) {var r = (0, l.insertBSurfaceKnotV)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._vKnots = r.vknots, this._controlPoints = r.P, this._weights = r.weights || [], this._clearCaches();}, f.prototype.relaxToPerpendicular = function (e, t, r, o, i, s, a) {var c = this;o && 0 !== o.length || (o = this.getRangeU()), i && 0 !== i.length || (i = this.getRangeV());var u = (0, g.newtonRaphson2D)(function (t) {var r = c.evaluate(t[0], t[1], 2);n.Vector3.sub(r.pos, r.pos, e);var o = n.Vector3.dot(r.du, r.pos),i = n.Vector3.dot(r.dv, r.pos),s = n.Vector3.dot(r.duu, r.pos) + n.Vector3.dot(r.du, r.du),a = n.Vector3.dot(r.duv, r.pos) + n.Vector3.dot(r.du, r.dv);return { val: [o, i], deriv1: [s, a], deriv2: [a, n.Vector3.dot(r.dvv, r.pos) + n.Vector3.dot(r.dv, r.dv)] };}, [t, r], [o, i]);return { u: u.param[0], v: u.param[1], status: u.status };}, f.prototype.closestParam = function (e) {for (var t = n.FLOAT64_TOLERANCE, r = [[this.getRangeU(), this.getRangeV()]], o = this.getBezierPatches(), i = (0, d.closestBSurfacePatches)(e, o, r), s = Number.POSITIVE_INFINITY, a = { u: void 0, v: void 0 }, u = 0; u < i.length; ++u) {if (!(i[u].minDistSqr > s)) for (var l = i[u].index, h = o[l[0]][l[1]], g = h.getRangeUnlimitedU(), p = h.getRangeUnlimitedV(), f = 0; f < r.length; ++f) {var v = [Math.max(g[0], r[f][0][0]), Math.min(g[1], r[f][0][1])],_ = [Math.max(p[0], r[f][1][0]), Math.min(p[1], r[f][1][1])];if (!(v[1] - v[0] <= n.FLOAT64_TOLERANCE || _[1] - _[0] <= n.FLOAT64_TOLERANCE)) {var y = (0, d.closestBSurfacePointApprox)(e, h.getDegreeU(), h.getDegreeV(), h.getKnotsU(), h.getKnotsV(), h.getControlPoints(), h.isRational() ? h.getWeights() : void 0, v, _),m = this.relaxToPerpendicular(e, y.u, y.v, v, _, t, 64),E = h.evaluatePosition(m.u, m.v),x = n.Vector3.squaredDistance(E, e);x < s && (s = x, a.u = m.u, a.v = m.v);}}}return this.isPeriodicUnlimitedU() && (a.u = (0, c.foldNearTo)(a.u, .5 * (this.getRangeU()[0] + this.getRangeU()[1]), this.getPeriodUnlimitedU())), this.isPeriodicUnlimitedV() && (a.v = (0, c.foldNearTo)(a.v, .5 * (this.getRangeV()[0] + this.getRangeV()[1]), this.getPeriodUnlimitedV())), a;}, f.prototype.vParamLine = function (e) {var t = (0, l.extractBSurfaceParamLineV)(e, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),r = t.ctrlPts.length / 3;t.weights && 0 !== t.weights.length || (t.weights = new Array(r), t.weights.fill(1));var n = new a.BCurve();return n.set(t.ctrlPts, t.weights, this._vDegree, this._vKnots), n;}, f.prototype.uParamLine = function (e) {var t = (0, l.extractBSurfaceParamLineU)(e, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),r = t.ctrlPts.length / 3;t.weights && 0 !== t.weights.length || (t.weights = new Array(r), t.weights.fill(1));var n = new a.BCurve();return n.set(t.ctrlPts, t.weights, this._uDegree, this._uKnots), n;}, f.prototype.getBoundingBox = function (e, t) {for (var r = new o.BoundingBox(), i = n.Vector3.createFloat64(), s = 0; s < this._controlPoints.length; s += 3) {n.Vector3.set(i, this._controlPoints[s], this._controlPoints[s + 1], this._controlPoints[s + 2]), r.includePoint(i);}return r;}, f.prototype.transform = function (e) {for (var t = n.Vector3.createFloat64(), r = 0; r < this._controlPoints.length; r += 3) {n.Vector3.set(t, this._controlPoints[r], this._controlPoints[r + 1], this._controlPoints[r + 2]), n.Vector3.transformMatrix44(t, t, e), this._controlPoints[r] = t[0], this._controlPoints[r + 1] = t[1], this._controlPoints[r + 2] = t[2];}this._clearCaches();}, f.prototype.getRangeUnlimitedU = function () {return [this._uKnots[0], this._uKnots[this._uKnots.length - 1]];}, f.prototype.getRangeUnlimitedV = function () {return [this._vKnots[0], this._vKnots[this._vKnots.length - 1]];}, f.prototype.isPeriodicUnlimitedU = function () {return this._checkClosure(), this._isPeriodicU;}, f.prototype.isPeriodicUnlimitedV = function () {return this._checkClosure(), this._isPeriodicV;}, f.prototype.isClosedUnlimitedU = function () {return this._checkClosure(), this._isClosedU;}, f.prototype.isClosedUnlimitedV = function () {return this._checkClosure(), this._isClosedV;}, f.prototype._checkClosure = function () {void 0 !== this._isClosedU && void 0 !== this._isPeriodicU || (this._isClosedU = this._isPeriodicU = !1), void 0 !== this._isClosedV && void 0 !== this._isPeriodicV || (this._isClosedV = this._isPeriodicV = !1);}, f.prototype.isSimpleBezier = function () {return this._uKnots.length === 2 * this._uDegree + 2 && this._vKnots.length === 2 * this._vDegree + 2;}, f.prototype.getBezierPatches = function () {if (this.isSimpleBezier()) return this._patches = void 0, [[this]];if (!this._patches) {var e = (0, h.decomposeBSurfaceToBezier)(this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._patches = [];for (var t = 0; t < e.U.length; ++t) {this._patches[t] = [];for (var r = 0; r < e.V.length; ++r) {var n = new f();n.set(this._uDegree, this._vDegree, e.U[t], e.V[r], e.P[t][r], e.w ? e.w[t][r] : void 0), this._patches[t][r] = n;}}}return this._patches;}, f.prototype._clearCaches = function () {this._isClosedU = void 0, this._isClosedV = void 0, this._isPeriodicU = void 0, this._isPeriodicV = void 0, this._patches = void 0;}, f.prototype.toObject = function () {return { uDegree: this._uDegree, vDegree: this._vDegree, uKnots: this._uKnots, vKnots: this._vKnots, controlPoints: this._controlPoints, weights: this._weights, uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.BSurface = f;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.WireBody = void 0;var n = r(9),o = r(0),i = r(4),s = r(19),a = function a() {n.BaseTopology.call(this), this._wires = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.WIREBODY;}, a.prototype.getWires = function () {return this._wires;}, a.prototype.setWires = function (e) {this._wires = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._wires[t] = e[t];}}, a.prototype.addWire = function (e) {this._wires ? this._wires.push(e) : this._wires = [e], e.setWireBody(this);}, a.prototype.addWires = function (e) {this._wires || (this._wires = []);for (var t = 0; t < e.length; ++t) {e[t].setWireBody(this);}this._wires = this._wires.concat(e);}, a.prototype.removeWire = function (e) {var t = this._wires.indexOf(e);return t > -1 && (this._wires.splice(t, 1), e.getWireBody() === this && e.setWireBody(void 0), !0);}, a.prototype.getBody = function () {return this;}, a.prototype.collectFaces = function (e) {return e || new Set();}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._wires.length; ++t) {this._wires[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._wires.length; ++t) {this._wires[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._wires.length; ++t) {e.include(this._wires[t].getBoundingBox());}return e;}, a.prototype.transform = function (e) {(0, s.transformTopology)(this, e);}, a.prototype.toString = function () {return \"WireBody\";}, a.prototype.toObject = function () {return { wires: this.refsToStrings(this._wires), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._wires, this._attributes]);}, t.WireBody = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.TopologyCloner = void 0;var n = r(16),o = r(20),i = r(27),s = r(13),a = r(15),c = r(26),u = r(25),l = r(24),h = r(41),d = function d() {this._edgeMap = {}, this._vertexMap = {}, this._coedgeMap = {}, this._progenitorMap = new h.ProgenitorMap();};d.prototype.cloneVertex = function (e) {var t = this._vertexMap[e.getGuid()];return t || (t = new n.Vertex(e.getPoint().clone()), this._vertexMap[e.getGuid()] = t, t.setPrecision(e.getPrecision()), this._progenitorMap.addEntry(t, [e])), t;}, d.prototype.cloneEdge = function (e) {var t = this._edgeMap[e.getGuid()];return t || (t = new o.Edge(e.getCurve().clone()), this._edgeMap[e.getGuid()] = t, t.setReversed(e.isReversed()), t.setRange(e.getRange()), t.setStartVertex(this.cloneVertex(e.getStartVertex())), t.setEndVertex(this.cloneVertex(e.getEndVertex())), t.setPrecision(e.getPrecision()), this._progenitorMap.addEntry(t, [e])), t;}, d.prototype.cloneCoedge = function (e) {var t,r,n = new i.Coedge();this._coedgeMap[e.getGuid()] = n, n.setReversed(e.isReversed()), n.setEdge(this.cloneEdge(e.getEdge())), n.getEdge().setCoedge(n);for (var o = e.getPartner(); o;) {var s = this._coedgeMap[o.getGuid()];s && (t || (t = s), r = s, e.getEdge().getCoedge() === o && n.getEdge().setCoedge(s)), (o = o.getPartner()) === e && (o = void 0);}return t && r && (n.setPartner(t), r.setPartner(n)), this._progenitorMap.addEntry(n, [e]), n;}, d.prototype.cloneLoop = function (e) {for (var t = new s.Loop(), r = e.getCoedges(), n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = this.cloneCoedge(r[o]);}return t.addCoedges(n), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneFace = function (e) {for (var t = new a.Face(), r = e.getLoops(), n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = this.cloneLoop(r[o]);}return t.addLoops(n), t.setSurface(e.getSurface().clone()), t.setReversed(e.isReversed()), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneFaces = function (e) {for (var t = new Array(e.length), r = 0; r < e.length; ++r) {t[r] = this.cloneFace(e[r]);}return t;}, d.prototype.cloneShell = function (e) {var t = new c.Shell();return t.addFaces(this.cloneFaces(e.getFaces())), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneLump = function (e) {for (var t = new u.Lump(), r = e.getShells(), n = 0; n < r.length; ++n) {t.addShell(this.cloneShell(r[n]));}return this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneBody = function (e) {for (var t = new l.Body(), r = e.getLumps(), n = 0; n < r.length; ++n) {t.addLump(this.cloneLump(r[n]));}return this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.getProgenitorMap = function () {return this._progenitorMap;}, t.TopologyCloner = d;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = function n(e, t) {if (t < 1) return \"\";for (var r = \"\"; t > 1;) {1 & t && (r += e), t >>= 1, e += e;}return r + e;},o = { isInitialized: !1, rngA: 4027999010, rngB: 3993266363, rngC: 3605298456, rotl32: function rotl32(e, t) {return (e << t >>> 0 | e >>> 32 - t) >>> 0;}, initialize: function initialize(e, t) {return o.isInitialized && !t ? 0 : (o.isInitialized && (o.rngA = 4027999010, o.rngB = 3993266363, o.rngC = 3605298456), o.isInitialized = !0, void 0 !== e ? r = e : (r = new Date().getTime(), r ^= Math.floor(2147483647 * Math.random() + 1)), o.rngA += 2097151 & r, o.rngB += r >> 7 & 524287, o.rngC += r >> 13, r);var r;}, genRandUInt32: function genRandUInt32() {return o.rngA = ~(2911329625 * o.rngA), o.rngA = o.rotl32(o.rngA, 17), o.rngB = 4031235431 * o.rngB, o.rngB = o.rotl32(o.rngB, 15), o.rngC = 3286325185 - o.rotl32(o.rngC, 19), o.rngA + o.rngB ^ o.rngC;} },i = function i(e) {for (var t = \"\", r = 0; r < 4; r++) {var o = e[r].toString(16);t += n(\"0\", 8 - o.length) + o;}return t.substr(0, 8) + \"-\" + t.substr(8, 4) + \"-\" + t.substr(12, 4) + \"-\" + t.substr(16, 4) + \"-\" + t.substr(20, 12);},s = function s(e, t) {var r = t;return void 0 === r && (r = new Uint32Array(4)), r[0] = parseInt(\"0x\" + e.substr(0, 8), 16), r[1] = parseInt(\"0x\" + e.substr(9, 4) + e.substr(14, 4), 16), r[2] = parseInt(\"0x\" + e.substr(19, 4) + e.substr(24, 4), 16), r[3] = parseInt(\"0x\" + e.substr(28, 8), 16), r;},a = function a(e, t) {var r = new Uint32Array(t);return r[0] += 2654435769, r[1] += 104395303, r[2] += 452930477, r[3] += 982451653, r[0] += e[3] << 6, r[1] += e[0] << 6, r[2] += e[1] << 6, r[3] += e[2] << 6, r[0] += e[2] >> 2, r[1] += e[3] >> 2, r[2] += e[0] >> 2, r[3] += e[1] >> 2, r[0] = 16777619 * (r[0] ^ e[1]) >>> 0, r[1] = 16777619 * (r[1] ^ e[2]) >>> 0, r[2] = 16777619 * (r[2] ^ e[3]) >>> 0, r[3] = 16777619 * (r[3] ^ e[0]) >>> 0, r;};o.initialize(), t.uint32x4ToGUID = i, t.guidToUint32x4 = s, t.generateGUID = function () {var e = new Uint32Array(4);return e[0] = o.genRandUInt32(), e[1] = o.genRandUInt32(), e[2] = o.genRandUInt32(), e[3] = o.genRandUInt32(), i(e);}, t.isGUID = function (e) {return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(e);}, t.combineGuids = function (e, t) {var r = s(e),n = s(t),o = a(r, n);return i(o);}, t.hashCombine4xUint32 = a;}, function (e, t) {var r;r = function () {return this;}();try {r = r || new Function(\"return this\")();} catch (e) {\"object\" == (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) && (r = window);}e.exports = r;}, function (e, t, r) {\"use strict\";e.exports = function (e, t) {for (var r = new Array(arguments.length - 1), n = 0, o = 2, i = !0; o < arguments.length;) {r[n++] = arguments[o++];}return new Promise(function (o, s) {r[n] = function (e) {if (i) if (i = !1, e) s(e);else {for (var t = new Array(arguments.length - 1), r = 0; r < t.length;) {t[r++] = arguments[r];}o.apply(null, t);}};try {e.apply(t || null, r);} catch (e) {i && (i = !1, s(e));}});};}, function (module, exports, __webpack_require__) {\"use strict\";function inquire(moduleName) {try {var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);if (mod && (mod.length || Object.keys(mod).length)) return mod;} catch (e) {}return null;}module.exports = inquire;}, function (e, t, r) {\"use strict\";t.Service = r(98);}, function (e, t, r) {\"use strict\";e.exports = {};}, function (e, t, r) {\"use strict\";e.exports = function (e) {for (var t, r = i.codegen([\"m\", \"w\"], e.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\"), a = e.fieldsArray.slice().sort(i.compareFieldsById), c = 0; c < a.length; ++c) {var u = a[c].resolve(),l = e._fieldsArray.indexOf(u),h = u.resolvedType instanceof n ? \"int32\" : u.type,d = o.basic[h];t = \"m\" + i.safeProp(u.name), u.map ? (r(\"if(%s!=null&&m.hasOwnProperty(%j)){\", t, u.name)(\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", t)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (u.id << 3 | 2) >>> 0, 8 | o.mapKey[u.keyType], u.keyType), void 0 === d ? r(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", l, t) : r(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | d, h, t), r(\"}\")(\"}\")) : u.repeated ? (r(\"if(%s!=null&&%s.length){\", t, t), u.packed && void 0 !== o.packed[h] ? r(\"w.uint32(%i).fork()\", (u.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", t)(\"w.%s(%s[i])\", h, t)(\"w.ldelim()\") : (r(\"for(var i=0;i<%s.length;++i)\", t), void 0 === d ? s(r, u, l, t + \"[i]\") : r(\"w.uint32(%i).%s(%s[i])\", (u.id << 3 | d) >>> 0, h, t)), r(\"}\")) : (u.optional && r(\"if(%s!=null&&m.hasOwnProperty(%j))\", t, u.name), void 0 === d ? s(r, u, l, t) : r(\"w.uint32(%i).%s(%s)\", (u.id << 3 | d) >>> 0, h, t));}return r(\"return w\");};var n = r(11),o = r(31),i = r(5);function s(e, t, r, n) {return t.resolvedType.group ? e(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", r, n, (t.id << 3 | 3) >>> 0, (t.id << 3 | 4) >>> 0) : e(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", r, n, (t.id << 3 | 2) >>> 0);}}, function (e, t, r) {\"use strict\";e.exports = y;var n = r(30);((y.prototype = Object.create(n.prototype)).constructor = y).className = \"Type\";var o = r(11),i = r(48),s = r(22),a = r(64),c = r(65),u = r(49),l = r(47),h = r(46),d = r(5),g = r(62),p = r(67),f = r(68),v = r(69),_ = r(70);function y(e, t) {n.call(this, e, t), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null;}function m(e) {return e._fieldsById = e._fieldsArray = e._oneofsArray = null, delete e.encode, delete e.decode, delete e.verify, e;}Object.defineProperties(y.prototype, { fieldsById: { get: function get() {if (this._fieldsById) return this._fieldsById;this._fieldsById = {};for (var e = Object.keys(this.fields), t = 0; t < e.length; ++t) {var r = this.fields[e[t]],n = r.id;if (this._fieldsById[n]) throw Error(\"duplicate id \" + n + \" in \" + this);this._fieldsById[n] = r;}return this._fieldsById;} }, fieldsArray: { get: function get() {return this._fieldsArray || (this._fieldsArray = d.toArray(this.fields));} }, oneofsArray: { get: function get() {return this._oneofsArray || (this._oneofsArray = d.toArray(this.oneofs));} }, ctor: { get: function get() {return this._ctor || (this.ctor = y.generateConstructor(this)());}, set: function set(e) {var t = e.prototype;t instanceof u || ((e.prototype = new u()).constructor = e, d.merge(e.prototype, t)), e.$type = e.prototype.$type = this, d.merge(e, u, !0), this._ctor = e;for (var r = 0; r < this.fieldsArray.length; ++r) {this._fieldsArray[r].resolve();}var n = {};for (r = 0; r < this.oneofsArray.length; ++r) {n[this._oneofsArray[r].resolve().name] = { get: d.oneOfGetter(this._oneofsArray[r].oneof), set: d.oneOfSetter(this._oneofsArray[r].oneof) };}r && Object.defineProperties(e.prototype, n);} } }), y.generateConstructor = function (e) {for (var t, r = d.codegen([\"p\"], e.name), n = 0; n < e.fieldsArray.length; ++n) {(t = e._fieldsArray[n]).map ? r(\"this%s={}\", d.safeProp(t.name)) : t.repeated && r(\"this%s=[]\", d.safeProp(t.name));}return r(\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\")(\"this[ks[i]]=p[ks[i]]\");}, y.fromJSON = function (e, t) {var r = new y(e, t.options);r.extensions = t.extensions, r.reserved = t.reserved;for (var u = Object.keys(t.fields), l = 0; l < u.length; ++l) {r.add((void 0 !== t.fields[u[l]].keyType ? a.fromJSON : s.fromJSON)(u[l], t.fields[u[l]]));}if (t.oneofs) for (u = Object.keys(t.oneofs), l = 0; l < u.length; ++l) {r.add(i.fromJSON(u[l], t.oneofs[u[l]]));}if (t.nested) for (u = Object.keys(t.nested), l = 0; l < u.length; ++l) {var h = t.nested[u[l]];r.add((void 0 !== h.id ? s.fromJSON : void 0 !== h.fields ? y.fromJSON : void 0 !== h.values ? o.fromJSON : void 0 !== h.methods ? c.fromJSON : n.fromJSON)(u[l], h));}return t.extensions && t.extensions.length && (r.extensions = t.extensions), t.reserved && t.reserved.length && (r.reserved = t.reserved), t.group && (r.group = !0), t.comment && (r.comment = t.comment), r;}, y.prototype.toJSON = function (e) {var t = n.prototype.toJSON.call(this, e),r = !!e && Boolean(e.keepComments);return d.toObject([\"options\", t && t.options || void 0, \"oneofs\", n.arrayToJSON(this.oneofsArray, e), \"fields\", n.arrayToJSON(this.fieldsArray.filter(function (e) {return !e.declaringField;}), e) || {}, \"extensions\", this.extensions && this.extensions.length ? this.extensions : void 0, \"reserved\", this.reserved && this.reserved.length ? this.reserved : void 0, \"group\", this.group || void 0, \"nested\", t && t.nested || void 0, \"comment\", r ? this.comment : void 0]);}, y.prototype.resolveAll = function () {for (var e = this.fieldsArray, t = 0; t < e.length;) {e[t++].resolve();}var r = this.oneofsArray;for (t = 0; t < r.length;) {r[t++].resolve();}return n.prototype.resolveAll.call(this);}, y.prototype.get = function (e) {return this.fields[e] || this.oneofs && this.oneofs[e] || this.nested && this.nested[e] || null;}, y.prototype.add = function (e) {if (this.get(e.name)) throw Error(\"duplicate name '\" + e.name + \"' in \" + this);if (e instanceof s && void 0 === e.extend) {if (this._fieldsById ? this._fieldsById[e.id] : this.fieldsById[e.id]) throw Error(\"duplicate id \" + e.id + \" in \" + this);if (this.isReservedId(e.id)) throw Error(\"id \" + e.id + \" is reserved in \" + this);if (this.isReservedName(e.name)) throw Error(\"name '\" + e.name + \"' is reserved in \" + this);return e.parent && e.parent.remove(e), this.fields[e.name] = e, e.message = this, e.onAdd(this), m(this);}return e instanceof i ? (this.oneofs || (this.oneofs = {}), this.oneofs[e.name] = e, e.onAdd(this), m(this)) : n.prototype.add.call(this, e);}, y.prototype.remove = function (e) {if (e instanceof s && void 0 === e.extend) {if (!this.fields || this.fields[e.name] !== e) throw Error(e + \" is not a member of \" + this);return delete this.fields[e.name], e.parent = null, e.onRemove(this), m(this);}if (e instanceof i) {if (!this.oneofs || this.oneofs[e.name] !== e) throw Error(e + \" is not a member of \" + this);return delete this.oneofs[e.name], e.parent = null, e.onRemove(this), m(this);}return n.prototype.remove.call(this, e);}, y.prototype.isReservedId = function (e) {return n.isReservedId(this.reserved, e);}, y.prototype.isReservedName = function (e) {return n.isReservedName(this.reserved, e);}, y.prototype.create = function (e) {return new this.ctor(e);}, y.prototype.setup = function () {for (var e = this.fullName, t = [], r = 0; r < this.fieldsArray.length; ++r) {t.push(this._fieldsArray[r].resolve().resolvedType);}this.encode = g(this)({ Writer: h, types: t, util: d }), this.decode = p(this)({ Reader: l, types: t, util: d }), this.verify = f(this)({ types: t, util: d }), this.fromObject = v.fromObject(this)({ types: t, util: d }), this.toObject = v.toObject(this)({ types: t, util: d });var n = _[e];if (n) {var o = Object.create(this);o.fromObject = this.fromObject, this.fromObject = n.fromObject.bind(o), o.toObject = this.toObject, this.toObject = n.toObject.bind(o);}return this;}, y.prototype.encode = function (e, t) {return this.setup().encode(e, t);}, y.prototype.encodeDelimited = function (e, t) {return this.encode(e, t && t.len ? t.fork() : t).ldelim();}, y.prototype.decode = function (e, t) {return this.setup().decode(e, t);}, y.prototype.decodeDelimited = function (e) {return e instanceof l || (e = l.create(e)), this.decode(e, e.uint32());}, y.prototype.verify = function (e) {return this.setup().verify(e);}, y.prototype.fromObject = function (e) {return this.setup().fromObject(e);}, y.prototype.toObject = function (e, t) {return this.setup().toObject(e, t);}, y.d = function (e) {return function (t) {d.decorateType(t, e);};};}, function (e, t, r) {\"use strict\";e.exports = s;var n = r(22);((s.prototype = Object.create(n.prototype)).constructor = s).className = \"MapField\";var o = r(31),i = r(5);function s(e, t, r, o, s, a) {if (n.call(this, e, t, o, void 0, void 0, s, a), !i.isString(r)) throw TypeError(\"keyType must be a string\");this.keyType = r, this.resolvedKeyType = null, this.map = !0;}s.fromJSON = function (e, t) {return new s(e, t.id, t.keyType, t.type, t.options, t.comment);}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject([\"keyType\", this.keyType, \"type\", this.type, \"id\", this.id, \"extend\", this.extend, \"options\", this.options, \"comment\", t ? this.comment : void 0]);}, s.prototype.resolve = function () {if (this.resolved) return this;if (void 0 === o.mapKey[this.keyType]) throw Error(\"invalid key type: \" + this.keyType);return n.prototype.resolve.call(this);}, s.d = function (e, t, r) {return \"function\" == typeof r ? r = i.decorateType(r).name : r && \"object\" == _typeof(r) && (r = i.decorateEnum(r).name), function (n, o) {i.decorateType(n.constructor).add(new s(o, e, t, r));};};}, function (e, t, r) {\"use strict\";e.exports = a;var n = r(30);((a.prototype = Object.create(n.prototype)).constructor = a).className = \"Service\";var o = r(66),i = r(5),s = r(60);function a(e, t) {n.call(this, e, t), this.methods = {}, this._methodsArray = null;}function c(e) {return e._methodsArray = null, e;}a.fromJSON = function (e, t) {var r = new a(e, t.options);if (t.methods) for (var n = Object.keys(t.methods), i = 0; i < n.length; ++i) {r.add(o.fromJSON(n[i], t.methods[n[i]]));}return t.nested && r.addJSON(t.nested), r.comment = t.comment, r;}, a.prototype.toJSON = function (e) {var t = n.prototype.toJSON.call(this, e),r = !!e && Boolean(e.keepComments);return i.toObject([\"options\", t && t.options || void 0, \"methods\", n.arrayToJSON(this.methodsArray, e) || {}, \"nested\", t && t.nested || void 0, \"comment\", r ? this.comment : void 0]);}, Object.defineProperty(a.prototype, \"methodsArray\", { get: function get() {return this._methodsArray || (this._methodsArray = i.toArray(this.methods));} }), a.prototype.get = function (e) {return this.methods[e] || n.prototype.get.call(this, e);}, a.prototype.resolveAll = function () {for (var e = this.methodsArray, t = 0; t < e.length; ++t) {e[t].resolve();}return n.prototype.resolve.call(this);}, a.prototype.add = function (e) {if (this.get(e.name)) throw Error(\"duplicate name '\" + e.name + \"' in \" + this);return e instanceof o ? (this.methods[e.name] = e, e.parent = this, c(this)) : n.prototype.add.call(this, e);}, a.prototype.remove = function (e) {if (e instanceof o) {if (this.methods[e.name] !== e) throw Error(e + \" is not a member of \" + this);return delete this.methods[e.name], e.parent = null, c(this);}return n.prototype.remove.call(this, e);}, a.prototype.create = function (e, t, r) {for (var n, o = new s.Service(e, t, r), a = 0; a < this.methodsArray.length; ++a) {var c = i.lcFirst((n = this._methodsArray[a]).resolve().name).replace(/[^$\\w_]/g, \"\");o[c] = i.codegen([\"r\", \"c\"], i.isReserved(c) ? c + \"_\" : c)(\"return this.rpcCall(m,q,s,r,c)\")({ m: n, q: n.resolvedRequestType.ctor, s: n.resolvedResponseType.ctor });}return o;};}, function (e, t, r) {\"use strict\";e.exports = i;var n = r(21);((i.prototype = Object.create(n.prototype)).constructor = i).className = \"Method\";var o = r(5);function i(e, t, r, i, s, a, c, u) {if (o.isObject(s) ? (c = s, s = a = void 0) : o.isObject(a) && (c = a, a = void 0), void 0 !== t && !o.isString(t)) throw TypeError(\"type must be a string\");if (!o.isString(r)) throw TypeError(\"requestType must be a string\");if (!o.isString(i)) throw TypeError(\"responseType must be a string\");n.call(this, e, c), this.type = t || \"rpc\", this.requestType = r, this.requestStream = !!s || void 0, this.responseType = i, this.responseStream = !!a || void 0, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = u;}i.fromJSON = function (e, t) {return new i(e, t.type, t.requestType, t.responseType, t.requestStream, t.responseStream, t.options, t.comment);}, i.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return o.toObject([\"type\", \"rpc\" !== this.type && this.type || void 0, \"requestType\", this.requestType, \"requestStream\", this.requestStream, \"responseType\", this.responseType, \"responseStream\", this.responseStream, \"options\", this.options, \"comment\", t ? this.comment : void 0]);}, i.prototype.resolve = function () {return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), n.prototype.resolve.call(this));};}, function (e, t, r) {\"use strict\";e.exports = function (e) {var t = i.codegen([\"r\", \"l\"], e.name + \"$decode\")(\"if(!(r instanceof Reader))\")(\"r=Reader.create(r)\")(\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (e.fieldsArray.filter(function (e) {return e.map;}).length ? \",k\" : \"\"))(\"while(r.pos<c){\")(\"var t=r.uint32()\");e.group && t(\"if((t&7)===4)\")(\"break\"), t(\"switch(t>>>3){\");for (var r = 0; r < e.fieldsArray.length; ++r) {var a = e._fieldsArray[r].resolve(),c = a.resolvedType instanceof n ? \"int32\" : a.type,u = \"m\" + i.safeProp(a.name);t(\"case %i:\", a.id), a.map ? (t(\"r.skip().pos++\")(\"if(%s===util.emptyObject)\", u)(\"%s={}\", u)(\"k=r.%s()\", a.keyType)(\"r.pos++\"), void 0 !== o.long[a.keyType] ? void 0 === o.basic[c] ? t('%s[typeof k===\"object\"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())', u, r) : t('%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()', u, c) : void 0 === o.basic[c] ? t(\"%s[k]=types[%i].decode(r,r.uint32())\", u, r) : t(\"%s[k]=r.%s()\", u, c)) : a.repeated ? (t(\"if(!(%s&&%s.length))\", u, u)(\"%s=[]\", u), void 0 !== o.packed[c] && t(\"if((t&7)===2){\")(\"var c2=r.uint32()+r.pos\")(\"while(r.pos<c2)\")(\"%s.push(r.%s())\", u, c)(\"}else\"), void 0 === o.basic[c] ? t(a.resolvedType.group ? \"%s.push(types[%i].decode(r))\" : \"%s.push(types[%i].decode(r,r.uint32()))\", u, r) : t(\"%s.push(r.%s())\", u, c)) : void 0 === o.basic[c] ? t(a.resolvedType.group ? \"%s=types[%i].decode(r)\" : \"%s=types[%i].decode(r,r.uint32())\", u, r) : t(\"%s=r.%s()\", u, c), t(\"break\");}for (t(\"default:\")(\"r.skipType(t&7)\")(\"break\")(\"}\")(\"}\"), r = 0; r < e._fieldsArray.length; ++r) {var l = e._fieldsArray[r];l.required && t(\"if(!m.hasOwnProperty(%j))\", l.name)(\"throw util.ProtocolError(%j,{instance:m})\", s(l));}return t(\"return m\");};var n = r(11),o = r(31),i = r(5);function s(e) {return \"missing required '\" + e.name + \"'\";}}, function (e, t, r) {\"use strict\";e.exports = function (e) {var t = o.codegen([\"m\"], e.name + \"$verify\")('if(typeof m!==\"object\"||m===null)')(\"return%j\", \"object expected\"),r = {};e.oneofsArray.length && t(\"var p={}\");for (var n = 0; n < e.fieldsArray.length; ++n) {var c = e._fieldsArray[n].resolve(),u = \"m\" + o.safeProp(c.name);if (c.optional && t(\"if(%s!=null&&m.hasOwnProperty(%j)){\", u, c.name), c.map) t(\"if(!util.isObject(%s))\", u)(\"return%j\", i(c, \"object\"))(\"var k=Object.keys(%s)\", u)(\"for(var i=0;i<k.length;++i){\"), a(t, c, \"k[i]\"), s(t, c, n, u + \"[k[i]]\")(\"}\");else if (c.repeated) t(\"if(!Array.isArray(%s))\", u)(\"return%j\", i(c, \"array\"))(\"for(var i=0;i<%s.length;++i){\", u), s(t, c, n, u + \"[i]\")(\"}\");else {if (c.partOf) {var l = o.safeProp(c.partOf.name);1 === r[c.partOf.name] && t(\"if(p%s===1)\", l)(\"return%j\", c.partOf.name + \": multiple values\"), r[c.partOf.name] = 1, t(\"p%s=1\", l);}s(t, c, n, u);}c.optional && t(\"}\");}return t(\"return null\");};var n = r(11),o = r(5);function i(e, t) {return e.name + \": \" + t + (e.repeated && \"array\" !== t ? \"[]\" : e.map && \"object\" !== t ? \"{k:\" + e.keyType + \"}\" : \"\") + \" expected\";}function s(e, t, r, o) {if (t.resolvedType) {if (t.resolvedType instanceof n) {e(\"switch(%s){\", o)(\"default:\")(\"return%j\", i(t, \"enum value\"));for (var s = Object.keys(t.resolvedType.values), a = 0; a < s.length; ++a) {e(\"case %i:\", t.resolvedType.values[s[a]]);}e(\"break\")(\"}\");} else e(\"{\")(\"var e=types[%i].verify(%s);\", r, o)(\"if(e)\")(\"return%j+e\", t.name + \".\")(\"}\");} else switch (t.type) {case \"int32\":case \"uint32\":case \"sint32\":case \"fixed32\":case \"sfixed32\":e(\"if(!util.isInteger(%s))\", o)(\"return%j\", i(t, \"integer\"));break;case \"int64\":case \"uint64\":case \"sint64\":case \"fixed64\":case \"sfixed64\":e(\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", o, o, o, o)(\"return%j\", i(t, \"integer|Long\"));break;case \"float\":case \"double\":e('if(typeof %s!==\"number\")', o)(\"return%j\", i(t, \"number\"));break;case \"bool\":e('if(typeof %s!==\"boolean\")', o)(\"return%j\", i(t, \"boolean\"));break;case \"string\":e(\"if(!util.isString(%s))\", o)(\"return%j\", i(t, \"string\"));break;case \"bytes\":e('if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))', o, o, o)(\"return%j\", i(t, \"buffer\"));}return e;}function a(e, t, r) {switch (t.keyType) {case \"int32\":case \"uint32\":case \"sint32\":case \"fixed32\":case \"sfixed32\":e(\"if(!util.key32Re.test(%s))\", r)(\"return%j\", i(t, \"integer key\"));break;case \"int64\":case \"uint64\":case \"sint64\":case \"fixed64\":case \"sfixed64\":e(\"if(!util.key64Re.test(%s))\", r)(\"return%j\", i(t, \"integer|Long key\"));break;case \"bool\":e(\"if(!util.key2Re.test(%s))\", r)(\"return%j\", i(t, \"boolean key\"));}return e;}}, function (e, t, r) {\"use strict\";var n = t,o = r(11),i = r(5);function s(e, t, r, n) {if (t.resolvedType) {if (t.resolvedType instanceof o) {e(\"switch(d%s){\", n);for (var i = t.resolvedType.values, s = Object.keys(i), a = 0; a < s.length; ++a) {t.repeated && i[s[a]] === t.typeDefault && e(\"default:\"), e(\"case%j:\", s[a])(\"case %i:\", i[s[a]])(\"m%s=%j\", n, i[s[a]])(\"break\");}e(\"}\");} else e('if(typeof d%s!==\"object\")', n)(\"throw TypeError(%j)\", t.fullName + \": object expected\")(\"m%s=types[%i].fromObject(d%s)\", n, r, n);} else {var c = !1;switch (t.type) {case \"double\":case \"float\":e(\"m%s=Number(d%s)\", n, n);break;case \"uint32\":case \"fixed32\":e(\"m%s=d%s>>>0\", n, n);break;case \"int32\":case \"sint32\":case \"sfixed32\":e(\"m%s=d%s|0\", n, n);break;case \"uint64\":c = !0;case \"int64\":case \"sint64\":case \"fixed64\":case \"sfixed64\":e(\"if(util.Long)\")(\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", n, n, c)('else if(typeof d%s===\"string\")', n)(\"m%s=parseInt(d%s,10)\", n, n)('else if(typeof d%s===\"number\")', n)(\"m%s=d%s\", n, n)('else if(typeof d%s===\"object\")', n)(\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", n, n, n, c ? \"true\" : \"\");break;case \"bytes\":e('if(typeof d%s===\"string\")', n)(\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", n, n, n)(\"else if(d%s.length)\", n)(\"m%s=d%s\", n, n);break;case \"string\":e(\"m%s=String(d%s)\", n, n);break;case \"bool\":e(\"m%s=Boolean(d%s)\", n, n);}}return e;}function a(e, t, r, n) {if (t.resolvedType) t.resolvedType instanceof o ? e(\"d%s=o.enums===String?types[%i].values[m%s]:m%s\", n, r, n, n) : e(\"d%s=types[%i].toObject(m%s,o)\", n, r, n);else {var i = !1;switch (t.type) {case \"double\":case \"float\":e(\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", n, n, n, n);break;case \"uint64\":i = !0;case \"int64\":case \"sint64\":case \"fixed64\":case \"sfixed64\":e('if(typeof m%s===\"number\")', n)(\"d%s=o.longs===String?String(m%s):m%s\", n, n, n)(\"else\")(\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", n, n, n, n, i ? \"true\" : \"\", n);break;case \"bytes\":e(\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", n, n, n, n, n);break;default:e(\"d%s=m%s\", n, n);}}return e;}n.fromObject = function (e) {var t = e.fieldsArray,r = i.codegen([\"d\"], e.name + \"$fromObject\")(\"if(d instanceof this.ctor)\")(\"return d\");if (!t.length) return r(\"return new this.ctor\");r(\"var m=new this.ctor\");for (var n = 0; n < t.length; ++n) {var a = t[n].resolve(),c = i.safeProp(a.name);a.map ? (r(\"if(d%s){\", c)('if(typeof d%s!==\"object\")', c)(\"throw TypeError(%j)\", a.fullName + \": object expected\")(\"m%s={}\", c)(\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", c), s(r, a, n, c + \"[ks[i]]\")(\"}\")(\"}\")) : a.repeated ? (r(\"if(d%s){\", c)(\"if(!Array.isArray(d%s))\", c)(\"throw TypeError(%j)\", a.fullName + \": array expected\")(\"m%s=[]\", c)(\"for(var i=0;i<d%s.length;++i){\", c), s(r, a, n, c + \"[i]\")(\"}\")(\"}\")) : (a.resolvedType instanceof o || r(\"if(d%s!=null){\", c), s(r, a, n, c), a.resolvedType instanceof o || r(\"}\"));}return r(\"return m\");}, n.toObject = function (e) {var t = e.fieldsArray.slice().sort(i.compareFieldsById);if (!t.length) return i.codegen()(\"return {}\");for (var r = i.codegen([\"m\", \"o\"], e.name + \"$toObject\")(\"if(!o)\")(\"o={}\")(\"var d={}\"), n = [], s = [], c = [], u = 0; u < t.length; ++u) {t[u].partOf || (t[u].resolve().repeated ? n : t[u].map ? s : c).push(t[u]);}if (n.length) {for (r(\"if(o.arrays||o.defaults){\"), u = 0; u < n.length; ++u) {r(\"d%s=[]\", i.safeProp(n[u].name));}r(\"}\");}if (s.length) {for (r(\"if(o.objects||o.defaults){\"), u = 0; u < s.length; ++u) {r(\"d%s={}\", i.safeProp(s[u].name));}r(\"}\");}if (c.length) {for (r(\"if(o.defaults){\"), u = 0; u < c.length; ++u) {var l = c[u],h = i.safeProp(l.name);if (l.resolvedType instanceof o) r(\"d%s=o.enums===String?%j:%j\", h, l.resolvedType.valuesById[l.typeDefault], l.typeDefault);else if (l.long) r(\"if(util.Long){\")(\"var n=new util.Long(%i,%i,%j)\", l.typeDefault.low, l.typeDefault.high, l.typeDefault.unsigned)(\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", h)(\"}else\")(\"d%s=o.longs===String?%j:%i\", h, l.typeDefault.toString(), l.typeDefault.toNumber());else if (l.bytes) {var d = \"[\" + Array.prototype.slice.call(l.typeDefault).join(\",\") + \"]\";r(\"if(o.bytes===String)d%s=%j\", h, String.fromCharCode.apply(String, l.typeDefault))(\"else{\")(\"d%s=%s\", h, d)(\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", h, h)(\"}\");} else r(\"d%s=%j\", h, l.typeDefault);}r(\"}\");}var g = !1;for (u = 0; u < t.length; ++u) {l = t[u];var p = e._fieldsArray.indexOf(l);h = i.safeProp(l.name), l.map ? (g || (g = !0, r(\"var ks2\")), r(\"if(m%s&&(ks2=Object.keys(m%s)).length){\", h, h)(\"d%s={}\", h)(\"for(var j=0;j<ks2.length;++j){\"), a(r, l, p, h + \"[ks2[j]]\")(\"}\")) : l.repeated ? (r(\"if(m%s&&m%s.length){\", h, h)(\"d%s=[]\", h)(\"for(var j=0;j<m%s.length;++j){\", h), a(r, l, p, h + \"[j]\")(\"}\")) : (r(\"if(m%s!=null&&m.hasOwnProperty(%j)){\", h, l.name), a(r, l, p, h), l.partOf && r(\"if(o.oneofs)\")(\"d%s=%j\", i.safeProp(l.partOf.name), l.name)), r(\"}\");}return r(\"return d\");};}, function (e, t, r) {\"use strict\";var n = t,o = r(49);n[\".google.protobuf.Any\"] = { fromObject: function fromObject(e) {if (e && e[\"@type\"]) {var t = this.lookup(e[\"@type\"]);if (t) {var r = \".\" === e[\"@type\"].charAt(0) ? e[\"@type\"].substr(1) : e[\"@type\"];return this.create({ type_url: \"/\" + r, value: t.encode(t.fromObject(e)).finish() });}}return this.fromObject(e);}, toObject: function toObject(e, t) {if (t && t.json && e.type_url && e.value) {var r = e.type_url.substring(e.type_url.lastIndexOf(\"/\") + 1),n = this.lookup(r);n && (e = n.decode(e.value));}if (!(e instanceof this.ctor) && e instanceof o) {var i = e.$type.toObject(e, t);return i[\"@type\"] = e.$type.fullName, i;}return this.toObject(e, t);} };}, function (e, t, r) {\"use strict\";e.exports = h;var n = r(30);((h.prototype = Object.create(n.prototype)).constructor = h).className = \"Root\";var o,i,s,a = r(22),c = r(11),u = r(48),l = r(5);function h(e) {n.call(this, \"\", e), this.deferred = [], this.files = [];}function d() {}h.fromJSON = function (e, t) {return t || (t = new h()), e.options && t.setOptions(e.options), t.addJSON(e.nested);}, h.prototype.resolvePath = l.path.resolve, h.prototype.load = function e(t, r, n) {\"function\" == typeof r && (n = r, r = void 0);var o = this;if (!n) return l.asPromise(e, o, t, r);var a = n === d;function c(e, t) {if (n) {var r = n;if (n = null, a) throw e;r(e, t);}}function u(e, t) {try {if (l.isString(t) && \"{\" === t.charAt(0) && (t = JSON.parse(t)), l.isString(t)) {i.filename = e;var n,s = i(t, o, r),u = 0;if (s.imports) for (; u < s.imports.length; ++u) {(n = o.resolvePath(e, s.imports[u])) && h(n);}if (s.weakImports) for (u = 0; u < s.weakImports.length; ++u) {(n = o.resolvePath(e, s.weakImports[u])) && h(n, !0);}} else o.setOptions(t.options).addJSON(t.nested);} catch (e) {c(e);}a || g || c(null, o);}function h(e, t) {var r = e.lastIndexOf(\"google/protobuf/\");if (r > -1) {var i = e.substring(r);i in s && (e = i);}if (!(o.files.indexOf(e) > -1)) if (o.files.push(e), e in s) a ? u(e, s[e]) : (++g, setTimeout(function () {--g, u(e, s[e]);}));else if (a) {var h;try {h = l.fs.readFileSync(e).toString(\"utf8\");} catch (e) {return void (t || c(e));}u(e, h);} else ++g, l.fetch(e, function (r, i) {--g, n && (r ? t ? g || c(null, o) : c(r) : u(e, i));});}var g = 0;l.isString(t) && (t = [t]);for (var p, f = 0; f < t.length; ++f) {(p = o.resolvePath(\"\", t[f])) && h(p);}if (a) return o;g || c(null, o);}, h.prototype.loadSync = function (e, t) {if (!l.isNode) throw Error(\"not supported\");return this.load(e, t, d);}, h.prototype.resolveAll = function () {if (this.deferred.length) throw Error(\"unresolvable extensions: \" + this.deferred.map(function (e) {return \"'extend \" + e.extend + \"' in \" + e.parent.fullName;}).join(\", \"));return n.prototype.resolveAll.call(this);};var g = /^[A-Z]/;function p(e, t) {var r = t.parent.lookup(t.extend);if (r) {var n = new a(t.fullName, t.id, t.type, t.rule, void 0, t.options);return n.declaringField = t, t.extensionField = n, r.add(n), !0;}return !1;}h.prototype._handleAdd = function (e) {if (e instanceof a) void 0 === e.extend || e.extensionField || p(0, e) || this.deferred.push(e);else if (e instanceof c) g.test(e.name) && (e.parent[e.name] = e.values);else if (!(e instanceof u)) {if (e instanceof o) for (var t = 0; t < this.deferred.length;) {p(0, this.deferred[t]) ? this.deferred.splice(t, 1) : ++t;}for (var r = 0; r < e.nestedArray.length; ++r) {this._handleAdd(e._nestedArray[r]);}g.test(e.name) && (e.parent[e.name] = e);}}, h.prototype._handleRemove = function (e) {if (e instanceof a) {if (void 0 !== e.extend) if (e.extensionField) e.extensionField.parent.remove(e.extensionField), e.extensionField = null;else {var t = this.deferred.indexOf(e);t > -1 && this.deferred.splice(t, 1);}} else if (e instanceof c) g.test(e.name) && delete e.parent[e.name];else if (e instanceof n) {for (var r = 0; r < e.nestedArray.length; ++r) {this._handleRemove(e._nestedArray[r]);}g.test(e.name) && delete e.parent[e.name];}}, h._configure = function (e, t, r) {o = e, i = t, s = r;};}, function (e, t, r) {\"use strict\";function n(e, t, r, n, o, i) {o[0] = i.b = n[0], o[1] = i.a = -t * i.b + n[1];for (var s = 2; s < e; s++) {o[s] = -(t * i.a + r * i.b) + n[s], i.b = i.a, i.a = o[s];}}function o(e, t, r, o, i, s, a, c, u) {var l = new Object(),h = 3;return l.b = l.a = 0, n(t, a, c, s, u, l), i.c = l.a, i.d = l.b, Math.abs(i.c) <= 100 * e * Math.abs(s[t - 1]) && Math.abs(i.d) <= 100 * e * Math.abs(s[t - 2]) || (i.h = c * o, Math.abs(i.d) >= Math.abs(i.c) ? (h = 2, i.e = r / i.d, i.f = i.c / i.d, i.g = a * o, i.a3 = i.e * (i.g + r) + i.h * (o / i.d), i.a1 = -r + i.f * o, i.a7 = i.h + (i.f + a) * r) : (h = 1, i.e = r / i.c, i.f = i.d / i.c, i.g = i.e * a, i.a3 = i.e * r + (i.g + i.h / i.c) * o, i.a1 = -r * (i.d / i.c) + o, i.a7 = i.g * i.d + i.h * i.f + r)), h;}function i(e, t, r, n, o, i, s, a, c) {var u;if (3 != r) {if (u = 1 == r ? o : n, Math.abs(i.a1) > 10 * e * Math.abs(u)) for (i.a7 /= i.a1, i.a3 /= i.a1, s[0] = c[0], s[1] = -c[0] * i.a7 + c[1], l = 2; l < t; l++) {s[l] = -c[l - 1] * i.a7 + a[l - 2] * i.a3 + c[l];} else for (s[0] = 0, s[1] = -c[0] * i.a7, l = 2; l < t; l++) {s[l] = -c[l - 1] * i.a7 + a[l - 2] * i.a3;}} else {s[1] = s[0] = 0;for (var l = 2; l < t; l++) {s[l] = a[l - 2];}}}function s(e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f, v) {var _, y, m, E, x, R, A, P;t.b = t.a = 0, 3 != e && (2 != e ? (_ = r + d * s + h * u, y = a + (d + g * u) * c) : (_ = (r + l) * u + h, y = (u + d) * a + g * c), 0 != (P = -(A = -((x = (m = -p[f - 1] / v[f]) * i) + (R = m * m * o)) + g * (E = -(p[f - 2] + m * v[f - 1]) / v[f]) * n) + y + m * _) && (t.a = -(d * (R + x) + g * (m * n + E * i)) / P + d, t.b = g * (1 + A / P)));}function a(e, t, r, n) {var o, i, s;n.sr = n.si = n.lr = n.li = 0, 0 != e ? 0 != r ? (o = t / 2, Math.abs(o) < Math.abs(r) ? (s = -(s = r >= 0 ? e : -e) + o * (o / Math.abs(r)), i = Math.sqrt(Math.abs(s)) * Math.sqrt(Math.abs(r))) : (s = -e / o * (r / o) + 1, i = Math.sqrt(Math.abs(s)) * Math.abs(o)), s >= 0 ? (i = o >= 0 ? -i : i, n.lr = (-o + i) / e, n.sr = 0 != n.lr ? r / n.lr / e : n.sr) : (n.lr = n.sr = -o / e, n.si = Math.abs(i / e), n.li = -n.si)) : n.lr = -t / e : n.sr = 0 != t ? -r / t : n.sr;}function c(e, t, r, c, u, l, h, d, g, p, f, v) {var _,y,m,E,x,R,A,P,V,T,C,b = new Object(),L = 0,O = 0;r.NZ = 0, R = c, P = u;do {if (b.li = b.lr = b.si = b.sr = 0, a(1, R, P, b), r.szr = b.sr, r.szi = b.si, r.lzr = b.lr, r.lzi = b.li, Math.abs(Math.abs(r.szr) - Math.abs(r.lzr)) > .01 * Math.abs(r.lzr)) break;for (n(h, R, P, g, l, d), y = Math.abs(-r.szr * d.b + d.a) + Math.abs(r.szi * d.b), T = Math.sqrt(Math.abs(P)), _ = 2 * Math.abs(l[0]), x = -r.szr * d.b, C = 1; C < t; C++) {_ = _ * T + Math.abs(l[C]);}if (y <= 20 * (_ = (9 * (_ = _ * T + Math.abs(x + d.a)) + 2 * Math.abs(x) - 7 * (Math.abs(d.a + x) + T * Math.abs(d.b))) * e)) {r.NZ = 2;break;}if (++L > 20) break;if (L >= 2 && E <= .01 && y >= m && !O) {for (n(h, R -= R * (E = E < e ? Math.sqrt(e) : Math.sqrt(E)), P += P * E, g, l, d), C = 0; C < 5; C++) {i(e, t, o(e, t, d.a, d.b, f, v, R, P, p), d.a, d.b, f, v, p, l);}O = 1, L = 0;}m = y, i(e, t, o(e, t, d.a, d.b, f, v, R, P, p), d.a, d.b, f, v, p, l), s(o(e, t, d.a, d.b, f, v, R, P, p), d, d.a, f.a1, f.a3, f.a7, d.b, f.c, f.d, f.f, f.g, f.h, R, P, v, t, g), A = d.a, 0 != (V = d.b) && (E = Math.abs((-P + V) / V), R = A, P = V);} while (0 != V);}function u(e, t, r, n, o, i, s, a, c) {var u,l,h,d,g,p,f,v,_,y,m,E = n - 1;for (t.NZ = m = _ = 0, f = r.a;;) {for (s[0] = p = o[0], y = 1; y < i; y++) {s[y] = p = p * f + o[y];}for (h = Math.abs(p), d = Math.abs(f), u = .5 * Math.abs(s[0]), y = 1; y < i; y++) {u = u * d + Math.abs(s[y]);}if (h <= 20 * e * (2 * u - h)) {t.NZ = 1, t.szr = f, t.szi = 0;break;}if (++m > 10) break;if (m >= 2 && Math.abs(v) <= .001 * Math.abs(-v + f) && h > g) {_ = 1, t.a = f;break;}for (g = h, c[0] = l = a[0], y = 1; y < n; y++) {c[y] = l = l * f + a[y];}if (Math.abs(l) > 10 * Math.abs(a[E]) * e) for (v = -p / l, a[0] = s[0], y = 1; y < n; y++) {a[y] = v * c[y - 1] + s[y];} else for (a[0] = 0, y = 1; y < n; y++) {a[y] = c[y - 1];}for (l = a[0], y = 1; y < n; y++) {l = l * f + a[y];}f += v = Math.abs(l) > 10 * Math.abs(a[E]) * e ? -p / l : 0;}return _;}function l(e, t, r, a, l, h, d, g, p, f, v) {var _,y,m,E,x,R,A,P,V,T,C,b,L,O,S,M,w,N,F,I,D,j,B,U,k,G,z,Y,K = new Object(),q = new Object(),W = new Array(t),H = new Array(t);for (v.NZ = 0, E = m = .25, S = -2 * a, x = a, P = w = l, q.h = q.g = q.f = q.e = q.d = q.c = q.a7 = q.a3 = q.a1 = K.b = K.a = 0, n(p, S, w, g, f, K), G = o(e, d, _ = K.a, y = K.b, q, h, S, w, W), B = 0; B < r; B++) {if (i(e, d, G, _, y, q, h, W, f), s(G = o(e, d, _, y, q, h, S, w, W), K, _, q.a1, q.a3, q.a7, y, q.c, q.d, q.f, q.g, q.h, S, w, h, d, g), M = K.a, F = N = K.b, T = 0 != h[d - 1] ? -g[d] / h[d - 1] : 0, C = L = 1, 0 != B && 3 != G && (z = (O = (L = 0 != F ? Math.abs((F - P) / F) : L) < A ? L * A : 1) < E ? 1 : 0, (U = (b = (C = 0 != T ? Math.abs((T - x) / T) : C) < R ? C * R : 1) < m ? 1 : 0) || z)) {for (D = 0; D < d; D++) {H[D] = h[D];}V = T, k = Y = 0, I = 1;do {if (j = 1, I && 0 == (I = 0) && U && (!z || b < O)) ;else {if (c(e, d, v, M, N, f, p, K, g, W, q, h), _ = K.a, y = K.b, v.NZ > 0) return;if (Y = 1, E *= .25, k || !U) j = 0;else for (D = 0; D < d; D++) {h[D] = H[D];}}if (0 != j) {if (K.a = V, j = u(e, v, K, d, g, p, f, h, W), V = K.a, v.NZ > 0) return;if (k = 1, m *= .25, 0 != j) {M = -(V + V), N = V * V;continue;}}for (D = 0; D < d; D++) {h[D] = H[D];}} while (z && !Y);n(p, S, w, g, f, K), G = o(e, d, _ = K.a, y = K.b, q, h, S, w, W);}P = F, x = T, A = L, R = C;}}Object.defineProperty(t, \"__esModule\", { value: !0 }), t.getRealPolynomialRoots = function (e) {var t = { Degree: e.length - 1 },r = new Array(e.length),n = new Array(e.length);!function (e, t, r, n) {var o,i,s,c,u,h,d,g,p,f,v,_,y,m,E,x,R,A,P,V,T,C,b = e.Degree,L = Math.LN2,O = e.Degree + 1,S = new Array(O),M = new Array(O),w = new Array(O),N = new Array(O),F = new Object(),I = new Object();_ = 1;do {i = _, y = 1 + (_ /= 2);} while (y > 1);var D = 117549435082229e-52 / i,j = Math.cos(1.6406094968746698),B = Math.sin(1.6406094968746698),U = Math.sqrt(.5),k = -U;for (I.NZ = R = 0, I.szr = I.szi = I.lzr = I.lzi = 0; 0 == t[b];) {r[R] = n[R] = 0, b--, R++;}for (T = b + 1; b >= 1;) {if (b <= 2) {b < 2 ? (r[e.Degree - 1] = -t[1] / t[0], n[e.Degree - 1] = 0) : (F.li = F.lr = F.si = F.sr = 0, a(t[0], t[1], t[2], F), r[e.Degree - 2] = F.sr, n[e.Degree - 2] = F.si, r[e.Degree - 1] = F.lr, n[e.Degree - 1] = F.li);break;}for (d = 0, g = 340282346638529e24, G = 0; G < T; G++) {(f = Math.abs(t[G])) > d && (d = f), 0 != f && f < g && (g = f);}if (((p = D / g) <= 1 && d >= 10 || p > 1 && 340282346638529e24 / p >= d) && (p = 0 == p ? 117549435082229e-52 : p, P = Math.floor(Math.log(p) / L + .5), 1 != (u = Math.pow(2, P)))) for (G = 0; G < T; G++) {t[G] *= u;}for (var G = 0; G < T; G++) {M[G] = Math.abs(t[G]);}M[b] = -M[b], V = b - 1, f = Math.exp((Math.log(-M[b]) - Math.log(M[0])) / b), 0 != M[V] && (f = (v = -M[b] / M[V]) < f ? v : f), v = f;do {for (v = .1 * (f = v), h = M[0], G = 1; G < T; G++) {h = h * v + M[G];}} while (h > 0);for (c = f; Math.abs(c / f) > .005;) {for (s = h = M[0], G = 1; G < b; G++) {s = f * s + (h = f * h + M[G]);}f -= c = (h = f * h + M[b]) / s;}for (o = f, G = 1; G < b; G++) {S[G] = (b - G) * t[G] / b;}for (S[0] = t[0], _ = t[b], y = t[V], C = 0 == S[V] ? 1 : 0, A = 0; A < 5; A++) {if (m = S[V], C) {for (G = 0; G < V; G++) {S[R = V - G] = S[R - 1];}S[0] = 0, C = 0 == S[V] ? 1 : 0;} else {for (E = -_ / m, G = 0; G < V; G++) {S[R = V - G] = E * S[R - 1] + t[R];}S[0] = t[0], C = Math.abs(S[V]) <= Math.abs(y) * i * 10 ? 1 : 0;}}for (G = 0; G < b; G++) {N[G] = S[G];}for (A = 1; A <= 20; A++) {if (x = -B * k + j * U, k = B * U + j * k, l(i, O, 20 * A, o * (U = x), o, S, b, t, T, w, I), 0 != I.NZ) {for (r[R = e.Degree - b] = I.szr, n[R] = I.szi, b = (T -= I.NZ) - 1, G = 0; G < T; G++) {t[G] = w[G];}1 != I.NZ && (r[R + 1] = I.lzr, n[R + 1] = I.lzi);break;}for (G = 0; G < b; G++) {S[G] = N[G];}}if (A > 20) {e.Degree -= b;break;}}}(t, e, r, n);for (var o = [], i = e.length - t.Degree - 1; i < e.length; i++) {Math.abs(n[i]) < 1e-8 && o.push(r[i]);}return o;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.relaxBCurveToPerpendicular = t.closestBCurveSegments = t.maxDistanceSqrToHull = t.minDistanceSqrToHull = void 0;var n = r(1),o = r(0),i = r(37),s = r(35),a = function a(e, t) {var r,i = t.length / 3,s = n.Vector3.asFloat64(0, 0, 0);for (r = 0; r < i; ++r) {s[0] += t[3 * r], s[1] += t[3 * r + 1], s[2] += t[3 * r + 2];}n.Vector3.scale(s, s, 1 / i), n.Vector3.sub(s, s, e);var a = n.Vector3.squaredLength(s);if (a < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return 0;var c = Number.POSITIVE_INFINITY;for (r = 0; r < i; ++r) {var u = s[0] * (t[3 * r] - e[0]) + s[1] * (t[3 * r + 1] - e[1]) + s[2] * (t[3 * r + 2] - e[2]);u < c && (c = u);}return c <= 0 ? 0 : c * c / a;},c = function c(e, t) {for (var r = t.length / 3, n = 0, o = 0; o < r; ++o) {var i = t[3 * o] - e[0],s = t[3 * o + 1] - e[1],a = t[3 * o + 2] - e[2],c = i * i + s * s + a * a;c > n && (n = c);}return n;};t.minDistanceSqrToHull = a, t.maxDistanceSqrToHull = c, t.closestBCurveSegments = function (e, t, r, o) {for (var i = Number.POSITIVE_INFINITY, s = [], u = 0; u < t.length; ++u) {var l,h = t[u],d = h.getRangeUnlimited();if (o) {l = !1;for (var g = 0; g < o.length; ++g) {if (d[1] >= o[g][0] + n.FLOAT64_TOLERANCE && d[0] <= o[g][1] - n.FLOAT64_TOLERANCE) {l = !0;break;}}} else l = !0;if (l) {var p = r ? r[u] : 0,f = h.getControlPoints(),v = a(e, f);if ((v = Math.max(0, v - p)) <= i) {var _ = c(e, f) + p;s.push({ index: u, minDistSqr: v, maxDistSqr: _ }), _ < i && (i = _);}}}return (s = s.filter(function (e) {return e.minDistSqr <= i;})).sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), s;}, t.relaxBCurveToPerpendicular = function (e, t, r, o, a, c, u, l) {var h = u || n.FLOAT64_TOLERANCE,d = l || 32,g = t.length / 3,p = e.length - g - 1;return (0, s.newtonRaphson1D)(function (n) {var s = (0, i.evaluateBCurveDerivs)(n, 2, p, e, t, r),a = s[0],c = s[1],u = s[2],l = [a[0] - o[0], a[1] - o[1], a[2] - o[2]];return { val: 2 * (l[0] * c[0] + l[1] * c[1] + l[2] * c[2]), deriv: 2 * (l[0] * u[0] + l[1] * u[1] + l[2] * u[2] + (c[0] * c[0] + c[1] * c[1] + c[2] * c[2])) };}, c, a, h, d);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Sphere = void 0;var n = r(1),o = r(3),i = r(0),s = r(12),a = r(6),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.SPHERE;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t;var s = void 0 === r || n.Vector3.squaredLength(r) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE,a = void 0 === o || n.Vector3.squaredLength(o) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE;s && a ? (n.Vector3.set(this._xAxis, 1, 0, 0), n.Vector3.set(this._zAxis, 0, 0, 1)) : s ? (n.Vector3.normalize(this._xAxis, o), n.Vector3.computeOrthogonal(this._zAxis, this._xAxis), n.Vector3.normalize(this._zAxis, this._zAxis)) : a ? (n.Vector3.normalize(this._zAxis, r), n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)) : (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, o, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, o), n.Vector3.normalize(this._zAxis, r)), this._computeYAxis();}, l.prototype.getRadius = function () {return this._radius;}, l.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), (n.Vector3.squaredLength(this._zAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._zAxis, this._xAxis), n.Vector3.normalize(this._zAxis, this._zAxis)), this._computeYAxis();}, l.prototype.evaluatePosition = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = Math.cos(t),a = this._radius * o * s,c = this._radius * o * i,u = this._radius * r,l = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(l, l, this._xAxis, a), n.Vector3.scaleAndAdd(l, l, this._yAxis, c), n.Vector3.scaleAndAdd(l, l, this._zAxis, u), l;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = o * Math.cos(t),a = o * i,c = r,u = n.Vector3.createFloat64();return n.Vector3.scale(u, this._xAxis, s), n.Vector3.scaleAndAdd(u, u, this._yAxis, a), n.Vector3.scaleAndAdd(u, u, this._zAxis, c), u;}, l.prototype.evaluateDu = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = Math.cos(t),a = -this._radius * r * s,c = -this._radius * r * i,u = this._radius * o,l = n.Vector3.createFloat64();return n.Vector3.scale(l, this._xAxis, a), n.Vector3.scaleAndAdd(l, l, this._yAxis, c), n.Vector3.scaleAndAdd(l, l, this._zAxis, u), l;}, l.prototype.evaluateDv = function (e, t) {var r = Math.cos(e),o = Math.sin(t),i = Math.cos(t),s = -this._radius * r * o,a = this._radius * r * i,c = n.Vector3.createFloat64();return n.Vector3.scale(c, this._xAxis, s), n.Vector3.scaleAndAdd(c, c, this._yAxis, a), c;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.length(t);if (r < i.KERNEL_TOLERANCE) return { u: 0, v: 0 };var s = n.Vector3.dot(t, this._xAxis),a = n.Vector3.dot(t, this._yAxis),c = n.Vector3.dot(t, this._zAxis);return { u: Math.asin((0, o.clamp)(c / r, -1, 1)), v: Math.atan2(a, s) };}, l.prototype.vParamLine = function (e) {var t = Math.cos(e),r = Math.sin(e),o = this._radius * t,s = this._radius * r;if (Math.abs(o) > i.KERNEL_TOLERANCE) {var u = new c.Circle(),l = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(l, l, this._zAxis, s);var h = n.Vector3.clone(this._xAxis);n.Vector3.scale(h, h, o);var d = n.Vector3.clone(this._zAxis);return n.Vector3.negate(d, d), u.set(l, d, h), u;}var g = n.Vector3.clone(this._center);return s = s < 0 ? -this._radius : this._radius, n.Vector3.scaleAndAdd(g, g, this._zAxis, s), new a.Point(g);}, l.prototype.uParamLine = function (e) {var t = new c.Circle(),r = Math.sin(e),o = Math.cos(e),i = this._radius * o,s = this._radius * r,a = n.Vector3.clone(this._xAxis);n.Vector3.scale(a, a, -s), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.normalize(a, a);var u = n.Vector3.clone(this._xAxis);return n.Vector3.scale(u, u, i), n.Vector3.scaleAndAdd(u, u, this._yAxis, s), t.set(this._center, a, u), t;}, l.prototype.getBoundingBox = function (e, t) {e = e || [-Math.PI / 2, Math.PI / 2], t = t || [-Math.PI, Math.PI];var r = e[0],i = e[1],s = t[0],a = t[1],c = this.vParamLine(r).getBoundingBox(t);c.include(this.vParamLine(i).getBoundingBox(t)), c.include(this.uParamLine(s).getBoundingBox(e)), c.include(this.uParamLine(a).getBoundingBox(e));for (var u = n.Vector3.createFloat64(), l = 0; l < 3; ++l) {for (var h = 0; h < 2; ++h) {var d = 0 === h ? 1 : -1,g = Math.atan2(d * this._yAxis[l], d * this._xAxis[l]),p = Math.asin(d * this._zAxis[l]);g = (0, o.adjustParameterToPeriodicRange)(g, t, o.PI2), p > r && p < i && g > s && g < a && (n.Vector3.set(u, 0, 0, 0), u[l] = d * this._radius, c.includePoint(n.Vector3.add(u, this._center, u)));}}return c;}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-Math.PI / 2, Math.PI / 2];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this.getCenter()), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Sphere = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Torus = void 0;var n = r(1),o = r(3),i = r(0),s = r(12),a = r(6),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._lemon = !1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.TORUS;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._lemon = e._lemon, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s, a) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._majorRadius = t, u.ConsoleUtils.assert(r > i.KERNEL_TOLERANCE), this._minorRadius = r, u.ConsoleUtils.assert(n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, o), void 0 !== s && n.Vector3.squaredLength(s) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, s, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, s)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._lemon = !0 === a, this._computeYAxis();}, l.prototype.getMajorRadius = function () {return this._majorRadius;}, l.prototype.setMajorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._majorRadius = e;}, l.prototype.getMinorRadius = function () {return this._minorRadius;}, l.prototype.setMinorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._minorRadius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.isDoughnut = function () {return this._majorRadius > this._minorRadius + i.KERNEL_TOLERANCE;}, l.prototype.isVortex = function () {return Math.abs(this._majorRadius - this._minorRadius) <= i.KERNEL_TOLERANCE;}, l.prototype.isApple = function () {return this._majorRadius < this._minorRadius - i.KERNEL_TOLERANCE && !this._lemon;}, l.prototype.isLemon = function () {return this._majorRadius < this._minorRadius - i.KERNEL_TOLERANCE && this._lemon;}, l.prototype.setLemon = function (e) {this._lemon = e;}, l.prototype.getSingularUParams = function () {var e, t, r;return this.isDoughnut() ? [] : this.isApple() ? (e = -this._majorRadius, t = this._minorRadius, [-(r = Math.acos(e / t)), r]) : this.isLemon() ? (e = this._minorRadius - this._majorRadius, t = this._minorRadius, [-(r = Math.acos(e / t)), r]) : [-Math.PI, Math.PI];}, l.prototype.evaluatePosition = function (e, t) {var r = this._minorRadius * Math.cos(e);this.isLemon() ? r -= this._majorRadius : r += this._majorRadius;var o = r * Math.cos(t),i = r * Math.sin(t),s = this._minorRadius * Math.sin(e),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = o * Math.cos(t),a = o * i,c = r,u = n.Vector3.createFloat64();return n.Vector3.scale(u, this._xAxis, s), n.Vector3.scaleAndAdd(u, u, this._yAxis, a), n.Vector3.scaleAndAdd(u, u, this._zAxis, c), u;}, l.prototype.evaluateDu = function (e, t) {var r = -this._minorRadius * Math.sin(e),o = r * Math.cos(t),i = r * Math.sin(t),s = this._minorRadius * Math.cos(e),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, l.prototype.evaluateDv = function (e, t) {var r = this._minorRadius * Math.cos(e);this.isLemon() ? r -= this._majorRadius : r += this._majorRadius;var o = -r * Math.sin(t),i = r * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._xAxis),o = n.Vector3.dot(t, this._yAxis),s = n.Vector3.dot(t, this._zAxis),a = Math.sqrt(r * r + o * o);return this.isLemon() ? a += this._majorRadius : a -= this._majorRadius, { u: s * s + a * a > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? Math.atan2(s, a) : 0, v: r * r + o * o > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? Math.atan2(o, r) : 0 };}, l.prototype.vParamLine = function (e) {var t = this._minorRadius * Math.cos(e);this.isLemon() ? t -= this._majorRadius : t += this._majorRadius;var r = this._minorRadius * Math.sin(e);if (Math.abs(t) > i.KERNEL_TOLERANCE) {var o = new c.Circle(),s = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(s, s, this._zAxis, r);var u = n.Vector3.clone(this._xAxis);n.Vector3.scale(u, u, t);var l = n.Vector3.clone(this._zAxis);return n.Vector3.negate(l, l), o.set(s, l, u), o;}var h = n.Vector3.clone(this._center),d = this.getSingularUParams();return d[0] && r < 0 ? r = this._minorRadius * Math.sin(d[0]) : d[1] && r > 0 && (r = this._minorRadius * Math.sin(d[1])), n.Vector3.scaleAndAdd(h, h, this._zAxis, r), new a.Point(h);}, l.prototype.uParamLine = function (e) {var t = new c.Circle(),r = Math.sin(e),o = Math.cos(e),i = this._majorRadius * o,s = this._majorRadius * r;this.isLemon() && (i = -i, s = -s);var a = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(a, a, this._xAxis, i), n.Vector3.scaleAndAdd(a, a, this._yAxis, s);var u = this._minorRadius * o,l = this._minorRadius * r,h = n.Vector3.clone(this._xAxis);n.Vector3.scale(h, h, -l), n.Vector3.scaleAndAdd(h, h, this._yAxis, u), n.Vector3.normalize(h, h);var d = n.Vector3.clone(this._xAxis);return n.Vector3.scale(d, d, u), n.Vector3.scaleAndAdd(d, d, this._yAxis, l), t.set(a, h, d), t;}, l.prototype.getBoundingBox = function (e, t) {e = e || (this.isDoughnut() ? [-Math.PI, Math.PI] : this.getSingularUParams()), t = t || [-Math.PI, Math.PI];var r = e[0],i = e[1],s = t[0],a = t[1],c = this.vParamLine(r).getBoundingBox(t);c.include(this.vParamLine(i).getBoundingBox(t)), c.include(this.uParamLine(s).getBoundingBox(e)), c.include(this.uParamLine(a).getBoundingBox(e));for (var u = n.Vector3.createFloat64(), l = n.Vector3.createFloat64(), h = 0; h < 3; ++h) {for (var d = 0; d < 2; ++d) {var g = 0 === d ? -1 : 1,p = Math.atan2(g * this._yAxis[h], g * this._xAxis[h]);if ((p = (0, o.adjustParameterToPeriodicRange)(p, t, o.PI2)) > s && p < a) {var f = this.uParamLine(p);u = f.evaluatePosition(0), n.Vector3.sub(u, u, f.getCenter()), l = f.evaluatePosition(Math.PI / 2), n.Vector3.sub(l, l, f.getCenter());var v = (0, o.minMaxCosSinFunc)(u[h], l[h], f.getCenter()[h], e);0 === h ? c.includeX(v[d]) : 1 === h ? c.includeY(v[d]) : c.includeZ(v[d]);}}}return c;}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return this.isDoughnut() ? [-Math.PI, Math.PI] : this.getSingularUParams();}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return this.isDoughnut();}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return this.isDoughnut() || this.isVortex();}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this.getCenter()), coordAxis: this.vectorToObject(this.getUvOriginDir()), axis: this.vectorToObject(this.getAxisDir()), majorRadius: this.getMajorRadius(), minorRadius: this.getMinorRadius(), lemon: this.isLemon(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Torus = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.evaluateBSurfaceDerivs = t.evaluateBSurfacePoint = void 0;var n = r(1),o = r(3),i = r(17),s = r(37);t.evaluateBSurfacePoint = function (e, t, r, o, a, c, u, l) {return l && l.length > 0 ? function (e, t, r, o, a, c, u, l) {for (var h, d = c.length - o - 1, g = (0, i.findKnotSpan)(e, a), p = (0, s.evaluateBasisFunctions)(g, e, r, a), f = (0, i.findKnotSpan)(t, c), v = (0, s.evaluateBasisFunctions)(f, t, o, c), _ = g - r, y = n.Vector4.createFloat64(), m = n.Vector4.createFloat64(), E = 0; E <= o; E++) {n.Vector4.set(m, 0, 0, 0, 0), h = f - o + E;for (var x = 0; x <= r; x++) {var R = (_ + x) * d + h,A = p[x] * l[R];m[0] += A * u[3 * R], m[1] += A * u[3 * R + 1], m[2] += A * u[3 * R + 2], m[3] += A;}y[0] += v[E] * m[0], y[1] += v[E] * m[1], y[2] += v[E] * m[2], y[3] += v[E] * m[3];}return n.Vector3.createFloat64FromValues(y[0] / y[3], y[1] / y[3], y[2] / y[3]);}(e, t, r, o, a, c, u, l) : function (e, t, r, o, a, c, u) {for (var l, h = c.length - o - 1, d = (0, i.findKnotSpan)(e, a), g = (0, s.evaluateBasisFunctions)(d, e, r, a), p = (0, i.findKnotSpan)(t, c), f = (0, s.evaluateBasisFunctions)(p, t, o, c), v = d - r, _ = n.Vector3.createFloat64(), y = n.Vector3.createFloat64(), m = 0; m <= o; m++) {n.Vector3.set(y, 0, 0, 0), l = p - o + m;for (var E = 0; E <= r; E++) {var x = (v + E) * h + l;y[0] += g[E] * u[3 * x], y[1] += g[E] * u[3 * x + 1], y[2] += g[E] * u[3 * x + 2];}_[0] += f[m] * y[0], _[1] += f[m] * y[1], _[2] += f[m] * y[2];}return _;}(e, t, r, o, a, c, u);}, t.evaluateBSurfaceDerivs = function (e, t, r, a, c, u, l, h, d) {return function (e, t, r, a, c, u, l, h, d) {var g,p,f,v,_,y,m = new Array(r + 1),E = new Array(r + 1),x = new Array(r + 1),R = new Array(r + 1);for (g = 0; g <= r; g++) {for (m[g] = new Array(r + 1 - g), E[g] = new Array(r + 1 - g), p = 0; p <= r - g; p++) {m[g][p] = n.Vector3.createFloat64(), E[g][p] = 0;}x[g] = new Array(a + 1), R[g] = new Array(c + 1);}var A = Math.min(r, a),P = (0, i.findKnotSpan)(e, u);(0, s.evaluateBasisDerivatives)(P, e, a, A, u, x);var V = Math.min(r, c),T = (0, i.findKnotSpan)(t, l);(0, s.evaluateBasisDerivatives)(T, t, c, V, l, R);var C = d && d.length > 0,b = l.length - c - 1,L = new Array(c + 1);for (g = 0; g <= A; g++) {for (f = 0; f <= c; f++) {for (L[f] = [0, 0, 0, 0], v = 0; v <= a; v++) {var O = (P - a + v) * b + (T - c + f),S = x[g][v];C && (S *= d[O], L[f][3] += S), L[f][0] += S * h[3 * O], L[f][1] += S * h[3 * O + 1], L[f][2] += S * h[3 * O + 2];}}var M = Math.min(r - g, V);for (p = 0; p <= M; p++) {for (f = 0; f <= c; f++) {m[g][p][0] += R[p][f] * L[f][0], m[g][p][1] += R[p][f] * L[f][1], m[g][p][2] += R[p][f] * L[f][2], C && (E[g][p] += R[p][f] * L[f][3]);}}}if (C) {var w = o.binomialCoefficients,N = n.Vector3.createFloat64();for (g = 0; g <= r; g++) {for (p = 0; p <= r - g; p++) {var F = m[g][p];for (y = 1; y <= p; y++) {n.Vector3.scaleAndAdd(F, F, m[g][p - y], -w[p][y] * E[0][y]);}for (_ = 1; _ <= g; _++) {for (n.Vector3.scaleAndAdd(F, F, m[g - _][p], -w[g][_] * E[_][0]), n.Vector3.set(N, 0, 0, 0), y = 1; y <= p; y++) {n.Vector3.scaleAndAdd(N, N, m[g - _][p - y], w[p][y] * E[_][y]);}n.Vector3.scaleAndAdd(F, F, N, -w[g][_]);}n.Vector3.scale(F, F, 1 / E[0][0]);}}}return m;}(e, t, r, a, c, u, l, h, d);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.newtonRaphson2D = t.RelaxResult = void 0;var n = r(1),o = {};o[o.Success = 0] = \"Success\", o[o.OutOfRange = 1] = \"OutOfRange\", o[o.DegenerateStep = 2] = \"DegenerateStep\", o[o.TooManySteps = 3] = \"TooManySteps\", o[o.RootNotFound = 4] = \"RootNotFound\", t.RelaxResult = o, t.newtonRaphson2D = function (e, t, r, i, s) {i = i || 1e-12, s = s || 100;var a = [void 0, void 0];r && 2 === r.length && (r[0] && 2 === r[0].length && (a[0] = r[0]), r[1] && 2 === r[1].length && (a[1] = r[1])), a[0] && (a[0][0], a[0][1]), a[1] && (a[1][0], a[1][1]);for (var c = [0, 0], u = 1 / 0, l = 1 / 0, h = !1, d = n.Matrix22.createFloat64(), g = n.Matrix22.createFloat64(), p = n.Vector2.clone(t), f = o.Success, v = 0; v <= s; v++) {var _ = e(p);if (u = n.Vector2.squaredLength(_.val), p[0], p[1], u < n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {f = o.Success;break;}if (v > 0) {var y = Math.max(Math.abs(c[0]), Math.abs(c[1]));if (y < i) {u >= l && (n.Vector2.sub(p, p, c), u = l, _ = e(p));var m = 10 * i * (n.Vector2.len(_.deriv1) + n.Vector2.len(_.deriv2)),E = m * m;f = u > E ? h ? o.OutOfRange : o.RootNotFound : o.Success;break;}}if (v === s) {u >= l && (n.Vector2.sub(p, p, c), u = l), f = o.TooManySteps;break;}if (v > 0 && u >= l) {var x = l / (l + u);x = Math.max(x, .1), n.Vector2.sub(p, p, c), n.Vector2.scale(c, c, x), n.Vector2.add(p, p, c), u = l;} else {if (l = u, n.Matrix22.set(d, -_.deriv1[0], -_.deriv1[1], -_.deriv2[0], -_.deriv2[1]), Math.abs(n.Matrix22.determinant(d)) < n.FLOAT64_TOLERANCE) {f = o.DegenerateStep;break;}n.Matrix22.invert(g, d), n.Vector2.transformMatrix22(c, _.val, g), c[0], c[1], n.Vector2.add(p, p, c), h = !1;for (var R = 0; R < 3; R++) {var A = R >= 2,P = R % 2;if (a[P]) {var V = 0;if (p[P] < a[P][0] ? (V = p[P] - a[P][0], p[P] = a[P][0]) : p[P] > a[P][1] && (V = p[P] - a[P][1], p[P] = a[P][1]), 0 !== V) {p[P];var T = c[P];if (c[P] -= V, A) ;else {var C = 1 - P;if (p[C] -= c[C], Math.abs(c[P]) > i) {var b = c[P] / T;c[C] *= b;} else {h = !0;var L = 0 === C ? _.deriv1 : _.deriv2;c[C] = -n.Vector2.dot(_.val, L) / Math.max(n.Vector2.dot(L, L), n.FLOAT64_TOLERANCE);}p[C] += c[C], c[0], c[1];}}}}}}return o[f], p[0], p[1], { param: p, status: f };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.getOrderedFacesOnVertex = function (e) {var t = e.getEdges(),r = new n(e),o = [];return t.forEach(function (t) {var n = t.getCoedges();for (var _t6 = 0; _t6 < n.length; ++_t6) {if (n[_t6].getStartVertex() === e) {var _e3 = r.marchFan(n[_t6]);_e3.faces.length > 0 && o.push(_e3);break;}}}), o;};var n = /*#__PURE__*/function () {function n(e) {_classCallCheck(this, n);this._vertex = e, this._visitedCoeds = new Set(), this._unvisitedCoeds = new Set(), this._faces = [], this._type = \"unset\";}_createClass(n, [{ key: \"addVisitedCoedge\", value: function addVisitedCoedge(e) {this._visitedCoeds.add(e), this._unvisitedCoeds.delete(e);} }, { key: \"getNextFace\", value: function getNextFace(e) {var t = e.getFace();t && this._faces.push(t), this.addVisitedCoedge(e);} }, { key: \"getPrevFace\", value: function getPrevFace(e) {var t = e.getFace();t && this._faces.unshift(t), this.addVisitedCoedge(e);} }, { key: \"collectUnvisitedCoeds\", value: function collectUnvisitedCoeds(e) {var _this = this;e.getEdge().getCoedges().forEach(function (e) {_this._visitedCoeds.has(e) || e.getStartVertex() !== _this._vertex || _this._unvisitedCoeds.add(e);});} }, { key: \"nextFace\", value: function nextFace(e) {var t = e.getPartner();if (!t) return void (\"unset\" === this._type && (this._type = \"chain\"));if (this._visitedCoeds.has(t)) return;if (t.getPartner() !== e && (this._type = \"unordered\", this.collectUnvisitedCoeds(e)), t.getEndVertex() !== this._vertex) return this._type = \"unordered\", void this.collectUnvisitedCoeds(t);this.addVisitedCoedge(t);var r = t.getNext();if (!this._visitedCoeds.has(r)) return this.getNextFace(r), r;\"unset\" === this._type && (this._type = \"cycle\");} }, { key: \"prevFace\", value: function prevFace(e) {var t = e.getPrevious();if (this._visitedCoeds.has(t)) return;var r = t.getPartner();return r && !this._visitedCoeds.has(r) ? (r.getPartner() !== t && (this._type = \"unordered\", this.collectUnvisitedCoeds(t)), r.getStartVertex() !== this._vertex ? (this._type = \"unordered\", void this.collectUnvisitedCoeds(r.getNext())) : (this.addVisitedCoedge(t), this.getPrevFace(r), r)) : void 0;} }, { key: \"collectFanFaces\", value: function collectFanFaces(e) {if (this._visitedCoeds.has(e)) return;var t = e;this.getNextFace(t);var r = t;for (; r;) {r = this.nextFace(r);}for (r = t; r;) {r = this.prevFace(r);}} }, { key: \"marchFan\", value: function marchFan(e) {for (this._faces = [], this._type = \"unset\", this.collectFanFaces(e); this._unvisitedCoeds.size > 0;) {var _e4 = this._unvisitedCoeds.values();this.collectFanFaces(_e4.next().value);}return { faces: this._faces, type: this._type };} }]);return n;}();}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Attribute = void 0;var n = r(44);var o = { \"autodesk.brep:nmiattributestr-1.0.0\": \"nmiattributestr\", \"autodesk.brep:nmiattributearr-1.0.0\": \"nmiattributearr\", \"autodesk.brep:textattribute-1.0.0\": \"textattribute\" };var i = function i(e, t) {n.Base.call(this), this._topologies = [], this.typeid = e, this.values = t || {};};(i.prototype = Object.create(n.Base.prototype)).getValues = function () {return this.values;}, i.prototype.getTypeid = function () {return this.typeid;}, i.prototype.getTopologies = function () {return this._topologies;}, i.prototype.addTopology = function (e) {this._topologies ? this._topologies.push(e) : this._topologies = [e];}, i.prototype.removeTopology = function (e) {var t = this._topologies.indexOf(e);return t > -1 && (this._topologies.splice(t, 1), !0);}, i.prototype.toObject = function () {return this.values;}, i.prototype.addToModelObject = function (e) {if (!e.attributes[this.getGuid()]) {var _t7 = o[this.typeid];if (_t7) {var _r4 = {};_r4[_t7] = this.toObject(), e.attributes[this.getGuid()] = _r4;} else console.warn(\"Attribute.addToModelObject : Unknown attribute type for proto object!\");}}, t.Attribute = i;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SketchRegionSolver = void 0;var n = r(1),o = r(3),i = r(0),s = r(18),a = r(7),c = r(14),u = r(33),l = r(23),h = r(6),d = r(13),g = r(27),p = r(81),f = r(82),v = r(56),_ = r(36),y = r(55),m = r(41),E = r(112),x = r(113),R = r(2),A = r(8),P = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),V = function V() {this.SIDE = { LEFT: 0, RIGHT: 1 }, this._sketch = void 0, this._intersectionVertices = [], this._edgeSegments = [], this._cells = [], this._faces = [], this._workspace = { edgeIntersections: [], edgeOverlapRegions: [], segmentBlackList: [], edges: [], edgeIDs: [], sweepLineIntersections: void 0, sweepLineRegions: void 0, currentVertex: void 0, nextVertex: void 0, edgesPerCell: void 0 }, this._sketchRegionTopologies = {}, this._planeGeometry = new s.Plane(), this._planeGeometry.set([0, 0, 0], [0, 0, 1], [1, 0, 0]), this._sketchSummary = {}, this._internalToFinalMap = null, this._finalFaces = [], this._progenitorMap = null;};V.prototype.compute = function (e) {this._sketchEdges = e, this._initializeWorkspace(), this._findIntersections(), this._addGraphEdges(), this._mergeCoincidentSegments(), this._sortEdgesAroundVertex(), this._assignAdjacentEdges(), this._sweepRegions(), this._assignleftmostEdges(), this._removeGrazingIntersectionVertices(), this._updateVertexGuidLists(), this._removeTemporaryVertices(), this._assignLoops(), this._updateSketchRegionTopology(), this._clearWorkspace(), this._prepareResult();}, V.prototype._initializeWorkspace = function () {var e = this._workspace;e.edges = {};for (var t = 0; t < this._sketchEdges.length; ++t) {e.edges[this._sketchEdges[t].getGuid()] = this._sketchEdges[t];}for (e.edgeIDs = Object.getOwnPropertyNames(e.edges).sort(), e.edgeIntersections = {}, e.edgeOverlapRegions = {}, e.segmentBlackList = {}, t = 0; t < e.edgeIDs.length; t++) {e.edgeIntersections[e.edgeIDs[t]] = [], e.edgeOverlapRegions[e.edgeIDs[t]] = [], e.segmentBlackList[e.edgeIDs[t]] = [];}e.sweepLineIntersections = void 0, e.sweepLineRegions = void 0, e.edgesPerCell = [], this._faces = [];}, V.prototype._clearWorkspace = function () {this._workspace = { edgeIntersections: [], edgeOverlapRegions: [], segmentBlackList: [], edges: [], edgeIDs: [], sweepLineIntersections: void 0, sweepLineRegions: void 0, currentVertex: void 0, nextVertex: void 0, sweepLinePosition: void 0, edgesPerCell: [] };}, V.prototype._findIntersections = function () {for (var e = this._workspace, t = 0; t < e.edgeIDs.length; t++) {for (var r = e.edges[e.edgeIDs[t]], s = t; s < e.edgeIDs.length; s++) {var a = e.edges[e.edgeIDs[s]];if (s > t || r.getCurveType() === i.GEOMETRY_TYPES.BCURVE) for (var c = (0, p.computeCurveCurveIntersections)(r, a, !0, !1, i.KERNEL_TOLERANCE), u = 0; u < c.length; u++) {var l = c[u];if (l.rangeInfo) e.edgeIntersections[e.edgeIDs[t]].push(P.default.extend(l.rangeInfo[0], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[t]].push(P.default.extend(l.rangeInfo[1], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.extend(l.rangeByInfo[0], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.extend(l.rangeByInfo[1], { temporary: !1 })), e.edgeOverlapRegions[e.edgeIDs[t]].push({ overlapRange: (0, o.convertToOtherPeriodicRange)([l.rangeInfo[0].param, l.rangeInfo[1].param], r.getRange(), r.getCurve().getPeriod(), i.KERNEL_TOLERANCE), otherEdge: e.edgeIDs[s], otherRange: (0, o.convertToOtherPeriodicRange)([l.rangeByInfo[0].param, l.rangeByInfo[1].param], a.getRange(), a.getCurve().getPeriod(), i.KERNEL_TOLERANCE) }), e.edgeOverlapRegions[e.edgeIDs[s]].push({ overlapRange: (0, o.convertToOtherPeriodicRange)([l.rangeByInfo[0].param, l.rangeByInfo[1].param], a.getRange(), a.getCurve().getPeriod(), i.KERNEL_TOLERANCE), otherEdge: e.edgeIDs[t], otherRange: (0, o.convertToOtherPeriodicRange)([l.rangeInfo[0].param, l.rangeInfo[1].param], r.getRange(), r.getCurve().getPeriod(), i.KERNEL_TOLERANCE) });else {if (l.cutInfo.param < r.t0() || l.cutInfo.param > r.t1()) {A.DebugUtils.warn(\"Intersection outside the bounds of the edge, ignoring\");continue;}e.edgeIntersections[e.edgeIDs[t]].push(P.default.defaults(l.cutInfo, { temporary: !1, virtualIntersection: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.defaults(l.cutByInfo, { temporary: !1, virtualIntersection: !1 }));}}}var h = r.getStartVertex(),d = r.getEndVertex(),g = r.t0();h && void 0 !== P.default.findWhere(e.edgeIntersections[e.edgeIDs[t]], { param: g, atVertex: h }) || e.edgeIntersections[e.edgeIDs[t]].push({ param: g, atVertex: h, temporary: !1, virtualIntersection: void 0 });var f = r.t1();d && void 0 !== P.default.findWhere(e.edgeIntersections[e.edgeIDs[t]], { param: f, atVertex: d }) || e.edgeIntersections[e.edgeIDs[t]].push({ param: f, atVertex: d, temporary: !1, virtualIntersection: void 0 }), this._makeEdgeXMonotone(r, e.edgeIntersections[e.edgeIDs[t]]);}var v = [];for (t = 0; t < e.edgeIDs.length; t++) {for (s = 0; s < e.edgeIntersections[e.edgeIDs[t]].length; s++) {v.push({ position: e.edges[e.edgeIDs[t]].evaluatePosition(e.edgeIntersections[e.edgeIDs[t]][s].param), virtualIntersection: e.edgeIntersections[e.edgeIDs[t]][s].virtualIntersection });}}for (t = 0; t < e.edgeIDs.length; t++) {var _ = e.edges[e.edgeIDs[t]];for (s = 0; s < v.length; s++) {var y = v[s];if (_.getBoundingBox().isPointInsideWithTolerance(y.position, i.KERNEL_TOLERANCE)) {var m = _.closestToPointParam(y.position);n.Vector3.distance(y.position, _.evaluatePosition(m)) < i.KERNEL_TOLERANCE && m > _.t0() + i.PARAMETER_SPACE_TOLERANCE && m < _.t1() - i.PARAMETER_SPACE_TOLERANCE && e.edgeIntersections[e.edgeIDs[t]].push({ param: m, atVertex: null, temporary: !0, virtualIntersection: y.virtualIntersection });}}}}, V.prototype._addGraphEdges = function () {var e = this._workspace;this._intersectionVertices = [], this._edgeSegments = [];for (var t = function t(_t8, r) {var n = e.segmentBlackList[_t8],s = e.edges[_t8].getCurve(),a = s.getPeriod(),c = e.edges[_t8].isReversed() ? -1 : 1,u = i.KERNEL_TOLERANCE / s.tangentLength(c * r[0]),l = i.KERNEL_TOLERANCE / s.tangentLength(c * r[1]);if (e.edges[_t8].getCurve().isPeriodic()) {for (var h = 0; h < n.length; h++) {if ((0, o.periodicDifference)(n[h].range[0], r[0], a) < u && (0, o.periodicDifference)(n[h].range[1], r[1], a) < l) return n[h].edge;}} else for (h = 0; h < n.length; h++) {if (Math.abs(n[h].range[0] - r[0]) < u && Math.abs(n[h].range[1] - r[1]) < l) return n[h].edge;}}, r = 0; r < e.edgeIDs.length; r++) {var s = e.edges[e.edgeIDs[r]],a = 1,c = this._createGUIDfromEdgeAndLocalID(s, a);e.edgeIntersections[e.edgeIDs[r]] = e.edgeIntersections[e.edgeIDs[r]].sort(function (e, t) {return e.param - t.param;});for (var u = e.edgeIntersections[e.edgeIDs[r]], l = void 0, h = 0; h < u.length; h++) {var d = s.evaluatePosition(u[h].param),g = this._findVertexIndex(d);void 0 === g ? (g = this._intersectionVertices.length, this._intersectionVertices.push({ position: d, adjacentEdges: [], vertices: [], index: g, guidList: [], mergedPositions: [], topologyVertex: void 0, temporary: u[h].temporary, virtualIntersection: u[h].virtualIntersection })) : (this._intersectionVertices[g].temporary = this._intersectionVertices[g].temporary && u[h].temporary, void 0 !== u[h].virtualIntersection && (void 0 === this._intersectionVertices[g].virtualIntersection ? this._intersectionVertices[g].virtualIntersection = u[h].virtualIntersection : this._intersectionVertices[g].virtualIntersection = this._intersectionVertices[g].virtualIntersection && u[h].virtualIntersection), this._intersectionVertices[g].mergedPositions.push(d));var p = this._intersectionVertices[g];if (u[h].atVertex && -1 === p.vertices.indexOf(u[h].atVertex) && p.vertices.push(u[h].atVertex), h > 0 && l !== g) {c = this._createGUIDfromEdgeAndLocalID(s, a), a++;var f = [u[h - 1].param, u[h].param],v = t(s.getGuid(), f);if (void 0 === v) {var _ = { originalEdge: s, parameterRange: f, startVertex: this._intersectionVertices[l], endVertex: this._intersectionVertices[g], coincidentRanges: [], adjacent: [{ prevEdge: void 0, nextEdge: void 0, face: void 0 }, { prevEdge: void 0, nextEdge: void 0, face: void 0 }], index: this._edgeSegments.length, localGuid: c, topologyEdge: void 0 };this._edgeSegments.push(_), this._intersectionVertices[l].adjacentEdges.push(_), this._intersectionVertices[g].adjacentEdges.push(_);for (var y = 0; y < e.edgeOverlapRegions[e.edgeIDs[r]].length; y++) {var m = e.edgeOverlapRegions[e.edgeIDs[r]][y],E = f,x = i.KERNEL_TOLERANCE;if (s.getCurve().isPeriodic() && (s.getCurveType() === i.GEOMETRY_TYPES.CIRCLE && (x /= s.getCurve().getRadius()), E = (0, o.convertToOtherPeriodicRange)(E, s.getRange(), s.getCurve().getPeriod(), x)), E[0] >= m.overlapRange[0] - i.KERNEL_TOLERANCE && E[1] <= m.overlapRange[1] + i.KERNEL_TOLERANCE) {var R = m.otherEdge,A = [e.edges[R].getCurve().closestToPointParam(_.startVertex.position), e.edges[R].getCurve().closestToPointParam(_.endVertex.position)];if (e.edges[R].getCurve().isPeriodic()) {var P = _.originalEdge.getCurve().evaluateDt(_.parameterRange[0]),V = e.edges[R].getCurve().evaluateDt(A[0]);for (n.Vector3.dot(P, V) < 0 && (T = A[0], A[0] = A[1], A[1] = T); A[1] < A[0];) {A[1] += e.edges[R].getCurve().getPeriod();}} else if (A[0] > A[1]) {var T = A[0];A[0] = A[1], A[1] = T;}e.segmentBlackList[m.otherEdge].push({ range: A, edge: _ });}}} else {var C,b = n.Vector3.distance(v.startVertex.position, s.evaluatePosition(f[0])) > n.Vector3.distance(v.startVertex.position, s.evaluatePosition(f[1]));if (v.coincidentRanges.push({ originalEdge: s, parameterRange: f, localGuid: c, flipped: b }), 0 === p.adjacentEdges.length && ((C = n.Vector3.distance(d, v.startVertex.position) < n.Vector3.distance(d, v.endVertex.position) ? v.startVertex : v.endVertex).mergedPositions.push(d), d = C.position, g = C.index, u[h].atVertex && -1 === C.vertices.indexOf(u[h].atVertex) && C.vertices.push(u[h].atVertex), this._intersectionVertices.pop()), v.startVertex.index !== l && v.endVertex.index !== l) {var L = v.startVertex.index === g ? v.endVertex : v.startVertex,O = this._intersectionVertices[l];for (y = 0; y < O.adjacentEdges.length; y++) {var S = O.adjacentEdges[y];S.startVertex === O && (S.startVertex = L), S.endVertex === O && (S.endVertex = L), L.adjacentEdges.push(S);}for (L.mergedPositions.push(O.position), y = 0; y < O.mergedPositions.length; y++) {L.mergedPositions.push(O.mergedPositions[y]);}for (u[h].atVertex && -1 === L.vertices.indexOf(u[h].atVertex) && L.vertices.push(u[h].atVertex), this._intersectionVertices.splice(l, 1), y = l; y < this._intersectionVertices.length; y++) {this._intersectionVertices[y].index = y;}}}}l = g;}}}, V.prototype._mergeCoincidentSegments = function () {for (var e, t = {}, r = 0; r < this._intersectionVertices.length; r++) {for (var n = this._intersectionVertices[r], o = {}, s = 0; s < n.adjacentEdges.length; s++) {var a = (e = n.adjacentEdges[s]).startVertex === n ? e.endVertex : e.startVertex;t[String(n.index) + \"_\" + String(a.index)] || (o[String(a.index)] = o[String(a.index)] || [], o[String(a.index)].push(e));}var c = P.default.keys(o);for (s = 0; s < c.length; s++) {if (t[c[s] + \"_\" + String(n.index)] = !0, o[c[s]].length > 1) for (var u = o[c[s]], l = 0; l < u.length; l++) {for (var h = [], d = l + 1; d < u.length; d++) {(0, f.curvesAreCoincident)(u[l].originalEdge.getCurve(), u[d].originalEdge.getCurve(), u[l].parameterRange, u[d].parameterRange, i.KERNEL_TOLERANCE) && (h.push(u[d]), u.splice(d, 1), d--);}for (d = 0; d < h.length; d++) {var g = h[d];u[l].coincidentRanges.push({ originalEdge: g.originalEdge, parameterRange: g.parameterRange, localGuid: g.localGuid, flipped: g.startVertex !== u[l].startVertex }), g.startVertex.adjacentEdges.splice(g.startVertex.adjacentEdges.indexOf(g), 1), g.endVertex.adjacentEdges.splice(g.endVertex.adjacentEdges.indexOf(g), 1);var p = this._edgeSegments.indexOf(g);this._edgeSegments.splice(p, 1);for (var v = p; v < this._edgeSegments.length; v++) {this._edgeSegments[v].index = v;}}}}}}, V.prototype._sortEdgesAroundVertex = function () {for (var e = 0; e < this._intersectionVertices.length; e++) {for (var t = this._intersectionVertices[e], r = [], s = 0; s < t.adjacentEdges.length; s++) {var a = this._computeAngleAndPositionForEdge(s, t);r.push({ index: s, originalAngle: a.angle, angle: a.angle, position: a.position, derivative: void 0 });}for (var c = 0, u = !1; !u;) {u = !0;var l = -Math.PI + c;for (s = 0; s < r.length; s++) {if ((0, o.angleDifference)(l, r[s].angle) < 1e-5) {u = !1;break;}}if (u) break;c += 2e-5;}for (s = 0; s < t.adjacentEdges.length; s++) {r[s].angle = (0, o.normalizeParameterToShiftedRange)(r[s].angle - c, [-Math.PI, Math.PI]);}var h = this;r = r.sort(function (e, r) {if ((0, o.angleDifference)(e.angle, r.angle) > 1e-5) return e.angle - r.angle;var s = t.adjacentEdges[e.index],a = t.adjacentEdges[r.index],c = s.startVertex === t ? s.parameterRange[0] : s.parameterRange[1],u = a.startVertex === t ? a.parameterRange[0] : a.parameterRange[1],l = s.originalEdge.evaluatePosition(c),d = a.originalEdge.evaluatePosition(u),g = n.Vector3.distance(l, d),p = n.Vector3.createFloat64(),f = n.Vector3.createFloat64(),v = s.originalEdge.evaluateCurvature(c, p),_ = a.originalEdge.evaluateCurvature(u, f);if (0 === v && 0 === _) return e.angle - r.angle;if (0 === v || 0 === _) {var y = 1 / Math.max(v, _);g += 1.5 * Math.sqrt(Math.pow(y, 2) - Math.pow(y - g, 2)) + i.KERNEL_TOLERANCE;} else {var m = 1 / v,E = 1 / _;if (m < E) {var x = m;m = E, E = x;}n.Vector3.dot(p, f) < 0 ? g += -Math.sqrt(-.25 * Math.pow(g, 4) + Math.pow(g, 3) * m - g * g * m * m - (g * g - 2 * g * m) * E * E + (g * g * g - 3 * g * g * m + 2 * g * m * m) * E) / (g - m - E) * 1.5 : g += Math.sqrt(-.25 * Math.pow(g, 4) - Math.pow(g, 3) * m - g * g * m * m - (g * g + 2 * g * m) * E * E + (g * g * g + 3 * g * g * m + 2 * g * m * m) * E) / (g + m - E) * 1.5;}var R = Math.min(n.Vector3.distance(s.endVertex.position, s.startVertex.position), n.Vector3.distance(a.endVertex.position, a.startVertex.position));g = Math.max(i.KERNEL_TOLERANCE, g), g = Math.min(.9 * R, g);var A = !1;do {var P = h._computeEdgeDirectionAtVertex(e, t, g),V = h._computeEdgeDirectionAtVertex(r, t, g);A = (0, o.angleDifference)(P, V) > 1e-8, g *= 5;} while (!A && g < R);var T = P - V;return T > Math.PI ? T -= o.PI2 : T < -Math.PI && (T += o.PI2), T;}), t.adjacentEdges = P.default.map(r, function (e) {return t.adjacentEdges[e.index];});}}, V.prototype._assignAdjacentEdges = function () {for (var e = 0; e < this._edgeSegments.length; e++) {var t = this._edgeSegments[e];this._assignAdjacentEdgesToSegment(t);}}, V.prototype._assignAdjacentEdgesToSegment = function (e) {var t = e.startVertex.adjacentEdges,r = t.indexOf(e);R.ConsoleUtils.assert(-1 !== r, \"Error in topology\");for (var n = 0, i = e.endVertex.adjacentEdges; n < i.length && i[n] !== e;) {n++;}R.ConsoleUtils.assert(n < i.length, \"Error in topology\"), e.adjacent[this.SIDE.LEFT].nextEdge = i[(0, o.modulus)(n - 1, i.length)], e.adjacent[this.SIDE.LEFT].prevEdge = t[(0, o.modulus)(r + 1, t.length)], e.adjacent[this.SIDE.RIGHT].nextEdge = i[(0, o.modulus)(n + 1, i.length)], e.adjacent[this.SIDE.RIGHT].prevEdge = t[(0, o.modulus)(r - 1, t.length)];}, V.prototype._sweepRegions = function () {var e = this._workspace,t = P.default.clone(this._intersectionVertices).sort(function (e, t) {if (Math.abs(e.position[0] - t.position[0]) < 1e-9) {for (var r = 0; r < e.adjacentEdges.length; r++) {for (var o = 0; o < t.adjacentEdges.length; o++) {if (e.adjacentEdges[r].originalEdge === t.adjacentEdges[o].originalEdge) {var s = e.adjacentEdges[r],a = t.adjacentEdges[o],c = s.startVertex === e ? s.parameterRange[0] : s.parameterRange[1],u = a.startVertex === t ? a.parameterRange[0] : a.parameterRange[1],l = !0,h = n.Vector3.createFloat64();n.Vector3.normalize(h, s.originalEdge.evaluateDt(c));var d = n.Vector3.createFloat64();if (n.Vector3.normalize(d, a.originalEdge.evaluateDt(u)), Math.sign(h[0]) !== Math.sign(d[0])) continue;if (Math.abs(h[0]) > i.KERNEL_TOLERANCE && Math.abs(d[0]) > i.KERNEL_TOLERANCE) l = h[0] > 0;else {if (Math.abs(e.position[1] - t.position[1]) < i.KERNEL_TOLERANCE) continue;l = h[1] > 0;}return (c - u) * (l ? 1 : -1);}}}return e.position[1] - t.position[1];}return e.position[0] - t.position[0];});this._cells = [];var r = { index: -1, loops: [], loopOrientations: [], dangling: [], leftmostVertex: void 0 };e.sweepLineIntersections = [-1 / 0, 1 / 0], e.sweepLineRegions = e.sweepLineRegions = [r];for (var o = [], s = 0; s < t.length; s++) {e.sweepLineRegions.length !== e.sweepLineIntersections.length - 1 && console.error(\"Error during sweep computation\");var a = t[s],c = P.default.clone(a.adjacentEdges),u = void 0;if (o[a.index]) {for (var l = o[a.index], h = [], d = 0; d < e.sweepLineIntersections.length - 1; d++) {P.default.contains(l, e.sweepLineIntersections[d]) && (void 0 === u && (u = d - 1), P.default.contains(l, e.sweepLineIntersections[d + 1]) && h.push(d));}for (d = 0; d < l.length; d++) {for (var g = l[d], p = 0; p < e.sweepLineIntersections.length; p++) {e.sweepLineIntersections[p] === g && e.sweepLineIntersections.splice(p, 1);}for (p = 0; p < c.length; p++) {c[p] === g && c.splice(p, 1);}}for (d = h.length - 1; d >= 0; d--) {e.sweepLineRegions.splice(h[d], 1);}} else u = this._findVertexOnSweepLine(a), e.sweepLineRegions.splice(u + 1, 0, e.sweepLineRegions[u]);if (c.length > 0) {var f = u + 1;for (d = 0; d < c.length; d++) {var v = c[d];e.sweepLineIntersections.splice(f, 0, v);var _ = v.startVertex === a ? v.endVertex : v.startVertex;if (void 0 === o[_.index] && (o[_.index] = []), o[_.index].push(v), d > 0) {var y = { index: this._cells.length, loops: [], loopOrientations: [], dangling: [], leftmostVertex: a };this._cells.push(y), e.sweepLineRegions.splice(f - 1, 0, y);}f++;}for (f = u, d = 0; d < c.length; d++) {var m = (v = c[d]).startVertex !== a;v.adjacent[m ? this.SIDE.RIGHT : this.SIDE.LEFT].face = e.sweepLineRegions[f + 1], v.adjacent[m ? this.SIDE.LEFT : this.SIDE.RIGHT].face = e.sweepLineRegions[f], f++;}} else if (e.sweepLineRegions[u] !== e.sweepLineRegions[u + 1]) {var E = e.sweepLineRegions[u + 1],x = e.sweepLineRegions[u];for (x === r ? (x = E, E = r, e.sweepLineRegions.splice(u, 1)) : (void 0 !== x.leftmostVertex && (void 0 === E.leftmostVertex || E.leftmostVertex.position[0] > x.leftmostVertex.position[0]) && (E.leftmostVertex = x.leftmostVertex), e.sweepLineRegions.splice(u + 1, 1)), d = 0; d < this._edgeSegments.length; d++) {this._edgeSegments[d].adjacent[this.SIDE.LEFT].face === x && (this._edgeSegments[d].adjacent[this.SIDE.LEFT].face = E), this._edgeSegments[d].adjacent[this.SIDE.RIGHT].face === x && (this._edgeSegments[d].adjacent[this.SIDE.RIGHT].face = E);}for (d = 0; d < e.sweepLineRegions.length; d++) {e.sweepLineRegions[d] === x && (e.sweepLineRegions[d] = E);}this._cells[x.index] = void 0;} else e.sweepLineRegions.splice(u + 1, 1);}for (s = 0; s < this._cells.length; s++) {void 0 === this._cells[s] && (this._cells.splice(s, 1), s--);}for (s = 0; s < this._cells.length; s++) {this._cells[s].index = s;}}, V.prototype._assignleftmostEdges = function () {for (var e = this, t = 0; t < this._cells.length; t++) {var r = this._cells[t],n = r.leftmostVertex,o = P.default.filter(n.adjacentEdges, function (t) {var n = t.adjacent[e.SIDE.LEFT].face,o = t.adjacent[e.SIDE.RIGHT].face;return (n === r || o === r) && n !== o;});if (R.ConsoleUtils.assert(o.length >= 2, \"In each loop there should be at least two adjacent edges\"), o.length > 2) for (var i = 0; i < o.length; i++) {var s = o[i].adjacent[e.SIDE.LEFT].face === r ? e.SIDE.LEFT : e.SIDE.RIGHT,a = o[i].adjacent[s],c = o[i].startVertex === n ? a.prevEdge : a.nextEdge;if (P.default.contains(o, c)) {o = [o[i], c];break;}}var u = o[0];u.loopsCurveAligned = !!(u.startVertex === n ^ o[0].adjacent[e.SIDE.RIGHT].face === r), r.leftmostEdge = u, r.leftmostVertex = void 0;}}, V.prototype._removeGrazingIntersectionVertices = function () {for (var e = {}, t = 0, r = this._intersectionVertices.slice(); r.length > 0;) {var n = r.pop();if (2 === n.adjacentEdges.length && (1 === n.adjacentEdges[0].coincidentRanges.length || 1 === n.adjacentEdges[1].coincidentRanges.length) && n.virtualIntersection) {var i,s,a = 1 === n.adjacentEdges[0].coincidentRanges.length && 1 === n.adjacentEdges[1].coincidentRanges.length,c = n.adjacentEdges.slice();if (a) {if (i = [c[0].originalEdge, c[0].coincidentRanges[0].originalEdge], s = [c[1].originalEdge, c[1].coincidentRanges[0].originalEdge], !(i[0] === s[0] && i[1] === s[1] || i[0] === s[1] && i[1] === s[0])) continue;e[c[0].originalEdge.getGuid()] = !0, e[c[0].coincidentRanges[0].originalEdge.getGuid()] = !0, e[c[1].originalEdge.getGuid()] = !0, e[c[1].coincidentRanges[0].originalEdge] = !0;var u = [c[0].startVertex === n ? c[0].endVertex : c[0].startVertex, n, c[1].startVertex === n ? c[1].endVertex : c[1].startVertex];} else {var l;c[0].coincidentRanges.length > 0 ? (l = 0, i = [c[0].originalEdge, c[0].coincidentRanges[0].originalEdge]) : (l = 1, i = [c[1].originalEdge, c[1].coincidentRanges[0].originalEdge]), e[i[0].getGuid()] = !0, e[i[1].getGuid()] = !0, u = [c[l].startVertex === n ? c[l].endVertex : c[l].startVertex, n], c = [c[l]];}var h = void 0,d = void 0;if (u[0].vertices.length > 0 ? (h = u[0], d = a ? [u[1], u[2]] : [u[1]]) : a && u[2].vertices.length > 0 ? (h = u[2], d = [u[0], u[1]]) : (h = u[1], d = a ? [u[0], u[2]] : [u[0]]), d[0].vertices.length > 0 || d[1] && (d[1].vertices.length > 0 || d[0] === d[1])) continue;for (var g = !0, p = P.default.without(d, n), f = 0; f < p.length; f++) {var v = p[f].adjacentEdges;if ((v = P.default.difference(v, c)).length > 2) {g = !1;break;}for (var _ = 0; _ < v.length; _++) {if (v[_].coincidentRanges.length > 0 || v[_].originalEdge !== i[0] && v[_].originalEdge !== i[1]) {g = !1;break;}}}if (!g) continue;for (f = 0; f < p.length; f++) {var y = p[f],m = P.default.intersection(c, y.adjacentEdges)[0],E = n !== h && a ? P.default.without(c, m)[0] : m,x = P.default.without(y.adjacentEdges, m);for (y.adjacentEdges[1] === m && (x = x.reverse()), _ = 0; _ < x.length; _++) {var R = x[_],A = E.startVertex === h ? 0 : 1,V = void 0;if (E.originalEdge === R.originalEdge) V = E.parameterRange[A];else {var T = E.coincidentRanges[0].flipped ? 1 - A : A;V = E.coincidentRanges[0].parameterRange[T];}R.startVertex === y ? (R.startVertex = h, R.parameterRange[0] = V) : (R.endVertex = h, R.parameterRange[1] = V);for (var C = 0; C < R.adjacent.length; C++) {var b = R.adjacent[C].face;b.leftmostEdge !== m && b.leftmostEdge !== E || (R.loopsCurveAligned = b.leftmostEdge.loopsCurveAligned, b.leftmostEdge = R), (b.leftmostVertex === d[0] || void 0 !== d[1] && b.leftmostVertex === d[1]) && (b.leftmostVertex = h);}}var L = h.adjacentEdges.indexOf(E);Array.prototype.splice.apply(h.adjacentEdges, [L, 1].concat(x));var O = h.adjacentEdges.length,S = [(0, o.modulus)(L - 1, O), L, L + 1, (L + 2) % O];for (_ = 0; _ < S.length; _++) {var M = h.adjacentEdges[S[_]];this._assignAdjacentEdgesToSegment(M);}}this._intersectionVertices = P.default.difference(this._intersectionVertices, d), r = P.default.difference(r, d), this._edgeSegments = P.default.difference(this._edgeSegments, c), t++;}}if (t > 0) {for (var w = 0; w < this._intersectionVertices.length; w++) {this._intersectionVertices[w].index = w;}for (w = 0; w < this._edgeSegments.length; w++) {this._edgeSegments[w].index = w;}}var N = P.default.keys(e);for (w = 0; w < N.length; w++) {var F = N[w],I = [];for (f = 0; f < this._edgeSegments.length; f++) {for ((D = this._edgeSegments[f]).originalEdge.getGuid() === F && I.push([D, D.parameterRange[0]]), _ = 0; _ < D.coincidentRanges.length; _++) {D.coincidentRanges[_].originalEdge.getGuid() === F && I.push([D, D.coincidentRanges[_].parameterRange[0]]);}}for (I.sort(function (e, t) {return e[1] - t[1];}), f = 0; f < I.length; f++) {var D;for ((D = I[f][0]).originalEdge.getGuid() === F && (D.localGuid = this._createGUIDfromEdgeAndLocalID(D.originalEdge, f + 1)), _ = 0; _ < D.coincidentRanges.length; _++) {D.coincidentRanges[_].originalEdge.getGuid() === F && (D.coincidentRanges[_].localGuid = this._createGUIDfromEdgeAndLocalID(D.coincidentRanges[_].originalEdge, f + 1));}}}}, V.prototype._removeTemporaryVertices = function () {for (var e = 0, t = 0; t < this._intersectionVertices.length; t++) {var r = this._intersectionVertices[t];if (r.temporary && 2 === r.adjacentEdges.length && r.adjacentEdges[0].originalEdge === r.adjacentEdges[1].originalEdge && r.adjacentEdges[0] !== r.adjacentEdges[1]) {var n, o;r.adjacentEdges[0].endVertex === r ? (n = r.adjacentEdges[0], o = r.adjacentEdges[1]) : (n = r.adjacentEdges[1], o = r.adjacentEdges[0]), R.ConsoleUtils.assert(n.adjacent[this.SIDE.LEFT].face === o.adjacent[this.SIDE.LEFT].face), R.ConsoleUtils.assert(n.adjacent[this.SIDE.RIGHT].face === o.adjacent[this.SIDE.RIGHT].face);var s = n.parameterRange[1] - o.parameterRange[0],a = (n.originalEdge.isReversed() ? -1 : 1) * n.parameterRange[0],c = i.KERNEL_TOLERANCE / n.originalEdge.getCurve().tangentLength(a);if (n.originalEdge.getCurve().isPeriodic() && Math.abs(s - n.originalEdge.getCurve().getPeriod()) < c) n.parameterRange[1] = o.parameterRange[1] + s;else {if (Math.abs(s) > c) continue;n.parameterRange[1] = o.parameterRange[1];}n.endVertex = o.endVertex, n.adjacent[this.SIDE.LEFT].nextEdge = o.adjacent[this.SIDE.LEFT].nextEdge, n.adjacent[this.SIDE.RIGHT].nextEdge = o.adjacent[this.SIDE.RIGHT].nextEdge, n.adjacent[this.SIDE.LEFT].prevEdge === o && (n.adjacent[this.SIDE.LEFT].prevEdge = n), n.adjacent[this.SIDE.RIGHT].prevEdge === o && (n.adjacent[this.SIDE.RIGHT].prevEdge = n);var u = n.adjacent[this.SIDE.LEFT].nextEdge;u.adjacent[this.SIDE.LEFT].prevEdge === o && (u.adjacent[this.SIDE.LEFT].prevEdge = n), u.adjacent[this.SIDE.LEFT].nextEdge === o && (u.adjacent[this.SIDE.LEFT].nextEdge = n), u.adjacent[this.SIDE.RIGHT].prevEdge === o && (u.adjacent[this.SIDE.RIGHT].prevEdge = n), u.adjacent[this.SIDE.RIGHT].nextEdge === o && (u.adjacent[this.SIDE.RIGHT].nextEdge = n);var l = n.adjacent[this.SIDE.RIGHT].nextEdge;l.adjacent[this.SIDE.LEFT].prevEdge === o && (l.adjacent[this.SIDE.LEFT].prevEdge = n), l.adjacent[this.SIDE.LEFT].nextEdge === o && (l.adjacent[this.SIDE.LEFT].nextEdge = n), l.adjacent[this.SIDE.RIGHT].prevEdge === o && (l.adjacent[this.SIDE.RIGHT].prevEdge = n), l.adjacent[this.SIDE.RIGHT].nextEdge === o && (l.adjacent[this.SIDE.RIGHT].nextEdge = n), o.adjacent[this.SIDE.LEFT].face.leftmostEdge === o && (o.adjacent[this.SIDE.LEFT].face.leftmostEdge = n), o.adjacent[this.SIDE.RIGHT].face.leftmostEdge === o && (o.adjacent[this.SIDE.RIGHT].face.leftmostEdge = n), void 0 === n.loopsCurveAligned && (n.loopsCurveAligned = o.loopsCurveAligned), (0, v.hashCombine4xUint32)(n.localGuid, o.localGuid, n.localGuid);var h = n.endVertex.adjacentEdges.indexOf(o);n.endVertex.adjacentEdges[h] = n, this._intersectionVertices.splice(t, 1), this._edgeSegments.splice(o.index - e, 1), t--, e++;} else this._intersectionVertices[t].index -= e;}for (t = 0; t < this._edgeSegments.length; t++) {this._edgeSegments[t].index = t;}}, V.prototype._updateVertexGuidLists = function () {for (var e = 0; e < this._intersectionVertices.length; e++) {var t = this._intersectionVertices[e];if (t.vertices.length > 0) for (var r = 0; r < t.vertices.length; r++) {t.guidList.push((0, v.guidToUint32x4)(t.vertices[r].getGuid()));} else {var n = {};for (r = 0; r < t.adjacentEdges.length; r++) {var o = t.adjacentEdges[r];if (!n[o.index]) {n[o.index] = !0, t.guidList.push(o.localGuid);for (var i = 0; i < o.coincidentRanges.length; i++) {t.guidList.push(o.coincidentRanges[i].localGuid);}}}}}}, V.prototype._assignLoops = function () {var e = this._workspace;e.edgesPerCell = [];for (var t = 0; t < this._cells.length; t++) {e.edgesPerCell[t] = [];}for (t = 0; t < this._edgeSegments.length; t++) {var r = this._edgeSegments[t],n = r.adjacent[this.SIDE.LEFT].face.index;n >= 0 && e.edgesPerCell[n].push(r);var o = r.adjacent[this.SIDE.RIGHT].face.index;o >= 0 && n !== o && e.edgesPerCell[o].push(r);}var i = [];for (t = 0; t < this._cells.length; t++) {var s = [];i[t] = s;for (var a = this._followLoopFromEdge(this._cells[t].leftmostEdge, this._cells[t], !1, !0), c = 0; c < a.loop.length; c++) {s[a.loop[c].index] = !0;}this._cells[t].loops.push(a.loop), this._cells[t].loopOrientations.push(a.orientations);}for (t = 0; t < this._cells.length; t++) {s = i[t];for (var u = 0; u < e.edgesPerCell[t].length; u++) {var l = e.edgesPerCell[t][u];if (l.adjacent[this.SIDE.LEFT].face !== l.adjacent[this.SIDE.RIGHT].face) {if (!0 !== s[l.index]) {for (a = this._followLoopFromEdge(l, this._cells[t], !0, !1), c = 0; c < a.loop.length; c++) {s[a.loop[c].index] = !0;}this._cells[t].loops.push(a.loop), this._cells[t].loopOrientations.push(a.orientations);}} else this._cells[t].dangling.push(l);}}}, V.prototype._updateSketchRegionTopology = function () {for (var e = this._workspace, t = P.default.keys(this._sketchRegionTopologies), r = 0; r < t.length; r++) {var n = t[r];this._sketchRegionTopologies[n].updated = !1, \"FaceID\" === this._sketchRegionTopologies[n].topology.tuid && this._sketchRegionTopologies[n].topology.removeAllEdges();}var o = {},s = {};for (r = 0; r < this._intersectionVertices.length; r++) {var a = this._addOrFindTopologySubcomponent(\"VertexID\", i.GEOMETRY_TYPES.POINT, this._intersectionVertices[r].guidList, s);a.setPoint(new h.Point(this._intersectionVertices[r].position)), a.setAssociatedEntities(P.default.clone(this._intersectionVertices[r].vertices));for (var c = 0; c < this._intersectionVertices[r].vertices.length; ++c) {var u = this._intersectionVertices[r].vertices[c].getGuid();R.ConsoleUtils.assert(!o[u], \"vertex should only map to one topology vertex\"), o[u] = a;}this._intersectionVertices[r].topologyVertex = a;}for (r = 0; r < this._edgeSegments.length; r++) {var l = this._edgeSegments[r],p = [l.localGuid];for (c = 0; c < l.coincidentRanges.length; c++) {p.push(l.coincidentRanges[c].localGuid);}(V = this._addOrFindTopologySubcomponent(\"EdgeID\", l.originalEdge.getCurveType(), p, s)).setToEdgeSegment(l.originalEdge, l.parameterRange), V.setStartVertex(l.startVertex.topologyVertex), V.setEndVertex(l.endVertex.topologyVertex);var f = [{ edge: l.originalEdge, range: P.default.clone(l.parameterRange), flipped: !1 }];for (c = 0; c < l.coincidentRanges.length; c++) {f.push({ edge: l.coincidentRanges[c].originalEdge, range: P.default.clone(l.coincidentRanges[c].parameterRange), flipped: l.coincidentRanges[c].flipped });}V.setAssociatedEdges(f), l.topologyEdge = V;}for (r = 0; r < this._cells.length; r++) {var _ = this._cells[r];for (p = [], c = 0; c < e.edgesPerCell[r].length; c++) {p.push((0, v.guidToUint32x4)(e.edgesPerCell[r][c].topologyEdge.getGuid()));}var y = this._addOrFindTopologySubcomponent(\"FaceID\", i.GEOMETRY_TYPES.PLANE, p, s);y.setSurface(this._planeGeometry);var m = [];for (c = 0; c < _.loops.length; c++) {var E = new d.Loop();E.setFace(y), m.push(E);for (var x = [], A = 0; A < _.loops[c].length; A++) {var V = _.loops[c][A].topologyEdge,T = new g.Coedge();T.setLoop(E), x.push(T), T.setEdge(V), T.setReversed(!_.loopOrientations[c][A]), V.getCoedge() ? V.getCoedge().getPartner() || (V.getCoedge().setPartner(T), T.setPartner(V.getCoedge())) : V.setCoedge(T), _.loops[c][A].topologyEdge.setIsDangling(!1);}E.setCoedges(x);}for (y.setLoops(m), this._faces.push(y), c = 0; c < _.dangling.length; c++) {y.addDanglingEdge(_.dangling[c].topologyEdge), _.dangling[c].topologyEdge.setIsDangling(!0);}}for (r = 0; r < t.length; r++) {this._sketchRegionTopologies[t[r]].updated || delete this._sketchRegionTopologies[t[r]];}}, V.prototype._followLoopFromEdge = function (e, t, r, n) {var o = [],i = [],s = e,a = [],c = e.adjacent[this.SIDE.LEFT].face === t ? this.SIDE.LEFT : this.SIDE.RIGHT,u = !!(s.loopsCurveAligned ^ c !== this.SIDE.LEFT),l = u ? e.startVertex : e.endVertex;do {if (s.adjacent[c].face !== t) {console.error(\"REGION: Adjacent edge face does not match cell! FIXME!\");break;}if (a[s.index]) {console.error(\"REGION: Malformed edges; walking edge lead us to despair\");break;}a[s.index] = !0, o.push(s), i.push(u);do {u ? (l = s.endVertex, s = s.adjacent[c].nextEdge) : (l = s.startVertex, s = s.adjacent[c].prevEdge), s.startVertex === s.endVertex ? c = s.adjacent[this.SIDE.LEFT].face === t ? this.SIDE.LEFT : this.SIDE.RIGHT : (c = s.startVertex === l ? this.SIDE.LEFT : this.SIDE.RIGHT, s.adjacent[this.SIDE.LEFT].face === s.adjacent[this.SIDE.RIGHT].face && (c = 1 - c, l = s.startVertex === l ? s.endVertex : s.startVertex)), u = c === this.SIDE.LEFT;} while (s.adjacent[this.SIDE.LEFT].face === s.adjacent[this.SIDE.RIGHT].face);n && void 0 === s.loopsCurveAligned && (s.loopsCurveAligned = !!(u ^ c !== this.SIDE.LEFT));} while (s !== e);return { loop: o, orientations: i };}, V.prototype._addNewRegionTopology = function (e) {switch (e.tuid) {case \"VertexID\":var t = new E.RegionTopologyVertex(new h.Point());return t.setGuid(e.guid), t;case \"EdgeID\":var r = void 0;switch (e.minortype) {case i.GEOMETRY_TYPES.LINE:r = new a.Line();break;case i.GEOMETRY_TYPES.CIRCLE:r = new c.Circle();break;case i.GEOMETRY_TYPES.ELLIPSE:r = new l.Ellipse();break;case i.GEOMETRY_TYPES.BCURVE:r = new u.BCurve();break;default:console.error(\"Unhandled curve type\");}var n = new E.RegionTopologyEdge(r);return n.setGuid(e.guid), n;case \"FaceID\":switch (r = void 0, e.minortype) {case i.GEOMETRY_TYPES.PLANE:r = new s.Plane();break;default:console.error(\"Unhandled surface type\");}var o = new E.RegionTopologyFace(r);return o.setGuid(e.guid), o;default:console.error(\"Unhandled topology type\");}}, V.prototype._addOrFindTopologySubcomponent = function (e, t, r, n) {var o = this._createNameFromGuidList(e, t, r, n);if (this._sketchRegionTopologies[o]) {var i = this._sketchRegionTopologies[o];return i.updated = !0, i.topology;}var s = this._addNewRegionTopology({ tuid: e, minortype: t, guid: o });return this._sketchRegionTopologies[o] = { topology: s, updated: !0 }, s;};var T = { VertexID: [1168004130, 3764602020, 2270554856, 1368826480], EdgeID: [2942887333, 1472546498, 2159971906, 413489693], FaceID: [2166479754, 2329626594, 2838556660, 1584616933] },C = {};C[i.GEOMETRY_TYPES.POINT] = [2299429810, 2248164535, 3202574069, 2684287321], C[i.GEOMETRY_TYPES.LINE] = [910992607, 3428993096, 3010390753, 2966835859], C[i.GEOMETRY_TYPES.CIRCLE] = [2229232555, 842549819, 2526558959, 4217038233], C[i.GEOMETRY_TYPES.PLANE] = [2122299449, 3667741317, 2812958731, 939246365], C[i.GEOMETRY_TYPES.BCURVE] = [420548527, 2703575863, 2792852189, 2595995847], C[i.GEOMETRY_TYPES.ELLIPSE] = [902753991, 1129557208, 9277753211, 1913737389];var b = function b(e, t) {var r = 2166136261;return t && (r = 16777619 * (r ^ t) >>> 0), 16777619 * (((r = 16777619 * (((r = 16777619 * (((r = 16777619 * ((r ^ 255 & e) >>> 0) >>> 0) ^ e >> 8 & 255) >>> 0) >>> 0) ^ e >> 16 & 255) >>> 0) >>> 0) ^ e >> 24 & 255) >>> 0) >>> 0;},L = function () {var e = new Uint32Array(4);return function (t) {return e[0] = t, e[1] = 16777619, e[2] = t, e[3] = t, (0, v.hashCombine4xUint32)(e, e);};}(),O = function O(e, t) {for (var r = 0; r < e.length; r++) {e[r] = (e[r] ^ t[r]) >>> 0;}};V.prototype._createNameFromGuidList = function (e, t, r, n) {var o = P.default.clone(T[e]),i = C[t];R.ConsoleUtils.assert(o && i, \"Unsupported tuid or minortype!\"), O(o, i);for (var s = 0; s < r.length; s++) {O(o, r[s]);}var a = (0, v.uint32x4ToGUID)(o);if (n[a]) {var c = ++n[a];return (r = P.default.clone(r)).push(L(b(c))), this._createNameFromGuidList(e, t, r, n);}return n[a] = 1, a;}, V.prototype._createGUIDfromEdgeAndLocalID = function (e, t) {var r = (0, v.guidToUint32x4)(e.getGuid()),n = L(b(t));return (0, v.hashCombine4xUint32)(r, n);}, V.prototype._findVertexIndex = function (e) {for (var t = 0; t < this._intersectionVertices.length; t++) {if (n.Vector3.distance(this._intersectionVertices[t].position, e) < i.KERNEL_TOLERANCE) return t;for (var r = 0; r < this._intersectionVertices[t].mergedPositions.length; r++) {if (n.Vector3.distance(this._intersectionVertices[t].mergedPositions[r], e) < i.KERNEL_TOLERANCE) return t;}}}, V.prototype._findVertexOnSweepLine = function (e) {for (var t = this._workspace, r = 0, n = t.sweepLineIntersections.length - 1; n >= r;) {if (r + 1 >= n) return r;var o = Math.floor((r + n) / 2);this._isVertexAboveEdgeSegment(t.sweepLineIntersections[o], e) ? r = o : n = o;}console.error(\"Error in binary search function!\");}, V.prototype._isVertexAboveEdgeSegment = function (e, t) {if (e === -1 / 0) return !0;if (e === 1 / 0) return !1;var r = e.originalEdge;switch (r.getCurveType()) {case i.GEOMETRY_TYPES.LINE:var o = r.getStartVertex().getPosition(),s = n.Vector3.createFloat64();n.Vector3.subtract(s, r.getEndVertex().getPosition(), o);var a = n.Vector3.createFloat64();return n.Vector3.subtract(a, t.position, o), (s[0] < 0 || 0 === s[0] && s[1] < 0) && n.Vector3.negate(s, s), a[1] * s[0] - a[0] * s[1] > 0;case i.GEOMETRY_TYPES.CIRCLE:var c = t.position[0] - r.getCurve().getCenter()[0],u = .5 * (e.parameterRange[0] + e.parameterRange[1]),l = r.getCurve().evaluateDtt(u)[1] > 0 ? -1 : 1;return Math.abs(c) > r.getCurve().getRadius() ? r.getCurve().getCenter()[1] < t.position[1] : r.getCurve().getCenter()[1] + l * Math.sqrt(r.getCurve().getRadius() * r.getCurve().getRadius() - c * c) < t.position[1];default:return this.getYvalueForX(e, t.position[0]) < t.position[1];}}, V.prototype._makeEdgeXMonotone = function (e, t) {var r = e.getCurve(),s = [];switch (e.getCurveType()) {case i.GEOMETRY_TYPES.LINE:break;case i.GEOMETRY_TYPES.CIRCLE:var a = r.evaluatePosition(0);n.Vector3.subtract(a, a, r.getCenter());var c = r.getNormal()[2] > 0 ? -1 : 1;s[0] = c * Math.atan2(a[1], a[0]), s[1] = s[0] - Math.PI;break;case i.GEOMETRY_TYPES.ELLIPSE:var u = r.getMajorAxis()[0] * r.getMajorRadius(),l = r.getMinorAxis()[0] * r.getMinorRadius();s[0] = Math.atan2(l, u), s[1] = s[0] - Math.PI;break;case i.GEOMETRY_TYPES.BCURVE:s = _.SplineCurveHelper.extremalParams(r, 0);break;default:console.warn(\"Unsupported edge type in sketch region op\");}for (var h = 0; h < s.length; h++) {var d = s[h];e.isReversed() && (d = -d), r.isPeriodicUnlimited() && (d = (0, o.adjustParameterToPeriodicRange)(d, e.getRange(), r.getPeriodUnlimited())), d >= e.t0() && d <= e.t1() && (t.push({ param: d, atVertex: null, temporary: !0 }), A.DebugUtils.level(\"region3D\") > 0 && A.DebugUtils.drawPoint3D(e.evaluatePosition(d), { color: 16711935, label: \"x monotonic\" }));}}, V.prototype.plotSegments = function (e, t) {var r = this._workspace;Debug.hold(\"on\"), Debug.clearFigure(), Debug.delayUpdates(!0);for (var o = 0; o < this._intersectionVertices.length; o++) {var i = Debug.plotColorForIndex(this._intersectionVertices[o].adjacentEdges.length);if (\"sweepLineState\" === e && (i = \"k\", this._intersectionVertices[o] === r.currentVertex && (i = \"g\"), this._intersectionVertices[o] === r.nextVertex && (i = \"b\")), Debug.plot([this._intersectionVertices[o].position], i + \"o\"), \"orderColored\" === e) for (var s = this._intersectionVertices[o], a = [], c = 0; c < s.adjacentEdges.length; c++) {i = Debug.plotColorForIndex(c);var u = s.adjacentEdges[c],l = P.default.clone(u.parameterRange);u.startVertex !== s || a[u.index] ? l[0] = .5 * (l[0] + l[1]) : l[1] = .5 * (l[0] + l[1]), a[u.index] = !0;var h = u.originalEdge.tessellate(l).positions;Debug.plot(h, i + \"-\");}}if (\"orderColored\" !== e) for (o = 0; o < this._edgeSegments.length; o++) {if (u = this._edgeSegments[o], \"coincidenceCount\" === e) {var d = u.coincidentRanges.length + 1;i = Debug.plotColorForIndex(d);} else i = Debug.plotColorForIndex(o);if (\"sweepLineState\" === e && (i = r.sweepLineIntersections.indexOf(u) > -1 ? \"r\" : \"k\"), t && t.highlightLoop && (i = P.default.contains(t.highlightLoop, u) ? \"R\" : \"k\"), h = u.originalEdge.tessellate(u.parameterRange).positions, \"regions\" === e) {var g = [],p = [];for (c = 0; c < h.length; c++) {if (c < h.length - 1) {var f = n.Vector3.createFloat64();n.Vector3.subtract(f, h[c + 1], h[c]);} else f = n.Vector3.createFloat64(), n.Vector3.subtract(f, h[c], h[c - 1]);n.Vector3.normalize(f, f), n.Vector3.scale(f, f, .05), n.Vector3.cross(f, [0, 0, 1], f);var v = n.Vector3.clone(h[c]);g.push(n.Vector3.add(v, v, f));var _ = n.Vector3.clone(h[c]);p.push(n.Vector3.subtract(_, _, f));}var y = u.adjacent[this.SIDE.LEFT].face.index;i = Debug.plotColorForIndex(y), Debug.plot(g, i + \"-\");var m = u.adjacent[this.SIDE.RIGHT].face.index;i = Debug.plotColorForIndex(m), Debug.plot(p, i + \"-\");} else Debug.plot(h, i + \"-\");}if (\"sweepLineState\" === e && r.sweepLinePosition) {var E = r.sweepLinePosition,x = void 0;for (o = 0; o < r.sweepLineIntersections.length; o++) {var R,A = r.sweepLineIntersections[o];void 0 !== (R = A === 1 / 0 ? 5 : A === -1 / 0 ? -5 : this.getYvalueForX(A, E)) && (Debug.plot([E], [R], \"y.\"), void 0 !== x && (i = Debug.plotColorForIndex(r.sweepLineRegions[o - 1].index), Debug.plot([E, E], [x, R], i + \"-\")), x = R);}}if (t && t.showOrientation) {h = [];var V = [],T = [];for (o = 0; o < this._edgeSegments.length; o++) {var C = !(void 0 === (u = this._edgeSegments[o]).loopsCurveAligned || !0 === u.loopsCurveAligned),b = C ? .05 : .95,L = u.parameterRange[0] * (1 - b) + u.parameterRange[1] * b,O = u.originalEdge.evaluatePosition(L);h.push(O);var S = t.arrowSize || .1,M = C ? -S : S;if (u.adjacent[this.SIDE.LEFT].face.index >= 0) {var w = u.originalEdge.evaluateDt(L);n.Vector3.normalize(w, w);var N = [O[0] - S * w[1], O[1] + S * w[0]];V.push(N), T.push([M * w[0], M * w[1]]);}if (u.adjacent[this.SIDE.RIGHT].face.index >= 0) {var F = u.parameterRange[0] * b + u.parameterRange[1] * (1 - b),I = u.originalEdge.evaluatePosition(F),D = u.originalEdge.evaluateDt(F);n.Vector3.normalize(D, D);var j = [I[0] + S * D[1], I[1] - S * D[0]];V.push(j), T.push([-M * D[0], -M * D[1]]);}}Debug.plot(h, \"k.\"), Debug.quiver(V, T, \"g\", \"c\");}Debug.delayUpdates(!1), Debug.equalAxis();}, V.prototype.plotEdgeSegment = function (e, t) {Debug.plotEdgeList([e.originalEdge], !1, t + \"-\", { ranges: [e.parameterRange] });}, V.prototype.plotEdgesAroundVertex = function (e, t) {Debug.plot([e.position], \"gx\");for (var r = 0; r < e.adjacentEdges.length; r++) {var n,o = e.adjacentEdges[r];console.log(r), n = o.startVertex === e ? [o.parameterRange[0], o.parameterRange[0] + t / o.originalEdge.getCurve().tangentLength(o.parameterRange[0])] : [o.parameterRange[1] - t / o.originalEdge.getCurve().tangentLength(o.parameterRange[0]), o.parameterRange[1]], Debug.plotEdgeList([o.originalEdge], !1, \"-\" + Debug.plotColorForIndex(r), { ranges: [n], showOrientation: !1, resolution: 1e4 });}}, V.prototype.getYvalueForX = function (e, t) {var r = e.parameterRange[0],n = e.parameterRange[1],o = e.originalEdge.evaluatePosition(r),s = e.originalEdge.evaluatePosition(n),a = o[0],c = s[0];if (a > c) {var u = r;r = n, n = u, u = a, a = c, c = u, u = o, o = s, s = u;}if (t <= a + i.KERNEL_TOLERANCE || t >= c - i.KERNEL_TOLERANCE) return Math.abs(t - a) <= i.KERNEL_TOLERANCE ? o[1] : Math.abs(t - c) <= i.KERNEL_TOLERANCE ? s[1] : void console.warn(\"Failure in getYvalueForX, in_x oustide segment range, returning undefined\");for (; c >= a;) {if (a + i.KERNEL_TOLERANCE >= c) return h[1];var l = (r + n) / 2,h = e.originalEdge.evaluatePosition(l);if (Math.abs(r - n) <= i.PARAMETER_SPACE_TOLERANCE) return R.ConsoleUtils.assert(!1, \"Could not converge to a solution for getYvalueForX\"), h[1];h[0] < t ? (a = h[0], r = l) : (c = h[0], n = l);}console.warn(\"Failure in getYvalueForX, returning undefined\");}, V.prototype._computeAngleAndPositionForEdge = function (e, t, r) {var o = t.adjacentEdges[e],i = o.startVertex === t,s = o.parameterRange[i ? 0 : 1];if (void 0 === r || !((s += (i ? 1 : -1) * r) < o.parameterRange[0] || s > o.parameterRange[1])) {var a = n.Vector3.createFloat64();return n.Vector3.normalize(a, o.originalEdge.evaluateDt(s)), i || n.Vector3.negate(a, a), { angle: Math.atan2(a[1], a[0]), position: o.originalEdge.evaluatePosition(s) };}}, V.prototype._computeEdgeDirectionAtVertex = function (e, t, r) {var o = t.adjacentEdges[e.index],i = o.startVertex === t,s = o.parameterRange[i ? 0 : 1],a = s + (i ? 1 : -1) * r / n.Vector3.length(o.originalEdge.evaluateDt(s)),c = o.originalEdge.evaluatePosition(a),u = n.Vector3.subtract(c, c, t.position);return Math.atan2(u[1], u[0]);}, V.prototype._prepareResult = function () {var e = new y.TopologyCloner();this._finalFaces = e.cloneFaces(this._faces), this._internalToFinalMap = e.getProgenitorMap(), this._progenitorMap = new m.ProgenitorMap();for (var t = e.getProgenitorMap().getAllNewTopology(), r = 0; r < t.length; r++) {var n = t[r],o = e.getProgenitorMap().getProgenitors(n)[0],s = void 0;n.getTopologyType() === i.TOPOLOGY_TYPES.FACE ? (s = new Set(), o.collectEdges().forEach(function (e) {e.getAssociatedEntities().forEach(function (e) {s.add(e);});}), s = Array.from(s)) : (n.getTopologyType() === i.TOPOLOGY_TYPES.EDGE || n.getTopologyType() === i.TOPOLOGY_TYPES.VERTEX) && (s = o.getAssociatedEntities()), s && this._progenitorMap.addEntry(n, s);}this._sketchSummary = { regionFaces: [], regionEdges: [], regionVertices: [], sketchEdges: {} };for (var a = P.default.keys(this._sketchRegionTopologies), c = 0; c < a.length; c++) {var u = this._sketchRegionTopologies[a[c]].topology;u instanceof E.RegionTopologyFace ? this._sketchSummary.regionFaces.push(u) : u instanceof E.RegionTopologyEdge ? this._sketchSummary.regionEdges.push(u) : u instanceof E.RegionTopologyVertex ? this._sketchSummary.regionVertices.push(u) : R.ConsoleUtils.assert(!1);}for (var l = 0; l < this._sketchEdges.length; l++) {var h = this._sketchEdges[l];this._sketchSummary.sketchEdges[h.getGuid()] = h;}}, V.prototype.getFaces = function () {return this._finalFaces;}, V.prototype.getRegionTopologyFaces = function () {return this._faces;}, V.prototype.getProgenitorMap = function () {return this._progenitorMap;}, V.prototype.createFaceRecipe = function (e) {var t = this._finalFaces.indexOf(e);if (t < 0) return \"\";var r = this._faces[t],n = (0, x.createRecipeFromRegionFace)(r, this._sketchSummary);return (0, x.serializeRegionFaceRecipe)(n);}, V.prototype.matchFaceRecipe = function (e) {for (var t = (0, x.deserializeRegionFaceRecipe)(e), r = (0, x.matchRegionFaceRecipe)(t, this._sketchSummary), n = [], o = 0; o < r.regions.length; o++) {var i = this._faces.indexOf(r.regions[o]);R.ConsoleUtils.assert(i >= 0), n.push(this._finalFaces[i]);}return n;}, V.prototype.createEdgeRecipe = function (e) {var t = this._internalToFinalMap.getProgenitors(e);if (!t || 1 !== t.length) return \"\";var r = (0, x.createRecipeFromRegionEdge)(t[0], this._sketchSummary);return (0, x.serializeRegionEdgeRecipe)(r);}, V.prototype.matchEdgeRecipe = function (e) {for (var t = (0, x.deserializeRegionEdgeRecipe)(e), r = (0, x.matchRegionEdgeRecipe)(t, this._sketchSummary), n = [], o = 0; o < r.edges.length; o++) {var i = this._internalToFinalMap.getDescendants(r.edges[o]);R.ConsoleUtils.assert(1 === i.length), n.push(i[0]);}return n;}, t.SketchRegionSolver = V;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.computeCurveCurveIntersections = void 0;var n = r(1),o = r(0),i = r(6),s = r(7),a = r(20),c = r(16),u = r(72),l = r(36),h = r(3),d = r(110),g = o.KERNEL_TOLERANCE,p = function p(e, t, r, o) {var i = t,s = e.getRange();if (e.getCurve().isPeriodicUnlimited() && (i < s[0] - n.FLOAT64_TOLERANCE || i > s[1] + n.FLOAT64_TOLERANCE)) {var a = e.getCurve().getPeriodUnlimited();i = (0, h.foldNearTo)(i, .5 * (s[0] + s[1]), a);}var c = Math.abs(i - s[0]) < Math.abs(i - s[1]) ? 0 : 1,u = n.Vector3.length(e.evaluateDt(i));return Math.abs(i - s[c]) * u < r ? { param: s[c], atVertex: e.getVertex(c) } : i >= s[0] && i <= s[1] ? { param: i, atVertex: void 0 } : !e.isClosed() && o.distanceToPoint(e.getVertex(c).getPosition()) < r ? { param: s[c], atVertex: e.getVertex(c) } : void 0;},f = function f(e, t, r, o, i) {var s = p(e, t, i, r);if (s) {if (s.atVertex) {var a = r.getRange();e === r && (a = [o - .1 * (l = Math.abs(a[1] - a[0])), o + .1 * l]);var c = r.closestToPointParam(s.atVertex.getPosition(), a);n.Vector3.distance(r.evaluatePosition(c), s.atVertex.getPosition()) < i && (o = c);}var u = p(r, o, i, e);if (u) {var l;if (u.atVertex) a = e.getRange(), e === r && (a = [t - .1 * (l = Math.abs(a[1] - a[0])), t + .1 * l]), c = e.closestToPointParam(u.atVertex.getPosition(), a), n.Vector3.distance(e.evaluatePosition(c), u.atVertex.getPosition()) < i && (s = p(e, t = c, i, r));if (s) return { cutInfo: s, cutByInfo: u };}}},v = function v(e, t, r) {var n = [t - e.getRange()[0], t - e.getRange()[1]];if (n[0] >= r && n[1] <= -r) return { param: t, atVertex: void 0 };var o = Math.abs(n[0]) < Math.abs(n[1]) ? 0 : 1;return Math.abs(n[o]) < r ? { param: e.getRange()[o], atVertex: e.getVertex(o) } : void 0;},_ = function _(e, t, r, i, s, a, c) {var u = e.getCurve().getPeriodUnlimited(),l = t.getCurve().getPeriodUnlimited(),d = [r[0], r[2]],g = [i[0], i[2]],f = [s / n.Vector3.length(e.evaluateDt(d[0])), s / n.Vector3.length(e.evaluateDt(d[1]))],v = [s / n.Vector3.length(t.evaluateDt(g[0])), s / n.Vector3.length(t.evaluateDt(g[1]))];if (((0, h.isParameterWithinPeriodicRange)(d[0], e.getRange(), u, f[0]) || (0, h.isParameterWithinPeriodicRange)(d[1], e.getRange(), u, f[1])) && ((0, h.isParameterWithinPeriodicRange)(g[0], t.getRange(), l, v[0]) || (0, h.isParameterWithinPeriodicRange)(g[1], t.getRange(), l, v[1]))) {for (var _ = 0; _ < 2; _++) {d[_] = (0, h.adjustParameterToPeriodicRange)(d[_], e.getRange(), u, !1, !0), g[_] = (0, h.adjustParameterToPeriodicRange)(g[_], t.getRange(), l, !1, !0);var y = (0, h.periodicDifference)(d[_], e.getRange()[0], u) < 3e-15 || (0, h.periodicDifference)(d[_], e.getRange()[1], u) < 3e-15,m = (0, h.periodicDifference)(g[_], t.getRange()[0], l) < 3e-15 || (0, h.periodicDifference)(g[_], t.getRange()[1], l) < 3e-15;if (d[_] - e.getRange()[0] < f[_] && (d[_] = e.getRange()[0], y = !0), e.getRange()[1] - d[_] < f[_] && (d[_] = e.getRange()[1], y = !0), g[_] - t.getRange()[0] < v[_] && (g[_] = t.getRange()[0], m = !0), t.getRange()[1] - g[_] < v[_] && (g[_] = t.getRange()[1], m = !0), y) {var E = t.closestToPointParam(e.evaluatePosition(d[_]));g[_] = (0, h.adjustParameterToPeriodicRange)(E, t.getRange(), l, !1, !0);}if (m) {var x = e.closestToPointParam(t.evaluatePosition(g[_]));d[_] = (0, h.adjustParameterToPeriodicRange)(x, e.getRange(), u, !1, !0), ((0, h.periodicDifference)(d[_], e.getRange()[0], u) < 3e-15 || (0, h.periodicDifference)(d[_], e.getRange()[1], u) < 3e-15) && (E = t.closestToPointParam(e.evaluatePosition(d[_])), g[_] = (0, h.adjustParameterToPeriodicRange)(E, t.getRange(), l, !1, !0));}}var R, A;if ((0, h.periodicDifference)(d[0], d[1], u) < Math.min(f[0], f[1]) && (0, h.periodicDifference)(g[0], g[1], l) < Math.min(v[0], v[1])) R = p(e, .5 * (d[0] + d[1]), s, e), A = p(t, .5 * (g[0] + g[1]), s, t);else for (R = p(e, r[1], s, e), A = p(t, i[1], s, t), _ = 0; _ < 2; _++) {if (!((0, h.periodicDifference)(d[_], R.param, u) < f[_] && (0, h.periodicDifference)(g[_], A.param, l) < v[_])) {var P,V,T = p(e, d[_], s, e),C = p(t, g[_], s, t);if (isFinite(u)) {var b = (0, h.getShortestParametricRange)(T.param, R.param, u);P = (0, h.periodicDifference)(R.param, b[0], u) <= o.KERNEL_ANGULAR_TOLERANCE;} else P = T.param > R.param;isFinite(l) ? (b = (0, h.getShortestParametricRange)(C.param, A.param, l), V = (0, h.periodicDifference)(A.param, b[0], l) <= o.KERNEL_ANGULAR_TOLERANCE) : V = C.param > A.param, a.push({ rangeInfo: P ? [R, T] : [T, R], rangeByInfo: V ? [A, C] : [C, A] });}}c && c.push({ firstParam: R.param, secondParam: A.param });}},y = function y(e, t, r, o) {var i = e.getRange(),s = e.evaluatePosition(0),a = e.evaluateDt(0),c = n.Vector2.length(a),u = t.getRange(),l = t.evaluatePosition(0),d = t.evaluateDt(0),g = n.Vector2.length(d),p = [a[1] / c, -a[0] / c],_ = t.evaluatePosition(u[0]);n.Vector2.subtract(_, _, s);var y = n.Vector2.dot(_, p),m = t.evaluatePosition(u[1]);n.Vector2.subtract(m, m, s);var E = n.Vector2.dot(m, p);if (Math.abs(y) <= o && Math.abs(E) <= o) {var x = n.Vector2.dot(_, a) / (c * c),R = n.Vector2.dot(m, a) / (c * c),A = [Math.min(x, R), Math.max(x, R)],P = o / c,V = o / g;if (A[1] < i[0] - P || A[0] > i[1] + P) return [];var T = [Math.max(i[0], A[0]), Math.min(i[1], A[1])];if (T[1] - T[0] < P) {var C = .5 * (T[0] + T[1]),b = Math.abs(R - x) > n.FLOAT64_TOLERANCE ? u[0] + (u[1] - u[0]) * (C - x) / (R - x) : .5 * (u[0] + u[1]);return [{ cutInfo: v(e, C, P), cutByInfo: v(t, b, V) }];}if (!r) return [];var L = u[0] + (u[1] - u[0]) * (T[0] - x) / (R - x),O = u[0] + (u[1] - u[0]) * (T[1] - x) / (R - x);return [{ rangeInfo: [v(e, T[0], P), v(e, T[1], P)], rangeByInfo: [v(t, Math.min(L, O), V), v(t, Math.max(L, O), V)] }];}if (y > o && E > o || y < -o && E < -o) return [];var S = [[a[0], -d[0], l[0] - s[0]], [a[1], -d[1], l[1] - s[1]]],M = (0, h.solveTwoEquationsTwoVariables)(S);if (M) {var w = f(e, M[0], t, M[1], o);if (w) return [w];}return [];},m = function m(e, t, r) {var o,i = t.getCenter(),s = e.closestToPointParam(i, []),a = e.evaluatePosition(s),c = n.Vector3.squaredDistance(a, i),u = [],l = t.getRadius(),h = l - Math.sqrt(c);if (h < -r) ;else if (h < r) o = t.closestToPointParam(a, []), u.push({ lineParam: s, circleParam: o });else for (var d = Math.sqrt(l * l - c) / n.Vector3.length(e.evaluateDt(0)), g = 0; g < 2; ++g) {var p = s + (0 === g ? -1 : 1) * d,f = e.evaluatePosition(p);o = t.closestToPointParam(f, []), u.push({ lineParam: p, circleParam: o });}return u;},E = function E(e, t, r, n, o, i) {var s = [r[0] + t * n[0] - e * n[1], r[1] + t * n[1] + e * n[0], 0];return { firstParam: o.closestToPointParam(s, [0, 2 * Math.PI]), secondParam: i.closestToPointParam(s, [0, 2 * Math.PI]) };},x = function x(e, t) {t || (t = o.KERNEL_TOLERANCE);for (var r = [], n = !1, i = [], s = [], a = 0; a < e.length; ++a) {e[a].hasOwnProperty(\"rangeInfo\") ? (!1 === n ? (i = e[a].rangeInfo, s = e[a].rangeByInfo) : Math.abs(i[1].param - e[a].rangeInfo[0].param) < t && Math.abs(s[1].param - e[a].rangeByInfo[0].param) < t ? (i[1] = e[a].rangeInfo[1], s[1] = e[a].rangeByInfo[1]) : (r.push({ rangeInfo: i, rangeByInfo: s }), i = e[a].rangeInfo, s = e[a].rangeByInfo), n = !0) : e[a].hasOwnProperty(\"cutInfo\") ? (n && r.push({ rangeInfo: i, rangeByInfo: s }), r.push(e[a]), n = !1) : console.warn(\"unknown segment type in intersection code\");}return n && r.push({ rangeInfo: i, rangeByInfo: s }), r;},R = function R(e, t, r, o, i) {var s = r.getControlPoints(),a = r.getKnotVector(),c = e.getBoundingBox(),u = [];if (!r.getBoundingBox([a[0], a[a.length - 1]]).intersectsWithTolerance(c, i)) return u;var d = new Float64Array(s.length),g = s.length / 3 - 1,y = n.Vector2.createFloat64FromValues(e.getStartVertex().getPosition()[0], e.getStartVertex().getPosition()[1]),m = n.Vector3.createFloat64();n.Vector3.sub(m, e.getEndVertex().getPosition(), e.getStartVertex().getPosition()), n.Vector3.normalize(m, m);for (var E = n.Vector2.createFloat64FromValues(m[0], m[1]), x = n.Vector2.createFloat64(), R = !0, A = 0; A <= g; ++A) {x[0] = s[3 * A + 0], x[1] = s[3 * A + 1], d[3 * A + 0] = A / g, d[3 * A + 1] = (0, h.signedDistanceTo2DLine)(y, E, x), Math.abs(d[3 * A + 1]) > i && (R = !1), d[3 * A + 2] = 0;}if (R) return o ? u = function (e, t, r, o, i) {var s = o.length / 3 - 1,a = n.Vector3.createFloat64FromValues(o[0], o[1], o[2]),c = e.closestToPointParam(a),u = n.Vector3.createFloat64FromValues(o[3 * s + 0], o[3 * s + 1], o[3 * s + 2]),l = e.closestToPointParam(u),h = [v(e, c, r), v(e, l, r)];if (h[0].param > h[1].param) {var d = h[0];h[0] = h[1], h[1] = d;}var g = i[0],f = i[i.length - 1];if (t.isReversed()) {var _ = g;g = -f, f = -_;}var y = [p(t, g, r, e), p(t, f, r, e)];return h[0] && h[1] && y[0] && y[1] ? [{ rangeInfo: h, rangeByInfo: y }] : (console.warn(\"Error in intersection computation.\"), []);}(e, t, i, s, a) : [];var P = new Float64Array(3),V = [];return function (e, t, r, n, o, i, s, a, c) {var u,l = [],h = n.length / 3 - 1;3 === i ? (s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u), s[1] > s[2] && (u = s[1], s[1] = s[2], s[2] = u), s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u)) : 2 === i && s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u);var d = [!1, !1, !1],g = o[o.length - 1] - o[0],v = t.getCurve().tangentLength(o[0]) * g;Math.abs(n[1]) < r && (0 === i || s[0] > r / v) && (i++, s[2] = s[1], s[1] = s[0], s[0] = 0, d[0] = !0);var y = t.getCurve().tangentLength(o[o.length - 1]) * g;Math.abs(n[3 * h + 1]) < r && (0 === i || 1 - s[i - 1] > r / y) && (s[i] = 1, d[i] = !0, i++);for (var m = e.isReversed() ? -1 : 1, E = t.isReversed() ? -1 : 1, x = 0, R = 0; R < i + 1; ++R) {var A = !1;if (R !== i) {var P = s[R];s[R] = o[0] + (o[o.length - 1] - o[0]) * s[R];var V = t.getCurve().evaluatePosition(s[R]),T = e.getCurve().closestToPointParam(V, []),C = f(e, T * m, t, s[R] * E, r);C && (C.cutInfo.virtualIntersection = d[R], C.cutByInfo.virtualIntersection = d[R], l.push(C));} else P = o[o.length - 1], A = Math.abs(n[3 * h + 1]) > r;if (0 === R && P > 0 && Math.abs(n[0]) > r && (A = !0), c) {var b = void 0;if (a.length > 0 && a[0][0] >= x && a[0][0] <= P && (b = a[0]), a.length > 1 && a[1][0] >= x && a[1][0] <= P && (b = a[1]), void 0 !== b && Math.abs(b[1]) < r && !A) {var L = [o[0] + (o[o.length - 1] - o[0]) * x, o[0] + (o[o.length - 1] - o[0]) * P],O = [e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(L[0]), []), e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(L[1]), [])];if (Math.abs(O[0] - O[1]) > r) {var S = [p(e, O[0] * m, r, t), p(e, O[1] * m, r, t)],M = [p(t, L[0] * E, r, e), p(t, L[1] * E, r, e)];if (S[0] && S[1] && M[0] && M[1]) {var w = o[0] + (o[o.length - 1] - o[0]) * b[0];w !== L[0] && w !== L[1] || (w = .5 * (L[0] + L[1]));var N = e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(w), []);_(e, t, [O[0] * m, N * m, O[1] * m], [L[0] * E, w * E, L[1] * E], r, l);var F = { cutInfo: p(e, N * m, r, e), cutByInfo: p(t, w * E, r, e) };F.cutInfo.virtualIntersection = !0, F.cutByInfo.virtualIntersection = !0, l.push(F);}}}}x = P;}return l;}(e, t, i, d, a, l.SplineCurveHelper.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D([0, 0, 0], d, P, V), P, V, o);},A = function A(e, t, r, n) {var o = e.getBoundingBox(),i = [];if (!t.getBoundingBox().intersectsWithTolerance(o, n)) return i;for (var s = t.getCurve().getBezierSegments(), a = s.length, c = 0; c < a; c++) {for (var u = R(e, t, s[c], r, n), l = 0; l < u.length; ++l) {i.push(u[l]);}}return x(i);},P = function P(e, t, r, o, i) {var a = r.getControlPoints(),c = r.getKnotVector(),l = e.getBoundingBox(),d = [];if (!r.getBoundingBox([c[0], c[c.length - 1]]).intersectsWithTolerance(l, i)) return d;for (var v = !0, _ = n.Vector2.createFloat64(), y = n.Vector2.createFloat64(), E = n.Vector2.createFloat64(), x = 0; x < a.length / 3 - 2 && v; ++x) {_[0] = a[3 * x + 0], _[1] = a[3 * x + 1], y[0] = a[3 * x + 3], y[1] = a[3 * x + 4], E[0] = a[3 * x + 6], E[1] = a[3 * x + 7], v = Math.abs((0, h.orient2D)(_, y, E)) < g;}if (v) {var R = new s.Line(),A = n.Vector3.createFloat64FromValues(a[0], a[1], a[2]),P = n.Vector3.createFloat64FromValues(a[a.length - 3], a[a.length - 2], a[a.length - 1]);R.setFromEndpoints(A, P);var V = n.Vector3.distance(P, A),T = m(R, e.getCurve(), i);for (x = 0; x < T.length; ++x) {if (T[x].lineParam >= 0 && T[x].lineParam <= V) {T[x].lineParam = t.getCurve().closestToPointParam(R.evaluatePosition(T[x].lineParam), []);var C = p(e, T[x].circleParam * (e.isReversed() ? -1 : 1), i, t),b = p(t, T[x].lineParam * (t.isReversed() ? -1 : 1), i, e);b && C && d.push({ cutInfo: C, cutByInfo: b });}}return d;}var L = n.Vector2.createFloat64(),O = n.Vector2.createFloat64(),S = n.Vector2.createFloat64(),M = n.Vector2.createFloat64();L[0] = -a[0] + 3 * a[3] - 3 * a[6] + a[9], L[1] = -a[1] + 3 * a[4] - 3 * a[7] + a[10], O[0] = 3 * a[0] - 6 * a[3] + 3 * a[6], O[1] = 3 * a[1] - 6 * a[4] + 3 * a[7], S[0] = -3 * a[0] + 3 * a[3], S[1] = -3 * a[1] + 3 * a[4], M[0] = a[0], M[1] = a[1];var w = e.getCurve().getCenter(),N = e.getCurve().getRadius() * e.getCurve().getRadius(),F = N,I = new Float64Array(7);I[0] = F * L[0] * L[0] + N * L[1] * L[1], I[1] = 2 * F * L[0] * O[0] + 2 * O[1] * N * L[1], I[2] = 2 * S[0] * F * L[0] + O[1] * O[1] * N + F * O[0] * O[0] + 2 * S[1] * N * L[1], I[3] = -2 * w[1] * N * L[1] + 2 * O[1] * S[1] * N + 2 * S[0] * F * O[0] - 2 * F * L[0] * w[0] + 2 * F * L[0] * M[0] + 2 * M[1] * N * L[1], I[4] = -2 * F * w[0] * O[0] + S[1] * S[1] * N - 2 * w[1] * O[1] * N + 2 * F * M[0] * O[0] + S[0] * S[0] * F + 2 * M[1] * O[1] * N, I[5] = -2 * w[1] * S[1] * N - 2 * S[0] * F * w[0] + 2 * S[0] * F * M[0] + 2 * M[1] * S[1] * N, I[6] = F * w[0] * w[0] - 2 * M[1] * w[1] * N - F * N + w[1] * w[1] * N + M[1] * M[1] * N - 2 * F * w[0] * M[0] + F * M[0] * M[0];var D = (0, u.getRealPolynomialRoots)(I);for (x = 0; x < D.length; ++x) {if (D[x] >= 0 && D[x] <= 1) {D[x] = c[0] + (c[c.length - 1] - c[0]) * D[x];var j = t.getCurve().evaluatePosition(D[x]),B = e.getCurve().closestToPointParam(j, []),U = f(e, B * (e.isReversed() ? -1 : 1), t, D[x] * (t.isReversed() ? -1 : 1), i);U && d.push(U);}}return d;},V = function V(e, t, r, n, o) {var i = e.getBoundingBox(),s = [];if (!t.getBoundingBox().intersectsWithTolerance(i, o)) return s;var a = 0;e.isClosed() && n && (a = 1);for (var c = t.getCurve().getBezierSegments(), u = c.length, l = 0; l < u; l++) {for (var h = P(e, t, c[l], 0, o), d = 0; d < h.length; ++d) {for (var g = -a; g <= a; ++g) {s.push({ cutInfo: { atVertex: h[d].cutInfo.atVertex, param: h[d].cutInfo.param + g * Math.PI * 2 }, cutByInfo: h[d].cutByInfo });}}}return x(s);},T = function T(e, t, r, l, d, v, _) {var m = r.getControlPoints(),E = r.getKnotVector(),x = l.getControlPoints(),A = l.getKnotVector(),P = r.getBoundingBox([E[0], E[E.length - 1]]),V = l.getBoundingBox([A[0], A[A.length - 1]]),T = e === t,C = !1,b = !1;T && Math.abs(m[m.length - 3] - x[0]) < v && Math.abs(m[x.length - 2] - x[1]) < v && Math.abs(m[x.length - 1] - x[2]) < v && (C = !0), T && Math.abs(m[0] - x[m.length - 3]) < v && Math.abs(m[1] - x[x.length - 2]) < v && Math.abs(m[2] - x[x.length - 1]) < v && (b = !0);var L = [];if (!P.intersectsWithTolerance(V, v)) return L;var O = !0,S = !0,M = n.Vector2.createFloat64(),w = n.Vector2.createFloat64(),N = n.Vector2.createFloat64();for (we = 0; we < m.length / 3 - 2 && O; ++we) {M[0] = m[3 * we + 0], M[1] = m[3 * we + 1], w[0] = m[3 * we + 3], w[1] = m[3 * we + 4], N[0] = m[3 * we + 6], N[1] = m[3 * we + 7], O = Math.abs((0, h.orient2D)(M, w, N)) < g;}for (we = 0; we < x.length / 3 - 2 && S; ++we) {M[0] = x[3 * we + 0], M[1] = x[3 * we + 1], w[0] = x[3 * we + 3], w[1] = x[3 * we + 4], N[0] = x[3 * we + 6], N[1] = x[3 * we + 7], S = Math.abs((0, h.orient2D)(M, w, N)) < g;}if (O || S) return function (e, t, r, u, l, h, d, g, v) {var _ = l.getControlPoints(),m = h.getControlPoints(),E = [];if (e && !t || !e && t) {var x,A,P = new s.Line();e ? (x = n.Vector3.createFloat64FromValues(_[0], _[1], _[2]), A = n.Vector3.createFloat64FromValues(_[_.length - 3], _[_.length - 2], _[_.length - 1])) : (x = n.Vector3.createFloat64FromValues(m[0], m[1], m[2]), A = n.Vector3.createFloat64FromValues(m[m.length - 3], m[m.length - 2], m[m.length - 1])), P.setFromEndpoints(x, A);var V = new a.Edge(P),T = n.Vector3.distance(A, x);V.setRange([0, T]);var C = new i.Point();C.setPosition(x[0], x[1], x[2]);var b = new i.Point();b.setPosition(A[0], A[1], A[2]);var L,O = new c.Vertex(C),S = new c.Vertex(b);V.setStartVertex(O), V.setEndVertex(S), ee = e ? R(V, u, h, d, g) : R(V, r, l, d, g);for (var M = 0; M < ee.length; ++M) {if (ee[M].hasOwnProperty(\"cutInfo\") && ee[M].hasOwnProperty(\"cutByInfo\")) {if (ee[M].cutInfo.param >= 0 && ee[M].cutInfo.param <= T && (e ? (ee[M].cutInfo.param = r.closestToPointParam(P.evaluatePosition(ee[M].cutInfo.param)), L = f(r, ee[M].cutInfo.param, u, ee[M].cutByInfo.param, g)) : (ee[M].cutInfo.param = u.closestToPointParam(P.evaluatePosition(ee[M].cutInfo.param)), L = f(r, ee[M].cutByInfo.param, u, ee[M].cutInfo.param, g)), L)) if (v) {var w = L.cutInfo.param,N = L.cutByInfo.param;(F = Math.abs(w - N) * n.Vector3.length(r.evaluateDt(w))) > o.KERNEL_TOLERANCE && !ee[M].cutInfo.virtualIntersection && E.push(L);} else E.push(L);} else if (ee[M].hasOwnProperty(\"rangeInfo\") && ee[M].hasOwnProperty(\"rangeByInfo\") && ee[M].rangeInfo[0].param >= 0 && ee[M].rangeInfo[0].param <= T && ee[M].rangeInfo[1].param >= 0 && ee[M].rangeInfo[1].param <= T) if (e ? (ee[M].rangeInfo[0].param = r.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = r.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[1].param))) : (ee[M].rangeInfo[0].param = u.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = u.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[1].param))), e ? (te = [p(r, ee[M].rangeInfo[0].param, g, u), p(r, ee[M].rangeInfo[1].param, g, u)], re = [p(u, ee[M].rangeByInfo[0].param, g, r), p(u, ee[M].rangeByInfo[1].param, g, r)]) : (te = [p(r, ee[M].rangeByInfo[0].param, g, u), p(r, ee[M].rangeByInfo[1].param, g, u)], re = [p(u, ee[M].rangeInfo[0].param, g, r), p(u, ee[M].rangeInfo[1].param, g, r)]), te[0] && te[1] && re[0] && re[1]) {var F = Math.abs(te[1].param - re[0].param) * n.Vector3.length(r.evaluateDt(te[1]));(!v || v && F > o.KERNEL_TOLERANCE) && E.push({ rangeInfo: te, rangeByInfo: re });} else console.warn(\"Error in intersection computation.\");}} else {var I = new s.Line(),D = new s.Line(),j = n.Vector3.createFloat64FromValues(_[0], _[1], _[2]),B = n.Vector3.createFloat64FromValues(_[_.length - 3], _[_.length - 2], _[_.length - 1]),U = n.Vector3.createFloat64FromValues(m[0], m[1], m[2]),k = n.Vector3.createFloat64FromValues(m[m.length - 3], m[m.length - 2], m[m.length - 1]);I.setFromEndpoints(j, B), D.setFromEndpoints(U, k);var G = new a.Edge(I),z = n.Vector3.distance(B, j),Y = new a.Edge(D),K = n.Vector3.distance(k, U);G.setRange([0, z]), Y.setRange([0, K]);var q = new i.Point();q.setPosition(j[0], j[1], j[2]);var W = new i.Point();W.setPosition(B[0], B[1], B[2]);var H = new i.Point();H.setPosition(U[0], U[1], U[2]);var X = new i.Point();X.setPosition(k[0], k[1], k[2]);var J = new c.Vertex(q),$ = new c.Vertex(W),Z = new c.Vertex(H),Q = new c.Vertex(X);G.setStartVertex(J), G.setEndVertex($), Y.setStartVertex(Z), Y.setEndVertex(Q);var ee = y(G, Y, d, g);for (M = 0; M < ee.length; ++M) {if (ee[M].hasOwnProperty(\"cutInfo\") && ee[M].hasOwnProperty(\"cutByInfo\")) ee[M].cutInfo.param >= 0 && ee[M].cutInfo.param <= z && ee[M].cutByInfo.param >= 0 && ee[M].cutByInfo.param <= K && (ee[M].cutInfo.param = r.closestToPointParam(I.evaluatePosition(ee[M].cutInfo.param)), ee[M].cutByInfo.param = u.closestToPointParam(D.evaluatePosition(ee[M].cutByInfo.param)), L = f(r, ee[M].cutInfo.param, u, ee[M].cutByInfo.param, g)) && (w = L.cutInfo.param, N = L.cutByInfo.param, F = Math.abs(w - N) * n.Vector3.length(r.evaluateDt(w)), (!v || v && F > o.KERNEL_TOLERANCE) && E.push(L));else if (ee[M].hasOwnProperty(\"rangeInfo\") && ee[M].hasOwnProperty(\"rangeByInfo\") && ee[M].rangeInfo[0].param >= 0 && ee[M].rangeInfo[0].param <= z && ee[M].rangeInfo[1].param >= 0 && ee[M].rangeInfo[1].param <= z && ee[M].rangeByInfo[0].param >= 0 && ee[M].rangeByInfo[0].param <= K && ee[M].rangeByInfo[1].param >= 0 && ee[M].rangeByInfo[1].param <= K) {ee[M].rangeInfo[0].param = r.closestToPointParam(I.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = r.closestToPointParam(I.evaluatePosition(ee[M].rangeInfo[1].param)), ee[M].rangeByInfo[0].param = u.closestToPointParam(D.evaluatePosition(ee[M].rangeByInfo[0].param)), ee[M].rangeByInfo[1].param = u.closestToPointParam(D.evaluatePosition(ee[M].rangeByInfo[1].param));var te = [p(r, ee[M].rangeInfo[0].param, g, u), p(r, ee[M].rangeInfo[1].param, g, u)],re = [p(u, ee[M].rangeByInfo[0].param, g, r), p(u, ee[M].rangeByInfo[1].param, g, r)];te[0] && te[1] && re[0] && re[1] ? (F = Math.abs(te[1].param - re[0].param) * n.Vector3.length(r.evaluateDt(te[1])), (!v || v && F > o.KERNEL_TOLERANCE) && E.push({ rangeInfo: te, rangeByInfo: re })) : console.warn(\"Error in intersection computation.\");}}}return E;}(O, S, e, t, r, l, d, v, _);var F = -m[0] + 3 * m[3] - 3 * m[6] + m[9],I = 3 * m[0] - 6 * m[3] + 3 * m[6],D = -3 * m[0] + 3 * m[3],j = m[0],B = -m[1] + 3 * m[4] - 3 * m[7] + m[10],U = 3 * m[1] - 6 * m[4] + 3 * m[7],k = -3 * m[1] + 3 * m[4],G = m[1],z = j * j,Y = D * D,K = I * I,q = F * F,W = j * j * j,H = D * D * D,X = I * I * I,J = F * F * F,$ = G * G,Z = k * k,Q = U * U,ee = B * B,te = G * G * G,re = k * k * k,ne = U * U * U,oe = B * B * B,ie = -x[0] + 3 * x[3] - 3 * x[6] + x[9],se = 3 * x[0] - 6 * x[3] + 3 * x[6],ae = -3 * x[0] + 3 * x[3],ce = x[0],ue = -x[1] + 3 * x[4] - 3 * x[7] + x[10],le = 3 * x[1] - 6 * x[4] + 3 * x[7],he = -3 * x[1] + 3 * x[4],de = x[1],ge = ce * ce,pe = ce * ce * ce,fe = de * de,ve = de * de * de,_e = ae * ae,ye = ae * ae * ae,me = he * he,Ee = he * he * he,xe = se * se,Re = se * se * se,Ae = le * le,Pe = le * le * le,Ve = ie * ie,Te = ue * ue,Ce = new Float64Array(10),be = F * ue - B * ie;Ce[0] = be * be * be, Ce[1] = 3 * (F * le - B * se) * be * be, Ce[2] = 3 * (F * ue - B * ie) * (q * he * ue + q * Ae - F * B * ae * ue - 2 * F * B * se * le - F * B * ie * he + ee * ae * ie + ee * xe), Ce[3] = 3 * j * q * B * Te - 6 * j * F * ee * ie * ue + 3 * j * oe * Ve - 3 * D * I * F * B * Te + 3 * D * I * ee * ie * ue + 2 * D * q * U * Te - D * F * U * B * ie * ue - D * U * ee * Ve + X * B * Te - K * F * U * Te - 2 * K * U * B * ie * ue + I * q * k * Te + I * F * k * B * ie * ue + 2 * I * F * Q * ie * ue - 2 * I * k * ee * Ve + I * Q * B * Ve - 3 * J * G * Te + 3 * J * de * Te + 6 * J * he * le * ue + J * Pe + 6 * q * G * B * ie * ue - 3 * q * k * U * ie * ue - 3 * q * B * ce * Te - 6 * q * B * ae * le * ue - 6 * q * B * se * he * ue - 3 * q * B * se * Ae - 6 * q * B * ie * de * ue - 6 * q * B * ie * he * le - 3 * F * G * ee * Ve + 3 * F * k * U * B * Ve - F * ne * Ve + 6 * F * ee * ce * ie * ue + 6 * F * ee * ae * se * ue + 6 * F * ee * ae * ie * le + 3 * F * ee * xe * le + 6 * F * ee * se * ie * he + 3 * F * ee * Ve * de - 3 * oe * ce * Ve - 6 * oe * ae * se * ie - oe * Re, Ce[4] = 6 * j * q * B * le * ue - 6 * j * F * ee * se * ue - 6 * j * F * ee * ie * le + 6 * j * oe * se * ie - 6 * D * I * F * B * le * ue + 3 * D * I * ee * se * ue + 3 * D * I * ee * ie * le + 4 * D * q * U * le * ue - D * F * U * B * se * ue - D * F * U * B * ie * le - 2 * D * U * ee * se * ie + 2 * X * B * le * ue - 2 * K * F * U * le * ue - 2 * K * U * B * se * ue - 2 * K * U * B * ie * le + 2 * I * q * k * le * ue + I * F * k * B * se * ue + I * F * k * B * ie * le + 2 * I * F * Q * se * ue + 2 * I * F * Q * ie * le - 4 * I * k * ee * se * ie + 2 * I * Q * B * se * ie - 6 * J * G * le * ue + 6 * J * de * le * ue + 3 * J * me * ue + 3 * J * he * Ae + 6 * q * G * B * se * ue + 6 * q * G * B * ie * le - 3 * q * k * U * se * ue - 3 * q * k * U * ie * le - 6 * q * B * ce * le * ue - 6 * q * B * ae * he * ue - 3 * q * B * ae * Ae - 6 * q * B * se * de * ue - 6 * q * B * se * he * le - 6 * q * B * ie * de * le - 3 * q * B * ie * me - 6 * F * G * ee * se * ie + 6 * F * k * U * B * se * ie - 2 * F * ne * se * ie + 6 * F * ee * ce * se * ue + 6 * F * ee * ce * ie * le + 3 * F * ee * _e * ue + 6 * F * ee * ae * se * le + 6 * F * ee * ae * ie * he + 3 * F * ee * xe * he + 6 * F * ee * se * ie * de - 6 * oe * ce * se * ie - 3 * oe * _e * ie - 3 * oe * ae * xe, Ce[5] = 6 * j * q * B * he * ue + 3 * j * q * B * Ae - 6 * j * F * ee * ae * ue - 6 * j * F * ee * se * le - 6 * j * F * ee * ie * he + 6 * j * oe * ae * ie + 3 * j * oe * xe - 6 * D * I * F * B * he * ue - 3 * D * I * F * B * Ae + 3 * D * I * ee * ae * ue + 3 * D * I * ee * se * le + 3 * D * I * ee * ie * he + 4 * D * q * U * he * ue + 2 * D * q * U * Ae - D * F * U * B * ae * ue - D * F * U * B * se * le - D * F * U * B * ie * he - 2 * D * U * ee * ae * ie - D * U * ee * xe + 2 * X * B * he * ue + X * B * Ae - 2 * K * F * U * he * ue - K * F * U * Ae - 2 * K * U * B * ae * ue - 2 * K * U * B * se * le - 2 * K * U * B * ie * he + 2 * I * q * k * he * ue + I * q * k * Ae + I * F * k * B * ae * ue + I * F * k * B * se * le + I * F * k * B * ie * he + 2 * I * F * Q * ae * ue + 2 * I * F * Q * se * le + 2 * I * F * Q * ie * he - 4 * I * k * ee * ae * ie - 2 * I * k * ee * xe + 2 * I * Q * B * ae * ie + I * Q * B * xe - 6 * J * G * he * ue - 3 * J * G * Ae + 6 * J * de * he * ue + 3 * J * de * Ae + 3 * J * me * le + 6 * q * G * B * ae * ue + 6 * q * G * B * se * le + 6 * q * G * B * ie * he - 3 * q * k * U * ae * ue - 3 * q * k * U * se * le - 3 * q * k * U * ie * he - 6 * q * B * ce * he * ue - 3 * q * B * ce * Ae - 6 * q * B * ae * de * ue - 6 * q * B * ae * he * le - 6 * q * B * se * de * le - 3 * q * B * se * me - 6 * q * B * ie * de * he - 6 * F * G * ee * ae * ie - 3 * F * G * ee * xe + 6 * F * k * U * B * ae * ie + 3 * F * k * U * B * xe - 2 * F * ne * ae * ie - F * ne * xe + 6 * F * ee * ce * ae * ue + 6 * F * ee * ce * se * le + 6 * F * ee * ce * ie * he + 3 * F * ee * _e * le + 6 * F * ee * ae * se * he + 6 * F * ee * ae * ie * de + 3 * F * ee * xe * de - 6 * oe * ce * ae * ie - 3 * oe * ce * xe - 3 * oe * _e * se, Ce[6] = 3 * z * F * ee * ue - 3 * z * oe * ie - 3 * j * D * I * ee * ue + j * D * F * U * B * ue + 2 * j * D * U * ee * ie + 2 * j * K * U * B * ue - j * I * F * k * B * ue - 2 * j * I * F * Q * ue + 4 * j * I * k * ee * ie - 2 * j * I * Q * B * ie - 6 * j * q * G * B * ue + 3 * j * q * k * U * ue + 6 * j * q * B * de * ue + 6 * j * q * B * he * le + 6 * j * F * G * ee * ie - 6 * j * F * k * U * B * ie + 2 * j * F * ne * ie - 6 * j * F * ee * ce * ue - 6 * j * F * ee * ae * le - 6 * j * F * ee * se * he - 6 * j * F * ee * ie * de + 6 * j * oe * ce * ie + 6 * j * oe * ae * se + H * ee * ue - Y * I * U * B * ue - 2 * Y * F * k * B * ue + Y * F * Q * ue - Y * k * ee * ie + D * K * k * B * ue + 6 * D * I * F * G * B * ue - D * I * F * k * U * ue - 6 * D * I * F * B * de * ue - 6 * D * I * F * B * he * le - 3 * D * I * G * ee * ie + D * I * k * U * B * ie + 3 * D * I * ee * ce * ue + 3 * D * I * ee * ae * le + 3 * D * I * ee * se * he + 3 * D * I * ee * ie * de - 4 * D * q * G * U * ue + D * q * Z * ue + 4 * D * q * U * de * ue + 4 * D * q * U * he * le + D * F * G * U * B * ie + 2 * D * F * Z * B * ie - D * F * k * Q * ie - D * F * U * B * ce * ue - D * F * U * B * ae * le - D * F * U * B * se * he - D * F * U * B * ie * de - 2 * D * U * ee * ce * ie - 2 * D * U * ee * ae * se - 2 * X * G * B * ue + 2 * X * B * de * ue + 2 * X * B * he * le + 2 * K * F * G * U * ue - 2 * K * F * U * de * ue - 2 * K * F * U * he * le + 2 * K * G * U * B * ie - K * Z * B * ie - 2 * K * U * B * ce * ue - 2 * K * U * B * ae * le - 2 * K * U * B * se * he - 2 * K * U * B * ie * de - 2 * I * q * G * k * ue + 2 * I * q * k * de * ue + 2 * I * q * k * he * le - I * F * G * k * B * ie - 2 * I * F * G * Q * ie + I * F * Z * U * ie + I * F * k * B * ce * ue + I * F * k * B * ae * le + I * F * k * B * se * he + I * F * k * B * ie * de + 2 * I * F * Q * ce * ue + 2 * I * F * Q * ae * le + 2 * I * F * Q * se * he + 2 * I * F * Q * ie * de - 4 * I * k * ee * ce * ie - 4 * I * k * ee * ae * se + 2 * I * Q * B * ce * ie + 2 * I * Q * B * ae * se + 3 * J * $ * ue - 6 * J * G * de * ue - 6 * J * G * he * le + 3 * J * fe * ue + 6 * J * de * he * le + J * Ee - 3 * q * $ * B * ie + 3 * q * G * k * U * ie + 6 * q * G * B * ce * ue + 6 * q * G * B * ae * le + 6 * q * G * B * se * he + 6 * q * G * B * ie * de - q * re * ie - 3 * q * k * U * ce * ue - 3 * q * k * U * ae * le - 3 * q * k * U * se * he - 3 * q * k * U * ie * de - 6 * q * B * ce * de * ue - 6 * q * B * ce * he * le - 6 * q * B * ae * de * le - 3 * q * B * ae * me - 6 * q * B * se * de * he - 3 * q * B * ie * fe - 6 * F * G * ee * ce * ie - 6 * F * G * ee * ae * se + 6 * F * k * U * B * ce * ie + 6 * F * k * U * B * ae * se - 2 * F * ne * ce * ie - 2 * F * ne * ae * se + 3 * F * ee * ge * ue + 6 * F * ee * ce * ae * le + 6 * F * ee * ce * se * he + 6 * F * ee * ce * ie * de + 3 * F * ee * _e * he + 6 * F * ee * ae * se * de - 3 * oe * ge * ie - 6 * oe * ce * ae * se - oe * ye, Ce[7] = 3 * z * F * ee * le - 3 * z * oe * se - 3 * j * D * I * ee * le + j * D * F * U * B * le + 2 * j * D * U * ee * se + 2 * j * K * U * B * le - j * I * F * k * B * le - 2 * j * I * F * Q * le + 4 * j * I * k * ee * se - 2 * j * I * Q * B * se - 6 * j * q * G * B * le + 3 * j * q * k * U * le + 6 * j * q * B * de * le + 3 * j * q * B * me + 6 * j * F * G * ee * se - 6 * j * F * k * U * B * se + 2 * j * F * ne * se - 6 * j * F * ee * ce * le - 6 * j * F * ee * ae * he - 6 * j * F * ee * se * de + 6 * j * oe * ce * se + 3 * j * oe * _e + H * ee * le - Y * I * U * B * le - 2 * Y * F * k * B * le + Y * F * Q * le - Y * k * ee * se + D * K * k * B * le + 6 * D * I * F * G * B * le - D * I * F * k * U * le - 6 * D * I * F * B * de * le - 3 * D * I * F * B * me - 3 * D * I * G * ee * se + D * I * k * U * B * se + 3 * D * I * ee * ce * le + 3 * D * I * ee * ae * he + 3 * D * I * ee * se * de - 4 * D * q * G * U * le + D * q * Z * le + 4 * D * q * U * de * le + 2 * D * q * U * me + D * F * G * U * B * se + 2 * D * F * Z * B * se - D * F * k * Q * se - D * F * U * B * ce * le - D * F * U * B * ae * he - D * F * U * B * se * de - 2 * D * U * ee * ce * se - D * U * ee * _e - 2 * X * G * B * le + 2 * X * B * de * le + X * B * me + 2 * K * F * G * U * le - 2 * K * F * U * de * le - K * F * U * me + 2 * K * G * U * B * se - K * Z * B * se - 2 * K * U * B * ce * le - 2 * K * U * B * ae * he - 2 * K * U * B * se * de - 2 * I * q * G * k * le + 2 * I * q * k * de * le + I * q * k * me - I * F * G * k * B * se - 2 * I * F * G * Q * se + I * F * Z * U * se + I * F * k * B * ce * le + I * F * k * B * ae * he + I * F * k * B * se * de + 2 * I * F * Q * ce * le + 2 * I * F * Q * ae * he + 2 * I * F * Q * se * de - 4 * I * k * ee * ce * se - 2 * I * k * ee * _e + 2 * I * Q * B * ce * se + I * Q * B * _e + 3 * J * $ * le - 6 * J * G * de * le - 3 * J * G * me + 3 * J * fe * le + 3 * J * de * me - 3 * q * $ * B * se + 3 * q * G * k * U * se + 6 * q * G * B * ce * le + 6 * q * G * B * ae * he + 6 * q * G * B * se * de - q * re * se - 3 * q * k * U * ce * le - 3 * q * k * U * ae * he - 3 * q * k * U * se * de - 6 * q * B * ce * de * le - 3 * q * B * ce * me - 6 * q * B * ae * de * he - 3 * q * B * se * fe - 6 * F * G * ee * ce * se - 3 * F * G * ee * _e + 6 * F * k * U * B * ce * se + 3 * F * k * U * B * _e - 2 * F * ne * ce * se - F * ne * _e + 3 * F * ee * ge * le + 6 * F * ee * ce * ae * he + 6 * F * ee * ce * se * de + 3 * F * ee * _e * de - 3 * oe * ge * se - 3 * oe * ce * _e, Ce[8] = 3 * z * F * ee * he - 3 * z * oe * ae - 3 * j * D * I * ee * he + j * D * F * U * B * he + 2 * j * D * U * ee * ae + 2 * j * K * U * B * he - j * I * F * k * B * he - 2 * j * I * F * Q * he + 4 * j * I * k * ee * ae - 2 * j * I * Q * B * ae - 6 * j * q * G * B * he + 3 * j * q * k * U * he + 6 * j * q * B * de * he + 6 * j * F * G * ee * ae - 6 * j * F * k * U * B * ae + 2 * j * F * ne * ae - 6 * j * F * ee * ce * he - 6 * j * F * ee * ae * de + 6 * j * oe * ce * ae + H * ee * he - Y * I * U * B * he - 2 * Y * F * k * B * he + Y * F * Q * he - Y * k * ee * ae + D * K * k * B * he + 6 * D * I * F * G * B * he - D * I * F * k * U * he - 6 * D * I * F * B * de * he - 3 * D * I * G * ee * ae + D * I * k * U * B * ae + 3 * D * I * ee * ce * he + 3 * D * I * ee * ae * de - 4 * D * q * G * U * he + D * q * Z * he + 4 * D * q * U * de * he + D * F * G * U * B * ae + 2 * D * F * Z * B * ae - D * F * k * Q * ae - D * F * U * B * ce * he - D * F * U * B * ae * de - 2 * D * U * ee * ce * ae - 2 * X * G * B * he + 2 * X * B * de * he + 2 * K * F * G * U * he - 2 * K * F * U * de * he + 2 * K * G * U * B * ae - K * Z * B * ae - 2 * K * U * B * ce * he - 2 * K * U * B * ae * de - 2 * I * q * G * k * he + 2 * I * q * k * de * he - I * F * G * k * B * ae - 2 * I * F * G * Q * ae + I * F * Z * U * ae + I * F * k * B * ce * he + I * F * k * B * ae * de + 2 * I * F * Q * ce * he + 2 * I * F * Q * ae * de - 4 * I * k * ee * ce * ae + 2 * I * Q * B * ce * ae + 3 * J * $ * he - 6 * J * G * de * he + 3 * J * fe * he - 3 * q * $ * B * ae + 3 * q * G * k * U * ae + 6 * q * G * B * ce * he + 6 * q * G * B * ae * de - q * re * ae - 3 * q * k * U * ce * he - 3 * q * k * U * ae * de - 6 * q * B * ce * de * he - 3 * q * B * ae * fe - 6 * F * G * ee * ce * ae + 6 * F * k * U * B * ce * ae - 2 * F * ne * ce * ae + 3 * F * ee * ge * he + 6 * F * ee * ce * ae * de - 3 * oe * ge * ae, Ce[9] = W * oe - z * D * U * ee - 2 * z * I * k * ee + z * I * Q * B - 3 * z * F * G * ee + 3 * z * F * k * U * B - z * F * ne + 3 * z * F * ee * de - 3 * z * oe * ce + j * Y * k * ee + 3 * j * D * I * G * ee - j * D * I * k * U * B - 3 * j * D * I * ee * de - j * D * F * G * U * B - 2 * j * D * F * Z * B + j * D * F * k * Q + j * D * F * U * B * de + 2 * j * D * U * ee * ce - 2 * j * K * G * U * B + j * K * Z * B + 2 * j * K * U * B * de + j * I * F * G * k * B + 2 * j * I * F * G * Q - j * I * F * Z * U - j * I * F * k * B * de - 2 * j * I * F * Q * de + 4 * j * I * k * ee * ce - 2 * j * I * Q * B * ce + 3 * j * q * $ * B - 3 * j * q * G * k * U - 6 * j * q * G * B * de + j * q * re + 3 * j * q * k * U * de + 3 * j * q * B * fe + 6 * j * F * G * ee * ce - 6 * j * F * k * U * B * ce + 2 * j * F * ne * ce - 6 * j * F * ee * ce * de + 3 * j * oe * ge - H * G * ee + H * ee * de + Y * I * G * U * B - Y * I * U * B * de + 2 * Y * F * G * k * B - Y * F * G * Q - 2 * Y * F * k * B * de + Y * F * Q * de - Y * k * ee * ce - D * K * G * k * B + D * K * k * B * de - 3 * D * I * F * $ * B + D * I * F * G * k * U + 6 * D * I * F * G * B * de - D * I * F * k * U * de - 3 * D * I * F * B * fe - 3 * D * I * G * ee * ce + D * I * k * U * B * ce + 3 * D * I * ee * ce * de + 2 * D * q * $ * U - D * q * G * Z - 4 * D * q * G * U * de + D * q * Z * de + 2 * D * q * U * fe + D * F * G * U * B * ce + 2 * D * F * Z * B * ce - D * F * k * Q * ce - D * F * U * B * ce * de - D * U * ee * ge + X * $ * B - 2 * X * G * B * de + X * B * fe - K * F * $ * U + 2 * K * F * G * U * de - K * F * U * fe + 2 * K * G * U * B * ce - K * Z * B * ce - 2 * K * U * B * ce * de + I * q * $ * k - 2 * I * q * G * k * de + I * q * k * fe - I * F * G * k * B * ce - 2 * I * F * G * Q * ce + I * F * Z * U * ce + I * F * k * B * ce * de + 2 * I * F * Q * ce * de - 2 * I * k * ee * ge + I * Q * B * ge - J * te + 3 * J * $ * de - 3 * J * G * fe + J * ve - 3 * q * $ * B * ce + 3 * q * G * k * U * ce + 6 * q * G * B * ce * de - q * re * ce - 3 * q * k * U * ce * de - 3 * q * B * ce * fe - 3 * F * G * ee * ge + 3 * F * k * U * B * ge - F * ne * ge + 3 * F * ee * ge * de - oe * pe;var Le = (0, u.getRealPolynomialRoots)(Ce),Oe = l.getApproxParameterSpaceTolerance(),Se = -Oe,Me = 1 + Oe;C && (Se = Oe), b && (Me = 1 - Oe);for (var we = 0; we < Le.length; ++we) {if (Le[we] >= Se && Le[we] <= Me) {Le[we] < 0 ? Le[we] = 0 : Le[we] > 1 && (Le[we] = 1), Le[we] = A[0] + (A[A.length - 1] - A[0]) * Le[we];var Ne = t.getCurve().evaluatePosition(Le[we]);if (P.isPointInsideWithTolerance(Ne)) {var Fe = r.closestToPointParam(Ne, []);if (Fe >= E[0] && Fe <= E[E.length - 1]) {var Ie = e.getCurve().evaluatePosition(Fe);if (n.Vector3.squaredDistance(Ie, Ne) <= v * v) {var De = f(e, Fe * (e.isReversed() ? -1 : 1), t, Le[we] * (t.isReversed() ? -1 : 1), v);De && L.push(De);}}}}}return L;},C = function C(e, t, r, o) {var i = [],a = t.getControlPoints(),c = e.isReversed() ? -1 : 1,u = new s.Line(),h = n.Vector3.createFloat64FromValues(a[0], a[1], a[2]),d = n.Vector3.createFloat64FromValues(a[a.length - 3], a[a.length - 2], a[a.length - 1]);u.setFromEndpoints(h, d);var g = n.Vector3.distance(d, h),p = n.Vector3.createFloat64FromValues(a[3], a[4], a[5]),v = n.Vector3.createFloat64FromValues(a[6], a[7], a[8]);if (u.closestToPointParam(p, []) > 0 && u.closestToPointParam(p, []) < g && u.closestToPointParam(v, []) > 0 && u.closestToPointParam(v, []) < g) return i;var _,y = -a[0] + 3 * a[3] - 3 * a[6] + a[9],m = -a[1] + 3 * a[4] - 3 * a[7] + a[10],E = 3 * a[0] - 6 * a[3] + 3 * a[6],x = 3 * a[1] - 6 * a[4] + 3 * a[7],R = -3 * a[0] + 3 * a[3],A = -3 * a[1] + 3 * a[4],P = E / y,V = R / y,T = x / m,C = A / m;if (Math.abs(P - T) < o || Math.abs(C - V) < o) return i;var b = new Float64Array(4);if (Math.abs(y) < o && Math.abs(m) < o) return i;Math.abs(y) < o ? (_ = -R / E, P = T, V = C) : _ = Math.abs(m) < o ? -A / x : (C - V) / (P - T), b[0] = (-_ * _ * _ - P * _ * _ - V * _) / 2, b[1] = (3 * _ * _ + 2 * _ * P + 2 * V) / 2, b[2] = -1.5 * _, b[3] = 1;var L,O = new Float64Array(3);if (3 !== l.SplineCurveHelper.solve_cubic_uniqueRoots(b, O)) return i;if (O[1] < O[0] && (L = O[0], O[0] = O[1], O[1] = L), O[2] < O[0] && (L = O[0], O[0] = O[2], O[2] = L), O[2] < O[1] && (L = O[1], O[1] = O[2], O[2] = L), O[0] >= 0 && O[0] <= 1 && O[2] >= 0 && O[2] <= 1) {var S = t.getKnotVector();O[0] = S[0] + (S[S.length - 1] - S[0]) * O[0], O[2] = S[0] + (S[S.length - 1] - S[0]) * O[2];var M = f(e, O[0] * c, e, O[2] * c, o);M && i.push(M);}return i;};t.computeCurveCurveIntersections = function (e, t, r, i, s) {s = void 0 === s ? o.KERNEL_TOLERANCE : s;var a = e.getCurveType(),c = a === o.GEOMETRY_TYPES.CIRCLE,u = a === o.GEOMETRY_TYPES.LINE,l = a === o.GEOMETRY_TYPES.BCURVE && !e.getCurve().isRational() && 3 === e.getCurve().getDegree(),g = t.getCurveType(),v = g === o.GEOMETRY_TYPES.CIRCLE,R = g === o.GEOMETRY_TYPES.LINE,P = g === o.GEOMETRY_TYPES.BCURVE && !t.getCurve().isRational() && 3 === t.getCurve().getDegree();return u && v ? function (e, t, r) {for (var n = m(e.getCurve(), t.getCurve(), r), o = [], i = 0; i < n.length; ++i) {var s = (e.isReversed() ? -1 : 1) * n[i].lineParam,a = (t.isReversed() ? -1 : 1) * n[i].circleParam,c = f(e, s, t, a, r);c && o.push(c);}return o;}(e, t, s) : c && R ? function (e, t, r, n) {var o = m(t.getCurve(), e.getCurve(), n),i = [],s = 0;e.isClosed() && r && (s = 1);for (var a = 0; a < o.length; ++a) {var c = (e.isReversed() ? -1 : 1) * o[a].circleParam,u = (t.isReversed() ? -1 : 1) * o[a].lineParam,l = f(e, c, t, u, n);if (l) for (var h = -s; h <= s; ++h) {i.push({ cutInfo: { atVertex: l.cutInfo.atVertex, param: l.cutInfo.param + h * Math.PI * 2 }, cutByInfo: l.cutByInfo });}}return i;}(e, t, i, s) : u && R ? y(e, t, r, s) : c && v ? function (e, t, r, o, i) {var s = [],a = e.getCurve().getCenter(),c = e.getCurve().getRadius(),u = t.getCurve().getCenter(),l = t.getCurve().getRadius(),d = 2 * Math.PI,g = n.Vector3.createFloat64();n.Vector3.sub(g, u, a);var v = n.Vector3.length(g),y = Math.abs(c - l);if (v < y - i) return s;if (v + y < i) {var m = i / c;if (e.getRange()[1] - e.getRange()[0] > d - m && t.getRange()[1] - t.getRange()[0] > d - m) return s.push({ rangeInfo: [p(e, e.getRange()[0], i, t), p(e, e.getRange()[1], i, t)], rangeByInfo: [p(t, t.getRange()[0], i, e), p(t, t.getRange()[1], i, e)] }), s;var x = [],R = e.closestToPointParam(t.evaluatePosition(0), [0, d]),A = n.Vector3.dot(e.evaluateDt(R), t.evaluateDt(0)) < 0,P = e.getRange(),V = t.getRange();V = A ? [R - V[1], R - V[0]] : [R + V[0], R + V[1]];var T = (0, h.foldAbove)(V[0], P[0], d) - V[0];if ((V = [V[0] + T, V[1] + T])[0] < P[1] + m && x.push([Math.min(V[0], P[1]), Math.min(P[1], V[1])]), V[1] > P[0] + d - m && x.push([P[0], Math.max(P[0], Math.min(P[1], V[1] - d))]), P[1] - P[0] > d - m || V[1] - V[0] > d - m) for (var C = x.length - 1; C >= 0 && 1 !== x.length; --C) {x[C][1] - x[C][0] < m && x.splice(C, 1);}for (C = 0; C < x.length; ++C) {var b = x[C],L = A ? [R - b[1], R - b[0]] : [b[0] - R, b[1] - R],O = (0, h.foldAbove)(L[0], t.getRange()[0], d) - L[0];if (L = [L[0] + O, L[1] + O], b[1] - b[0] < m) {var S = .5 * (b[0] + b[1]),M = .5 * (L[0] + L[1]),w = p(e, S, i, t),N = p(t, M, i, e);w && N && s.push({ cutInfo: w, cutByInfo: N });} else {var F = [p(e, b[0], i, t), p(e, b[1], i, t)],I = [p(t, L[0], i, e), p(t, L[1], i, e)];F[0] && F[1] && I[0] && I[1] && s.push({ rangeInfo: F, rangeByInfo: I });}}return s;}var D = (c * c - l * l + v * v) / (2 * v),j = c * c - D * D,B = c - Math.abs(D),U = [],k = [];if (B < -i) ;else {var G = Math.sqrt(Math.max(0, j));if (n.Vector3.scale(g, g, 1 / v), G < 2 * i) U.push(E(0, D, a, g, e, t)), k.push(!1);else if (B < i) {if (k.push(!1), r) {k[k.length - 1] = !0;var z = E(0, D, a, g, e, t),Y = [E(G, D, a, g, e, t), E(-G, D, a, g, e, t)];_(e, t, [Y[0].firstParam, z.firstParam, Y[1].firstParam], [Y[0].secondParam, z.secondParam, Y[1].secondParam], i, s, U);} else U.push(E(0, D, a, g, e, t));} else U.push(E(G, D, a, g, e, t)), U.push(E(-G, D, a, g, e, t));}var K = 0;for (e.isClosed() && o && (K = 1), C = 0; C < U.length; ++C) {var q = f(e, U[C].firstParam, t, U[C].secondParam, i);if (q) for (var W = -K; W <= K; ++W) {s.push({ cutInfo: { atVertex: q.cutInfo.atVertex, param: q.cutInfo.param + W * Math.PI * 2 }, cutByInfo: q.cutByInfo }), k[C] && (s[s.length - 1].cutInfo.virtualIntersection = !0, s[s.length - 1].cutByInfo.virtualIntersection = !0);}}return s;}(e, t, r, i, s) : u && P ? A(e, t, r, s) : l && R ? function (e, t, r, n, o) {var i = A(t, e, r, o),s = [],a = 0,c = 0;n && e.getCurve().isPeriodicUnlimited() && (a = 1, c = e.getCurve().getPeriodUnlimited());for (var u = 0; u < i.length; ++u) {if (i[u].hasOwnProperty(\"cutInfo\") && i[u].hasOwnProperty(\"cutByInfo\")) for (var l = -a; l <= a; ++l) {s.push({ cutInfo: { atVertex: i[u].cutByInfo.atVertex, param: i[u].cutByInfo.param + l * c }, cutByInfo: i[u].cutInfo });} else i[u].hasOwnProperty(\"rangeInfo\") && i[u].hasOwnProperty(\"rangeByInfo\") && s.push({ rangeInfo: i[u].rangeByInfo, rangeByInfo: i[u].rangeInfo });}return s;}(e, t, r, i, s) : c && P ? V(e, t, 0, i, s) : l && v ? function (e, t, r, n, o) {var i = V(t, e, 0, !1, o),s = [],a = 0,c = 0;n && e.getCurve().isPeriodicUnlimited() && (a = 1, c = e.getCurve().getPeriodUnlimited());for (var u = 0; u < i.length; ++u) {if (i[u].hasOwnProperty(\"cutInfo\") && i[u].hasOwnProperty(\"cutByInfo\")) for (var l = -a; l <= a; ++l) {s.push({ cutInfo: { atVertex: i[u].cutByInfo.atVertex, param: i[u].cutByInfo.param + l * c }, cutByInfo: i[u].cutInfo });} else i[u].hasOwnProperty(\"rangeInfo\") && i[u].hasOwnProperty(\"rangeByInfo\") && s.push({ rangeInfo: i[u].rangeByInfo, rangeByInfo: i[u].rangeInfo });}return s;}(e, t, 0, i, s) : l && P ? function (e, t, r, n, o) {var i = e === t,s = e.getBoundingBox(),a = t.getBoundingBox(),c = [];if (!s.intersectsWithTolerance(a, o)) return c;var u,l,h,d,g = e.getCurve().getBezierSegments(),p = g.length,f = t.getCurve().getBezierSegments(),v = f.length,_ = [],y = 0,m = 0,E = 0;for (n && e.getCurve().isPeriodic() && e.isClosed() && (m = 1, E = e.getCurve().getPeriod()), u = 0; u < p; u++) {for (i && (y = u + 1), l = y; l < v; l++) {var R = i && l === u + 1;for (_ = T(e, t, g[u], f[l], r, o, R), h = 0; h < _.length; ++h) {for (d = -m; d <= m; ++d) {_[h].cutInfo && c.push({ cutInfo: { atVertex: _[h].cutInfo.atVertex, param: _[h].cutInfo.param + d * E }, cutByInfo: _[h].cutByInfo }), _[h].rangeInfo && c.push(_[h]);}}}}if (i) for (u = 0; u < p; ++u) {for (_ = C(e, g[u], 0, o), h = 0; h < _.length; ++h) {for (d = -m; d <= m; ++d) {_[h].cutInfo && c.push({ cutInfo: { atVertex: _[h].cutInfo.atVertex, param: _[h].cutInfo.param + d * E }, cutByInfo: _[h].cutByInfo }), _[h].rangeInfo && c.push(_[h]);}}}return x(c);}(e, t, r, i, s) : function (e, t, r, n, i) {var s = e.getBoundingBox(),a = t.getBoundingBox(),c = [];if (!s.intersectsWithTolerance(a, i)) return c;var u = e.isReversed(),l = t.isReversed(),h = e.getRange();u && (h = [-h[1], -h[0]]);var g = t.getRange();l && (g = [-g[1], -g[0]]), c = new d.CCI(e.getCurve(), h, t.getCurve(), g, o.KERNEL_TOLERANCE).intersect();for (var p = 0; p < c.length; ++p) {u && (c[p].cutInfo ? c[p].cutInfo.param *= -1 : c[p].rangeInfo && (c[p].rangeInfo = [c[p].rangeInfo[1], c[p].rangeInfo[0]], c[p].rangeInfo[0].param *= -1, c[p].rangeInfo[1].param *= -1)), l && (c[p].cutByInfo ? c[p].cutByInfo.param *= -1 : c[p].rangeByInfo && (c[p].rangeByInfo[0].param *= -1, c[p].rangeByInfo[1].param *= -1));}return c;}(e, t, 0, 0, s);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.edgesAreCoincident = t.curvesAreCoincident = void 0;var n = r(1),o = r(0),i = r(2),s = r(8);function a(e, t, r, o, i) {var s = e.evaluatePosition(t),a = r.closestToPointParam(s, o),c = r.evaluatePosition(a);return n.Vector3.squaredDistance(s, c) < i * i;}function c(e, t, r, o, i, s) {var c = [0, 0, 0];if (n.Vector3.isParallel(e, t.getNormal())) return !0;n.Vector3.add(c, t.getCenter(), e);var u = t.closestToPointParam(c, o);if (u > o[0] && u < o[1] && !a(t, u, r, i, s)) return !1;n.Vector3.sub(c, t.getCenter(), e);var l = t.closestToPointParam(c, o);return !(l > o[0] && l < o[1] && !a(t, l, r, i, s));}function u(e, t, r, n, o) {if (!a(e, .5 * (r[0] + r[1]), t, n, o)) return !1;var i = t.closestToPointParam(e.getCenter(), n);return !(i > n[0] && i < n[1] && !a(t, i, e, r, o));}var l = function l(e, t, r, _l, h) {r ? 0 === r.length && (r = e.getRangeUnlimited()) : r = e.getRange(), _l ? 0 === _l.length && (_l = t.getRangeUnlimited()) : _l = t.getRange(), h || (h = o.KERNEL_TOLERANCE);var d = e.getGeometryType(),g = t.getGeometryType();if (!(isFinite(r[0]) && isFinite(r[1]) && isFinite(_l[0]) && isFinite(_l[1]))) {var p = r[0] === Number.NEGATIVE_INFINITY && r[1] === Number.POSITIVE_INFINITY,f = _l[0] === Number.NEGATIVE_INFINITY && _l[1] === Number.POSITIVE_INFINITY;return !(!p || !f) && (i.ConsoleUtils.assert(d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.LINE), function (e, t, r) {if (e === t) return !0;if (!a(e, 0, t, [], r) || !a(t, 0, e, [], r)) return !1;var o = e.evaluateDt(0);n.Vector3.normalize(o, o);var i = t.evaluateDt(0);return n.Vector3.normalize(i, i), n.Vector3.dot(o, i) < 0 && n.Vector3.negate(i, i), n.Vector3.equals(o, i, n.FLOAT64_TOLERANCE);}(e, t, h));}return e === t && Math.abs(r[0] - _l[0]) < n.FLOAT64_TOLERANCE && Math.abs(r[1] - _l[1]) < n.FLOAT64_TOLERANCE || !!(a(e, r[0], t, _l, h) && a(e, r[1], t, _l, h) && a(t, _l[0], e, r, h) && a(t, _l[1], e, r, h)) && (d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.LINE || (d === o.GEOMETRY_TYPES.CIRCLE && g === o.GEOMETRY_TYPES.CIRCLE ? function (e, t, r, o, i) {var s = .5 * (r[0] + r[1]),u = .5 * (o[0] + o[1]);if (!a(e, s, t, o, i) || !a(t, u, e, r, i)) return !1;var l = n.Vector3.sub([0, 0, 0], t.getCenter(), e.getCenter());if (n.Vector3.squaredLength(l) > n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {if (n.Vector3.normalize(l, l), !c(l, e, t, r, o, i)) return !1;if (!c(l, t, e, o, r, i)) return !1;}if (n.Vector3.dot(e.getNormal(), t.getNormal()) < 0 ? n.Vector3.add(l, e.getNormal(), t.getNormal()) : n.Vector3.sub(l, e.getNormal(), t.getNormal()), n.Vector3.squaredLength(l) > n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {if (n.Vector3.normalize(l, l), !c(l, e, t, r, o, i)) return !1;if (!c(l, t, e, o, r, i)) return !1;}if (r[1] - r[0] < 2 * Math.PI - n.FLOAT64_TOLERANCE) {var h = e.evaluatePosition(s + Math.PI),d = t.closestToPointParam(h, o);if (d > o[0] && d < o[1] && !a(t, d, e, r, i)) return !1;}if (o[1] - o[0] < 2 * Math.PI - n.FLOAT64_TOLERANCE) {var g = t.evaluatePosition(u + Math.PI),p = e.closestToPointParam(g, r);if (p > r[0] && p < r[1] && !a(e, p, t, o, i)) return !1;}return !0;}(e, t, r, _l, h) : d === o.GEOMETRY_TYPES.CIRCLE && g === o.GEOMETRY_TYPES.LINE ? u(e, t, r, _l, h) : d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.CIRCLE ? u(t, e, _l, r, h) : function (e, t, r, o, i) {for (var a = [r[0], r[1]], c = [e.evaluatePosition(r[0]), e.evaluatePosition(r[1])], u = 0; u < 100; ++u) {var l = .5 * (a[0] + a[1]),h = e.evaluatePosition(l),d = t.closestToPointParam(h, o),g = t.evaluatePosition(d),p = n.Vector3.sub([0, 0, 0], g, h);if (n.Vector3.squaredLength(p) > i * i) return !1;if (n.Vector3.distance(c[0], h) + n.Vector3.distance(h, c[1]) < i) return !0;var f = e.evaluateDt(l);n.Vector3.dot(f, p) < 0 ? (a[0] = l, c[0] = h) : (a[1] = l, c[1] = h);}return s.DebugUtils.warn(\"Binary search in coincidence check exceeded maximum iterations\"), !0;}(e, t, r, _l, h)));};t.curvesAreCoincident = l, t.edgesAreCoincident = function (e, t) {if (e === t) return !0;var r = Math.max(o.KERNEL_TOLERANCE, e.getPrecision(), t.getPrecision()),i = e.getCurve(),s = t.getCurve();if (!i || !s) {if (i || s) return !1;var a = e.getStartVertex(),c = t.getStartVertex();r = Math.max(r, a.getPrecision(), c.getPrecision());var u = a.getPosition(),h = c.getPosition();return n.Vector3.squaredDistance(u, h) < r * r;}var d = e.getRange();e.isReversed() && (d = [-d[1], -d[0]]);var g = t.getRange();return t.isReversed() && (g = [-g[1], -g[0]]), l(i, s, d, g, r);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.extrudeFace = void 0;var n = r(1),o = r(0),i = r(2),s = r(18),a = r(38),c = r(39),u = r(53),l = r(13),h = r(15),d = r(26),g = r(25),p = r(24),f = r(55),v = r(19),_ = r(28);function y(e, t, r) {var i = n.Vector3.length(r),s = n.Vector3.dot(e.getAxisDir(), r) > 0 ? [0, i] : [-i, 0];e.limitRangeU(s), t[1] - t[0] < 2 * Math.PI - o.PARAMETER_SPACE_TOLERANCE && e.limitRangeV(t);}var m = function m(e, t) {var r = e.getEdge().getCurve(),i = e.getRange(),l = !0;e.isReversed() !== e.getEdge().isReversed() && (i = [-i[1], -i[0]], l = !1);var h,d = l ? e.t0() : e.t1(),g = e.evaluateDt(d);if (n.Vector3.cross(g, g, t), n.Vector3.normalize(g, g), n.Vector3.negate(g, g), r.getGeometryType() === o.GEOMETRY_TYPES.LINE) h = function (e, t, r) {var o = new s.Plane(),i = e.evaluateDt(0),a = n.Vector3.createFloat64();n.Vector3.normalize(a, r);var c = n.Vector3.createFloat64();n.Vector3.cross(c, a, i), o.set(e.evaluatePosition(0), c, a);var u = n.Vector3.length(r),l = n.Vector3.dot(a, r) > 0 ? [0, u] : [-u, 0];return o.limitRangeV(t), o.limitRangeU(l), o;}(r, i, t);else if (r.getGeometryType() === o.GEOMETRY_TYPES.CIRCLE) h = function (e, t, r) {var o = e.evaluatePosition(0);n.Vector3.subtract(o, o, e.getCenter());var i = n.Vector3.createFloat64();n.Vector3.negate(i, e.getNormal());var s = new a.Cylinder();return s.set(e.getCenter(), e.getRadius(), i, o, 1), y(s, t, r), s;}(r, i, t);else if (r.getGeometryType() === o.GEOMETRY_TYPES.ELLIPSE) h = function (e, t, r) {var o = e.evaluatePosition(0);n.Vector3.subtract(o, o, e.getCenter());var i = n.Vector3.createFloat64();n.Vector3.negate(i, e.getNormal());var s = new c.EllipticalCylinder();return s.set(e.getCenter(), o, e.getMinorRadius() / e.getMajorRadius(), i, 1), y(s, t, r), s;}(r, i, t);else {if (r.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE) throw new Error(\"createSideFaceRuledSurface: Curve type not supported.\");h = function (e, t, r) {for (var n = new u.BSurface(), o = e.getDegree(), i = e.getKnotVector().slice(0), s = e.getControlPoints().slice(0), a = (s = s.concat(s)).length / 2; a < s.length; a += 3) {s[a] += r[0], s[a + 1] += r[1], s[a + 2] += r[2];}var c = void 0;return e.isRational() && (c = (c = e.getWeights().slice(0)).concat(c)), n.set(1, o, [0, 0, 1, 1], i, s, c), n.limitRangeU([0, 1]), n.limitRangeV(t), n;}(r, i, t);}var p = h.evaluateNormal(0, i[0]);return { surface: h, isReversed: n.Vector3.dot(p, g) < 0 };};t.extrudeFace = function (e, t) {i.ConsoleUtils.assert(e.getSurfaceType() === o.GEOMETRY_TYPES.PLANE);var r = e.evaluateNormal(0, 0);n.Vector3.scale(r, r, t);var s = new f.TopologyCloner().cloneFace(e),a = n.Matrix44.fromTranslation(n.Matrix44.createFloat64(), r);(0, v.transformTopology)(s, a), t > 0 ? (0, v.reverseFace)(e) : (0, v.reverseFace)(s);var c = function (e, t, r) {for (var n = [], o = e.getLoops(), i = t.getLoops(), s = 0; s < o.length; ++s) {for (var a = o[s].getCoedges(), c = i[s].getCoedges(), u = new Array(a.length), d = 0; d < a.length; ++d) {var g = new Array(4),p = a[d],f = c[a.length - 1 - d],v = p.getStartVertex(),y = p.getEndVertex(),E = f.getStartVertex(),x = f.getEndVertex();g[0] = (0, _.createCoedgeOnEdge)(p.getEdge()), 0 === d && (u[d] = (0, _.createLineEdgeBetweenVertices)(v, x)), g[1] = (0, _.createCoedgeOnEdge)(u[d]), g[2] = (0, _.createCoedgeOnEdge)(f.getEdge()), d !== a.length - 1 && (u[d + 1] = (0, _.createLineEdgeBetweenVertices)(E, y)), g[3] = (0, _.createCoedgeOnEdge)(u[(d + 1) % a.length]);var R = new l.Loop();R.addCoedges(g);var A = m(p, r),P = new h.Face(A.surface);P.setReversed(A.isReversed), P.addLoop(R), n.push(P);}}return n;}(e, s, r),u = e.getShell();u || (u = new d.Shell()).addFace(e), i.ConsoleUtils.assert(1 === u.getFaces().length), u.addFaces(c), u.addFace(s);var y = u.getLump();y || (y = new g.Lump()).addShell(u);var E = y.getBody();return E || (E = new p.Body()).addLump(y), E;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.getBoundedRegionFaces = t.getRegionEdges = t.mergeSketchRegions = void 0;var n = r(0),o = r(19),i = r(80),s = function s(e, t) {var r = e.getProgenitorMap(),o = new Set();return t.forEach(function (e) {r.getDescendants(e).forEach(function (e) {e.getTopologyType() === n.TOPOLOGY_TYPES.EDGE && o.add(e);});}), Array.from(o);},a = function a(e, t) {var r = [];return (0, o.findConnectedFaces)(e, { allowVertexConnections: !1, barrierEdges: t }).forEach(function (e) {(function (e, t) {e = new Set(e), t = new Set(t);var r = new Set();e.forEach(function (e) {e.collectEdges(r);}), r = Array.from(r);for (var n = 0; n < r.length; n++) {var o = r[n];if (!t.has(o)) {var i = o.getCoedges();if (i.length < 2) return !1;for (var s = 0; s < i.length; s++) {if (!e.has(i[s].getFace())) return !1;}}}return !0;})(e, t) && (r = r.concat(e));}), r;},c = function c(e, t) {for (var r = 0; r < e.length; r++) {if (t.indexOf(e[r]) < 0) return !1;}return !0;};t.mergeSketchRegions = function (e) {var t,r,n = [];e.forEach(function (e) {n = n.concat(e.getEdges());});var u = new i.SketchRegionSolver();u.compute(n);var l = u.getFaces(),h = [],d = [];for (t = 0; t < e.length; t++) {var g = s(u, e[t].getEdges());if (0 !== g.length) {var p = a(l, g);0 !== p.length && (d.push(g), h.push(p));}}for (var f = [], v = new Set(l), _ = !0; h.length > 0;) {var y = [];for (t = 0; t < h.length; t++) {var m = !1;for (r = 0; r < h.length; r++) {if (t !== r && c(h[t], h[r])) {m = !0;break;}}y.push(m);}var E = new Set();for (t = h.length - 1; t >= 0; t--) {y[t] ? h[t].forEach(function (e) {E.add(e), v.delete(e);}) : (h.splice(t, 1), d.splice(t, 1));}_ && (f = f.concat(Array.from(v))), v = E, _ = !_;}return (0, o.mergeConnectedFaces)(f);}, t.getRegionEdges = s, t.getBoundedRegionFaces = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.propertyToRange = t.GeometrySetters = void 0;var n = r(1),o = function o(e, t, r) {var n = t[r];e[0] = n.x, e[1] = n.y, e[2] = n.z;},i = function i(e, t) {var r = e[t];var n = r.type;return \"infinite\" === n || 0 === n ? [] : [r.low, r.high];},s = function s(e, t) {var r = i(e, \"uRange\");t.unlimitRangeU(), r.length > 0 && t.limitRangeU(r);var n = i(e, \"vRange\");t.unlimitRangeV(), n.length > 0 && t.limitRangeV(n);},a = function a(e, t) {var r = i(e, \"range\");t.unlimitRange(), r.length > 0 && t.limitRange(r);},c = { setBCurveFromProperty: function setBCurveFromProperty(e, t) {var r,n,o = t.degree,i = t.knots,s = t.controlPoints,c = t.weights,u = s.length / 3;if (0 === c.length) for (n = new Array(u), r = 0; r < u; ++r) {n[r] = 1;} else n = c;e.set(s, n, o, i), a(t, e);}, setBSurfaceFromProperty: function setBSurfaceFromProperty(e, t) {var r,n,o = t.uDegree,i = t.vDegree,a = t.uKnots,c = t.vKnots,u = t.controlPoints,l = t.weights;if (0 === l.length) {var h = u.length / 3;for (n = new Array(h), r = 0; r < h; ++r) {n[r] = 1;}} else n = l;e.set(o, i, a, c, u, n), s(t, e);}, setCircleFromProperty: function setCircleFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),s = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"normal\"), o(s, t, \"radius\"), e.set(r, i, s), a(t, e);}, setConeFromProperty: function setConeFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"axis\"), o(a, t, \"radius\");var c = n.Vector3.length(a);n.Vector3.normalize(a, a);var u = t.angle,l = t.uCoordScale;e.set(r, c, i, u, a, l), s(t, e);}, setCylinderFromProperty: function setCylinderFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"axis\"), o(a, t, \"radius\");var c = n.Vector3.length(a);n.Vector3.normalize(a, a);var u = t.uCoordScale;e.set(r, c, i, a, u), s(t, e);}, setEllipseFromProperty: function setEllipseFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),s = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"normal\"), o(s, t, \"majorRadius\");var c = t.radiusRatio;e.set(r, i, s, c), a(t, e);}, setEllipticalConeFromProperty: function setEllipticalConeFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"axis\"), o(a, t, \"majorRadius\");var c = t.angle,u = t.radiusRatio,l = t.uCoordScale;e.set(r, a, u, i, c, l), s(t, e);}, setEllipticalCylinderFromProperty: function setEllipticalCylinderFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"axis\"), o(a, t, \"majorRadius\");var c = t.radiusRatio,u = t.uCoordScale;e.set(r, a, c, i, u), s(t, e);}, setLineFromProperty: function setLineFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64();o(r, t, \"position\"), o(i, t, \"direction\"), e.set(r, i), a(t, e);}, setPlaneFromProperty: function setPlaneFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"origin\"), o(i, t, \"normal\"), o(a, t, \"uAxis\"), e.set(r, i, a), s(t, e);}, setPointFromProperty: function setPointFromProperty(e, t) {e.setPosition(t.position.x, t.position.y, t.position.z);}, setSphereFromProperty: function setSphereFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"radius\"), o(a, t, \"axis\");var c = n.Vector3.length(i);n.Vector3.normalize(i, i), e.set(r, c, a, i), s(t, e);}, setTorusFromProperty: function setTorusFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"axis\"), o(a, t, \"coordAxis\");var c = t.majorRadius,u = t.minorRadius,l = t.lemon;e.set(r, c, u, i, a, l), s(t, e);}, setHapCurveFromProperty: function setHapCurveFromProperty(e, t) {for (var r = t.spans, n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = {}, n[o].polyOrder = r[o].polyOrder, n[o].lowParam = r[o].lowParam, n[o].highParam = r[o].highParam, n[o].coefs = r[o].coefs.slice(0);}var i = {};i.spans = n;var s = t.periodic;void 0 === s && (s = !1), i.periodic = s, i.closed = s, e.setHapDefinition(i), a(t, e);}, setCurveRangeFromProperty: a, setSurfaceRangeFromProperty: s };t.GeometrySetters = c, t.propertyToRange = i;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.getBoundedRegionFaces = t.getRegionEdges = t.mergeConnectedFaces = t.getOrderedFacesOnVertex = t.saveToProtoMessage = t.saveToProtoBinary = t.SolidDefSaver = t.SolidDefLoader = t.Path2D = t.DebugUtils = t.svgFromWire = t.transformTopology = t.TopologyStitcher = t.TopologyCloner = t.extrudeFace = t.createEdgeFromCurve = t.createFaceFromPolyline = t.createShellsFromFaces = t.createPolyhedron = t.createLineEdgeBetweenVertices = t.createLineEdge = t.createCylinder = t.createCone = t.createBlock = t.computeCurveCurveIntersections = t.SketchRegionSolver = t.facetPlanarFace = t.checkValidity = t.BoundingBox = t.Attribute = t.Wire = t.WireBody = t.Vertex = t.Edge = t.Coedge = t.Loop = t.Face = t.Shell = t.Lump = t.Body = t.BSurface = t.Torus = t.EllipticalCone = t.Cone = t.Sphere = t.EllipticalCylinder = t.Cylinder = t.Plane = t.BCurve = t.Ellipse = t.Circle = t.Line = t.Point = t.TOPOLOGY_TYPES = t.GEOMETRY_TYPES = t.KERNEL_TOLERANCE = void 0;var n = r(0),o = r(4),i = r(6),s = r(7),a = r(14),c = r(23),u = r(33),l = r(18),h = r(38),d = r(39),g = r(74),p = r(51),f = r(52),v = r(75),_ = r(53),y = r(24),m = r(25),E = r(26),x = r(15),R = r(13),A = r(27),P = r(20),V = r(16),T = r(54),C = r(40),b = r(79),L = r(106),O = r(107),S = r(80),M = r(81),w = r(115),N = r(116),F = r(117),I = r(28),D = r(83),j = r(55),B = r(118),U = r(19),k = r(121),G = r(8),z = r(122),Y = r(123),K = r(126),q = r(84),W = r(78);t.KERNEL_TOLERANCE = n.KERNEL_TOLERANCE, t.GEOMETRY_TYPES = n.GEOMETRY_TYPES, t.TOPOLOGY_TYPES = n.TOPOLOGY_TYPES, t.Point = i.Point, t.Line = s.Line, t.Circle = a.Circle, t.Ellipse = c.Ellipse, t.BCurve = u.BCurve, t.Plane = l.Plane, t.Cylinder = h.Cylinder, t.EllipticalCylinder = d.EllipticalCylinder, t.Sphere = g.Sphere, t.Cone = p.Cone, t.EllipticalCone = f.EllipticalCone, t.Torus = v.Torus, t.BSurface = _.BSurface, t.Body = y.Body, t.Lump = m.Lump, t.Shell = E.Shell, t.Face = x.Face, t.Loop = R.Loop, t.Coedge = A.Coedge, t.Edge = P.Edge, t.Vertex = V.Vertex, t.WireBody = T.WireBody, t.Wire = C.Wire, t.Attribute = b.Attribute, t.BoundingBox = o.BoundingBox, t.checkValidity = L.checkValidity, t.facetPlanarFace = O.facetPlanarFace, t.SketchRegionSolver = S.SketchRegionSolver, t.computeCurveCurveIntersections = M.computeCurveCurveIntersections, t.createBlock = w.createBlock, t.createCone = N.createCone, t.createCylinder = N.createCylinder, t.createLineEdge = I.createLineEdge, t.createLineEdgeBetweenVertices = I.createLineEdgeBetweenVertices, t.createPolyhedron = F.createPolyhedron, t.createShellsFromFaces = I.createShellsFromFaces, t.createFaceFromPolyline = I.createFaceFromPolyline, t.createEdgeFromCurve = I.createEdgeFromCurve, t.extrudeFace = D.extrudeFace, t.TopologyCloner = j.TopologyCloner, t.TopologyStitcher = B.TopologyStitcher, t.transformTopology = U.transformTopology, t.svgFromWire = k.svgFromWire, t.DebugUtils = G.DebugUtils, t.Path2D = z.Path2D, t.SolidDefLoader = Y.SolidDefLoader, t.SolidDefSaver = K.SolidDefSaver, t.saveToProtoBinary = K.saveToProtoBinary, t.saveToProtoMessage = K.saveToProtoMessage, t.getOrderedFacesOnVertex = W.getOrderedFacesOnVertex, t.mergeConnectedFaces = U.mergeConnectedFaces, t.getRegionEdges = q.getRegionEdges, t.getBoundedRegionFaces = q.getBoundedRegionFaces;}, function (e, t, r) {\"use strict\";e.exports = r(88);}, function (e, t, r) {\"use strict\";var n = e.exports = r(89);n.build = \"light\", n.load = function (e, t, r) {return \"function\" == typeof t ? (r = t, t = new n.Root()) : t || (t = new n.Root()), t.load(e, r);}, n.loadSync = function (e, t) {return t || (t = new n.Root()), t.loadSync(e);}, n.encoder = r(62), n.decoder = r(67), n.verifier = r(68), n.converter = r(69), n.ReflectionObject = r(21), n.Namespace = r(30), n.Root = r(71), n.Enum = r(11), n.Type = r(63), n.Field = r(22), n.OneOf = r(48), n.MapField = r(64), n.Service = r(65), n.Method = r(66), n.Message = r(49), n.wrappers = r(70), n.types = r(31), n.util = r(5), n.ReflectionObject._configure(n.Root), n.Namespace._configure(n.Type, n.Service, n.Enum), n.Root._configure(n.Type), n.Field._configure(n.Type);}, function (e, t, r) {\"use strict\";var n = t;function o() {n.Reader._configure(n.BufferReader), n.util._configure();}n.build = \"minimal\", n.Writer = r(46), n.BufferWriter = r(96), n.Reader = r(47), n.BufferReader = r(97), n.util = r(10), n.rpc = r(60), n.roots = r(61), n.configure = o, n.Writer._configure(n.BufferWriter), o();}, function (e, t, r) {\"use strict\";var n = t;n.length = function (e) {var t = e.length;if (!t) return 0;for (var r = 0; --t % 4 > 1 && \"=\" === e.charAt(t);) {++r;}return Math.ceil(3 * e.length) / 4 - r;};for (var o = new Array(64), i = new Array(123), s = 0; s < 64;) {i[o[s] = s < 26 ? s + 65 : s < 52 ? s + 71 : s < 62 ? s - 4 : s - 59 | 43] = s++;}n.encode = function (e, t, r) {for (var n, i = null, s = [], a = 0, c = 0; t < r;) {var u = e[t++];switch (c) {case 0:s[a++] = o[u >> 2], n = (3 & u) << 4, c = 1;break;case 1:s[a++] = o[n | u >> 4], n = (15 & u) << 2, c = 2;break;case 2:s[a++] = o[n | u >> 6], s[a++] = o[63 & u], c = 0;}a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, s)), a = 0);}return c && (s[a++] = o[n], s[a++] = 61, 1 === c && (s[a++] = 61)), i ? (a && i.push(String.fromCharCode.apply(String, s.slice(0, a))), i.join(\"\")) : String.fromCharCode.apply(String, s.slice(0, a));}, n.decode = function (e, t, r) {for (var n, o = r, s = 0, a = 0; a < e.length;) {var c = e.charCodeAt(a++);if (61 === c && s > 1) break;if (void 0 === (c = i[c])) throw Error(\"invalid encoding\");switch (s) {case 0:n = c, s = 1;break;case 1:t[r++] = n << 2 | (48 & c) >> 4, n = c, s = 2;break;case 2:t[r++] = (15 & n) << 4 | (60 & c) >> 2, n = c, s = 3;break;case 3:t[r++] = (3 & n) << 6 | c, s = 0;}}if (1 === s) throw Error(\"invalid encoding\");return r - o;}, n.test = function (e) {return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);};}, function (e, t, r) {\"use strict\";function n() {this._listeners = {};}e.exports = n, n.prototype.on = function (e, t, r) {return (this._listeners[e] || (this._listeners[e] = [])).push({ fn: t, ctx: r || this }), this;}, n.prototype.off = function (e, t) {if (void 0 === e) this._listeners = {};else if (void 0 === t) this._listeners[e] = [];else for (var r = this._listeners[e], n = 0; n < r.length;) {r[n].fn === t ? r.splice(n, 1) : ++n;}return this;}, n.prototype.emit = function (e) {var t = this._listeners[e];if (t) {for (var r = [], n = 1; n < arguments.length;) {r.push(arguments[n++]);}for (n = 0; n < t.length;) {t[n].fn.apply(t[n++].ctx, r);}}return this;};}, function (e, t, r) {\"use strict\";function n(e) {return \"undefined\" != typeof Float32Array ? function () {var t = new Float32Array([-0]),r = new Uint8Array(t.buffer),n = 128 === r[3];function o(e, n, o) {t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3];}function i(e, n, o) {t[0] = e, n[o] = r[3], n[o + 1] = r[2], n[o + 2] = r[1], n[o + 3] = r[0];}function s(e, n) {return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], t[0];}function a(e, n) {return r[3] = e[n], r[2] = e[n + 1], r[1] = e[n + 2], r[0] = e[n + 3], t[0];}e.writeFloatLE = n ? o : i, e.writeFloatBE = n ? i : o, e.readFloatLE = n ? s : a, e.readFloatBE = n ? a : s;}() : function () {function t(e, t, r, n) {var o = t < 0 ? 1 : 0;if (o && (t = -t), 0 === t) e(1 / t > 0 ? 0 : 2147483648, r, n);else if (isNaN(t)) e(2143289344, r, n);else if (t > 34028234663852886e22) e((o << 31 | 2139095040) >>> 0, r, n);else if (t < 11754943508222875e-54) e((o << 31 | Math.round(t / 1401298464324817e-60)) >>> 0, r, n);else {var i = Math.floor(Math.log(t) / Math.LN2);e((o << 31 | i + 127 << 23 | 8388607 & Math.round(t * Math.pow(2, -i) * 8388608)) >>> 0, r, n);}}function r(e, t, r) {var n = e(t, r),o = 2 * (n >> 31) + 1,i = n >>> 23 & 255,s = 8388607 & n;return 255 === i ? s ? NaN : o * (1 / 0) : 0 === i ? 1401298464324817e-60 * o * s : o * Math.pow(2, i - 150) * (s + 8388608);}e.writeFloatLE = t.bind(null, o), e.writeFloatBE = t.bind(null, i), e.readFloatLE = r.bind(null, s), e.readFloatBE = r.bind(null, a);}(), \"undefined\" != typeof Float64Array ? function () {var t = new Float64Array([-0]),r = new Uint8Array(t.buffer),n = 128 === r[7];function o(e, n, o) {t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3], n[o + 4] = r[4], n[o + 5] = r[5], n[o + 6] = r[6], n[o + 7] = r[7];}function i(e, n, o) {t[0] = e, n[o] = r[7], n[o + 1] = r[6], n[o + 2] = r[5], n[o + 3] = r[4], n[o + 4] = r[3], n[o + 5] = r[2], n[o + 6] = r[1], n[o + 7] = r[0];}function s(e, n) {return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], r[4] = e[n + 4], r[5] = e[n + 5], r[6] = e[n + 6], r[7] = e[n + 7], t[0];}function a(e, n) {return r[7] = e[n], r[6] = e[n + 1], r[5] = e[n + 2], r[4] = e[n + 3], r[3] = e[n + 4], r[2] = e[n + 5], r[1] = e[n + 6], r[0] = e[n + 7], t[0];}e.writeDoubleLE = n ? o : i, e.writeDoubleBE = n ? i : o, e.readDoubleLE = n ? s : a, e.readDoubleBE = n ? a : s;}() : function () {function t(e, t, r, n, o, i) {var s = n < 0 ? 1 : 0;if (s && (n = -n), 0 === n) e(0, o, i + t), e(1 / n > 0 ? 0 : 2147483648, o, i + r);else if (isNaN(n)) e(0, o, i + t), e(2146959360, o, i + r);else if (n > 17976931348623157e292) e(0, o, i + t), e((s << 31 | 2146435072) >>> 0, o, i + r);else {var a;if (n < 22250738585072014e-324) e((a = n / 5e-324) >>> 0, o, i + t), e((s << 31 | a / 4294967296) >>> 0, o, i + r);else {var c = Math.floor(Math.log(n) / Math.LN2);1024 === c && (c = 1023), e(4503599627370496 * (a = n * Math.pow(2, -c)) >>> 0, o, i + t), e((s << 31 | c + 1023 << 20 | 1048576 * a & 1048575) >>> 0, o, i + r);}}}function r(e, t, r, n, o) {var i = e(n, o + t),s = e(n, o + r),a = 2 * (s >> 31) + 1,c = s >>> 20 & 2047,u = 4294967296 * (1048575 & s) + i;return 2047 === c ? u ? NaN : a * (1 / 0) : 0 === c ? 5e-324 * a * u : a * Math.pow(2, c - 1075) * (u + 4503599627370496);}e.writeDoubleLE = t.bind(null, o, 0, 4), e.writeDoubleBE = t.bind(null, i, 4, 0), e.readDoubleLE = r.bind(null, s, 0, 4), e.readDoubleBE = r.bind(null, a, 4, 0);}(), e;}function o(e, t, r) {t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;}function i(e, t, r) {t[r] = e >>> 24, t[r + 1] = e >>> 16 & 255, t[r + 2] = e >>> 8 & 255, t[r + 3] = 255 & e;}function s(e, t) {return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;}function a(e, t) {return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;}e.exports = n(n);}, function (e, t, r) {\"use strict\";var n = t;n.length = function (e) {for (var t = 0, r = 0, n = 0; n < e.length; ++n) {(r = e.charCodeAt(n)) < 128 ? t += 1 : r < 2048 ? t += 2 : 55296 == (64512 & r) && 56320 == (64512 & e.charCodeAt(n + 1)) ? (++n, t += 4) : t += 3;}return t;}, n.read = function (e, t, r) {if (r - t < 1) return \"\";for (var n, o = null, i = [], s = 0; t < r;) {(n = e[t++]) < 128 ? i[s++] = n : n > 191 && n < 224 ? i[s++] = (31 & n) << 6 | 63 & e[t++] : n > 239 && n < 365 ? (n = ((7 & n) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, i[s++] = 55296 + (n >> 10), i[s++] = 56320 + (1023 & n)) : i[s++] = (15 & n) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], s > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), s = 0);}return o ? (s && o.push(String.fromCharCode.apply(String, i.slice(0, s))), o.join(\"\")) : String.fromCharCode.apply(String, i.slice(0, s));}, n.write = function (e, t, r) {for (var n, o, i = r, s = 0; s < e.length; ++s) {(n = e.charCodeAt(s)) < 128 ? t[r++] = n : n < 2048 ? (t[r++] = n >> 6 | 192, t[r++] = 63 & n | 128) : 55296 == (64512 & n) && 56320 == (64512 & (o = e.charCodeAt(s + 1))) ? (n = 65536 + ((1023 & n) << 10) + (1023 & o), ++s, t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128) : (t[r++] = n >> 12 | 224, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128);}return r - i;};}, function (e, t, r) {\"use strict\";e.exports = function (e, t, r) {var n = r || 8192,o = n >>> 1,i = null,s = n;return function (r) {if (r < 1 || r > o) return e(r);s + r > n && (i = e(n), s = 0);var a = t.call(i, s, s += r);return 7 & s && (s = 1 + (7 | s)), a;};};}, function (e, t, r) {\"use strict\";e.exports = o;var n = r(10);function o(e, t) {this.lo = e >>> 0, this.hi = t >>> 0;}var i = o.zero = new o(0, 0);i.toNumber = function () {return 0;}, i.zzEncode = i.zzDecode = function () {return this;}, i.length = function () {return 1;};var s = o.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";o.fromNumber = function (e) {if (0 === e) return i;var t = e < 0;t && (e = -e);var r = e >>> 0,n = (e - r) / 4294967296 >>> 0;return t && (n = ~n >>> 0, r = ~r >>> 0, ++r > 4294967295 && (r = 0, ++n > 4294967295 && (n = 0))), new o(r, n);}, o.from = function (e) {if (\"number\" == typeof e) return o.fromNumber(e);if (n.isString(e)) {if (!n.Long) return o.fromNumber(parseInt(e, 10));e = n.Long.fromString(e);}return e.low || e.high ? new o(e.low >>> 0, e.high >>> 0) : i;}, o.prototype.toNumber = function (e) {if (!e && this.hi >>> 31) {var t = 1 + ~this.lo >>> 0,r = ~this.hi >>> 0;return t || (r = r + 1 >>> 0), -(t + 4294967296 * r);}return this.lo + 4294967296 * this.hi;}, o.prototype.toLong = function (e) {return n.Long ? new n.Long(0 | this.lo, 0 | this.hi, Boolean(e)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e) };};var a = String.prototype.charCodeAt;o.fromHash = function (e) {return e === s ? i : new o((a.call(e, 0) | a.call(e, 1) << 8 | a.call(e, 2) << 16 | a.call(e, 3) << 24) >>> 0, (a.call(e, 4) | a.call(e, 5) << 8 | a.call(e, 6) << 16 | a.call(e, 7) << 24) >>> 0);}, o.prototype.toHash = function () {return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);}, o.prototype.zzEncode = function () {var e = this.hi >> 31;return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;}, o.prototype.zzDecode = function () {var e = -(1 & this.lo);return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;}, o.prototype.length = function () {var e = this.lo,t = (this.lo >>> 28 | this.hi << 4) >>> 0,r = this.hi >>> 24;return 0 === r ? 0 === t ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : r < 128 ? 9 : 10;};}, function (e, t, r) {\"use strict\";e.exports = s;var n = r(46);(s.prototype = Object.create(n.prototype)).constructor = s;var o = r(10),i = o.Buffer;function s() {n.call(this);}s.alloc = function (e) {return (s.alloc = o._Buffer_allocUnsafe)(e);};var a = i && i.prototype instanceof Uint8Array && \"set\" === i.prototype.set.name ? function (e, t, r) {t.set(e, r);} : function (e, t, r) {if (e.copy) e.copy(t, r, 0, e.length);else for (var n = 0; n < e.length;) {t[r++] = e[n++];}};function c(e, t, r) {e.length < 40 ? o.utf8.write(e, t, r) : t.utf8Write(e, r);}s.prototype.bytes = function (e) {o.isString(e) && (e = o._Buffer_from(e, \"base64\"));var t = e.length >>> 0;return this.uint32(t), t && this._push(a, t, e), this;}, s.prototype.string = function (e) {var t = i.byteLength(e);return this.uint32(t), t && this._push(c, t, e), this;};}, function (e, t, r) {\"use strict\";e.exports = i;var n = r(47);(i.prototype = Object.create(n.prototype)).constructor = i;var o = r(10);function i(e) {n.call(this, e);}o.Buffer && (i.prototype._slice = o.Buffer.prototype.slice), i.prototype.string = function () {var e = this.uint32();return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len));};}, function (e, t, r) {\"use strict\";e.exports = o;var n = r(10);function o(e, t, r) {if (\"function\" != typeof e) throw TypeError(\"rpcImpl must be a function\");n.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(r);}(o.prototype = Object.create(n.EventEmitter.prototype)).constructor = o, o.prototype.rpcCall = function e(t, r, o, i, s) {if (!i) throw TypeError(\"request must be specified\");var a = this;if (!s) return n.asPromise(e, a, t, r, o, i);if (a.rpcImpl) try {return a.rpcImpl(t, r[a.requestDelimited ? \"encodeDelimited\" : \"encode\"](i).finish(), function (e, r) {if (e) return a.emit(\"error\", e, t), s(e);if (null !== r) {if (!(r instanceof o)) try {r = o[a.responseDelimited ? \"decodeDelimited\" : \"decode\"](r);} catch (e) {return a.emit(\"error\", e, t), s(e);}return a.emit(\"data\", r, t), s(null, r);}a.end(!0);});} catch (e) {return a.emit(\"error\", e, t), void setTimeout(function () {s(e);}, 0);} else setTimeout(function () {s(Error(\"already ended\"));}, 0);}, o.prototype.end = function (e) {return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;};}, function (e, t, r) {\"use strict\";function n(e, t) {\"string\" == typeof e && (t = e, e = void 0);var r = [];function o(e) {if (\"string\" != typeof e) {var t = i();if (n.verbose && console.log(\"codegen: \" + t), t = \"return \" + t, e) {for (var s = Object.keys(e), a = new Array(s.length + 1), c = new Array(s.length), u = 0; u < s.length;) {a[u] = s[u], c[u] = e[s[u++]];}return a[u] = t, Function.apply(null, a).apply(null, c);}return Function(t)();}for (var l = new Array(arguments.length - 1), h = 0; h < l.length;) {l[h] = arguments[++h];}if (h = 0, e = e.replace(/%([%dfijs])/g, function (e, t) {var r = l[h++];switch (t) {case \"d\":case \"f\":return String(Number(r));case \"i\":return String(Math.floor(r));case \"j\":return JSON.stringify(r);case \"s\":return String(r);}return \"%\";}), h !== l.length) throw Error(\"parameter count mismatch\");return r.push(e), o;}function i(n) {return \"function \" + (n || t || \"\") + \"(\" + (e && e.join(\",\") || \"\") + \"){\\n  \" + r.join(\"\\n  \") + \"\\n}\";}return o.toString = i, o;}e.exports = n, n.verbose = !1;}, function (e, t, r) {\"use strict\";e.exports = i;var n = r(58),o = r(59)(\"fs\");function i(e, t, r) {return \"function\" == typeof t ? (r = t, t = {}) : t || (t = {}), r ? !t.xhr && o && o.readFile ? o.readFile(e, function (n, o) {return n && \"undefined\" != typeof XMLHttpRequest ? i.xhr(e, t, r) : n ? r(n) : r(null, t.binary ? o : o.toString(\"utf8\"));}) : i.xhr(e, t, r) : n(i, this, e, t);}i.xhr = function (e, t, r) {var n = new XMLHttpRequest();n.onreadystatechange = function () {if (4 === n.readyState) {if (0 !== n.status && 200 !== n.status) return r(Error(\"status \" + n.status));if (t.binary) {var e = n.response;if (!e) {e = [];for (var o = 0; o < n.responseText.length; ++o) {e.push(255 & n.responseText.charCodeAt(o));}}return r(null, \"undefined\" != typeof Uint8Array ? new Uint8Array(e) : e);}return r(null, n.responseText);}}, t.binary && (\"overrideMimeType\" in n && n.overrideMimeType(\"text/plain; charset=x-user-defined\"), n.responseType = \"arraybuffer\"), n.open(\"GET\", e), n.send();};}, function (e, t, r) {\"use strict\";var n = t,o = n.isAbsolute = function (e) {return /^(?:\\/|\\w+:)/.test(e);},i = n.normalize = function (e) {var t = (e = e.replace(/\\\\/g, \"/\").replace(/\\/{2,}/g, \"/\")).split(\"/\"),r = o(e),n = \"\";r && (n = t.shift() + \"/\");for (var i = 0; i < t.length;) {\"..\" === t[i] ? i > 0 && \"..\" !== t[i - 1] ? t.splice(--i, 2) : r ? t.splice(i, 1) : ++i : \".\" === t[i] ? t.splice(i, 1) : ++i;}return n + t.join(\"/\");};n.resolve = function (e, t, r) {return r || (t = i(t)), o(t) ? t : (r || (e = i(e)), (e = e.replace(/(?:\\/|^)[^/]+$/, \"\")).length ? i(e + \"/\" + t) : t);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.decomposeBCurveFlags = t.decomposeBCurveToBezier = t.decomposeBCurveControlPoints = void 0;var n = r(17),o = r(2),i = function i(e, t, r) {o.ConsoleUtils.assert(t.length % r == 0);var n,i,s,a = e.length - t.length / r - 1;o.ConsoleUtils.assert(a > 0);var c = e.length - 1,u = a,l = a + 1,h = 0,d = [],g = [];for (g[h] = new Array((a + 1) * r), n = 0; n <= a; ++n) {for (s = 0; s < r; ++s) {g[h][n * r + s] = t[n * r + s];}}for (; l < c;) {for (var p = 1; l < c && e[l + 1] === e[l];) {++l, ++p;}var f = l === c;if (f || (g[h + 1] = new Array((a + 1) * r)), p < a) {var v = e[l] - e[u];for (i = a; i > p; --i) {d[i - p - 1] = v / (e[u + i] - e[u]);}var _ = a - p;for (i = 1; i <= _; ++i) {for (var y = _ - i, m = p + i, E = a; E >= m; --E) {var x = d[E - m];for (s = 0; s < r; ++s) {g[h][E * r + s] = g[h][E * r + s] * x + g[h][(E - 1) * r + s] * (1 - x);}}if (!f) for (s = 0; s < r; ++s) {g[h + 1][y * r + s] = g[h][a * r + s];}}}if (f) break;for (++h, n = a - p; n <= a; ++n) {for (s = 0; s < r; ++s) {g[h][n * r + s] = t[(l - a + n) * r + s];}}u = l, ++l;}return g;};t.decomposeBCurveControlPoints = i, t.decomposeBCurveToBezier = function (e, t, r) {var s,a = r && r.length > 0;o.ConsoleUtils.assert(t.length > 0 && t.length % 3 == 0), o.ConsoleUtils.assert(!a || t.length === 3 * r.length);var c,u,l = e.length - t.length / 3 - 1;if (o.ConsoleUtils.assert(l > 0), a) {var h = (0, n.controlPointsToHomogeneous)(t, r);for (c = i(e, h, 4), u = [], s = 0; s < c.length; ++s) {var d = (0, n.controlPointsFromHomogeneous)(c[s]);c[s] = d.P, u[s] = d.w;}} else c = i(e, t, 3), u = void 0;var g = (0, n.getUniqueKnots)(e);o.ConsoleUtils.assert(g.length === c.length + 1);var p = new Array(g.length - 1);for (s = 0; s < p.length; ++s) {p[s] = new Array(2 * l + 2), p[s].fill(g[s], 0, l + 1), p[s].fill(g[s + 1], l + 1);}return { U: p, P: c, w: u };}, t.decomposeBCurveFlags = function (e, t) {var r,n = e.length - t.length - 1,o = new Array(t.length);o.fill(!1);var i = n - 1;for (r = 0; r < t.length; ++r) {if (t[r]) {var s = Math.max(r - i, 0),a = Math.min(r + i, o.length - 1);o.fill(!0, s, a + 1);}}var c = [],u = e.length - 1,l = n + 1,h = 0;for (c[h] = !1, r = 0; r <= n; ++r) {o[r] && (c[h] = !0);}for (; l < u;) {for (var d = 1; l < u && e[l + 1] === e[l];) {++l, ++d;}if (l === u) break;for (c[++h] = !1, r = n - d; r <= n; ++r) {o[l - n + r] && (c[h] = !0);}++l;}return c;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.extractBSurfaceParamLineV = t.extractBSurfaceParamLineU = t.insertBSurfaceKnotV = t.insertBSurfaceKnotU = void 0;var n = r(1),o = r(17),i = r(0),s = function s(e, t, r, o, i, _s, a) {var c,u,l = new Array(o);for (u = 0; u < o; ++u) {l[u] = new Array(i - u - r);var h = t - i + u + 1;for (c = 0; c < i - u - r; ++c) {l[u][c] = (e - _s[h + c]) / (_s[c + t + 1] - _s[h + c]);}}for (var d = a.length, g = new Array(d), p = new Array(i - r + 1), f = 0; f < d; ++f) {for (g[f] = new Array(i - r + o - 1), c = 0; c <= i - r; ++c) {p[c] = n.Vector4.clone(a[f][c]);}for (u = 0; u < o; ++u) {for (c = 0; c < i - u - r; ++c) {n.Vector4.lerp(p[c], p[c], p[c + 1], l[u][c]);}g[f][u] = n.Vector4.clone(p[0]), g[f][i + o - r - u - 2] = n.Vector4.clone(p[i - u - r - 1]);}for (c = o; c < i - r - 1; c++) {g[f][c] = n.Vector4.clone(p[c - o + 1]);}}return g;};t.insertBSurfaceKnotU = function (e, t, r, a, c, u, l, h) {t = Math.min(t, r);var d = h && h.length > 0,g = (0, o.findKnotSpanAndMultiplicity)(e, c);e = g.knot;var p = g.span,f = g.multiplicity,v = t - f;if (e < c[0] + i.PARAMETER_SPACE_TOLERANCE || e > c[c.length - 1] - i.PARAMETER_SPACE_TOLERANCE || f >= t) return { uknots: c.slice(), P: l.slice(), weights: d ? h.slice() : void 0 };var _,y,m = c.length - r - 1,E = u.length - a - 1,x = new Array(E),R = p - r,A = p - f;for (y = 0; y < E; ++y) {for (x[y] = new Array(A - R + 1), _ = R; _ <= A; ++_) {var P = _ * E + y,V = d ? h[P] : 1;x[y][_ - R] = n.Vector4.createFloat64FromValues(V * l[3 * P], V * l[3 * P + 1], V * l[3 * P + 2], V);}}var T = s(e, p, f, v, r, c, x),C = c.slice(0, p + 1);for (_ = 0; _ < v; ++_) {C.push(e);}C = C.concat(c.slice(p + 1));var b,L = new Array(3 * (m + v) * E),O = new Array((m + v) * E);for (y = 0; y < E; ++y) {for (_ = 0; _ <= R; ++_) {P = b = _ * E + y, L[3 * b] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}for (_ = 0; _ < T[y].length; ++_) {b = (_ + R + 1) * E + y;var S = T[y][_];L[3 * b] = S[0] / S[3], L[3 * b + 1] = S[1] / S[3], L[3 * b + 2] = S[2] / S[3], O[b] = S[3];}for (_ = A; _ < m; ++_) {P = _ * E + y, L[3 * (b = (_ + v) * E + y)] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}}return { uknots: C, P: L, weights: d ? O : void 0 };}, t.insertBSurfaceKnotV = function (e, t, r, a, c, u, l, h) {t = Math.min(t, a);var d = h && h.length > 0,g = (0, o.findKnotSpanAndMultiplicity)(e, u);e = g.knot;var p = g.span,f = g.multiplicity,v = t - f;if (e < u[0] + i.PARAMETER_SPACE_TOLERANCE || e > u[u.length - 1] - i.PARAMETER_SPACE_TOLERANCE || f >= t) return { vknots: u.slice(), P: l.slice(), weights: d ? h.slice() : void 0 };var _,y,m = c.length - r - 1,E = u.length - a - 1,x = new Array(m),R = p - a,A = p - f;for (_ = 0; _ < m; ++_) {for (x[_] = new Array(A - R + 1), y = R; y <= A; ++y) {var P = _ * E + y,V = d ? h[P] : 1;x[_][y - R] = n.Vector4.createFloat64FromValues(V * l[3 * P], V * l[3 * P + 1], V * l[3 * P + 2], V);}}var T = s(e, p, f, v, a, u, x),C = u.slice(0, p + 1);for (y = 0; y < v; ++y) {C.push(e);}C = C.concat(u.slice(p + 1));var b,L = new Array(3 * m * (E + v)),O = new Array(m * (E + v));for (_ = 0; _ < m; ++_) {for (y = 0; y <= R; ++y) {P = _ * E + y, L[3 * (b = _ * (E + v) + y)] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}for (y = 0; y < T[_].length; ++y) {b = _ * (E + v) + (y + R + 1);var S = T[_][y];L[3 * b] = S[0] / S[3], L[3 * b + 1] = S[1] / S[3], L[3 * b + 2] = S[2] / S[3], O[b] = S[3];}for (y = A; y < E; ++y) {P = _ * E + y, L[3 * (b = _ * (E + v) + (y + v))] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}}return { vknots: C, P: L, weights: d ? O : void 0 };}, t.extractBSurfaceParamLineU = function (e, t, r, i, a, c, u) {var l = u && u.length > 0,h = (0, o.findKnotSpanAndMultiplicity)(e, a);e = h.knot;var d,g,p,f = h.span,v = e === a[a.length - 1],_ = v ? r + 1 : h.multiplicity,y = r - _,m = i.length - t - 1,E = a.length - r - 1,x = new Array(3 * m),R = new Array(m);if (_ >= r) for (g = v ? E - 1 : f - r, d = 0; d < m; ++d) {p = d * E + g, x[3 * d] = c[3 * p], x[3 * d + 1] = c[3 * p + 1], x[3 * d + 2] = c[3 * p + 2], R[d] = l ? u[p] : 1;} else {var A = new Array(m),P = f - r,V = f - _;for (d = 0; d < m; ++d) {for (A[d] = new Array(V - P + 1), g = P; g <= V; ++g) {p = d * E + g;var T = l ? u[p] : 1;A[d][g - P] = n.Vector4.createFloat64FromValues(T * c[3 * p], T * c[3 * p + 1], T * c[3 * p + 2], T);}}var C = s(e, f, _, y, r, a, A);for (g = y - 1, d = 0; d < m; ++d) {var b = C[d][g];x[3 * d] = b[0] / b[3], x[3 * d + 1] = b[1] / b[3], x[3 * d + 2] = b[2] / b[3], R[d] = b[3];}}return { ctrlPts: x, weights: l ? R : void 0 };}, t.extractBSurfaceParamLineV = function (e, t, r, i, a, c, u) {var l = u && u.length > 0,h = (0, o.findKnotSpanAndMultiplicity)(e, i);e = h.knot;var d,g,p,f = h.span,v = e === i[i.length - 1],_ = v ? t + 1 : h.multiplicity,y = t - _,m = i.length - t - 1,E = a.length - r - 1,x = new Array(3 * E),R = new Array(E);if (_ >= t) for (d = v ? m - 1 : f - t, g = 0; g < E; ++g) {p = d * E + g, x[3 * g] = c[3 * p], x[3 * g + 1] = c[3 * p + 1], x[3 * g + 2] = c[3 * p + 2], R[g] = l ? u[p] : 1;} else {var A = new Array(E),P = f - t,V = f - _;for (g = 0; g < E; ++g) {for (A[g] = new Array(V - P + 1), d = P; d <= V; ++d) {p = d * E + g;var T = l ? u[p] : 1;A[g][d - P] = n.Vector4.createFloat64FromValues(T * c[3 * p], T * c[3 * p + 1], T * c[3 * p + 2], T);}}var C = s(e, f, _, y, t, i, A);for (d = y - 1, g = 0; g < E; ++g) {var b = C[g][d];x[3 * g] = b[0] / b[3], x[3 * g + 1] = b[1] / b[3], x[3 * g + 2] = b[2] / b[3], R[g] = b[3];}}return { ctrlPts: x, weights: l ? R : void 0 };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.decomposeBSurfaceToBezier = t.decomposeBSurfaceControlPoints = t.decomposeBSurfaceControlPointsV = t.decomposeBSurfaceControlPointsU = void 0;var n = r(17),o = r(2),i = function i(e, t, r, n) {o.ConsoleUtils.assert(r.length % n == 0);var i = t.length - e - 1;o.ConsoleUtils.assert(r.length / n % i == 0);var s,a,c,u,l = r.length / (n * i),h = e + 1,d = l,g = t.length - 1,p = e,f = e + 1,v = 0,_ = [],y = [];for (y[v] = new Array(h * d * n), s = 0; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s * d + c) * n + u] = r[(s * l + c) * n + u];}}}for (; f < g;) {for (var m = 1; f < g && t[f + 1] === t[f];) {++f, ++m;}var E = f === g;if (E || (y[v + 1] = new Array(h * d * n)), m < e) {var x = t[f] - t[p];for (a = e; a > m; --a) {_[a - m - 1] = x / (t[p + a] - t[p]);}var R = e - m;for (a = 1; a <= R; ++a) {for (var A = R - a, P = m + a, V = e; V >= P; --V) {var T = _[V - P];for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(V * d + c) * n + u] = y[v][(V * d + c) * n + u] * T + y[v][((V - 1) * d + c) * n + u] * (1 - T);}}}if (!E) for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v + 1][(A * d + c) * n + u] = y[v][(e * d + c) * n + u];}}}}if (E) break;for (++v, s = e - m; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s * d + c) * n + u] = r[((f - e + s) * l + c) * n + u];}}}p = f, ++f;}return y;},s = function s(e, t, r, n) {o.ConsoleUtils.assert(r.length % n == 0);var i = t.length - e - 1;o.ConsoleUtils.assert(r.length / n % i == 0);var s,a,c,u,l = r.length / (n * i),h = l,d = e + 1,g = t.length - 1,p = e,f = e + 1,v = 0,_ = [],y = [];for (y[v] = new Array(h * d * n), s = 0; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s + c * d) * n + u] = r[(s + c * i) * n + u];}}}for (; f < g;) {for (var m = 1; f < g && t[f + 1] === t[f];) {++f, ++m;}var E = f === g;if (E || (y[v + 1] = new Array(h * d * n)), m < e) {var x = t[f] - t[p];for (a = e; a > m; --a) {_[a - m - 1] = x / (t[p + a] - t[p]);}var R = e - m;for (a = 1; a <= R; ++a) {for (var A = R - a, P = m + a, V = e; V >= P; --V) {var T = _[V - P];for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(V + c * d) * n + u] = y[v][(V + c * d) * n + u] * T + y[v][(V - 1 + c * d) * n + u] * (1 - T);}}}if (!E) for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v + 1][(A + c * d) * n + u] = y[v][(e + c * d) * n + u];}}}}if (E) break;for (++v, s = e - m; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s + c * d) * n + u] = r[(f - e + s + c * i) * n + u];}}}p = f, ++f;}return y;},a = function a(e, t, r, n, _a, c) {o.ConsoleUtils.assert(_a.length % c == 0), o.ConsoleUtils.assert(_a.length / c == (r.length - e - 1) * (n.length - t - 1));var u,l = r.length > 2 * e + 2,h = n.length > 2 * t + 2;if (!l && !h) return [[_a.slice()]];u = l ? i(e, r, _a, c) : [_a];for (var d = 0; d < u.length; ++d) {u[d] = h ? s(t, n, u[d], c) : [u[d]];}return u;};t.decomposeBSurfaceControlPointsU = i, t.decomposeBSurfaceControlPointsV = s, t.decomposeBSurfaceControlPoints = a, t.decomposeBSurfaceToBezier = function (e, t, r, i, s, c) {var u,l,h,d,g = c && c.length > 0;if (o.ConsoleUtils.assert(s.length > 0 && s.length % 3 == 0), o.ConsoleUtils.assert(!g || s.length === 3 * c.length), g) {var p = (0, n.controlPointsToHomogeneous)(s, c);for (h = a(e, t, r, i, p, 4), d = [], u = 0; u < h.length; ++u) {for (d[u] = [], l = 0; l < h[u].length; ++l) {var f = (0, n.controlPointsFromHomogeneous)(h[u][l]);h[u][l] = f.P, d[u][l] = f.w;}}} else h = a(e, t, r, i, s, 3), d = void 0;var v = (0, n.getUniqueKnots)(r);o.ConsoleUtils.assert(v.length === h.length + 1);var _ = new Array(v.length - 1);for (u = 0; u < _.length; ++u) {_[u] = new Array(2 * e + 2), _[u].fill(v[u], 0, e + 1), _[u].fill(v[u + 1], e + 1);}var y = (0, n.getUniqueKnots)(i);o.ConsoleUtils.assert(y.length === h[0].length + 1);var m = new Array(y.length - 1);for (u = 0; u < m.length; ++u) {m[u] = new Array(2 * t + 2), m[u].fill(y[u], 0, t + 1), m[u].fill(y[u + 1], t + 1);}return { U: _, V: m, P: h, w: d };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.closestBSurfacePointApprox = t.closestBSurfacePatches = void 0;var n = r(1),o = r(3),i = r(73),s = r(76);t.closestBSurfacePatches = function (e, t, r) {for (var o = Number.POSITIVE_INFINITY, s = [], a = 0; a < t.length; ++a) {for (var c = 0; c < t[a].length; ++c) {var u,l = t[a][c],h = l.getRangeUnlimitedU(),d = l.getRangeUnlimitedV();if (r) {u = !1;for (var g = 0; g < r.length; ++g) {if (h[1] >= r[g][0][0] + n.FLOAT64_TOLERANCE && h[0] <= r[g][0][1] - n.FLOAT64_TOLERANCE && d[1] >= r[g][1][0] + n.FLOAT64_TOLERANCE && d[0] <= r[g][1][1] - n.FLOAT64_TOLERANCE) {u = !0;break;}}} else u = !0;if (u) {var p = l.getControlPoints(),f = (0, i.minDistanceSqrToHull)(e, p, !0);if (f <= o) {var v = (0, i.maxDistanceSqrToHull)(e, p);s.push({ index: [a, c], minDistSqr: f, maxDistSqr: v }), v < o && (o = v);}}}}return (s = s.filter(function (e) {return e.minDistSqr <= o;})).sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), s;}, t.closestBSurfacePointApprox = function (e, t, r, i, a, c, u, l, h) {var d = t > 1 ? 2 * t : 1,g = r > 1 ? 2 * r : 1,p = (l[1] - l[0]) / (i[i.length - 1] - i[0]),f = (h[1] - h[0]) / (a[a.length - 1] - a[0]);d = Math.max(1, Math.round(d * p)), g = Math.max(1, Math.round(g * f));for (var v = (l[1] - l[0]) / d, _ = (h[1] - h[0]) / g, y = Number.POSITIVE_INFINITY, m = { u: void 0, v: void 0 }, E = void 0, x = n.Vector3.createFloat64(), R = 0; R <= g; ++R) {for (var A = h[0] + R * _, P = [], V = 0; V <= d; ++V) {var T,C,b = l[0] + V * v;P[V] = (0, s.evaluateBSurfacePoint)(b, A, t, r, i, a, c, u), V > 0 && R > 0 && (T = (0, o.closestPointToTriangle)(e, E[V - 1], E[V], P[V - 1], x), (C = n.Vector3.squaredDistance(e, x)) < y && (y = C, m.u = b + v * (T.coordA - 1), m.v = A + _ * (T.coordB - 1)), T = (0, o.closestPointToTriangle)(e, P[V], P[V - 1], E[V], x), (C = n.Vector3.squaredDistance(e, x)) < y && (y = C, m.u = b - v * T.coordA, m.v = A - _ * T.coordB));}E = P;}return m;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.checkValidity = void 0;var n = r(1),o = r(0),i = r(32),s = r(6),a = r(12),c = r(19);function u(e) {var t = [],r = e.getGuid();return r && \"string\" == typeof r || t.push({ error: \"BaseTopology has invalid GUID\", source: [e] }), t;}function l(e) {var t = u(e),r = 0,n = 0,i = 0,s = e.getLumps();if (s.length > 0) {for (var a = new Set(), c = 0; c < s.length; ++c) {var l = s[c];a.add(l), l && l.getTopologyType() === o.TOPOLOGY_TYPES.LUMP ? l.getBody() !== e && t.push({ error: \"Body is not the parent of child Lump\", source: [e, l] }) : t.push({ error: \"Body has invalid element in Lump array\", source: [e, l] }), r += l.collectFaces().size, n += l.collectEdges().size, i += l.collectVertices().size;}a.size !== s.length && t.push({ error: \"Body has non-unique Lumps\", source: [e] });}return r !== e.collectFaces().size && t.push({ error: \"Body has Lumps which share Faces\", source: [e] }), n !== e.collectEdges().size && t.push({ error: \"Body has Lumps which share Edges\", source: [e] }), i !== e.collectVertices().size && t.push({ error: \"Body has Lumps which share Vertices\", source: [e] }), t;}function h(e) {var t = u(e),r = e.getBody();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.BODY && t.push({ error: \"Lump has invalid parent Body\", source: [e] });var n = 0,i = 0,s = 0,a = e.getShells();if (a.length > 0) {for (var c = new Set(), l = 0; l < a.length; ++l) {var h = a[l];c.add(h), h && h.getTopologyType() === o.TOPOLOGY_TYPES.SHELL ? h.getLump() !== e && t.push({ error: \"Lump is not the parent of child Shell\", source: [e, h] }) : t.push({ error: \"Lump has invalid element in Shell array\", source: [e, h] }), n += h.collectFaces().size, i += h.collectEdges().size, s += h.collectVertices().size;}c.size !== a.length && t.push({ error: \"Lump has non-unique Shells\", source: [e] });} else t.push({ error: \"Lump has no Shells\", source: [e] });return n !== e.collectFaces().size && t.push({ error: \"Lump has Shells which share Faces\", source: [e] }), i !== e.collectEdges().size && t.push({ error: \"Lump has Shells which share Edges\", source: [e] }), s !== e.collectVertices().size && t.push({ error: \"Lump has Shells which share Vertices\", source: [e] }), t;}function d(e) {var t = u(e),r = e.getLump();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.LUMP && t.push({ error: \"Shell has invalid parent Lump\", source: [e] });var n = e.getFaces();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.FACE ? a.getShell() !== e && t.push({ error: \"Shell is not the parent of child Face\", source: [e, a] }) : t.push({ error: \"Shell has invalid element in Face array\", source: [e, a] });}i.size !== n.length && t.push({ error: \"Shell has non-unique Faces\", source: [e] });} else t.push({ error: \"Shell has no Faces\", source: [e] });1 !== (0, c.findConnectedFaces)(e.getFaces()).length && t.push({ error: \"Shell is disconnected\", source: [e] });var l = e.collectVertices(),h = e.collectEdges(),d = new Set(),g = new Set();return l.forEach(function (e) {e.collectEdges(d), e.collectFaces(g);}), d.size !== h.size && t.push({ error: \"Shell has rogue edges\", source: [e] }), l.size > 0 && g.size !== e.getFaces().length && t.push({ error: \"Shell has rogue faces\", source: [e] }), t;}function g(e) {var t = u(e),r = e.getShell();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.SHELL && t.push({ error: \"Face has invalid parent Shell\", source: [e] });var n = 0,i = 0,s = e.getLoops(),c = e.getSurface();if (s.length > 0) {for (var l = new Set(), h = 0; h < s.length; ++h) {var d = s[h];l.add(d), d && d.getTopologyType() === o.TOPOLOGY_TYPES.LOOP ? d.getFace() !== e && t.push({ error: \"Face is not the parent of child Loop\", source: [e, d] }) : t.push({ error: \"Face has invalid element in Loop array\", source: [e, d] }), n += d.collectEdges().size, i += d.collectVertices().size;}l.size !== s.length && t.push({ error: \"Face has non-unique Loops\", source: [e] });} else {var g = c.getGeometryType() === o.GEOMETRY_TYPES.SPHERE,p = c.getGeometryType() === o.GEOMETRY_TYPES.TORUS && c.isDoughnut();g || p || t.push({ error: \"Face has no Loops\", source: [e] });}return n !== e.collectEdges().size && t.push({ error: \"Face has Loops which share Edges\", source: [e] }), i !== e.collectVertices().size && t.push({ error: \"Face has Loops which share Vertices\", source: [e] }), c ? c instanceof a.Surface || t.push({ error: \"Face has invalid Surface geometry\", source: [e, c] }) : t.push({ error: \"Face has no Surface geometry\", source: [e] }), t;}function p(e) {var t = u(e),r = e.getFace();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.FACE && t.push({ error: \"Loop has invalid parent Face\", source: [e] });var n = e.getCoedges();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];if (i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.COEDGE) {a.getLoop() !== e && t.push({ error: \"Loop is not the parent of child Coedge\", source: [e, a] });var c = n[(s + 1) % n.length];a.getEndVertex() !== c.getStartVertex() && t.push({ error: \"Loop has disconnected Coedges\", source: [e, a, c] });} else t.push({ error: \"Loop has invalid element in Coedge array\", source: [e, a] });}i.size !== n.length && t.push({ error: \"Loop has non-unique Coedges\", source: [e] });} else t.push({ error: \"Loop has no Coedges\", source: [e] });return t;}function f(e) {var t = u(e),r = e.getLoop();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.LOOP && t.push({ error: \"Coedge has invalid parent Loop\", source: [e] });var n = e.getBody(),i = new Set(),s = e;do {if (i.has(s)) {t.push({ error: \"Coedge partner list does not form a loop\", source: [e] });break;}if (i.add(s), !s.getPartner()) {s !== e && t.push({ error: \"Coedge has no partner\", source: [e, s] });break;}if ((s = s.getPartner()).getTopologyType() !== o.TOPOLOGY_TYPES.COEDGE) {t.push({ error: \"Coedge has invalid entry in partner list\", source: [e, s] });break;}s.getEdge() !== e.getEdge() && t.push({ error: \"Coedge partner refers to a different Edge\", source: [e, s] }), s.getBody() !== n && t.push({ error: \"Coedge partner is part of a different Body\", source: [e, s] });} while (s !== e);var a = e.getEdge();return a ? a.getTopologyType() !== o.TOPOLOGY_TYPES.EDGE ? t.push({ error: \"Coedge has invalid Edge\", source: [e, a] }) : (s = a.getCoedge()) && i.has(s) || t.push({ error: \"Coedge partner list does not include parent of Edge\", source: [e, a] }) : t.push({ error: \"Coedge has no Edge\", source: [e] }), t;}function v(e) {var t = u(e),r = e.getCoedge(),s = e.getWire();s && r ? t.push({ error: \"Edge has too many parents, both Wire and Coedge\", source: [e] }) : s ? s.getTopologyType() !== o.TOPOLOGY_TYPES.WIRE && t.push({ error: \"Edge has invalid parent Wire\", source: [e] }) : r && r.getTopologyType() !== o.TOPOLOGY_TYPES.COEDGE && t.push({ error: \"Edge has invalid parent Coedge\", source: [e] });for (var a = e.getVertices(), c = 0; c < a.length; ++c) {var l = a[c];l && l.getTopologyType() === o.TOPOLOGY_TYPES.VERTEX ? l.isAdjacentEdge(e) || t.push({ error: \"Edge is not adjacent to own Vertex\", source: [e, l] }) : t.push({ error: \"Edge has invalid Vertex\", source: [e, l] });}var h = e.getCurve();return h ? h instanceof i.Curve ? t = t.concat(function (e, t) {var r = [],i = e.isReversed(),s = e.getRange();if (void 0 === s || 2 !== s.length || void 0 === s[0] || void 0 === s[1] || s[1] < s[0]) return r.push({ error: \"Edge range is not defined\", source: [e, s] }), r;var a = e.getStartVertex(),c = i ? -e.t0() : e.t0(),u = t.evaluatePosition(c),l = Math.max(o.KERNEL_TOLERANCE, a.getPrecision());n.Vector3.equals(a.getPosition(), u, l) || r.push({ error: \"Edge start position not consistent with Vertex\", source: [e, a, u] });var h = e.getEndVertex(),d = i ? -e.t1() : e.t1(),g = t.evaluatePosition(d),p = Math.max(o.KERNEL_TOLERANCE, h.getPrecision());return n.Vector3.equals(h.getPosition(), g, p) || r.push({ error: \"Edge end position not consistent with Vertex\", source: [e, h, g] }), e.isClosed() ? (a !== h && r.push({ error: \"Edge is closed but has different start and end Vertices\", source: [e] }), n.Vector3.equals(u, g, o.KERNEL_TOLERANCE) || r.push({ error: \"Edge is closed but has different start and end positions\", source: [e, u, g] }), t.isClosed() || r.push({ error: \"Edge is closed but its curve is not\", source: [e] })) : (a === h && r.push({ error: \"Edge is open but has same start and end Vertices\", source: [e] }), n.Vector3.equals(u, g, o.KERNEL_TOLERANCE) && r.push({ error: \"Edge is open but has same start and end positions\", source: [e, u, g] })), t.isPeriodic() ? Math.abs(d - c) > t.getPeriod() + o.PARAMETER_SPACE_TOLERANCE && r.push({ error: \"Edge parameter range is longer than curve period\", source: [e] }) : ((c + o.PARAMETER_SPACE_TOLERANCE < t.getRange()[0] || c - o.PARAMETER_SPACE_TOLERANCE > t.getRange()[1]) && r.push({ error: \"Edge start parameter is outside of curve range\", source: [e] }), (d + o.PARAMETER_SPACE_TOLERANCE < t.getRange()[0] || d - o.PARAMETER_SPACE_TOLERANCE > t.getRange()[1]) && r.push({ error: \"Edge end parameter is outside of curve range\", source: [e] })), r;}(e, h)) : t.push({ error: \"Edge has invalid Curve geometry\", source: [e, h] }) : t = t.concat(function (e) {if (e.getWire()) return [{ error: \"Degenerate Edge is part of a Wire\", source: [e] }];if (e.getStartVertex() !== e.getEndVertex()) return [{ error: \"Degenerate Edge has different start and end vertices\", source: [e] }];var t = Array.from(e.collectFaces());if (0 === t.length) return [];if (1 !== t.length) return [{ error: \"Degenerate Edge is part of multiple Faces\", source: [e] }];var r = e.getStartVertex().getPosition(),i = t[0].getSurface(),s = i.getGeometryType();if (s === o.GEOMETRY_TYPES.PLANE || s === o.GEOMETRY_TYPES.CYLINDER || s === o.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER || s === o.GEOMETRY_TYPES.SPHERE) return [{ error: \"Degenerate Edge is on a surface with no singularities\", source: [e, i] }];if (s === o.GEOMETRY_TYPES.CONE || s === o.GEOMETRY_TYPES.ELLIPTICAL_CONE) {if (!(l = i.getApexPosition())) return [{ error: \"Degenerate Edge is on a surface with no singularities\", source: [e, i] }];if (!n.Vector3.equals(r, l, o.KERNEL_TOLERANCE)) return [{ error: \"Degenerate Edge is not at a surface singularity\", source: [e, i] }];} else {if (s !== o.GEOMETRY_TYPES.TORUS) return [{ error: \"Degenerate Edge is not on an analytic surface\", source: [e] }];for (var a = !1, c = i.getSingularUParams(), u = 0; u < c.length; ++u) {var l = i.evaluatePosition(c[u], 0);n.Vector3.equals(r, l, o.KERNEL_TOLERANCE) && (a = !0);}if (!a) return [{ error: \"Degenerate Edge is not at a surface singularity\", source: [e, i] }];}return [];}(e)), t;}function _(e) {var t = u(e),r = e.getEdges();if (r.length > 0) for (var n = e.getBody(), i = 0; i < r.length; ++i) {var a = r[i];a && a.getTopologyType() === o.TOPOLOGY_TYPES.EDGE ? a.getStartVertex() !== e && a.getEndVertex() !== e ? t.push({ error: \"Vertex is not an end-point of adjacent Edge\", source: [e, a] }) : a.getBody() !== n && t.push({ error: \"Vertex has adjacent Edge from a different body\", source: [e, a] }) : t.push({ error: \"Vertex has invalid entry in Edge list\", source: [e, a] });} else t.push({ error: \"Vertex has no adjacent Edges\", source: [e] });var c = e.getPoint();return c ? c instanceof s.Point || t.push({ error: \"Vertex has invalid Point geometry\", source: [e, c] }) : t.push({ error: \"Vertex has no Point geometry\", source: [e] }), t;}function y(e) {var t = u(e),r = 0,n = 0,i = e.getWires();if (i.length > 0) {for (var s = new Set(), a = 0; a < i.length; ++a) {var c = i[a];s.add(c), c && c.getTopologyType() === o.TOPOLOGY_TYPES.WIRE ? c.getWireBody() !== e && t.push({ error: \"WireBody is not the parent of child Wire\", source: [e, c] }) : t.push({ error: \"WireBody has invalid element in Wire array\", source: [e, c] }), r += c.collectEdges().size, n += c.collectVertices().size;}s.size !== i.length && t.push({ error: \"WireBody has non-unique Wires\", source: [e] });} else t.push({ error: \"WireBody has no Wires\", source: [e] });return r !== e.collectEdges().size && t.push({ error: \"WireBody has Wires which share Edges\", source: [e] }), n !== e.collectVertices().size && t.push({ error: \"WireBody has Wires which share Vertices\", source: [e] }), t;}function m(e) {var t = u(e),r = e.getWireBody();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.WIREBODY && t.push({ error: \"Wire has invalid parent WireBody\", source: [e] });var n = e.getEdges();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.EDGE ? a.getWire() !== e && t.push({ error: \"Wire is not the parent of child Edge\", source: [e, a] }) : t.push({ error: \"Wire has invalid element in Edge array\", source: [e, a] });}i.size !== n.length && t.push({ error: \"Wire has non-unique Edges\", source: [e] });var l = (0, c.findConnectedEdges)(n);1 !== l.length ? t.push({ error: \"Wire is not a connected set of Edges\", source: [e] }) : l[0].length !== n.length && t.push({ error: \"Wire is connected to other unknown Edges\", source: [e] });} else t.push({ error: \"Wire has no Edges\", source: [e] });return t;}t.checkValidity = function (e) {for (var t, r, n, i = [], s = [e], a = new Set(), c = new Map(); s.length > 0;) {a.clear();var u = new Set();for (t = 0; t < s.length; ++t) {switch ((r = s[t]).getTopologyType()) {case o.TOPOLOGY_TYPES.BODY:i = i.concat(l(r)), r.getLumps().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.LUMP:i = i.concat(h(r)), r.getShells().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.SHELL:i = i.concat(d(r)), r.getFaces().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.FACE:i = i.concat(g(r)), r.getLoops().forEach(function (e) {a.add(e);}), r.getSurface() && u.add(r.getSurface());break;case o.TOPOLOGY_TYPES.LOOP:i = i.concat(p(r)), r.getCoedges().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.COEDGE:i = i.concat(f(r)), a.add(r.getEdge());break;case o.TOPOLOGY_TYPES.EDGE:i = i.concat(v(r)), r.getVertices().forEach(function (e) {e && a.add(e);}), r.getCurve() && u.add(r.getCurve());break;case o.TOPOLOGY_TYPES.VERTEX:i = i.concat(_(r)), r.getPoint() && u.add(r.getPoint());break;case o.TOPOLOGY_TYPES.WIREBODY:i = i.concat(y(r)), r.getWires().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.WIRE:i = i.concat(m(r)), r.getEdges().forEach(function (e) {a.add(e);});}n = r.getGuid(), c.has(n) ? i.push({ error: \"Objects have clashing GUIDs\", source: [r, c.get(n)] }) : c.set(n, r);}for (u = Array.from(u), t = 0; t < u.length; ++t) {n = (r = u[t]).getGuid(), c.has(n) ? i.push({ error: \"Objects have clashing GUIDs\", source: [r, c.get(n)] }) : c.set(n, r);}s = Array.from(a);}return i;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.facetPlanarFace = void 0;var n = r(1),o = r(0),i = r(108),s = r(3),a = r(109),c = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),u = r(8),l = 1e-8,h = o.KERNEL_TOLERANCE,d = function d(e, t, r) {var o,i = e[(0, s.modulus)(t - 1, e.length)],a = e[(0, s.modulus)(t + 1, e.length)],c = e[t],u = c[0] - i[0],l = c[1] - i[1],d = a[0] - c[0],g = a[1] - c[1],p = Math.sqrt(u * u + l * l),f = Math.sqrt(d * d + g * g);u * d + l * g < -.95 * p * f ? (u *= -1, l *= -1) : r ? (o = u, u = -l, l = o, o = d, d = -g, g = o) : (o = u, u = l, l = -o, o = d, d = g, g = -o);var v = .5 * (u / p + d / f),_ = .5 * (l / p + g / f),y = Math.sqrt(v * v + _ * _);e[t] = n.Vector3.clone(c), e[t][0] += h * v / y, e[t][1] += h * _ / y;},g = function g(e) {return String(e[0]) + String(e[1]);},p = function p(e) {for (var t = !1, r = {}, n = 0; n < e.length; n++) {var o = g(e[n]);void 0 === r[o] ? r[o] = [] : t = !0, r[o].push(n);}return { table: r, foundSelfIntersection: t };},f = function f(e) {var t = p(e);if (t.foundSelfIntersection) {for (var r = (0, i.isLoopCCW)(e), n = [], o = 0; o < e.length - 1; o++) {n[o] = !1;}var a = [];for (o = 0; o < e.length - 1; o++) {if (!n[o]) {var c = [],u = o;n[u] = !0, c.push(e[u]);var l = g(c[0]),h = e[(0, s.modulus)(u + 1, e.length)],f = g(h),v = [];for (t.table[l].length > 1 && v.push(0); f !== l;) {if (c.push(h), c.length > e.length) throw new Error(\"splitHole failure\");var _ = t.table[f];if (1 === _.length) u++;else {v.push(c.length - 1);for (var y = [], m = 0; m < _.length; m++) {_[m] !== u && y.push(_[m]);}var E = Math.atan2(e[u + 1][1] - e[u][1], e[u + 1][0] - e[u][0]);E = (0, s.normalizeParameterToShiftedRange)(E - Math.PI, [-Math.PI, Math.PI]);var x = -1,R = 0;for (m = 0; m < y.length; m++) {var A = Math.atan2(e[(0, s.modulus)(y[m] + 1, e.length)][1] - e[y[m]][1], e[(0, s.modulus)(y[m] + 1, e.length)][0] - e[y[m]][0]);A < E && r ? A += s.PI2 : A > E && !r && (A -= s.PI2);var P = Math.abs(A - E);P > R && (R = P, x = y[m]);}u = x;}h = e[(0, s.modulus)(u + 1, e.length)], f = g(h), n[u] = !0;}for (m = 0; m < v.length; m++) {d(c, v[m], r);}a.push(c);}}return a;}return [e];},v = function v(e, t) {for (var r = [], n = 0; n < e.length; n++) {r[n] = { index: void 0, loop: void 0 };for (var o = e[n], i = 0; i < t.length; i++) {for (var s = t[i], a = 0; a < s.length; a++) {if (s[a][0] === o[0] && s[a][1] === o[1]) {r[n].index = a, r[n].loop = s;break;}}}}return r;};function _(e, t) {var r,n = !1,o = t.length,i = o - 1;for (r = 0; r < o; r += 2) {t[r][1] > e[1] != t[i][1] > e[1] && e[0] < (t[i][0] - t[r][0]) * (e[1] - t[r][1]) / (t[i][1] - t[r][1]) + t[r][0] && (n = !n), i = r;}return n;}function y(e, t, r) {for (var o, s, a = v(e, [t].concat(r)), c = [], h = [], d = void 0, g = void 0, p = 0; p < 4; ++p) {a[p] && void 0 !== a[p].index && (d ? g || a[p].loop === d || (g = a[p].loop) : d = a[p].loop, a[p].loop === d ? (o = d, s = c) : (o = g, s = h), (P = [a[p].index - 1, a[p].index])[0] < 0 && (P[0] = o.length - 1), s.push(P), s.push([a[p].index, (a[p].index + 1) % o.length]));}g || (g = d, h = c);var f,y,m = void 0,E = d,x = c;for (p = 0; p < 3; ++p) {for (f = 0; f < c.length; ++f) {for (y = 0; y < h.length && (c === h && y >= f || !(m = (0, i.intersectSegments)(d[c[f][0]], d[c[f][1]], g[h[y][0]], g[h[y][1]], 0)) || !m.intersection); ++y) {;}if (m && m.intersection) break;}if (m && m.intersection || d === g) break;0 === p ? (d = g, c = h) : 1 === p && (d = E, c = x, g = E, h = x);}if (void 0 !== m && m.intersection) {var R = n.Vector3.subtract(n.Vector3.createFloat64(), d[c[f][1]], d[c[f][0]]);n.Vector3.scale(R, R, m.solutions[0]);var A = n.Vector3.add(R, R, d[c[f][0]]);if (c[f][0] > c[f][1]) {var P = c[f][1];c[f][1] = c[f][0], c[f][0] = P;}if (0 === c[f][0] && 1 !== c[f][1] && (c[f][0] = c[f][1], c[f][1] = 0), h[y][0] > h[y][1] && 0 !== h[y][1] && (P = h[y][1], h[y][1] = h[y][0], h[y][0] = P), 0 === h[y][0] && 1 !== h[y][1] && (h[y][0] = h[y][1], h[y][1] = 0), d === g) {if (d.length < 4) return void console.error(\"REGION: Failed to fix loop tessellation! [loop too short]\");console.log(\"REGION: Fixing self-intersection\");var V = new Array(4);c[f][0] < h[y][0] ? (V[0] = c[f][0], V[1] = c[f][1], V[2] = h[y][0], V[3] = h[y][1]) : (V[0] = h[y][0], V[1] = h[y][1], V[2] = c[f][0], V[3] = c[f][1]);var T = [];for (p = 0; p <= V[0]; ++p) {T.push(d[p]);}var C = n.Vector3.subtract(n.Vector3.createFloat64(), d[V[0]], d[V[1]]);n.Vector3.normalize(C, C), n.Vector3.scale(C, C, l);var b = n.Vector3.add(n.Vector3.createFloat64(), A, C);for (T.push(b), p = V[2]; p >= V[1]; --p) {T.push(d[p]);}var L = n.Vector3.subtract(n.Vector3.createFloat64(), A, C);if (T.push(L), V[3] > V[2]) for (p = V[3]; p < d.length; ++p) {T.push(d[p]);}for (d.length = T.length, p = 0; p < T.length; ++p) {d[p] = T[p];}} else {console.log(\"REGION: Fixing loop-loop intersection\");var O = d,S = g,M = h[y][0],w = h[y][1],N = c[f][0],F = c[f][1];(t === S || S.length > O.length && t !== O) && (O = g, S = d, M = c[f][0], w = c[f][1], N = h[y][0], F = h[y][1]);var I = 1;t !== S && t !== O && (I = -1);var D = 1;_(S[w], O) && (D = -1, P = M, M = w, w = P), n.Vector3.subtract(S[w], S[M], S[w]), n.Vector3.normalize(S[w], S[w]), n.Vector3.scale(S[w], S[w], I * l), n.Vector3.add(S[w], A, S[w]);var j,B,U = w;do {(w += D) < 0 ? w = S.length - 1 : w %= S.length;} while (w !== M && !_(S[w], O));(M = w - D) < 0 && (M = S.length - 1), F = N;do {j = O[F], B = O[F = ++F % O.length], m = (0, i.intersectSegments)(j, B, S[M], S[w], 0);} while (N !== F && !m.intersection);m.intersection && (n.Vector3.scale(R, n.Vector3.subtract(R, B, j), m.solutions[0]), n.Vector3.add(A, R, j), n.Vector3.subtract(S[M], S[w], S[M]), n.Vector3.normalize(S[M], S[M]), n.Vector3.scale(S[M], S[M], I * l), n.Vector3.add(S[M], A, S[M])), Math.min(Math.abs(U - M), Math.abs(U - M - S.length)) > 1 && console.warn(\"REGION: Remove loop segment! FIXME!\");}} else u.DebugUtils.warn(\"REGION: Failed to fix loop tessellation! [no intersected segments]\");}var m = function m(e, t) {var r = e;for (r < 0 ? r += t.length : r %= t.length; t[r] !== r;) {r = t[r];}return r;},E = function E(e, t, r, o) {return n.Vector3.distance(r[e], r[t]) < 1e-6 ? (o[0] = e, o[1] = e, 1) : 0;},x = function x(e, t, r, o, i) {var s = new Array(2);if (s[0] = o[e], s[1] = o[r], n.Vector3.length(n.Vector3.subtract(n.Vector3.createFloat64(), s[0], s[1])) < 1e-6) return i[0] = e, i[1] = e, i[2] = e, 2;var a = (s[0][0] - s[1][0]) * (o[t][1] - s[1][1]) - (s[0][1] - s[1][1]) * (o[t][0] - s[1][0]);return a > -l * l && a < l * l ? (i[0] = e, i[1] = e, i[2] = r, 1) : 0;},R = function R(e, t, r, n, o, s) {return (0, i.intersectSegments)(o[e], o[t], o[r], o[n]).intersection ? (s[0] = e, s[1] = t, s[2] = t, s[3] = n, 1) : (s[0] = -1, 0);},A = function A(e) {if (e.length < 4) return e;for (var t, r, n, o, i = e.length, s = new Int32Array(i), a = 0; a < i; ++a) {s[a] = a;}var c,u = new Array(3),l = new Array(3);for (l[0] = 0, l[1] = 0, l[2] = 0, a = 0; a < i; ++a) {t = m(a, s), r = m(a + 1, s), (c = E(t, r, e, u)) && (++l[0], s[t] = u[0], s[r] = u[1], t = m(a += c, s), r = m(a + 1, s)), n = m(a + 2, s), (c = x(t, r, n, e, u)) && (++l[1], s[t] = u[0], s[r] = u[1], s[n] = u[2], t = m(a += c, s), r = m(a + 1, s), n = m(a + 2, s)), o = m(a + 3, s), (c = R(t, r, n, o, e, u)) && (++l[2], s[t] = u[0], s[r] = u[1], s[n] = u[2], s[o] = u[3], a += c);}var h = [];for (a = 0; a < e.length; ++a) {s[a] === a && h.push(e[a]);}return h;},P = function P(e, t, r) {for (var n = v(e, [t].concat(r)), o = 0; o < n.length; o++) {d(n[o].loop, n[o].index, (0, i.isLoopCCW)(n[o].loop));}},V = function V(e, t) {var r = !1;!function (e) {var t = p(e);if (t.foundSelfIntersection) for (var r = (0, i.isLoopCCW)(e), n = c.default.keys(t.table), o = 0; o < n.length; o++) {if (t.table[n[o]].length > 1) for (var s = t.table[n[o]], a = 0; a < s.length; a++) {d(e, s[a], r);}}}(e);for (var n = [], o = 0; o < t.length; o++) {n.push.apply(n, f(t[o]));}var s = A(e),l = [];for (o = 0; o < n.length; o++) {l.push(A(n[o]));}var h = 8;do {r = !0;var g = (0, c.default)(s).map(function (e) {return new a.poly2tri.Point(e[0], e[1]);}),v = new a.poly2tri.SweepContext(g);for (o = 0; o < l.length; o++) {var _ = (0, c.default)(l[o]).map(function (e) {return new a.poly2tri.Point(e[0], e[1]);});v.addHole(_);}try {v.triangulate();} catch (e) {if (\"poly2tri Intersecting Constraints\" === e.message.substr(0, 33)) r = !1, y(e.points, s, l);else if (\"poly2tri EdgeEvent: Collinear not supported\" === e.message.substr(0, 43)) r = !1, P(e.points, s, l);else {if (!e.points) throw e;r = !1, y(e.points, s, l);}}} while (!r && h-- > 0);return h <= 0 && u.DebugUtils.warn(\"Computation of region tessellation failed, due to too many intersections.\"), v;};t.facetPlanarFace = function (e, t) {var r = e.getSurface(),o = (0, s.getPlaneTransforms)(r),a = new i.LoopCalculator(e, o.threeSpaceToUV).getRank0Loops();if (1 !== a.length) throw new Error(\"Each region should have exactly one top-loop\");var c = a[0],u = (0, i.tessellateLoop)(c._loop, t);if (o.threeSpaceToUV) for (var l = 0; l < u.length; l++) {n.Vector3.transformMatrix44(u[l], u[l], o.threeSpaceToUV);}for (var h = [], d = c.getImmediatelyInsideLoops(), g = 0; g < d.length; g++) {var p = (0, i.tessellateLoop)(d[g]._loop, t);if (h.push(p), o.threeSpaceToUV) for (l = 0; l < p.length; l++) {n.Vector3.transformMatrix44(p[l], p[l], o.threeSpaceToUV);}}var f = V(u, h),v = f.getTriangles(),_ = new Uint32Array(3 * v.length),y = new Float32Array(3 * f.pointCount()),m = n.Vector3.createFloat64();for (l = 0; l < f.pointCount(); l++) {var E = f.getPoint(l);n.Vector3.set(m, E.x, E.y, 0), o.uvToThreeSpace && n.Vector3.transformMatrix44(m, m, o.uvToThreeSpace), y[3 * l] = m[0], y[3 * l + 1] = m[1], y[3 * l + 2] = m[2], E.index = l;}for (l = 0; l < v.length; l++) {var x = v[l].getPoints();for (e.isReversed() && x.reverse(), g = 0; g < x.length; g++) {var R = x[g];_[3 * l + g] = R.index;}}return { indexBuffer: _, vertexBuffer: y };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.LoopCalculator = t.intersectSegments = t.isLoopCCW = t.tessellateLoop = void 0;var n = r(1),o = r(0),i = r(3),s = function s(e, t) {this._loop = e, this._enclosureRank = 0, this._isOuterLoop = !1, this._insideLoops = [], this._isOpen = !1, this._coedges = this._loop.getCoedges();for (var r = 0; r < this._coedges.length; ++r) {this._coedges[r].generateUVCurve(t);}};s.prototype.addInsideLoop = function (e) {this._insideLoops.push(e);}, s.prototype.uvAngleSubtended = function (e) {if (!this.isClosedLoop()) throw new Error(\"uvAngleSubtended cannot work with open loops\");for (var t = 0, r = 0; r < this._coedges.length; r++) {t += this._coedges[r].uvAngleSubtended(e);}return t;}, s.prototype.getArbitraryPointOnLoop = function () {if (1 === this._coedges.length) {var e = this._coedges[0].t0();return this._coedges[0].evaluatePosition(e);}var t = this._coedges[0].getStartVertex();if (t) return t.getPosition();}, s.prototype.isInside = function (e) {var t = this.getArbitraryPointOnLoop(),r = Math.abs(e.uvAngleSubtended(t)),n = Math.floor(r / (2 * Math.PI)),i = r - 2 * n * Math.PI;return !!(Math.abs(i) < o.KERNEL_TOLERANCE && n || Math.abs(i - 2 * Math.PI) < o.KERNEL_TOLERANCE);}, s.prototype.getEnclosureRank = function () {return this._enclosureRank;}, s.prototype.resetEnclosureRank = function () {this._enclosureRank = 0;}, s.prototype.decreaseEnclosureRank = function () {this._enclosureRank--;}, s.prototype.setIsOuterLoop = function (e) {this._isOuterLoop = e;}, s.prototype.isOuterLoop = function () {return this._isOuterLoop;}, s.prototype.isClosedLoop = function () {return !this._isOpen;}, s.prototype.addInsideLoop = function (e) {this._insideLoops.push(e);}, s.prototype.getImmediatelyInsideLoops = function () {for (var e = [], t = 0; t < this._insideLoops.length; t++) {this._insideLoops[t].getEnclosureRank() === this._enclosureRank - 1 && e.push(this._insideLoops[t]);}return e;};var a = function a(e, t) {this._face = e, this._loops = [];for (var r = 0; r < this._face.getLoops().length; ++r) {this._loops.push(new s(this._face.getLoops()[r], t));}this._calcSenses();};a.prototype._calcSenses = function () {for (var e = this._loops.length, t = 0; t < e; t++) {this._loops[t].resetEnclosureRank();}for (t = 0; t < e; t++) {if (this._loops[t].isClosedLoop()) for (var r = 0; r < e; r++) {this._loops[r].isClosedLoop() && t !== r && this._loops[t].isInside(this._loops[r]) && !this._loops[r].isInside(this._loops[t]) && (this._loops[t].decreaseEnclosureRank(), this._loops[r].addInsideLoop(this._loops[t]));}}for (t = 0; t < e; t++) {var n = 0 - this._loops[t].getEnclosureRank();this._loops[t].setIsOuterLoop(n % 2 == 0);}}, a.prototype.getRank0Loops = function () {var e = [];return this._loops.forEach(function (t) {0 === t.getEnclosureRank() && e.push(t);}), e;}, t.tessellateLoop = function (e, t) {for (var r = [], o = 0, i = e.getCoedges().length; o < i; ++o) {var s = e.getCoedges()[o],a = s.getEdge(),c = a.tessellate(void 0, t).positions;c = c.slice(1, c.length - 1), (c = [n.Vector3.clone(a.getStartVertex().getPosition())].concat(c)).push(n.Vector3.clone(a.getEndVertex().getPosition())), s.isReversed() && c.reverse(), r = r.concat(c.slice(0, c.length - 1));}return r;}, t.isLoopCCW = function (e) {for (var t = 0, r = 0; r < e.length; r++) {var n = (r + 1) % e.length;t += e[r][0] * e[n][1] - e[r][1] * e[n][0];}return t > 0;}, t.intersectSegments = function (e, t, r, o, s) {var a = [[t[0] - e[0], -(o[0] - r[0]), r[0] - e[0]], [t[1] - e[1], -(o[1] - r[1]), r[1] - e[1]]],c = (0, i.solveTwoEquationsTwoVariables)(a);if (void 0 === c) return !1;var u = n.Vector3.distance(e, t),l = n.Vector3.distance(r, o);return { intersection: -s < c[0] * u && (c[0] - 1) * u < s && -s < c[1] * l && (c[1] - 1) * l < s, solutions: c };}, t.LoopCalculator = a;}, function (e, t, r) {\"use strict\";var n, o;if (Object.defineProperty(t, \"__esModule\", { value: !0 }), void 0 === i) var i = {},s = { exports: {} };!function (a) {\"object\" == _typeof(i) ? s.exports = a() : void 0 === (o = \"function\" == typeof (n = a) ? n.call(t, r, t, e) : n) || (e.exports = o);}(function () {return function e(t, r, n) {function o(s, a) {if (!r[s]) {if (!t[s]) {if (i) return i(s, !0);throw new Error(\"Cannot find module '\" + s + \"'\");}var c = r[s] = { exports: {} };t[s][0].call(c.exports, function (e) {return o(t[s][1][e] || e);}, c, c.exports, e, t, r, n);}return r[s].exports;}for (var i = !1, s = 0; s < n.length; s++) {o(n[s]);}return o;}({ 1: [function (e, t, r) {t.exports = { version: \"1.3.5\" };}, {}], 2: [function (e, t, r) {var n = function n(e, t) {this.head_ = e, this.tail_ = t, this.search_node_ = e;};n.prototype.head = function () {return this.head_;}, n.prototype.setHead = function (e) {this.head_ = e;}, n.prototype.tail = function () {return this.tail_;}, n.prototype.setTail = function (e) {this.tail_ = e;}, n.prototype.search = function () {return this.search_node_;}, n.prototype.setSearch = function (e) {this.search_node_ = e;}, n.prototype.findSearchNode = function () {return this.search_node_;}, n.prototype.locateNode = function (e) {var t = this.search_node_;if (e < t.value) {for (; t = t.prev;) {if (e >= t.value) return this.search_node_ = t, t;}} else for (; t = t.next;) {if (e < t.value) return this.search_node_ = t.prev, t.prev;}return null;}, n.prototype.locatePoint = function (e) {var t = e.x,r = this.findSearchNode(t),n = r.point.x;if (t === n) {if (e !== r.point) if (e === r.prev.point) r = r.prev;else {if (e !== r.next.point) throw new Error(\"poly2tri Invalid AdvancingFront.locatePoint() call\");r = r.next;}} else if (t < n) for (; (r = r.prev) && e !== r.point;) {;} else for (; (r = r.next) && e !== r.point;) {;}return r && (this.search_node_ = r), r;}, t.exports = n, t.exports.Node = function (e, t) {this.point = e, this.triangle = t || null, this.next = null, this.prev = null, this.value = e.x;};}, {}], 3: [function (e, t, r) {t.exports = function (e, t) {if (!e) throw new Error(t || \"Assert Failed\");};}, {}], 4: [function (e, t, r) {var n = e(\"./xy\"),o = function o(e, t) {this.x = +e || 0, this.y = +t || 0, this._p2t_edge_list = null;};o.prototype.toString = function () {return n.toStringBase(this);}, o.prototype.toJSON = function () {return { x: this.x, y: this.y };}, o.prototype.clone = function () {return new o(this.x, this.y);}, o.prototype.set_zero = function () {return this.x = 0, this.y = 0, this;}, o.prototype.set = function (e, t) {return this.x = +e || 0, this.y = +t || 0, this;}, o.prototype.negate = function () {return this.x = -this.x, this.y = -this.y, this;}, o.prototype.add = function (e) {return this.x += e.x, this.y += e.y, this;}, o.prototype.sub = function (e) {return this.x -= e.x, this.y -= e.y, this;}, o.prototype.mul = function (e) {return this.x *= e, this.y *= e, this;}, o.prototype.length = function () {return Math.sqrt(this.x * this.x + this.y * this.y);}, o.prototype.normalize = function () {var e = this.length();return this.x /= e, this.y /= e, e;}, o.prototype.equals = function (e) {return this.x === e.x && this.y === e.y;}, o.negate = function (e) {return new o(-e.x, -e.y);}, o.add = function (e, t) {return new o(e.x + t.x, e.y + t.y);}, o.sub = function (e, t) {return new o(e.x - t.x, e.y - t.y);}, o.mul = function (e, t) {return new o(e * t.x, e * t.y);}, o.cross = function (e, t) {return \"number\" == typeof e ? \"number\" == typeof t ? e * t : new o(-e * t.y, e * t.x) : \"number\" == typeof t ? new o(t * e.y, -t * e.x) : e.x * t.y - e.y * t.x;}, o.toString = n.toString, o.compare = n.compare, o.cmp = n.compare, o.equals = n.equals, o.dot = function (e, t) {return e.x * t.x + e.y * t.y;}, t.exports = o;}, { \"./xy\": 11 }], 5: [function (e, t, r) {var n = e(\"./xy\"),o = function o(e, t) {this.name = \"PointError\", this.points = t = t || [], this.message = e || \"Invalid Points!\";for (var r = 0; r < t.length; r++) {this.message += \" \" + n.toString(t[r]);}};(o.prototype = new Error()).constructor = o, t.exports = o;}, { \"./xy\": 11 }], 6: [function (e, t, r) {(function (t) {var n = t.poly2tri;r.noConflict = function () {return t.poly2tri = n, r;}, r.VERSION = e(\"../dist/version.json\").version, r.PointError = e(\"./pointerror\"), r.Point = e(\"./point\"), r.Triangle = e(\"./triangle\"), r.SweepContext = e(\"./sweepcontext\");var o = e(\"./sweep\");r.triangulate = o.triangulate, r.sweep = { Triangulate: o.triangulate };}).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {});}, { \"../dist/version.json\": 1, \"./point\": 4, \"./pointerror\": 5, \"./sweep\": 7, \"./sweepcontext\": 8, \"./triangle\": 9 }], 7: [function (e, t, r) {var n = e(\"./assert\"),o = e(\"./pointerror\"),i = e(\"./triangle\"),s = e(\"./advancingfront\").Node,a = e(\"./utils\"),c = a.EPSILON,u = a.Orientation,l = a.orient2d,h = a.inScanArea,d = a.isAngleObtuse;function g(e, t) {var r = e.locateNode(t),o = function (e, t, r) {var n = new i(t, r.point, r.next.point);n.markNeighbor(r.triangle), e.addToMap(n);var o = new s(t);return o.next = r.next, o.prev = r, r.next.prev = o, r.next = o, y(e, n) || e.mapTriangleToNodes(n), o;}(e, t, r);return t.x <= r.point.x + c && _(e, r), function (e, t) {for (var r = t.next; r.next && !d(r.point, r.next.point, r.prev.point);) {_(e, r), r = r.next;}for (r = t.prev; r.prev && !d(r.point, r.next.point, r.prev.point);) {_(e, r), r = r.prev;}t.next && t.next.next && function (e) {var t = e.point.x - e.next.next.point.x,r = e.point.y - e.next.next.point.y;return n(r >= 0, \"unordered y\"), t >= 0 || Math.abs(t) < r;}(t) && function (e, t) {for (l(t.point, t.next.point, t.next.next.point) === u.CCW ? e.basin.left_node = t.next.next : e.basin.left_node = t.next, e.basin.bottom_node = e.basin.left_node; e.basin.bottom_node.next && e.basin.bottom_node.point.y >= e.basin.bottom_node.next.point.y;) {e.basin.bottom_node = e.basin.bottom_node.next;}if (e.basin.bottom_node !== e.basin.left_node) {for (e.basin.right_node = e.basin.bottom_node; e.basin.right_node.next && e.basin.right_node.point.y < e.basin.right_node.next.point.y;) {e.basin.right_node = e.basin.right_node.next;}e.basin.right_node !== e.basin.bottom_node && (e.basin.width = e.basin.right_node.point.x - e.basin.left_node.point.x, e.basin.left_highest = e.basin.left_node.point.y > e.basin.right_node.point.y, function e(t, r) {if (!function (e, t) {var r;return r = e.basin.left_highest ? e.basin.left_node.point.y - t.point.y : e.basin.right_node.point.y - t.point.y, e.basin.width > r;}(t, r) && (_(t, r), r.prev !== t.basin.left_node || r.next !== t.basin.right_node)) {if (r.prev === t.basin.left_node) {if (l(r.point, r.next.point, r.next.next.point) === u.CW) return;r = r.next;} else if (r.next === t.basin.right_node) {if (l(r.point, r.prev.point, r.prev.prev.point) === u.CCW) return;r = r.prev;} else r = r.prev.point.y < r.next.point.y ? r.prev : r.next;e(t, r);}}(e, e.basin.bottom_node));}}(e, t);}(e, o), o;}function p(e, t, r) {e.edge_event.constrained_edge = t, e.edge_event.right = t.p.x > t.q.x, v(r.triangle, t.p, t.q) || (function (e, t, r) {e.edge_event.right ? function (e, t, r) {for (; r.next.point.x < t.p.x;) {l(t.q, r.next.point, t.p) === u.CCW ? x(e, t, r) : r = r.next;}}(e, t, r) : function (e, t, r) {for (; r.prev.point.x > t.p.x;) {l(t.q, r.prev.point, t.p) === u.CW ? A(e, t, r) : r = r.prev;}}(e, t, r);}(e, t, r), f(e, t.p, t.q, r.triangle, t.q));}function f(e, t, r, n, i) {if (!v(n, t, r)) {var s = n.pointCCW(i),a = l(r, s, t);if (a === u.COLLINEAR) throw new o(\"poly2tri EdgeEvent: Collinear not supported!\", [r, s, t]);var c = n.pointCW(i),h = l(r, c, t);if (h === u.COLLINEAR) throw new o(\"poly2tri EdgeEvent: Collinear not supported!\", [r, c, t]);a === h ? f(e, t, r, n = a === u.CW ? n.neighborCCW(i) : n.neighborCW(i), i) : V(e, t, r, n, i);}}function v(e, t, r) {var n = e.edgeIndex(t, r);if (-1 !== n) {e.markConstrainedEdgeByIndex(n);var o = e.getNeighbor(n);return o && o.markConstrainedEdgeByPoints(t, r), !0;}return !1;}function _(e, t) {var r = new i(t.prev.point, t.point, t.next.point);r.markNeighbor(t.prev.triangle), r.markNeighbor(t.triangle), e.addToMap(r), t.prev.next = t.next, t.next.prev = t.prev, y(e, r) || e.mapTriangleToNodes(r);}function y(e, t) {for (var r = 0; r < 3; ++r) {if (!t.delaunay_edge[r]) {var n = t.getNeighbor(r);if (n) {var o = t.getPoint(r),i = n.oppositePoint(t, o),s = n.index(i);if (n.constrained_edge[s] || n.delaunay_edge[s]) {t.constrained_edge[r] = n.constrained_edge[s];continue;}if (m(o, t.pointCCW(o), t.pointCW(o), i)) {t.delaunay_edge[r] = !0, n.delaunay_edge[s] = !0, E(t, o, n, i);var a = !y(e, t);return a && e.mapTriangleToNodes(t), (a = !y(e, n)) && e.mapTriangleToNodes(n), t.delaunay_edge[r] = !1, n.delaunay_edge[s] = !1, !0;}}}}return !1;}function m(e, t, r, n) {var o = e.x - n.x,i = e.y - n.y,s = t.x - n.x,a = t.y - n.y,c = o * a - s * i;if (c <= 0) return !1;var u = r.x - n.x,l = r.y - n.y,h = u * i - o * l;return !(h <= 0) && (o * o + i * i) * (s * l - u * a) + (s * s + a * a) * h + (u * u + l * l) * c > 0;}function E(e, t, r, n) {var o, i, s, a, c, u, l, h, d, g, p, f;o = e.neighborCCW(t), i = e.neighborCW(t), s = r.neighborCCW(n), a = r.neighborCW(n), c = e.getConstrainedEdgeCCW(t), u = e.getConstrainedEdgeCW(t), l = r.getConstrainedEdgeCCW(n), h = r.getConstrainedEdgeCW(n), d = e.getDelaunayEdgeCCW(t), g = e.getDelaunayEdgeCW(t), p = r.getDelaunayEdgeCCW(n), f = r.getDelaunayEdgeCW(n), e.legalize(t, n), r.legalize(n, t), r.setDelaunayEdgeCCW(t, d), e.setDelaunayEdgeCW(t, g), e.setDelaunayEdgeCCW(n, p), r.setDelaunayEdgeCW(n, f), r.setConstrainedEdgeCCW(t, c), e.setConstrainedEdgeCW(t, u), e.setConstrainedEdgeCCW(n, l), r.setConstrainedEdgeCW(n, h), e.clearNeighbors(), r.clearNeighbors(), o && r.markNeighbor(o), i && e.markNeighbor(i), s && e.markNeighbor(s), a && r.markNeighbor(a), e.markNeighbor(r);}function x(e, t, r) {r.point.x < t.p.x && (l(r.point, r.next.point, r.next.next.point) === u.CCW ? R(e, t, r) : (function e(t, r, n) {l(n.next.point, n.next.next.point, n.next.next.next.point) === u.CCW ? R(t, r, n.next) : l(r.q, n.next.next.point, r.p) === u.CCW && e(t, r, n.next);}(e, t, r), x(e, t, r)));}function R(e, t, r) {_(e, r.next), r.next.point !== t.p && l(t.q, r.next.point, t.p) === u.CCW && l(r.point, r.next.point, r.next.next.point) === u.CCW && R(e, t, r);}function A(e, t, r) {r.point.x > t.p.x && (l(r.point, r.prev.point, r.prev.prev.point) === u.CW ? P(e, t, r) : (function e(t, r, n) {l(n.prev.point, n.prev.prev.point, n.prev.prev.prev.point) === u.CW ? P(t, r, n.prev) : l(r.q, n.prev.prev.point, r.p) === u.CW && e(t, r, n.prev);}(e, t, r), A(e, t, r)));}function P(e, t, r) {_(e, r.prev), r.prev.point !== t.p && l(t.q, r.prev.point, t.p) === u.CW && l(r.point, r.prev.point, r.prev.prev.point) === u.CW && P(e, t, r);}function V(e, t, r, i, s) {var a = i.neighborAcross(s);n(a, \"FLIP failed due to missing triangle!\");var c = a.oppositePoint(i, s);if (i.getConstrainedEdgeAcross(s)) {var d = i.index(s);throw new o(\"poly2tri Intersecting Constraints\", [s, c, i.getPoint((d + 1) % 3), i.getPoint((d + 2) % 3)]);}h(s, i.pointCCW(s), i.pointCW(s), c) ? (E(i, s, a, c), e.mapTriangleToNodes(i), e.mapTriangleToNodes(a), s === r && c === t ? r === e.edge_event.constrained_edge.q && t === e.edge_event.constrained_edge.p && (i.markConstrainedEdgeByPoints(t, r), a.markConstrainedEdgeByPoints(t, r), y(e, i), y(e, a)) : V(e, t, r, i = function (e, t, r, n, o, i) {var s;return t === u.CCW ? (s = n.edgeIndex(o, i), n.delaunay_edge[s] = !0, y(e, n), n.clearDelaunayEdges(), r) : (s = r.edgeIndex(o, i), r.delaunay_edge[s] = !0, y(e, r), r.clearDelaunayEdges(), n);}(e, l(r, c, t), i, a, s, c), s)) : (function e(t, r, o, i, s, a) {var c = s.neighborAcross(a);n(c, \"FLIP failed due to missing triangle\");var u = c.oppositePoint(s, a);h(o, i.pointCCW(o), i.pointCW(o), u) ? V(t, o, u, c, u) : e(t, r, o, i, c, T(r, o, c, u));}(e, t, r, i, a, T(t, r, a, c)), f(e, t, r, i, s));}function T(e, t, r, n) {var i = l(t, n, e);if (i === u.CW) return r.pointCCW(n);if (i === u.CCW) return r.pointCW(n);throw new o(\"poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!\", [t, n, e]);}r.triangulate = function (e) {e.initTriangulation(), e.createAdvancingFront(), function (e) {var t,r = e.pointCount();for (t = 1; t < r; ++t) {for (var n = e.getPoint(t), o = g(e, n), i = n._p2t_edge_list, s = 0; i && s < i.length; ++s) {p(e, i[s], o);}}}(e), function (e) {for (var t = e.front().head().next.triangle, r = e.front().head().next.point; !t.getConstrainedEdgeCW(r);) {t = t.neighborCCW(r);}e.meshClean(t);}(e);};}, { \"./advancingfront\": 2, \"./assert\": 3, \"./pointerror\": 5, \"./triangle\": 9, \"./utils\": 10 }], 8: [function (e, t, r) {var n = e(\"./pointerror\"),o = e(\"./point\"),i = e(\"./triangle\"),s = e(\"./sweep\"),a = e(\"./advancingfront\"),c = a.Node,u = function u(e, t) {if (this.p = e, this.q = t, e.y > t.y) this.q = e, this.p = t;else if (e.y === t.y) if (e.x > t.x) this.q = e, this.p = t;else if (e.x === t.x) throw new n(\"poly2tri Invalid Edge constructor: repeated points!\", [e]);this.q._p2t_edge_list || (this.q._p2t_edge_list = []), this.q._p2t_edge_list.push(this);},l = function l() {this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;};l.prototype.clear = function () {this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;};var h = function h(e, t) {t = t || {}, this.triangles_ = [], this.map_ = [], this.points_ = t.cloneArrays ? e.slice(0) : e, this.edge_list = [], this.pmin_ = this.pmax_ = null, this.front_ = null, this.head_ = null, this.tail_ = null, this.af_head_ = null, this.af_middle_ = null, this.af_tail_ = null, this.basin = new l(), this.edge_event = new function () {this.constrained_edge = null, this.right = !1;}(), this.initEdges(this.points_);};h.prototype.addHole = function (e) {this.initEdges(e);var t,r = e.length;for (t = 0; t < r; t++) {this.points_.push(e[t]);}return this;}, h.prototype.AddHole = h.prototype.addHole, h.prototype.addHoles = function (e) {var t,r = e.length;for (t = 0; t < r; t++) {this.initEdges(e[t]);}return this.points_ = this.points_.concat.apply(this.points_, e), this;}, h.prototype.addPoint = function (e) {return this.points_.push(e), this;}, h.prototype.AddPoint = h.prototype.addPoint, h.prototype.addPoints = function (e) {return this.points_ = this.points_.concat(e), this;}, h.prototype.triangulate = function () {return s.triangulate(this), this;}, h.prototype.getBoundingBox = function () {return { min: this.pmin_, max: this.pmax_ };}, h.prototype.getTriangles = function () {return this.triangles_;}, h.prototype.GetTriangles = h.prototype.getTriangles, h.prototype.front = function () {return this.front_;}, h.prototype.pointCount = function () {return this.points_.length;}, h.prototype.head = function () {return this.head_;}, h.prototype.setHead = function (e) {this.head_ = e;}, h.prototype.tail = function () {return this.tail_;}, h.prototype.setTail = function (e) {this.tail_ = e;}, h.prototype.getMap = function () {return this.map_;}, h.prototype.initTriangulation = function () {var e,t = this.points_[0].x,r = this.points_[0].x,n = this.points_[0].y,i = this.points_[0].y,s = this.points_.length;for (e = 1; e < s; e++) {var a = this.points_[e];a.x > t && (t = a.x), a.x < r && (r = a.x), a.y > n && (n = a.y), a.y < i && (i = a.y);}this.pmin_ = new o(r, i), this.pmax_ = new o(t, n);var c = .3 * (t - r),u = .3 * (n - i);this.head_ = new o(t + c, i - u), this.tail_ = new o(r - c, i - u), this.points_.sort(o.compare);}, h.prototype.initEdges = function (e, t) {var r,n = e.length,o = t ? e.length - 1 : e.length;for (r = 0; r < o; ++r) {this.edge_list.push(new u(e[r], e[(r + 1) % n]));}}, h.prototype.getPoint = function (e) {return this.points_[e];}, h.prototype.addToMap = function (e) {this.map_.push(e);}, h.prototype.locateNode = function (e) {return this.front_.locateNode(e.x);}, h.prototype.createAdvancingFront = function () {var e,t,r,n = new i(this.points_[0], this.tail_, this.head_);this.map_.push(n), e = new c(n.getPoint(1), n), t = new c(n.getPoint(0), n), r = new c(n.getPoint(2)), this.front_ = new a(e, r), e.next = t, t.next = r, t.prev = e, r.prev = t;}, h.prototype.removeNode = function (e) {}, h.prototype.mapTriangleToNodes = function (e) {for (var t = 0; t < 3; ++t) {if (!e.getNeighbor(t)) {var r = this.front_.locatePoint(e.pointCW(e.getPoint(t)));r && (r.triangle = e);}}}, h.prototype.removeFromMap = function (e) {var t,r = this.map_,n = r.length;for (t = 0; t < n; t++) {if (r[t] === e) {r.splice(t, 1);break;}}}, h.prototype.meshClean = function (e) {for (var t, r, n = [e]; t = n.pop();) {if (!t.isInterior()) for (t.setInterior(!0), this.triangles_.push(t), r = 0; r < 3; r++) {t.constrained_edge[r] || n.push(t.getNeighbor(r));}}}, t.exports = h;}, { \"./advancingfront\": 2, \"./point\": 4, \"./pointerror\": 5, \"./sweep\": 7, \"./triangle\": 9 }], 9: [function (e, t, r) {var n = function n(e, t, r) {this.points_ = [e, t, r], this.neighbors_ = [null, null, null], this.interior_ = !1, this.constrained_edge = [!1, !1, !1], this.delaunay_edge = [!1, !1, !1];},o = e(\"./xy\").toString;n.prototype.toString = function () {return \"[\" + o(this.points_[0]) + o(this.points_[1]) + o(this.points_[2]) + \"]\";}, n.prototype.getPoint = function (e) {return this.points_[e];}, n.prototype.GetPoint = n.prototype.getPoint, n.prototype.getPoints = function () {return this.points_;}, n.prototype.getNeighbor = function (e) {return this.neighbors_[e];}, n.prototype.containsPoint = function (e) {var t = this.points_;return e === t[0] || e === t[1] || e === t[2];}, n.prototype.containsEdge = function (e) {return this.containsPoint(e.p) && this.containsPoint(e.q);}, n.prototype.containsPoints = function (e, t) {return this.containsPoint(e) && this.containsPoint(t);}, n.prototype.isInterior = function () {return this.interior_;}, n.prototype.setInterior = function (e) {return this.interior_ = e, this;}, n.prototype.markNeighborPointers = function (e, t, r) {var n = this.points_;if (e === n[2] && t === n[1] || e === n[1] && t === n[2]) this.neighbors_[0] = r;else if (e === n[0] && t === n[2] || e === n[2] && t === n[0]) this.neighbors_[1] = r;else {if (!(e === n[0] && t === n[1] || e === n[1] && t === n[0])) throw new Error(\"poly2tri Invalid Triangle.markNeighborPointers() call\");this.neighbors_[2] = r;}}, n.prototype.markNeighbor = function (e) {var t = this.points_;e.containsPoints(t[1], t[2]) ? (this.neighbors_[0] = e, e.markNeighborPointers(t[1], t[2], this)) : e.containsPoints(t[0], t[2]) ? (this.neighbors_[1] = e, e.markNeighborPointers(t[0], t[2], this)) : e.containsPoints(t[0], t[1]) && (this.neighbors_[2] = e, e.markNeighborPointers(t[0], t[1], this));}, n.prototype.clearNeighbors = function () {this.neighbors_[0] = null, this.neighbors_[1] = null, this.neighbors_[2] = null;}, n.prototype.clearDelaunayEdges = function () {this.delaunay_edge[0] = !1, this.delaunay_edge[1] = !1, this.delaunay_edge[2] = !1;}, n.prototype.pointCW = function (e) {var t = this.points_;return e === t[0] ? t[2] : e === t[1] ? t[0] : e === t[2] ? t[1] : null;}, n.prototype.pointCCW = function (e) {var t = this.points_;return e === t[0] ? t[1] : e === t[1] ? t[2] : e === t[2] ? t[0] : null;}, n.prototype.neighborCW = function (e) {return e === this.points_[0] ? this.neighbors_[1] : e === this.points_[1] ? this.neighbors_[2] : this.neighbors_[0];}, n.prototype.neighborCCW = function (e) {return e === this.points_[0] ? this.neighbors_[2] : e === this.points_[1] ? this.neighbors_[0] : this.neighbors_[1];}, n.prototype.getConstrainedEdgeCW = function (e) {return e === this.points_[0] ? this.constrained_edge[1] : e === this.points_[1] ? this.constrained_edge[2] : this.constrained_edge[0];}, n.prototype.getConstrainedEdgeCCW = function (e) {return e === this.points_[0] ? this.constrained_edge[2] : e === this.points_[1] ? this.constrained_edge[0] : this.constrained_edge[1];}, n.prototype.getConstrainedEdgeAcross = function (e) {return e === this.points_[0] ? this.constrained_edge[0] : e === this.points_[1] ? this.constrained_edge[1] : this.constrained_edge[2];}, n.prototype.setConstrainedEdgeCW = function (e, t) {e === this.points_[0] ? this.constrained_edge[1] = t : e === this.points_[1] ? this.constrained_edge[2] = t : this.constrained_edge[0] = t;}, n.prototype.setConstrainedEdgeCCW = function (e, t) {e === this.points_[0] ? this.constrained_edge[2] = t : e === this.points_[1] ? this.constrained_edge[0] = t : this.constrained_edge[1] = t;}, n.prototype.getDelaunayEdgeCW = function (e) {return e === this.points_[0] ? this.delaunay_edge[1] : e === this.points_[1] ? this.delaunay_edge[2] : this.delaunay_edge[0];}, n.prototype.getDelaunayEdgeCCW = function (e) {return e === this.points_[0] ? this.delaunay_edge[2] : e === this.points_[1] ? this.delaunay_edge[0] : this.delaunay_edge[1];}, n.prototype.setDelaunayEdgeCW = function (e, t) {e === this.points_[0] ? this.delaunay_edge[1] = t : e === this.points_[1] ? this.delaunay_edge[2] = t : this.delaunay_edge[0] = t;}, n.prototype.setDelaunayEdgeCCW = function (e, t) {e === this.points_[0] ? this.delaunay_edge[2] = t : e === this.points_[1] ? this.delaunay_edge[0] = t : this.delaunay_edge[1] = t;}, n.prototype.neighborAcross = function (e) {return e === this.points_[0] ? this.neighbors_[0] : e === this.points_[1] ? this.neighbors_[1] : this.neighbors_[2];}, n.prototype.oppositePoint = function (e, t) {var r = e.pointCW(t);return this.pointCW(r);}, n.prototype.legalize = function (e, t) {var r = this.points_;if (e === r[0]) r[1] = r[0], r[0] = r[2], r[2] = t;else if (e === r[1]) r[2] = r[1], r[1] = r[0], r[0] = t;else {if (e !== r[2]) throw new Error(\"poly2tri Invalid Triangle.legalize() call\");r[0] = r[2], r[2] = r[1], r[1] = t;}}, n.prototype.index = function (e) {var t = this.points_;if (e === t[0]) return 0;if (e === t[1]) return 1;if (e === t[2]) return 2;throw new Error(\"poly2tri Invalid Triangle.index() call\");}, n.prototype.edgeIndex = function (e, t) {var r = this.points_;if (e === r[0]) {if (t === r[1]) return 2;if (t === r[2]) return 1;} else if (e === r[1]) {if (t === r[2]) return 0;if (t === r[0]) return 2;} else if (e === r[2]) {if (t === r[0]) return 1;if (t === r[1]) return 0;}return -1;}, n.prototype.markConstrainedEdgeByIndex = function (e) {this.constrained_edge[e] = !0;}, n.prototype.markConstrainedEdgeByEdge = function (e) {this.markConstrainedEdgeByPoints(e.p, e.q);}, n.prototype.markConstrainedEdgeByPoints = function (e, t) {var r = this.points_;t === r[0] && e === r[1] || t === r[1] && e === r[0] ? this.constrained_edge[2] = !0 : t === r[0] && e === r[2] || t === r[2] && e === r[0] ? this.constrained_edge[1] = !0 : (t === r[1] && e === r[2] || t === r[2] && e === r[1]) && (this.constrained_edge[0] = !0);}, t.exports = n;}, { \"./xy\": 11 }], 10: [function (e, t, r) {var n = 1e-16;r.EPSILON = n;var o = { CW: 1, CCW: -1, COLLINEAR: 0 };r.Orientation = o, r.orient2d = function (e, t, r) {var i = (e.x - r.x) * (t.y - r.y) - (e.y - r.y) * (t.x - r.x);return i > -n && i < n ? o.COLLINEAR : i > 0 ? o.CCW : o.CW;}, r.inScanArea = function (e, t, r, o) {return !((e.x - t.x) * (o.y - t.y) - (o.x - t.x) * (e.y - t.y) >= -n || (e.x - r.x) * (o.y - r.y) - (o.x - r.x) * (e.y - r.y) <= n);}, r.isAngleObtuse = function (e, t, r) {var n = t.x - e.x,o = t.y - e.y;return n * (r.x - e.x) + o * (r.y - e.y) < 0;};}, {}], 11: [function (e, t, r) {function n(e) {return \"(\" + e.x + \";\" + e.y + \")\";}t.exports = { toString: function toString(e) {var t = e.toString();return \"[object Object]\" === t ? n(e) : t;}, toStringBase: n, compare: function compare(e, t) {return e.y === t.y ? e.x - t.x : e.y - t.y;}, equals: function equals(e, t) {return e.x === t.x && e.y === t.y;} };}, {}] }, {}, [6])(6);});var a = s.exports;t.poly2tri = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.CCI = void 0;var n = r(1),o = r(111),i = r(77),s = function s(e, t, r, n, i) {this._cu1 = e, this._range1 = t, this._cu2 = r, this._range2 = n, this._epsilon = i, this._tree = new o.SubCurveTree(e, t, r, n, i);};s.prototype.intersect = function () {var e = [];this._tree.build();for (var t = 0; t < this._tree._overlaps.length; ++t) {var r = this._tree._overlaps[t][0],n = this._tree._overlaps[t][1];e = e.concat(this._solve(r._range, n._range));}return this._merge(e), e;}, s.prototype._distanceSquared = function (e, t) {var r = this._cu1.evaluatePosition(e),o = this._cu2.evaluatePosition(t);return n.Vector3.squaredDistance(r, o);}, s.prototype._solve = function (e, t) {var r = [],n = [.5 * (e[0] + e[1]), .5 * (t[0] + t[1])],o = this._relaxNR(n, [e, t]),s = o === i.RelaxResult.Success;if (o === i.RelaxResult.OutOfRange) {var a = n[0] < e[0] + 1e-12 || n[0] > e[1] - 1e-12,c = n[1] < t[0] + 1e-12 || n[1] > t[1] - 1e-12;(a || c) && this._distanceSquared(n[0], n[1]) < this._epsilon * this._epsilon && (s = !0);}return s && r.push(new function (e, t) {this.cutInfo = e, this.cutByInfo = t;}({ param: n[0], atVertex: void 0 }, { param: n[1], atVertex: void 0 })), r;}, s.prototype._relaxNR = function (e, t) {var r = this,o = (0, i.newtonRaphson2D)(function (e) {var t = r._cu1.evaluatePosition(e[0]),o = r._cu2.evaluatePosition(e[1]),i = [t[0] - o[0], t[1] - o[1]],s = r._cu1.evaluateDt(e[0]),a = r._cu2.evaluateDt(e[1]);return n.Vector3.negate(a, a), { val: i, deriv1: s, deriv2: a };}, e, t);return e[0] = o.param[0], e[1] = o.param[1], o.status;}, s.prototype._merge = function (e) {e.sort(function (e, t) {return e.cutInfo.param - t.cutInfo.param;});for (var t = 0; t < e.length; t++) {if (e[t]) for (var r = e[t].cutInfo.param, n = e[t].cutByInfo.param, o = t + 1; o < e.length; o++) {if (e[o]) {var i = e[o].cutInfo.param,s = e[o].cutByInfo.param;if (i > r + 1e-11) break;if (Math.abs(s - n) <= 1e-11) {e[t] = void 0;break;}}}}for (t = 0; t < e.length; t++) {e[t] || (e.splice(t, 1), t--);}}, t.CCI = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SubCurveTree = void 0;var n = 100 * r(0).KERNEL_TOLERANCE,o = Math.PI / 180 * 10,i = function i(e, t, r) {void 0 === r && (r = 0), this._cu = e, this._range = t, this._bx = e.getBoundingBox(t).clone(), this._simple = void 0, this._split_param = void 0, this._children = [], this._depth = r;};i.prototype.isSimple = function () {if (void 0 === this._simple) {this._simple = !1;var e = [this._range[0] + 1e-8, this._range[1] - 1e-8];if (this._split_param = this._cu.suggestSplittingParam(e), void 0 === this._split_param) {this._split_param = .5 * (this._range[0] + this._range[1]);var t = this._cu.getTangentCone(this._range);(t.isDegenerate() || t.angle < o) && (this._simple = !0);}}return this._simple;}, i.prototype.canDivide = function () {return !(this._depth >= 10 || this._range[1] - this._range[0] < 2e-8 || Math.max(this._bx.getWidth(0), this._bx.getWidth(1), this._bx.getWidth(2)) < n);}, i.prototype.divide = function () {if (0 === this._children.length) {var e = [this._range[0], this._split_param],t = [this._split_param, this._range[1]];this._children = [new i(this._cu, e, this._depth + 1), new i(this._cu, t, this._depth + 1)];}}, i.prototype.fullSubdivision = function () {if (!this.isSimple() && this.canDivide()) {this.divide();for (var e = 0; e < this._children.length; ++e) {this._children[e].fullSubdivision();}}}, i.prototype.toString = function () {if (this._children.length > 0) {for (var e = \"\", t = 0; t < this._children.length; ++t) {e += this._children[t];}return e;}return \"t=[\" + this._range[0] + \" \" + this._range[1] + \"] \" + this._bx + \"\\n\";};var s = function s(e, t, r, n, o) {this._cu1_root_node = new i(e, t), this._cu2_root_node = new i(r, n), this._epsilon = o, this._overlaps = [];};s.prototype.process = function (e, t) {if (e._bx.intersectsWithTolerance(t._bx, this._epsilon)) {var r = e.canDivide(),n = t.canDivide(),o = e.isSimple() || !r,i = t.isSimple() || !n;if (o && i) this._overlaps.push([e, t]);else if (r && n) {e.divide(), t.divide();for (var s = 0; s < e._children.length; ++s) {for (var a = 0; a < t._children.length; ++a) {this.process(e._children[s], t._children[a]);}}} else if (r) for (e.divide(), s = 0; s < e._children.length; ++s) {this.process(e._children[s], t);} else if (n) for (t.divide(), s = 0; s < t._children.length; ++s) {this.process(e, t._children[s]);}}}, s.prototype.build = function () {this.process(this._cu1_root_node, this._cu2_root_node);}, t.SubCurveTree = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.RegionTopologyFace = t.RegionTopologyEdge = t.RegionTopologyVertex = void 0;var n = r(1),o = r(16),i = r(20),s = r(15),a = r(0),c = r(2),u = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),l = function l(e) {o.Vertex.call(this, e), this._associatedVertices = [];};(l.prototype = Object.create(o.Vertex.prototype)).setAssociatedEntities = function (e) {this._associatedVertices = u.default.clone(e);}, l.prototype.getAssociatedEntities = function () {return this._associatedVertices;};var h = function h(e) {i.Edge.call(this, e), this._sourceEdge = void 0, this._associatedEdges = [], this._isDangling = !1;};(h.prototype = Object.create(i.Edge.prototype)).setAssociatedEdges = function (e) {this._associatedEdges = e;}, h.prototype.getAssociatedEntities = function () {return u.default.map(this._associatedEdges, function (e) {return e.edge;});}, h.prototype.getAssociatedEdgeInfo = function () {return this._associatedEdges;}, h.prototype.setToEdgeSegment = function (e, t) {this._sourceEdge = e, this._curve = e.getCurve(), this._reversed = e.isReversed(), this.setRange(t);}, h.prototype.setIsDangling = function (e) {this._isDangling = e;}, h.prototype.isDangling = function () {return this._isDangling;}, h.prototype.getSourceEdge = function () {return this._sourceEdge;};var d = function d(e) {s.Face.call(this, e), this._danglingEdges = [];};(d.prototype = Object.create(s.Face.prototype)).addDanglingEdge = function (e) {this._danglingEdges.push(e);}, d.prototype.isPointInsideFace = function (e) {for (var t = 0, r = 0; r < this.getLoops().length; ++r) {for (var n = this.getLoops()[r], o = 0; o < n.getCoedges().length; ++o) {var i = n.getCoedges()[o];i.getEdge().isDangling() || (t += i.uvAngleSubtended(e));}}t = Math.abs(t);var s = Math.floor(t / (2 * Math.PI)),c = t - 2 * s * Math.PI;return !!(Math.abs(c) < a.PARAMETER_SPACE_TOLERANCE && s || Math.abs(c - 2 * Math.PI) < a.PARAMETER_SPACE_TOLERANCE);}, d.prototype.getRepresentativePoint = function () {var e,t,r = n.Vector3.createFloat64(),o = this.getBoundingBox(),i = (o.max[0] - o.min[0]) / 33,s = (o.max[1] - o.min[1]) / 33;for (e = 1; e < 32; ++e) {for (t = 1; t < 32; ++t) {if (r[0] = o.min[0] + i * e, r[1] = o.min[1] + s * t, this.isPointInsideFace(r)) return r;}}return c.ConsoleUtils.assert(!1), o.getCenter();}, d.prototype.getDanglingEdges = function () {return this._danglingEdges;}, t.RegionTopologyVertex = l, t.RegionTopologyEdge = h, t.RegionTopologyFace = d;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.matchRegionEdgeRecipe = t.deserializeRegionEdgeRecipe = t.serializeRegionEdgeRecipe = t.createRecipeFromRegionEdge = t.matchRegionFaceRecipe = t.deserializeRegionFaceRecipe = t.serializeRegionFaceRecipe = t.createRecipeFromRegionFace = void 0;var n = r(1),o = r(3),i = r(0),s = r(114),a = r(2),c = r(8),u = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),l = function l(e, t) {var r = u.default.filter(t.regionVertices, function (t) {return u.default.contains(t.getAssociatedEntities(), e.getStartVertex());});a.ConsoleUtils.assert(1 === r.length), r = r[0];var n = [],o = [],i = new Set(),s = r,c = void 0;if (s) do {n.push(s);var l = u.default.filter(s.getEdges(), function (t) {return t !== c && u.default.contains(t.getAssociatedEntities(), e) && !i.has(t);});if (0 === l.length) {a.ConsoleUtils.assert(!e.isClosed()), a.ConsoleUtils.assert(u.default.contains(s.getAssociatedEntities(), e.getEndVertex()));break;}var h = void 0;if (l.length > 1) {l.sort(function (e, t) {return e.t0() - t.t0();});for (var d = 0; d < l.length; d++) {if (l[d].getStartVertex() === s) {h = l[d];break;}}a.ConsoleUtils.assert(h);} else h = l[0];s = h.getOtherVertex(s), a.ConsoleUtils.assert(s), c = h, i.add(c), o.push(c);} while (s !== r);return { edges: o, vertices: n };},h = function h(e, t, r) {var o = [],s = u.default.filter(t, function (t) {return t !== e;});if (0 === s.length) ;else for (var a = r.vertices, c = 0; c < a.length; c++) {for (var l = a[c], h = !1, d = l.getEdges(), g = 0; g < d.length; g++) {if (u.default.intersection(s, d[g].getAssociatedEntities()).length > 0) {h = !0;break;}}h && o.push({ vertex: l, indexInTopology: c });}if (e.isClosed() && 2 === o.length && 1 === s.length) {var p = !1;if (s[0].getCurveType() === i.GEOMETRY_TYPES.LINE) {var f = s[0],v = f.closestToPointParam(o[0].vertex.getPosition());p = f.closestToPointParam(o[1].vertex.getPosition()) < v;} else if (e.getCurveType() === i.GEOMETRY_TYPES.CIRCLE && s[0].getCurveType() === i.GEOMETRY_TYPES.CIRCLE) {var _ = e.getCurve().getCenter(),y = n.Vector3.sub([0, 0, 0], s[0].getCurve().getCenter(), _);if (n.Vector3.length(y) > 0) {n.Vector3.normalize(y, y);var m = n.Vector3.sub([0, 0, 0], o[0].vertex.getPosition(), _),E = n.Vector3.sub([0, 0, 0], o[1].vertex.getPosition(), _),x = m.x * y.y - m.y * y.x,R = E.x * y.y - E.y * y.x;x > 0 && R < 0 && (p = !0);}}if (p) {var A = o[1];o[1] = o[0], o[0] = A;}}return o;},d = function d(e, t, r, n, o) {var i,a = {};a[e.getGuid()] = { dist: 0, prev: null, prevEdge: null, vertex: e, guid: e.getGuid() };var c = new s.BinaryHeap(function (e) {return e.dist;}, function (e) {return e.guid;});for (c.push(a[e.getGuid()]); 0 !== c.size();) {var l = c.pop();if (l === t) break;i = l.vertex.getEdges();for (var h = 0; h < i.length; h++) {var d = i[h].getOtherVertex(l.vertex);if (d && !n[i[h].getGuid()] && (!r[d.getGuid()] || d === t)) {for (var g = i[h].getEndVertex() === d, p = !1, f = i[h].getAssociatedEntities(), v = 0; v < o.length; v++) {if (u.default.contains(f, o[v].edge) && o[v].orientation === g) {p = !0;break;}}var _ = a[l.guid].dist;p || (_ += 1), void 0 === a[d.getGuid()] ? (a[d.getGuid()] = { dist: _, prev: l, prevEdge: i[h], vertex: d, guid: d.getGuid() }, c.push(a[d.getGuid()])) : a[d.getGuid()].dist > _ && (a[d.getGuid()].dist = _, a[d.getGuid()].prev = l, a[d.getGuid()].prevEdge = i[h], c.updated(a[d.getGuid()]));}}}var y = a[t.getGuid()];if (y) {i = [];for (var m = [], E = y, x = t; E.prevEdge;) {var R = E.prevEdge;i.push(R), E = E.prev, m.push(R.getEndVertex() === x), x = R.getOtherVertex(x);}return { dist: y.dist, edges: i.reverse(), orientations: m.reverse(), startVertex: e, endVertex: t };}return { dist: 1 / 0, edges: [] };},g = function g(e, t, r, n, i, s, a) {for (var c = e[i], l = {}, h = 0; h < c.length; h++) {null !== c[h].endVertex && (l[c[h].endVertex.getGuid()] ? l[c[h].endVertex.getGuid()].incomingEdges.push({ edge: c[h].edge, orientation: c[h].edgeOriented }) : l[c[h].endVertex.getGuid()] = { edgeIndex: h, edgeInfo: c[h], vertex: c[h].endVertex, incomingEdges: [{ edge: c[h].edge, orientation: c[h].edgeOriented }] });}if (u.default.values(l).length > 0) {var g = s.vertices,p = s.edges,f = u.default.keys(l),v = { dist: 1 / 0 },_ = n;do {_ = (0, o.modulus)(_ - 1, e.length);for (var y = u.default.keys(a[_]), m = 0; m < y.length; m++) {var E = a[_][y[m]].vertex;if (E) for (var x = 0; x < f.length; x++) {var R = l[f[x]].vertex,A = a[_][y[m]].outgoingEdges.concat(l[f[x]].incomingEdges),P = d(E, R, g, p, A);P.dist < v.dist && ((v = P).startIndex = _);}}} while (_ !== t && v.dist === 1 / 0);if (v.dist < 1 / 0) {var V = a[v.startIndex][v.startVertex.getGuid()],T = a[i][v.endVertex.getGuid()],C = V.cost + v.dist;(!T || C < T.cost || i === t && v.endVertex.getGuid() === r.getGuid() && null === T.previousGuid) && (a[i][v.endVertex.getGuid()] = { previousGuid: v.startVertex.getGuid(), edgeSegment: null, indexRange: [], cost: V.cost + v.dist, vertex: v.endVertex, previousIndex: v.startIndex, connectionEdges: v.edges, connectionOrientation: v.orientations, outgoingEdges: [] });}}},p = function p(e, t, r, n, i) {var s = [],a = e[t][r].endVertex;s[t] = {}, s[t][a.getGuid()] = { previousGuid: null, edgeSegment: null, previousIndex: null, cost: 0, vertex: a, outgoingEdges: [] };var c = t;do {var l = (0, o.modulus)(c + 1, e.length),h = e[l];s[l] = s[l] || {};for (var d = u.default.keys(s[c]), p = 0, f = 0; f < d.length; f++) {for (var v = d[f], _ = 0; _ < h.length; _++) {if (h[_].startVertices[v]) {s[c][v].outgoingEdges.push({ edge: h[_].edge, orientation: h[_].edgeOriented });var y = h[_].endVertex;if (null !== y) {var m = s[c][v].cost;h[_].edge.isClosed() || h[_].endVertexTopologyIndex > h[_].startVertices[v].vertexIndex !== h[_].edgeOriented && (m += 1), (!s[l][y.getGuid()] || s[l][y.getGuid()].cost > m || l === t && y.getGuid() === a.getGuid() && null === s[l][y.getGuid()].previousGuid) && (s[l][y.getGuid()] = { previousGuid: v, edgeSegment: h[_], indexRange: [h[_].startVertices[v].vertexIndex, h[_].endVertexTopologyIndex], cost: m, vertex: y, previousIndex: c, outgoingEdges: [] }, p++);} else m = s[c][v].cost, (!s[l][v] || s[l][v].cost > m) && (s[l][v] = { previousGuid: v, edgeSegment: h[_], indexRange: [], cost: m, previousIndex: c, outgoingEdges: [] });}}}0 === p && g(e, t, a, c, l, n, s), c = l;} while (c !== t);null !== s[t][a.getGuid()].previousGuid && s[t][a.getGuid()].cost < i.cost && (i.cost = s[t][a.getGuid()].cost, i.state = s, i.startGuid = a.getGuid());},f = function f(e, t) {for (var r = function (e, t) {var r = {},n = {},i = {},s = t;do {var a = (0, o.modulus)(s + 1, e.length),c = e[s],u = e[a],l = i;i = {};for (var h = 0; h < u.length; h++) {var d = u[h].topologyAlongEdge.vertices,g = u[h].topologyAlongEdge.edges;u[h].startVertices = {};var p = void 0,f = void 0,v = c.length;void 0 !== l[u[h].edge.getGuid()] && v++;for (var _ = 0; _ < v; _++) {var y = void 0;if (_ === c.length) y = l[u[h].edge.getGuid()];else {if (!c[_].endVertex) continue;y = c[_].endVertex.getGuid();}for (var m = void 0, E = 0; E < d.length; E++) {if (d[E].getGuid() === y) {m = E;break;}}void 0 !== m && (u[h].startVertices[y] = { vertex: d[m], vertexIndex: m }, null !== u[h].endVertex && (u[h].edgeOriented ? (p = void 0 !== p ? Math.min(p, m) : m, f = void 0 !== f ? Math.max(f, u[h].endVertexTopologyIndex) : u[h].endVertexTopologyIndex) : (p = void 0 !== p ? Math.max(p, m) : m, f = void 0 !== f ? Math.min(f, u[h].endVertexTopologyIndex) : u[h].endVertexTopologyIndex)), void 0 === i[u[h].edge.getGuid()] && (i[u[h].edge.getGuid()] = y));}if (void 0 !== p && void 0 !== f) {if (p !== f) {var x;x = u[h].edge.isClosed() ? u[h].edgeOriented ? 1 : -1 : p < f ? 1 : -1;var R = p;do {if (r[d[R].getGuid()] = d[R], x > 0) R !== f && (n[g[R].getGuid()] = g[R]);else {var A = (0, o.modulus)(R - 1, g.length);n[g[A].getGuid()] = g[A];}R = (0, o.modulus)(R + x, d.length);} while (R !== f);}r[d[f].getGuid()] = d[f];}}s = a;} while (s !== t);return { vertices: r, edges: n };}(e, t), n = { cost: 1 / 0, state: void 0, startGuid: void 0 }, i = 0; i < e[t].length; i++) {null !== e[t][i].endVertex && p(e, t, i, r, n);}if (n.cost === 1 / 0) return { edges: void 0, edgeOrientedFlags: void 0, score: 1 / 0 };var s = function (e, t) {var r = [],n = e.startGuid,i = t;do {r.push(e.state[i][n]);var s = e.state[i][n].previousIndex;n = e.state[i][n].previousGuid, i = s;} while (i !== t);r = r.reverse();var a = [],c = [];for (i = 0; i < r.length; i++) {if (0 !== r[i].indexRange.length) {var u,l,h,d,g = r[i].edgeSegment.topologyAlongEdge;r[i].indexRange[0] < r[i].indexRange[1] ? (u = r[i].indexRange[0], l = r[i].indexRange[1], r[i].edgeSegment.edge.isClosed() && !r[i].edgeSegment.edgeOriented ? (h = -1, u = (0, o.modulus)(r[i].indexRange[0] - 1, g.edges.length), l = (0, o.modulus)(r[i].indexRange[1] - 1, g.edges.length), d = !1) : (h = 1, u = (0, o.modulus)(r[i].indexRange[0], g.edges.length), l = (0, o.modulus)(r[i].indexRange[1], g.edges.length), d = !0)) : r[i].edgeSegment.edge.isClosed() && r[i].edgeSegment.edgeOriented ? (h = 1, u = (0, o.modulus)(r[i].indexRange[0], g.edges.length), l = (0, o.modulus)(r[i].indexRange[1], g.edges.length), d = !0) : (h = -1, u = (0, o.modulus)(r[i].indexRange[0] - 1, g.edges.length), l = (0, o.modulus)(r[i].indexRange[1] - 1, g.edges.length), d = !1);var p = u;do {a.push(g.edges[p]), c.push(d), p = (0, o.modulus)(p + h, g.edges.length);} while (p !== l);} else if (r[i].connectionEdges) for (p = 0; p < r[i].connectionEdges.length; p++) {a.push(r[i].connectionEdges[p]), c.push(r[i].connectionOrientation[p]);}}return { topologyEdges: a, edgeOrientedFlags: c };}(n, t);return { edges: s.topologyEdges, edgeOrientedFlags: s.edgeOrientedFlags, score: n.cost };},v = function v(e, t) {var r,n = function (e, t) {for (var r = [], n = 0; n < e.length; n++) {for (var o = e[n], i = [], s = 0; s < o.length; s++) {var a = o[s],c = t.sketchEdges[a.edgeRef];c && i.push({ edgeRef: a.edgeRef, edgeOriented: a.edgeOriented, intersectionNumber: a.intersectionNumber, totalIntersections: a.totalIntersections, edge: c, topologyAlongEdge: l(c, t), endVertex: null, endVertexTopologyIndex: null });}r.push(i);}return r;}(e, t);if (c.DebugUtils.level(\"region_match\") >= 2) {var o = u.default.pluck(u.default.flatten(n), \"edge\");for (r = 0; r < o.length; r++) {c.DebugUtils.drawEdge3D(o[r], { color: 0, render: !1 });}c.DebugUtils.render();}if (function (e) {for (var t = 0; t < e.length; t++) {for (var r = u.default.pluck(e[(t + 1) % e.length], \"edge\"), n = 0; n < e[t].length; n++) {var o = e[t][n],i = h(o.edge, r, o.topologyAlongEdge);if (0 === o.totalIntersections) o.endVertex = null;else if (i.length === o.totalIntersections) {var s = i[o.intersectionNumber];o.endVertexTopologyIndex = s.indexInTopology, o.endVertex = s.vertex;} else 0 === i.length || c.DebugUtils.warn(\"Region matching problem! Intersection counts do not match\"), o.endVertex = null;}}}(n), c.DebugUtils.level(\"region_match\") >= 2) {var i = u.default.pluck(u.default.flatten(n), \"endVertex\");for (r = 0; r < i.length; r++) {null !== i[r] && c.DebugUtils.drawVertex3D(i[r], { color: 65280, render: !1 });}c.DebugUtils.render();}var s = function (e) {for (var t = 1 / 0, r = void 0, n = 0; n < e.length; n++) {var o = e[n];if (0 !== o.length) {for (var i = 0, s = 0; s < o.length; s++) {null !== o[s].endVertex && i++;}var a = o.length - i;if (0 === a) return n;i > 0 && a < t && (t = a, r = n);}}return r;}(n);if (void 0 === s) {for (var a = 0; a < n[0].length; a++) {var d = n[0][a].edge;if (d.isClosed() && u.default.all(n, function (e) {for (var t = 0; t < e.length; t++) {if (e[t].edge === d) return !0;}return !1;})) {var g = n[0][a].topologyAlongEdge.edges,p = new Array(g.length);for (r = 0; r < p.length; r++) {p[r] = n[0][a].edgeOriented;}return n[0][a].edgeOriented || g.reverse(), c.DebugUtils.level(\"region_match\") >= 2 && c.DebugUtils.drawEdge3D(d, { color: 16711680 }), { edges: g, edgeOrientedFlags: p, matchStatus: 2 };}}return { edges: void 0, edgeOrientedFlags: void 0, matchStatus: 0 };}var v,_ = f(n, s);if (c.DebugUtils.level(\"region_match\") >= 2 && void 0 !== _.edges) {for (r = 0; r < _.edges.length; r++) {c.DebugUtils.drawEdge3D(_.edges[r], { color: 16711680, render: !1 });}c.DebugUtils.render();}return v = 0 === _.score ? 2 : _.score === 1 / 0 ? 0 : 1, { edges: _.edges, edgeOrientedFlags: _.edgeOrientedFlags, matchStatus: v };},_ = function _(e, t) {if (!e || !e.edges) return new Set();for (var r = new Set(), n = 0; n < e.edges.length; n++) {var o = e.edgeOrientedFlags[n] === t,i = e.edges[n].getCoedges();a.ConsoleUtils.assert(i.length >= 1 && i.length <= 2);for (var s = void 0, c = 0; c < i.length; c++) {if (i[c].isReversed() === o) {s = i[c].getFace();break;}}s && !r.has(s) && r.add(s);}var u = new Set(e.edges);return r.forEach(function (e) {for (var t = Array.from(e.collectEdges()), n = 0; n < t.length; n++) {var o = t[n];if (!u.has(o)) {var i = void 0,s = o.getFaces();a.ConsoleUtils.assert(s.length >= 1 && s.length <= 2), 1 === s.length ? a.ConsoleUtils.assert(s[0] === e) : 2 === s.length && (a.ConsoleUtils.assert(s[0] === e || s[1] === e), i = s[0] === e ? s[1] : s[0]), i && !r.has(i) && r.add(i);}}}), r;};t.createRecipeFromRegionFace = function (e, t) {for (var r = [], n = e.getLoops(), o = 0; o < n.length; o++) {for (var i = n[o].getCoedges(), s = [], a = 0; a < i.length; a++) {for (var c = i[a], d = c.getEdge().getAssociatedEdgeInfo(), g = c.getEndVertex(), p = i[(a + 1) % i.length].getEdge().getAssociatedEdgeInfo(), f = u.default.pluck(p, \"edge\"), v = [], _ = 0; _ < d.length; _++) {for (var y = l(d[_].edge, t), m = h(d[_].edge, f, y), E = 0, x = 0; x < m.length; x++) {if (m[x].vertex === g) {E = x;break;}}var R = { edgeRef: d[_].edge.getGuid(), edgeOriented: !(c.isReversed() ^ d[_].flipped), intersectionNumber: E, totalIntersections: m.length, edge: d[_].edge };v.push(R);}s.push(v);}r.push(s);}return r;}, t.serializeRegionFaceRecipe = function (e) {for (var t = [], r = 0; r < e.length; r++) {for (var n = [], o = e[r], i = 0; i < o.length; i++) {for (var s = [], a = o[i], c = 0; c < a.length; c++) {var u = a[c];s.push(u.edgeRef + \"_\" + (u.edgeOriented ? \"t\" : \"f\") + \"_\" + u.intersectionNumber + \"_\" + u.totalIntersections);}n.push(s.join(\";\"));}t.push(n.join(\"+\"));}return t.join(\"/\");}, t.deserializeRegionFaceRecipe = function (e) {for (var t = e.split(\"/\"), r = 0; r < t.length; r++) {t[r] = t[r].split(\"+\");for (var n = t[r], o = 0; o < n.length; o++) {n[o] = n[o].split(\";\");for (var i = n[o], s = 0; s < i.length; s++) {var a = i[s].split(\"_\");i[s] = { edgeRef: a[0], edgeOriented: \"t\" === a[1], intersectionNumber: parseInt(a[2], 10), totalIntersections: parseInt(a[3], 10) };}}}return t;}, t.matchRegionFaceRecipe = function (e, t) {var r,n,o,i = 2,s = [];for (r = 0; r < e.length; r++) {var a = v(e[r], t);if (0 === a.matchStatus && 0 === r) return { regions: [], matchStatus: 0 };2 !== a.matchStatus && (i = 1), s.push(a);}if (c.DebugUtils.level(\"region_match\") > 0) {for (c.DebugUtils.clearView(), o = u.default.values(t.sketchEdges), r = 0; r < o.length; r++) {c.DebugUtils.drawEdge3D(o[r], { color: 0, render: !1 });}for (r = 0; r < s.length; r++) {for (n = 0; n < s[r].edges.length; n++) {var l = 0 === r ? 65280 : 16711680;c.DebugUtils.drawEdge3D(s[r].edges[n], { color: l, render: !1 });}}c.DebugUtils.render();}var h = _(s[0], !1);for (n = 1; n < s.length; n++) {_(s[n], !0).forEach(function (e) {h.delete(e);});}if (h = Array.from(h), c.DebugUtils.level(\"region_match\") > 0) {for (r = 0; r < h.length; r++) {for (o = Array.from(h[r].collectEdges()), n = 0; n < o.length; n++) {c.DebugUtils.drawEdge3D(o[n], { color: 13684736, render: !1 });}}c.DebugUtils.render();}return { regions: h, matchStatus: i };}, t.createRecipeFromRegionEdge = function (e, t) {var r,n,o = { startEdgeRefs: [], endEdgeRefs: [], edgeRef: [], edgeOriented: [], intersectionNumberStart: [], totalIntersectionsStart: [], intersectionNumberEnd: [], totalIntersectionsEnd: [] },i = e.getStartVertex(),s = [];i.getOtherEdges(e).forEach(function (e) {var t = u.default.pluck(e.getAssociatedEdgeInfo(), \"edge\");for (r = 0; r < t.length; r++) {s.indexOf(t[r]) < 0 && (s.push(t[r]), o.startEdgeRefs.push(t[r].getGuid()));}});var a = e.getEndVertex(),c = [];a.getOtherEdges(e).forEach(function (e) {var t = u.default.pluck(e.getAssociatedEdgeInfo(), \"edge\");for (r = 0; r < t.length; r++) {c.indexOf(t[r]) < 0 && (c.push(t[r]), o.endEdgeRefs.push(t[r].getGuid()));}});var d = e.getAssociatedEdgeInfo(),g = u.default.pluck(d, \"edge\");for (r = 0; r < d.length; r++) {var p = g[r],f = !d[r].flipped,v = l(p, t),_ = u.default.unique(s.concat(g)),y = h(p, _, v),m = 0;for (n = 0; n < y.length; n++) {if (y[n].vertex === i) {m = n;break;}}var E = u.default.unique(c.concat(g)),x = h(p, E, v),R = 0;for (n = 0; n < x.length; n++) {if (x[n].vertex === a) {R = n;break;}}o.edgeRef.push(p.getGuid()), o.edgeOriented.push(f), o.intersectionNumberStart.push(m), o.totalIntersectionsStart.push(y.length), o.intersectionNumberEnd.push(R), o.totalIntersectionsEnd.push(x.length);}return o;}, t.serializeRegionEdgeRecipe = function (e) {var t = { edge: e.edgeRef, orient: e.edgeOriented, start: e.startEdgeRefs, end: e.endEdgeRefs, sIdx: e.intersectionNumberStart, sNum: e.totalIntersectionsStart, eIdx: e.intersectionNumberEnd, eNum: e.totalIntersectionsEnd };return JSON.stringify(t);}, t.deserializeRegionEdgeRecipe = function (e) {var t = JSON.parse(e);return { edgeRef: t.edge, edgeOriented: t.orient, startEdgeRefs: t.start, endEdgeRefs: t.end, intersectionNumberStart: t.sIdx, totalIntersectionsStart: t.sNum, intersectionNumberEnd: t.eIdx, totalIntersectionsEnd: t.eNum };}, t.matchRegionEdgeRecipe = function (e, t) {var r = [],n = 0,o = [];e.startEdgeRefs.forEach(function (e) {var r = t.sketchEdges[e];r && o.push(r);});var i = [];e.endEdgeRefs.forEach(function (e) {var r = t.sketchEdges[e];r && i.push(r);}), e.edgeRef.forEach(function (e) {var r = t.sketchEdges[e];r && o.indexOf(r) < 0 && o.push(r), r && i.indexOf(r) < 0 && i.push(r);});for (var s = 0; s < e.edgeRef.length; s++) {var a = t.sketchEdges[e.edgeRef[s]];if (a) {var u = l(a, t),d = void 0,g = void 0,p = h(a, o, u);if (0 === e.totalIntersectionsStart[s]) d = u.vertices[0], g = 0;else if (p.length === e.totalIntersectionsStart[s]) {var f = p[e.intersectionNumberStart[s]];d = f.vertex, g = f.indexInTopology;}var v = void 0,_ = void 0,y = h(a, i, u);if (0 === e.totalIntersectionsEnd[s]) v = u.vertices[0], _ = u.vertices.length;else if (y.length === e.totalIntersectionsEnd[s]) {var m = y[e.intersectionNumberEnd[s]];v = m.vertex, 0 === (_ = m.indexInTopology) && a.isClosed() && (_ = u.vertices.length);}if (!e.edgeOriented[s]) {var E = d;d = v, v = E, E = g, g = _, _ = E;}if (d && v) {if (!(g >= _)) {r = u.edges.slice(g, _), n = 2;break;}c.DebugUtils.warn(\"Edge recipe match should find start vertex before end vertex\");}}}return { edges: r, matchStatus: n };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = function n(e, t) {this.content = [], this.scoreFunction = e, this.lookupFunction = t, this.lookupFunction && (this.nodeDict = {});};n.prototype = { push: function push(e) {this.content.push(e), this.lookupFunction && (this.nodeDict[this.lookupFunction(e)] = this.content.length - 1), this.bubbleUp(this.content.length - 1);}, pop: function pop() {var e = this.content[0],t = this.content.pop();return this.content.length > 0 && (this.content[0] = t, this.lookupFunction && (this.nodeDict[this.lookupFunction(t)] = 0), this.sinkDown(0)), this.lookupFunction && delete this.nodeDict[this.lookupFunction(e)], e;}, peek: function peek() {return this.content[0];}, getNodeIndex: function getNodeIndex(e) {if (this.lookupFunction) return this.nodeDict[this.lookupFunction(e)];for (var t = this.content.length, r = 0; r < t; r++) {if (this.content[r] === e) return r;}throw new Error(\"Node not found.\");}, updated: function updated(e) {var t = this.getNodeIndex(e),r = this.scoreFunction(e),n = Math.floor((t + 1) / 2) - 1,o = this.content[n];if (t > 0 && r < this.scoreFunction(o)) this.bubbleUp(t);else {var i = 2 * (t + 1),s = i - 1,a = this.content[s],c = this.content[i];(a && r > this.scoreFunction(a) || c && r > this.scoreFunction(c)) && this.sinkDown(t);}}, remove: function remove(e) {var t = this.content.length,r = this.getNodeIndex(e),n = this.content.pop();r !== t - 1 && (this.content[r] = n, this.scoreFunction(n) < this.scoreFunction(e) ? this.bubbleUp(r) : this.sinkDown(r));}, size: function size() {return this.content.length;}, bubbleUp: function bubbleUp(e) {for (var t = this.content[e]; e > 0;) {var r = Math.floor((e + 1) / 2) - 1,n = this.content[r];if (!(this.scoreFunction(t) < this.scoreFunction(n))) break;this.content[r] = t, this.content[e] = n, this.lookupFunction && (this.nodeDict[this.lookupFunction(t)] = r, this.nodeDict[this.lookupFunction(n)] = e), e = r;}}, sinkDown: function sinkDown(e) {for (var t = this.content.length, r = this.content[e], n = this.scoreFunction(r);;) {var o = 2 * (e + 1),i = o - 1,s = null;if (i < t) {var a = this.content[i],c = this.scoreFunction(a);c < n && (s = i);}if (o < t) {var u = this.content[o];this.scoreFunction(u) < (null === s ? n : c) && (s = o);}if (null === s) break;this.content[e] = this.content[s], this.content[s] = r, this.lookupFunction && (this.nodeDict[this.lookupFunction(this.content[e])] = e, this.nodeDict[this.lookupFunction(this.content[s])] = s), e = s;}} }, t.BinaryHeap = n;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.createBlock = void 0;var n = r(28),o = r(83),i = r(0),s = r(2);t.createBlock = function (e, t) {var r = [Math.min(e[0], t[0]), Math.min(e[1], t[1]), Math.min(e[2], t[2])],a = [Math.max(e[0], t[0]), Math.max(e[1], t[1]), Math.max(e[2], t[2])];s.ConsoleUtils.assert(a[0] - r[0] > i.KERNEL_TOLERANCE, \"block is degenerate in x axis\"), s.ConsoleUtils.assert(a[1] - r[1] > i.KERNEL_TOLERANCE, \"block is degenerate in y axis\"), s.ConsoleUtils.assert(a[2] - r[2] > i.KERNEL_TOLERANCE, \"block is degenerate in z axis\");var c = [[r[0], r[1], r[2]], [a[0], r[1], r[2]], [a[0], a[1], r[2]], [r[0], a[1], r[2]]],u = (0, n.createFaceFromPolyline)(c),l = a[2] - r[2];return (0, o.extrudeFace)(u, l);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.createCylinder = t.createCone = void 0;var n = r(1),o = r(28),i = r(0),s = r(18),a = r(51),c = r(38),u = r(39),l = r(52),h = r(13),d = r(15),g = r(26),p = r(25),f = r(24),v = r(2),_ = function _(e, t, r, _2, y, m) {var E = e,x = t,R = Math.abs(r),A = void 0 === _typeof(_2) ? R : Math.abs(_2);if (R < i.KERNEL_TOLERANCE) {E = t, x = e;var P = R;R = A, A = P;}v.ConsoleUtils.assert(R > i.KERNEL_TOLERANCE);var V = n.Vector3.createFloat64();n.Vector3.subtract(V, x, E);var T = n.Vector3.length(V);v.ConsoleUtils.assert(T > i.KERNEL_TOLERANCE), n.Vector3.scale(V, V, 1 / T);var C = A - R,b = Math.abs(C) > i.KERNEL_TOLERANCE,L = 0;b && (L = Math.atan2(C, T));var O,S = n.Vector3.createFloat64();m && n.Vector3.subtract(S, m, n.Vector3.scale(S, V, n.Vector3.dot(m, V))), (!m || n.Vector3.squaredLength(S) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE) && n.Vector3.computeOrthogonal(S, V), n.Vector3.normalize(S, S), n.Vector3.scale(S, S, R);var M = y || 1;v.ConsoleUtils.assert(M > 0 && M <= 1);var w = Math.max(R, A);Math.abs(w * (1 - M)) < i.KERNEL_TOLERANCE ? b ? (O = new a.Cone()).set(E, R, V, L, S, 1) : (O = new c.Cylinder()).set(E, R, V, S, 1) : b ? (O = new l.EllipticalCone()).set(E, S, M, V, L, 1) : (O = new u.EllipticalCylinder()).set(E, S, M, V, 1);var N = [0, T / Math.cos(L)];O.limitRangeU(N);var F = (0, o.makeConeOrCylinderVParamLoop)(O, N[0]),I = (0, o.makeConeOrCylinderVParamLoop)(O, N[1]);F.getCoedges()[0].setReversed(!0);var D = [];D[0] = new d.Face(), D[0].setSurface(O), D[0].addLoops([F, I]);var j = F.getCoedges()[0].getEdge();if (j.getCurve()) {var B = new h.Loop();B.addCoedge((0, o.createCoedgeOnEdge)(j)), (G = new d.Face()).addLoop(B);var U = new s.Plane();U.set(E, V), G.setSurface(U), G.setReversed(!0), D.push(G), v.ConsoleUtils.assert(B.getCoedges()[0].uvAngleSubtended(E) < -i.KERNEL_TOLERANCE);}var k = I.getCoedges()[0].getEdge();if (k.getCurve()) {var G,z = new h.Loop();z.addCoedge((0, o.createCoedgeOnEdge)(k)), (G = new d.Face()).addLoop(z);var Y = new s.Plane();Y.set(x, V), G.setSurface(Y), D.push(G), v.ConsoleUtils.assert(z.getCoedges()[0].uvAngleSubtended(x) < -i.KERNEL_TOLERANCE);}var K = new g.Shell();K.addFaces(D);var q = new p.Lump();q.addShell(K);var W = new f.Body();return W.addLump(q), W;};t.createCone = _, t.createCylinder = function (e, t, r, n, o) {return _(e, t, r, r, n, o);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.createPolyhedron = void 0;var n = r(24),o = r(25),i = r(15),s = r(13),a = r(16),c = r(18),u = r(6),l = r(28),h = r(3),d = r(2),g = r(8);function p(e, t) {var r,n = e.getCommonEdges(t);d.ConsoleUtils.assert(n.length <= 1), r = 0 === n.length ? (0, l.createLineEdgeBetweenVertices)(e, t) : n[0];var o = (0, l.createCoedgeOnEdge)(r);return d.ConsoleUtils.assert(o.getStartVertex() === e), d.ConsoleUtils.assert(o.getEndVertex() === t), o;}function f(e, t) {var r,n = [];for (r = 0; r < t.length; ++r) {n[r] = e[t[r]];}var o = (0, h.definePlaneThroughPoints)(n);if (o) {var i = new c.Plane();return i.set(o.origin, o.normal, o.uAxis), i.limitRangeU(o.uRange), i.limitRangeV(o.vRange), i;}g.DebugUtils.warn(\"Face is degenerate\");}t.createPolyhedron = function (e, t) {var r,c = [];for (r = 0; r < e.length; ++r) {var h = new a.Vertex(new u.Point(e[r]));c.push(h);}var g = [];for (r = 0; r < t.length; ++r) {var v = t[r];d.ConsoleUtils.assert(v.length >= 3);for (var _ = new s.Loop(), y = [], m = 0; m < v.length; ++m) {var E = v[m],x = v[(m + 1) % v.length];d.ConsoleUtils.assert(E >= 0 && E < e.length), d.ConsoleUtils.assert(x >= 0 && x < e.length);var R = p(c[E], c[x]);y.push(R);}_.addCoedges(y);var A = f(e, v),P = new i.Face(A);P.addLoop(_), g.push(P);}var V = (0, l.createShellsFromFaces)(g),T = [];for (r = 0; r < V.length; ++r) {T[r] = new o.Lump(), T[r].addShell(V[r]);}var C = new n.Body();return C.addLumps(T), C;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.TopologyStitcher = void 0;var n = r(1),o = r(119),i = r(41),s = r(2),a = function a() {this._shellSet = new Set(), this._lumpSet = new Set(), this._bodySet = new Set(), this._wireSet = new Set(), this._progenitorMap = new i.ProgenitorMap();};a.prototype.initMerge = function () {this._shellSet.clear(), this._lumpSet.clear(), this._bodySet.clear(), this._wireSet.clear();}, a.prototype.getEdgeOwnerToMerge = function (e) {var t = e.getWire();if (t) this._wireSet.add(t);else {var r = function (e) {var t = e.getCoedge();if (t) {var r = t.getFace();if (r) return r.getShell();}}(e);r && this._shellSet.add(r);}}, a.prototype.getVertexOwnerToMerge = function (e) {var t = e.getEdges();t.length > 0 && this.getEdgeOwnerToMerge(t[0]);}, a.prototype.stitchVertices = function (e, t) {var r;this.initMerge();var n = void 0;for (r = 0; r < e.length; ++r) {if (!t || !t.has(e[r])) {n = e[r];break;}}s.ConsoleUtils.assert(n);var o = [];for (r = 0; r < e.length; ++r) {if (this.getVertexOwnerToMerge(e[r]), e[r] !== n) {for (var i = e[r], a = i.getEdges().slice(0), c = 0; c < a.length; ++c) {var u = a[c];u.getStartVertex() === i && u.setStartVertex(n), u.getEndVertex() === i && u.setEndVertex(n);}s.ConsoleUtils.assert(0 === i.getEdges().length), t && t.has(i) || o.push(i);}}o.length > 0 && this._progenitorMap.addEntry(n, o), this.mergeTopology();}, a.prototype.stitchEdges = function (e, t) {var r,o = e[0];for (r = 0; r < e.length; ++r) {if (!t || !t.has(e[r])) {o = e[r];break;}}var i = [],s = [];for (r = 0; r < e.length; ++r) {var a = e[r],c = !1;if (a.getStartVertex() !== o.getStartVertex() && a.getStartVertex() === o.getEndVertex()) {var u = a.evaluateDt(a.t0()),l = o.evaluateDt(o.t1());n.Vector3.dot(u, l) < 0 && (c = !0);}for (var h = a.getCoedge(); h;) {i.push(h), c && h.setReversed(!h.isReversed()), (h = h.getPartner()) === a.getCoedge() && (h = void 0);}a !== o && (a.setStartVertex(null), a.setEndVertex(null), s.push(a));}for (this.initMerge(), r = 0; r < i.length; ++r) {var d = i[r];this.getEdgeOwnerToMerge(d.getEdge()), d.setEdge(o);var g = (r + 1) % i.length;d.setPartner(i[g]);}this.mergeTopology(), this._progenitorMap.addEntry(o, s);}, a.prototype.mergeTopology = function () {if (this._shellSet.size > 1 && this.mergeShells(), this._wireSet.size > 1) throw new Error(\"Merging wires in TopologyStitcher is not yet supported.\");}, a.prototype.mergeShells = function () {var e = new i.ProgenitorMap();if (this._shellSet.size > 1) {var t = Array.from(this._shellSet),r = t[0],n = r.getLump();n && this._lumpSet.add(n);for (var o = 1; o < t.length; ++o) {var s = t[o];r.addFaces(s.getFaces()), s.setFaces([]), (n = s.getLump()) && (n.removeShell(s), this._lumpSet.add(n));}e.addEntry(r, t.slice(1));}if (this._lumpSet.size > 1) {var a = Array.from(this._lumpSet),c = a[0],u = c.getBody();for (u && this._bodySet.add(u), o = 1; o < a.length; ++o) {var l = a[o];c.addShells(l.getShells()), l.setShells([]), (u = l.getBody()) && (u.removeLump(l), this._bodySet.add(u));}e.addEntry(c, a.slice(1));}if (this._bodySet.size > 1) {var h = Array.from(this._bodySet),d = h[0];for (o = 1; o < h.length; ++o) {for (var g = h[o], p = g.getLumps().slice(0), f = 0; f < p.length; ++f) {p[f].getShells().length > 0 && d.addLump(p[f]);}g.setLumps([]);}e.addEntry(d, h.slice(1));}e.size() > 0 && (this._progenitorMap = e.collapseMaps(this._progenitorMap, { keepIntermediates: !0, keepAllDescendants: !0 }));}, a.prototype.getProgenitorMap = function () {return this._progenitorMap;}, a.prototype.stitchTwoEdgeSets = function (e, t) {var r = new o.MatchFinder();r.setEdges(e, t), r.compute();for (var n = r.getVertexMatches(), i = r.getEdgeMatches(), s = r.getNewVertices(), a = new Set(r.getEdgeProgenitors().getAllNewTopology()), c = 0; c < n.length; ++c) {this.stitchVertices(n[c], s);}for (c = 0; c < i.length; ++c) {this.stitchEdges(i[c], a);}this._progenitorMap = this._progenitorMap.collapseMaps(r.getEdgeProgenitors(), { keepIntermediates: !1, keepAllDescendants: !0 });}, a.prototype.stitchTwoTopology = function (e, t) {s.ConsoleUtils.assert(\"function\" == typeof e.collectEdges), s.ConsoleUtils.assert(\"function\" == typeof t.collectEdges);var r = e.collectEdges(),n = t.collectEdges();this.stitchTwoEdgeSets(r, n);}, a.prototype.stitchEdgeSet = function (e) {this.stitchTwoEdgeSets(e, e);}, t.TopologyStitcher = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.MatchFinder = void 0;var n = r(1),o = r(0),i = r(120),s = r(82),a = r(41),c = r(2),u = function u() {this._edges1 = [], this._edges2 = [], this._verts1 = [], this._verts2 = [], this._vertexMatchMap = new Map(), this._edgeMatchMap = new Map(), this._sameEdgeLists = !1, this._newVertices = new Set(), this._edgeProgenitors = new a.ProgenitorMap();};u.prototype.addMergeToMap = function (e, t, r) {var n = r.get(e),o = r.get(t);if (n && !o) n.push(t), r.set(t, n);else if (!n && o) o.push(e), r.set(e, o);else if (n || o) {if (n && o && n !== o) for (var i = 0; i < o.length; ++i) {n.push(o[i]), r.set(o[i], n);}} else {var s = [e, t];r.set(e, s), r.set(t, s);}}, u.prototype.addVertexMerge = function (e, t) {this.addMergeToMap(e, t, this._vertexMatchMap);}, u.prototype.addEdgeMerge = function (e, t) {this.addMergeToMap(e, t, this._edgeMatchMap);}, u.prototype.verticesMatch = function (e, t) {var r = Math.max(e.getPrecision(), t.getPrecision(), o.KERNEL_TOLERANCE);return n.Vector3.squaredDistance(e.getPosition(), t.getPosition()) < r * r;}, u.prototype.findEdgeSplitParam = function (e, t) {var r = e.getStartVertex();if (r !== t) {var i = e.getEndVertex();if (i !== t) {var s = this._vertexMatchMap.get(r);if (!s || -1 === s.indexOf(t)) {var a = this._vertexMatchMap.get(i);if (!a || -1 === a.indexOf(t)) {var c = t.getPosition(),u = Math.max(t.getPrecision(), o.KERNEL_TOLERANCE),l = e.closestToPointParam(c);if (void 0 !== l) {var h = e.evaluatePosition(l);if (!(n.Vector3.squaredDistance(c, h) > u * u)) return { param: l, position: h };}}}}}}, u.prototype.matchVertices = function () {for (var e = new Set(), t = 0; t < this._edges1.length; ++t) {this._edges1[t].collectVertices(e);}this._verts1 = Array.from(e);var r = new Set();for (t = 0; t < this._edges2.length; ++t) {this._edges2[t].collectVertices(r);}this._verts2 = Array.from(r);var n = this;e.forEach(function (e) {r.forEach(function (t) {e !== t && n.verticesMatch(e, t) && n.addVertexMerge(e, t);});});}, u.prototype.findVertexOnEdgeSplits = function (e, t) {for (var r = t.length, n = 0; n < r; ++n) {for (var o = t[n], i = [], s = 0; s < e.length; ++s) {var a = e[s],c = this.findEdgeSplitParam(o, a);c && i.push({ vertex: a, param: c.param, position: c.position });}if (i.length > 0) {var u = this.splitEdgeAtParams(o, i);if (u.length > 0) {t[n] = u[0];for (var l = 1; l < u.length; ++l) {t.push(u[l]);}}}}}, u.prototype.doEdgeSplits = function () {this.findVertexOnEdgeSplits(this._verts1, this._edges2), this._sameEdgeLists || this.findVertexOnEdgeSplits(this._verts2, this._edges1);}, u.prototype.splitEdgeAtParams = function (e, t) {t.sort(function (e, t) {return e.param - t.param;});for (var r = [], s = e, a = 0; a < t.length; ++a) {var c = t[a].vertex,u = t[a].param,l = t[a].position,h = s.getStartVertex().getPosition();if (n.Vector3.squaredDistance(l, h) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) this.addVertexMerge(c, s.getStartVertex());else {0 === r.length && (s = (0, i.replaceEdge)(s), r.push(s), this._edgeProgenitors.addEntry(s, [e]));var d = (0, i.splitEdge)(s, u, l);r.push(d), this._edgeProgenitors.addEntry(d, [e]);var g = d.getStartVertex();this.addVertexMerge(c, g), this._newVertices.add(g), s = d;}}return r;}, u.prototype.edgesMatch = function (e, t) {return (0, s.edgesAreCoincident)(e, t);}, u.prototype.matchEdges = function () {for (var e = 0; e < this._edges1.length; ++e) {for (var t = this._edges1[e], r = t.getStartVertex(), n = t.getEndVertex(), o = 0; o < this._edges2.length; ++o) {var i = this._edges2[o],s = i.getStartVertex(),a = i.getEndVertex();if (!(this._sameEdgeLists && o <= e) && t !== i) {var c,u = r === s || r === a;if (!u) {var l = this._vertexMatchMap.get(r);l && (u = l === this._vertexMatchMap.get(s) || l === this._vertexMatchMap.get(a));}if (u && !(c = n === s || n === a)) {var h = this._vertexMatchMap.get(n);h && (c = h === this._vertexMatchMap.get(s) || h === this._vertexMatchMap.get(a));}u && c && this.edgesMatch(t, i) && this.addEdgeMerge(t, i);}}}}, u.prototype.setEdges = function (e, t) {e instanceof Set ? this._edges1 = Array.from(e) : e instanceof Array && (this._edges1 = e), t && t !== e ? t instanceof Set ? this._edges2 = Array.from(t) : t instanceof Array && (this._edges2 = t) : this._edges2 = this._edges1, this._sameEdgeLists = this._edges1 === this._edges2, c.ConsoleUtils.assert(this._edges1 && this._edges2);}, u.prototype.compute = function () {this.matchVertices(), this.doEdgeSplits(), this.matchEdges();}, u.prototype.getVertexMatches = function () {var e = new Set();return this._vertexMatchMap.forEach(function (t, r) {e.add(t);}), Array.from(e);}, u.prototype.getEdgeMatches = function () {var e = new Set();return this._edgeMatchMap.forEach(function (t, r) {e.add(t);}), Array.from(e);}, u.prototype.getNewVertices = function () {return this._newVertices;}, u.prototype.getEdgeProgenitors = function () {return this._edgeProgenitors;}, t.MatchFinder = u;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.replaceEdge = t.splitEdge = void 0;var n = r(16),o = r(20),i = r(27),s = r(6),a = function a(e, t) {var r = new i.Coedge();r.setEdge(t), e.getEdge().getCoedge() === e && t.setCoedge(r), r.setReversed(e.isReversed()), r.setLoop(e.getLoop());var n = e.getLoop().getCoedges(),o = n.indexOf(e);return r.isReversed() ? n.splice(o, 0, r) : n.splice((o + 1) % n.length, 0, r), r;};t.splitEdge = function (e, t, r) {var i = new n.Vertex(new s.Point(r)),c = [e.getRange()[0], e.getRange()[1]],u = e.getEndVertex();e.setRange([c[0], t]), e.setEndVertex(i);var l = new o.Edge();l.setCurve(e.getCurve()), l.setReversed(e.isReversed()), l.setRange([t, c[1]]), l.setStartVertex(i), l.setEndVertex(u), l.setPrecision(e.getPrecision()), l.setWire(e.getWire());for (var h = [], d = e.getCoedge(); d;) {h.push(a(d, l)), (d = d.getPartner()) === e.getCoedge() && (d = void 0);}for (var g = 0; g < h.length; ++g) {var p = (g + 1) % h.length;h[g].setPartner(h[p]);}if (l.getWire()) {var f = l.getWire().getEdges().slice(),v = f.indexOf(e);f.splice(v + 1, 0, l), l.getWire().setEdges(f);}return l;}, t.replaceEdge = function (e) {var t = new o.Edge();t.setCurve(e.getCurve()), t.setReversed(e.isReversed()), t.setRange([e.getRange()[0], e.getRange()[1]]), t.setStartVertex(e.getStartVertex()), t.setEndVertex(e.getEndVertex()), t.setPrecision(e.getPrecision()), t.setCoedge(e.getCoedge()), t.setWire(e.getWire()), e.setStartVertex(null), e.setEndVertex(null), e.setCoedge(void 0), e.setWire(void 0);for (var r = t.getCoedge(); r;) {r.setEdge(t), (r = r.getPartner()) === t.getCoedge() && (r = void 0);}if (t.getWire()) {var n = t.getWire().getEdges().slice();n[n.indexOf(e)] = t, t.getWire().setEdges(n);}return t;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.svgFromWire = void 0;var n = r(0),o = r(2);t.svgFromWire = function (e) {e.getTopologyType() === n.TOPOLOGY_TYPES.WIREBODY && console.warn(\"svgFromWire: Pass a wire, not a wire body.\"), o.ConsoleUtils.assert(e.getTopologyType() === n.TOPOLOGY_TYPES.WIRE, \"Input topology is not a Wire\");var t = e.getOrderedEdges();if (0 === t.edges.length) return \"\";for (var r = t.start, i = r.getPosition(), s = \"M \" + i[0] + \" \" + i[1], a = 0; a < t.edges.length; ++a) {var c = t.edges[a];i = (r = r === c.getStartVertex() ? c.getEndVertex() : c.getStartVertex()).getPosition();var u = c.getCurve();if (u) if (u.getGeometryType() === n.GEOMETRY_TYPES.LINE) s += \" L \" + i[0] + \" \" + i[1];else if (u.getGeometryType() !== n.GEOMETRY_TYPES.BCURVE || 3 !== u.getDegree() || u.isRational()) console.warn(\"Unhandled curve type in svgFromWire\");else {for (var l = [], h = u.getBezierSegments(), d = 0; d < h.length; d++) {var g = h[d];if (g) for (var p = g.getControlPoints(), f = 0; f < p.length; f += 3) {l.push([p[f], p[f + 1]]);}}r === c.getStartVertex() !== c.isReversed() && l.reverse(), o.ConsoleUtils.assert(l.length === 4 * h.length, \"Unexpected number of control points\");for (var v = 0; v < h.length; ++v) {s += \" C \" + l[4 * v + 1][0] + \" \" + l[4 * v + 1][1] + \" \" + l[4 * v + 2][0] + \" \" + l[4 * v + 2][1] + \" \", v === h.length - 1 ? s += i[0] + \" \" + i[1] : s += l[4 * v + 3][0] + \" \" + l[4 * v + 3][1];}}}return s;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Path2D = void 0;var n = r(1),o = r(0),i = r(54),s = r(40),a = r(33),c = r(14),u = r(23),l = r(7),h = r(28),d = r(84),g = r(2),p = r(8),f = { assert: function assert(e, t) {if (!e) throw { message: t || \"assertion failed\" };}, assert_arg: function assert_arg(e, t, r, n) {var o = \"Invalid argument '\" + t + \"': \" + r + \"\\nUsage: \" + n;this.assert(e, o);}, assert_number: function assert_number(e, t, r) {this.assert_arg(\"number\" == typeof e, t, \"should be a number\", r);}, assert_boolean: function assert_boolean(e, t, r) {this.assert_arg(\"boolean\" == typeof e, t, \"should be a boolean\", r);}, assert_string: function assert_string(e, t, r) {this.assert_arg(\"string\" == typeof e, t, \"should be a string\", r);} },v = function v() {this._wireBody = new i.WireBody(), this._curves = [], this._xy = [0, 0], this._mergeBCurves = !0, this._healPath = !1, this._tangentTol = o.KERNEL_ANGULAR_TOLERANCE;};function _(e, t, r) {var o = 3 * (t - 1),i = [e[o], e[o + 1], e[o + 2]],s = 3 * r,a = [e[s], e[s + 1], e[s + 2]],c = n.Vector3.sub([0, 0, 0], a, i);n.Vector3.scale(c, c, -.1);for (var u = 1; u <= r - t; ++u) {var l = n.Vector3.scaleAndAdd([0, 0, 0], a, c, u);e[s - 3 * u] = l[0], e[s - 3 * u + 1] = l[1], e[s - 3 * u + 2] = l[2];}}function y(e, t, r) {var o = 3 * t,i = [e[o], e[o + 1], e[o + 2]],s = 3 * (r + 1),a = [e[s], e[s + 1], e[s + 2]],c = n.Vector3.sub([0, 0, 0], a, i);n.Vector3.scale(c, c, .1);for (var u = 1; u <= r - t; ++u) {var l = n.Vector3.scaleAndAdd([0, 0, 0], i, c, u);e[o + 3 * u] = l[0], e[o + 3 * u + 1] = l[1], e[o + 3 * u + 2] = l[2];}}function m(e, t) {for (var r, o, i, s = [], a = e.getControlPoints(), c = [a[0], a[1], a[2]], u = a.length / 3, l = 1; l < u; ++l) {r = [a[3 * l], a[3 * l + 1], a[3 * l + 2]];var h = l === u - 1;n.Vector3.squaredDistance(c, r) < t ? (void 0 === o && (o = l - 1), i = l) : h = !0, h && void 0 !== o && void 0 !== i && (s.push([o, i]), h = !1, o = void 0, i = void 0), c = r;}return s;}function E(e, t) {var r = m(e, t);if (1 === r.length && r[0][1] - r[0][0] == 1) {var n = r[0];0 === n[0] ? e.addControlPointOnCurve(e.evaluatePosition(.1)) : n[1] === e.getNumControlPoints() - 1 ? e.addControlPointOnCurve(e.evaluatePosition(.9)) : (e.addControlPointOnCurve(e.evaluatePosition(.45)), e.addControlPointOnCurve(e.evaluatePosition(.55)));}return r.length > 0;}function x(e, t) {for (var r = m(e, t), n = 0; n < r.length; ++n) {var o = r[n],i = e.getControlPoints().slice();o[0] > 0 ? _(i, o[0], o[1]) : o[1] < i.length / 3 - 1 ? y(i, o[0], o[1]) : p.DebugUtils.warn(\"Degenerate BCurve!\"), e.setControlPoints(i);}}function R(e, t) {var r = e.getControlPoints(),o = [r[0], r[1], r[2]],i = [r[3], r[4], r[5]],s = n.Vector3.distance(o, i);r[3] = o[0] + t[0] * s, r[4] = o[1] + t[1] * s, r[5] = o[2] + t[2] * s, e.setControlPoints(r);}function A(e, t) {var r = e.getControlPoints(),o = e.getControlPoints().length,i = [r[o - 6], r[o - 5], r[o - 4]],s = [r[o - 3], r[o - 2], r[o - 1]],a = n.Vector3.distance(i, s);r[o - 6] = s[0] - t[0] * a, r[o - 5] = s[1] - t[1] * a, r[o - 4] = s[2] - t[2] * a, e.setControlPoints(r);}function P(e) {var t = new a.BCurve(),r = e.getRange(),o = e.evaluatePosition(r[0]),i = e.evaluatePosition(r[1]),s = n.Vector3.lerp([0, 0, 0], o, i, 1 / 3),c = n.Vector3.lerp([0, 0, 0], o, i, 2 / 3),u = [o[0], o[1], 0, s[0], s[1], 0, c[0], c[1], 0, i[0], i[1], 0];return t.set(u, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), t;}function V(e, t) {for (var r, o = e.getRange(), i = e.evaluatePosition(o[0]), s = e.evaluatePosition(o[1]), a = n.Vector3.distance(i, s), c = 0, u = t.getControlPoints(), l = [u[0], u[1], u[2]], h = u.length / 3, d = 1; d < h; ++d) {r = [u[3 * d], u[3 * d + 1], u[3 * d + 2]], c += n.Vector3.distance(l, r), l = r;}return a < c;}function T(e, t) {var r = e.getControlPoints().concat(t.getControlPoints().slice(3)),o = e.getWeights().concat(t.getWeights().slice(1)),i = e.getKnotVector().slice(0, -1),s = e.evaluateDt(e.getRange()[1]),a = t.evaluateDt(t.getRange()[0]),c = Math.sqrt(n.Vector3.squaredLength(a) / n.Vector3.squaredLength(s)),u = i[i.length - 1] - t.getKnotVector()[0] * c,l = t.getKnotVector().slice(t.getDegree() + 1);return l = l.map(function (e) {return e * c + u;}), i = i.concat(l), e.set(r, o, 3, i), e;}function C(e, t, r, i, s) {var a = n.Vector2.subtract([], s, e),u = n.Vector2.length(a);if (!(u < o.KERNEL_TOLERANCE)) {u > 2 * t && (t = u / 2);var l = n.Vector2.scaleAndAdd([], e, a, .5);if (u < 2 * t - n.FLOAT64_TOLERANCE) {var h = Math.sqrt(t * t - u * u / 4);!0 === i != (!1 === r) && (h = -h);var d = n.Vector2.normalize([], [-a[1], a[0]]);n.Vector2.scaleAndAdd(l, l, d, h);}var g = [0, 0, i ? 1 : -1],p = new c.Circle();p.set([l[0], l[1], 0], g, [t, 0, 0]);var f = p.closestToPointParam([e[0], e[1], 0]),v = p.closestToPointParam([s[0], s[1], 0]);return v <= f && (v += 2 * Math.PI), p.limitRange([f, v]), p;}}function b(e, t) {var r = e.slice(1);r = r.replace(/([^e])-/g, \"$1 -\");for (var n = 0; n < 2; ++n) {r = r.replace(/\\.[0-9]*\\./g, function (e) {return e.slice(0, -1) + \" .\";});}for (var o = r.split(/[,\\s]/), i = [], s = 0; s < o.length; ++s) {if (o[s].length > 0) {var a = Number(o[s]);t(!isNaN(a), \"could not parse command\"), i.push(a);}}return i;}v.prototype.numWires = function () {var e = this._wireBody.getWires().length;return this._curves.length > 0 && (e += 1), e;}, v.prototype.numClosed = function () {for (var e = 0, t = 0; t < this._wireBody.getWires().length; ++t) {this._wireBody.getWires()[t].isClosed() && (e += 1);}return this._areCurvesClosed() && (e += 1), e;}, v.prototype._fixCoincidentControlPoints = function () {for (var e = o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE, t = 0; t < this._curves.length; ++t) {var r = this._curves[t];r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && 3 === r.getDegree() && 4 === r.getNumControlPoints() && !1 === r.isRational() && E(r, e) && x(r, e);}}, v.prototype._snapBCurvesTangent = function () {for (var e = 0; e < this._curves.length; ++e) {var t = (e + 1) % this._curves.length;if (0 === t && !this._areCurvesClosed()) break;var r = this._curves[e],i = this._curves[t],s = r.evaluateDt(r.getRange()[1]),a = i.evaluateDt(i.getRange()[0]);n.Vector3.isParallel(s, a, 1, this._tangentTol) && (r.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE ? (n.Vector3.normalize(s, s), R(i, s)) : r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE && (n.Vector3.normalize(a, a), A(r, a)));}}, v.prototype._areCurvesClosed = function () {if (0 === this._curves.length) return !1;var e = this._curves[this._curves.length - 1],t = this._curves[0];return n.Vector3.squaredDistance(e.evaluatePosition(e.getRange()[1]), t.evaluatePosition(t.getRange()[0])) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE;}, v.prototype._mergeShortLinesWithBCurves = function () {for (var e = !1, t = 0; t < this._curves.length; ++t) {var r = (t + 1) % this._curves.length;if (0 === r && !this._areCurvesClosed()) break;var i = this._curves[t],s = this._curves[r],a = i.evaluateDt(i.getRange()[1]),c = s.evaluateDt(s.getRange()[0]);n.Vector3.isParallel(a, c, 1, o.KERNEL_ANGULAR_TOLERANCE) && (i.getGeometryType() === o.GEOMETRY_TYPES.LINE && s.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && V(i, s) ? (this._curves.splice(t, 1, T(P(i), s)), this._curves.splice(r, 1), t -= 1, e = !0) : i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && s.getGeometryType() === o.GEOMETRY_TYPES.LINE && V(s, i) && (this._curves.splice(t, 1, T(i, P(s))), this._curves.splice(r, 1), t -= 1, e = !0));}return e;}, v.prototype._mergeAdjacentBCurves = function () {for (var e = 0; e < this._curves.length; ++e) {var t = (e + 1) % this._curves.length;if (0 === t && !this._areCurvesClosed()) break;var r = this._curves[e],i = this._curves[t],s = r.evaluateDt(r.getRange()[1]),a = i.evaluateDt(i.getRange()[0]);n.Vector3.isParallel(s, a, 1, this._tangentTol) && r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && (n.Vector3.squaredLength(s) < n.Vector3.squaredLength(a) ? (n.Vector3.normalize(s, s), R(i, s)) : (n.Vector3.normalize(a, a), A(r, a)), r !== i && (T(r, i), this._curves.splice(t, 1), e -= 1));}}, v.prototype.setMergeBCurves = function (e) {this._mergeBCurves = e;}, v.prototype.setHealForASM = function (e, t) {this._healPath = e, this._tangentTol = void 0 !== t ? t : .01745240643728351;}, v.prototype._addWire = function () {if (0 !== this._curves.length) {this._healPath && (this._fixCoincidentControlPoints(), this._snapBCurvesTangent()), (this._mergeBCurves || this._healPath) && this._mergeAdjacentBCurves(), this._healPath && this._mergeShortLinesWithBCurves() && this._mergeAdjacentBCurves();var e = (0, h.createWiresFromEdges)((0, h.createEdgesFromCurves)(this._curves));g.ConsoleUtils.assert(1 === e.length), this._wireBody.addWire(e[0]), this._curves = [];}}, v.prototype._discardIfOpen = function () {if (0 !== this._curves.length) {var e = this._curves[0].evaluatePosition(this._curves[0].getRange()[0]),t = [this._xy[0], this._xy[1], 0];n.Vector3.squaredDistance(e, t) >= o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (this._curves = []);}}, v.prototype.moveTo = function (e, t) {var r = \"Path2D.moveTo(x, y)\";return f.assert_number(e, \"x\", r), f.assert_number(t, \"y\", r), this._addWire(), this._xy[0] = e, this._xy[1] = t, this;}, v.prototype.lineTo = function (e, t) {var r = \"Path2D.lineTo(x, y)\";f.assert_number(e, \"x\", r), f.assert_number(t, \"y\", r);var n = e - this._xy[0],i = t - this._xy[1];if (n * n + i * i > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) {var s = new l.Line();s.set([this._xy[0], this._xy[1], 0], [n, i, 0]), s.limitRange([0, 1]), this._curves.push(s);}return this._xy[0] = e, this._xy[1] = t, this;}, v.prototype.quadraticCurveTo = function (e, t, r, n) {var o = \"Path2D.quadraticCurveTo(cpx, cpy, x, y)\";f.assert_number(e, \"cpx\", o), f.assert_number(t, \"cpy\", o), f.assert_number(r, \"x\", o), f.assert_number(n, \"y\", o);var i = new a.BCurve(),s = 1 / 3 * this._xy[0] + 2 / 3 * e,c = 1 / 3 * this._xy[1] + 2 / 3 * t,u = 1 / 3 * r + 2 / 3 * e,l = 1 / 3 * n + 2 / 3 * t,h = [this._xy[0], this._xy[1], 0, s, c, 0, u, l, 0, r, n, 0];return i.set(h, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), this._curves.push(i), this._xy[0] = r, this._xy[1] = n, this;}, v.prototype.bezierCurveTo = function (e, t, r, n, o, i) {var s = \"Path2D.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\";f.assert_number(e, \"cp1x\", s), f.assert_number(t, \"cp1y\", s), f.assert_number(r, \"cp2x\", s), f.assert_number(n, \"cp2y\", s), f.assert_number(o, \"x\", s), f.assert_number(i, \"y\", s);var c = new a.BCurve(),u = [this._xy[0], this._xy[1], 0, e, t, 0, r, n, 0, o, i, 0];return c.set(u, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), this._curves.push(c), this._xy[0] = o, this._xy[1] = i, this;}, v.prototype.circleArcTo = function (e, t, r, n, o) {var i = \"Path2D.circleArcTo(radius, longest, anticlockwise, x, y)\";f.assert_number(e, \"radius\", i), f.assert_arg(e > 0, \"radius\", \"must be positive\", i), f.assert_boolean(t, \"longest\", i), f.assert_boolean(r, \"anticlockwise\", i), f.assert_number(n, \"x\", i), f.assert_number(o, \"y\", i);var s = C(this._xy, e, t, r, [n, o]);return s && (this._curves.push(s), this._xy[0] = n, this._xy[1] = o), this;}, v.prototype.ellipseArcTo = function (e, t, r, o, i, s, a) {var c = \"Path2D.ellipseArcTo(xRadius, yRadius, rotation, longest, anticlockwise, x, y)\";if (f.assert_number(e, \"xRadius\", c), f.assert_arg(e > 0, \"xRadius\", \"must be positive\", c), f.assert_number(t, \"yRadius\", c), f.assert_arg(t > 0, \"yRadius\", \"must be positive\", c), f.assert_number(r, \"rotation\", c), f.assert_boolean(o, \"longest\", c), f.assert_boolean(i, \"anticlockwise\", c), f.assert_number(s, \"x\", c), f.assert_number(a, \"y\", c), e < t) {var l = e;e = t, t = l, r += Math.PI / 2;}var h = Math.cos(r),d = Math.sin(r),g = e / t,p = n.Matrix22.multiply([], [1, 0, 0, g], [h, -d, d, h]),v = C(n.Vector2.transformMatrix22([], this._xy, p), e, o, i, n.Vector2.transformMatrix22([], [s, a], p));if (v) {var _ = [v.getCenter()[0], v.getCenter()[1]];n.Matrix22.invert(p, p), n.Vector2.transformMatrix22(_, _, p), _[2] = 0;var y = v.getRadius(),m = [y * h, y * d, 0],E = new u.Ellipse();E.set(_, v.getNormal(), m, 1 / g), E.limitRange(v.getRange()), this._curves.push(E), this._xy[0] = s, this._xy[1] = a;}return this;}, v.prototype.closePath = function () {if (this._curves.length > 0) {var e = this._curves[0],t = e.evaluatePosition(e.getRange()[0]);this.lineTo(t[0], t[1]), this._addWire();}return this;}, v.prototype.addCircle = function (e, t, r) {var n = \"Path2D.addCircle(x, y, radius)\";f.assert_number(e, \"x\", n), f.assert_number(t, \"y\", n), f.assert_number(r, \"radius\", n), f.assert_arg(r > 0, \"radius\", \"must be positive\", n), this._addWire();var o = new c.Circle();return o.set([e, t, 0], [0, 0, 1], [r, 0, 0]), this._curves.push(o), this._addWire(), this;}, v.prototype.addEllipse = function (e, t, r, n, o) {o = void 0 === o ? 0 : o;var i = \"Path2D.addEllipse(x, y, xRadius, yRadius, rotation)\";if (f.assert_number(e, \"x\", i), f.assert_number(t, \"y\", i), f.assert_number(r, \"xRadius\", i), f.assert_arg(r > 0, \"xRadius\", \"must be positive\", i), f.assert_number(n, \"yRadius\", i), f.assert_arg(n > 0, \"yRadius\", \"must be positive\", i), f.assert_number(o, \"rotation\", i), this._addWire(), r < n) {var s = r;r = n, n = s, o += Math.PI / 2;}var a = new u.Ellipse(),c = Math.cos(o),l = Math.sin(o),h = n / r;return a.set([e, t, 0], [0, 0, 1], [r * c, r * l, 0], h), this._curves.push(a), this._addWire(), this;}, v.prototype.addSVGPath = function (e, t) {t = void 0 !== t && t;var r = \"Path2D.addSVGPath(pathString, [includeOpen])\";f.assert_string(e, \"pathString\", r), f.assert_boolean(t, \"includeOpen\", r), this._addWire(), this._xy[0] = 0, this._xy[1] = 0;var n = function (e) {for (var t = []; e.length > 0;) {var r = e.slice(1).search(/[MmZzLlHhVvCcSsQqTtAa]/) + 1;r <= 0 && (r = e.length);var n = e.slice(0, r).trim();n.length > 0 && t.push(n), e = e.slice(r).trim();}return t;}(e);f.assert_arg(n.length > 0, \"pathString\", \"cannot be empty string\", r);for (var i = [this._xy[0], this._xy[1]], s = [this._xy[0], this._xy[1]], a = 0; a < n.length; ++a) {var c,u,l,h,d,g,p,v = function v(e, t) {f.assert_arg(e, \"pathString\", t + ' \"' + n[a] + '\"', r);},_ = n[a].charAt(0).toUpperCase(),y = _ !== n[a].charAt(0),m = b(n[a], v),E = y ? this._xy : [0, 0];switch (_) {case \"M\":for (v(m.length >= 2, \"insufficient arguments in command\"), v(m.length % 2 == 0, \"command requires pairs of x,y arguments\"), t || this._discardIfOpen(), this.moveTo(m[0] + E[0], m[1] + E[1]), p = 2; p < m.length; p += 2) {this.lineTo(m[p] + E[0], m[p + 1] + E[1]);}break;case \"Z\":v(0 === m.length, \"command should not have arguments\"), this.closePath();break;case \"L\":for (v(m.length >= 2, \"insufficient arguments in command\"), v(m.length % 2 == 0, \"command requires pairs of x,y arguments\"), p = 0; p < m.length; p += 2) {this.lineTo(m[p] + E[0], m[p + 1] + E[1]);}break;case \"H\":for (v(m.length >= 1, \"insufficient arguments in command\"), p = 0; p < m.length; p += 1) {this.lineTo(m[p] + E[0], this._xy[1]);}break;case \"V\":for (v(m.length >= 1, \"insufficient arguments in command\"), p = 0; p < m.length; p += 1) {this.lineTo(this._xy[0], m[p] + E[1]);}break;case \"C\":for (v(m.length >= 6, \"insufficient arguments in command\"), v(m.length % 6 == 0, \"command requires sets of 6 arguments\"), p = 0; p < m.length; p += 6) {c = m[p] + E[0], u = m[p + 1] + E[1], l = m[p + 2] + E[0], h = m[p + 3] + E[1], d = m[p + 4] + E[0], g = m[p + 5] + E[1], this.bezierCurveTo(c, u, l, h, d, g), s[0] = l, s[1] = h;}break;case \"S\":for (v(m.length >= 4, \"insufficient arguments in command\"), v(m.length % 4 == 0, \"command requires sets of 4 arguments\"), p = 0; p < m.length; p += 4) {c = 2 * this._xy[0] - s[0], u = 2 * this._xy[1] - s[1], l = m[p] + E[0], h = m[p + 1] + E[1], d = m[p + 2] + E[0], g = m[p + 3] + E[1], this.bezierCurveTo(c, u, l, h, d, g), s[0] = l, s[1] = h;}break;case \"Q\":for (v(m.length >= 4, \"insufficient arguments in command\"), v(m.length % 4 == 0, \"command requires sets of 4 arguments\"), p = 0; p < m.length; p += 4) {c = m[p] + E[0], u = m[p + 1] + E[1], l = m[p + 2] + E[0], h = m[p + 3] + E[1], this.quadraticCurveTo(c, u, l, h), i[0] = c, i[1] = u;}break;case \"T\":for (v(m.length >= 2, \"insufficient arguments in command\"), v(m.length % 2 == 0, \"command requires pairs of arguments\"), p = 0; p < m.length; p += 2) {c = 2 * this._xy[0] - i[0], u = 2 * this._xy[1] - i[1], l = m[p] + E[0], h = m[p + 1] + E[1], this.quadraticCurveTo(c, u, l, h), i[0] = c, i[1] = u;}break;case \"A\":for (v(m.length >= 7, \"insufficient arguments in command\"), v(m.length % 7 == 0, \"command requires sets of 7 arguments\"), p = 0; p < m.length; p += 7) {var x = Math.abs(m[p]),R = Math.abs(m[p + 1]),A = m[p + 2] * Math.PI / 180,P = 0 !== m[p + 3],V = 0 !== m[p + 4],T = m[p + 5] + E[0],C = m[p + 6] + E[1];x < o.KERNEL_TOLERANCE || R < o.KERNEL_TOLERANCE ? this.lineTo(T, C) : this.ellipseArcTo(x, R, A, P, V, T, C);}break;default:v(!1, \"unrecognised command\");}\"Q\" !== _ && \"T\" !== _ && (i = [this._xy[0], this._xy[1]]), \"C\" !== _ && \"S\" !== _ && (s = [this._xy[0], this._xy[1]]);}return t || this._discardIfOpen(), this._addWire(), this;}, v.prototype.getWireBody = function () {return this._addWire(), this._wireBody;}, v.prototype.computeRegionizedWireBody = function () {this.getWireBody();for (var e = new i.WireBody(), t = (0, d.mergeSketchRegions)(this._wireBody.getWires()), r = 0; r < t.length; ++r) {for (var n = t[r].getLoops(), o = 0; o < n.length; ++o) {var a = n[o],c = new s.Wire();c.addEdges(Array.from(a.collectEdges())), e.addWire(c);}}return e;}, v.prototype.reset = function () {this._wireBody = new i.WireBody(), this._curves = [], this._xy = [0, 0];}, t.Path2D = v;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SolidDefLoader = t.getTopologyRank = void 0;var n = r(6),o = r(7),i = r(14),s = r(23),a = r(33),c = r(18),u = r(38),l = r(39),h = r(74),d = r(51),g = r(52),p = r(75),f = r(53),v = r(24),_ = r(25),y = r(26),m = r(15),E = r(13),x = r(27),R = r(20),A = r(16),P = r(54),V = r(40),T = r(79),C = r(0),b = r(85),L = r(124),O = r(125),S = r(45),M = function () {var e = {};return e[C.TOPOLOGY_TYPES.BODY] = 10, e[C.TOPOLOGY_TYPES.WIREBODY] = 9, e[C.TOPOLOGY_TYPES.LUMP] = 8, e[C.TOPOLOGY_TYPES.SHELL] = 7, e[C.TOPOLOGY_TYPES.FACE] = 6, e[C.TOPOLOGY_TYPES.WIRE] = 5, e[C.TOPOLOGY_TYPES.LOOP] = 4, e[C.TOPOLOGY_TYPES.COEDGE] = 3, e[C.TOPOLOGY_TYPES.EDGE] = 2, e[C.TOPOLOGY_TYPES.VERTEX] = 1, function (t) {var r = void 0;return \"function\" == typeof t.getTopologyType && (r = e[t.getTopologyType()]), r || 0;};}(),w = function w() {this._runTimeMap = new Map(), this._typeidToFuncMap = {}, this.addLoader(\"body\", L.TopologySetters.setBodyData, v.Body), this.addLoader(\"wirebody\", L.TopologySetters.setWireBodyData, P.WireBody), this.addLoader(\"wire\", L.TopologySetters.setWireData, V.Wire), this.addLoader(\"lump\", L.TopologySetters.setLumpData, _.Lump), this.addLoader(\"shell\", L.TopologySetters.setShellData, y.Shell), this.addLoader(\"face\", L.TopologySetters.setFaceData, m.Face), this.addLoader(\"loop\", L.TopologySetters.setLoopData, E.Loop), this.addLoader(\"coedge\", L.TopologySetters.setCoedgeData, x.Coedge), this.addLoader(\"edge\", L.TopologySetters.setEdgeData, R.Edge), this.addLoader(\"vertex\", L.TopologySetters.setVertexData, A.Vertex), this.addLoader(\"point\", b.GeometrySetters.setPointFromProperty, n.Point), this.addLoader(\"line\", b.GeometrySetters.setLineFromProperty, o.Line), this.addLoader(\"circle\", b.GeometrySetters.setCircleFromProperty, i.Circle), this.addLoader(\"ellipse\", b.GeometrySetters.setEllipseFromProperty, s.Ellipse), this.addLoader(\"bcurve\", b.GeometrySetters.setBCurveFromProperty, a.BCurve), this.addLoader(\"plane\", b.GeometrySetters.setPlaneFromProperty, c.Plane), this.addLoader(\"sphere\", b.GeometrySetters.setSphereFromProperty, h.Sphere), this.addLoader(\"torus\", b.GeometrySetters.setTorusFromProperty, p.Torus), this.addLoader(\"cylinder\", b.GeometrySetters.setCylinderFromProperty, u.Cylinder), this.addLoader(\"cone\", b.GeometrySetters.setConeFromProperty, d.Cone), this.addLoader(\"ellipticalcylinder\", b.GeometrySetters.setEllipticalCylinderFromProperty, l.EllipticalCylinder), this.addLoader(\"ellipticalcone\", b.GeometrySetters.setEllipticalConeFromProperty, g.EllipticalCone), this.addLoader(\"bsurface\", b.GeometrySetters.setBSurfaceFromProperty, f.BSurface), this.addLoader(\"nmiattributestr\", O.AttributeSetters.setNMIAttributeStr, T.Attribute), this.addLoader(\"nmiattributearr\", O.AttributeSetters.setNMIAttributeArr, T.Attribute), this.addLoader(\"textattribute\", O.AttributeSetters.setTextAttribute, T.Attribute);};w.prototype.addLoader = function (e, t, r) {this._typeidToFuncMap[e] = [t, r];}, w.prototype._reset = function () {this._runTimeMap.clear();}, w.prototype.getDataSettingFunction = function (e) {var t = this._typeidToFuncMap[e];if (t) return t[0];}, w.prototype.createRunTimeObject = function (e) {var t = this.getTypeContructor(e);if (t) return new t();}, w.prototype.getTypeContructor = function (e) {var t = this._typeidToFuncMap[e];if (t && 2 === t.length) return t[1];}, w.prototype.setObjectProperties = function (e, t, r) {var n = this.getDataSettingFunction(e, r);var o = this;\"function\" == typeof n && n(t, r, function (e) {if (!e) return;var t = e;return t ? o._runTimeMap.get(t) : void 0;});}, w.prototype.makeGeometryObjectsProto = function (e) {var _this2 = this;Object.keys(e).forEach(function (t) {var r = e[t],n = r[r.geometry],o = _this2.createRunTimeObject(r.geometry);o && (_this2._runTimeMap.set(t, o), _this2.setObjectProperties(r.geometry, o, n), o.setGuid(t));});}, w.prototype.makeGeometryObject = function (e) {var t = e.getTypeid(),r = this.createRunTimeObject(t);return r ? this.setObjectProperties(t, r, e) : console.error(\"No constructor\"), r;}, w.prototype.makeTopologyObject = function (e) {var t = e.getTypeid(),r = this.createRunTimeObject(t);return r || console.error(\"No constructor\"), r;}, w.prototype.makeAttributeObjectsProto = function (e) {var _this3 = this;Object.keys(e).forEach(function (t) {var r = e[t],n = r[r.attribute],o = new T.Attribute();_this3._runTimeMap.set(t, o), _this3.setObjectProperties(r.attribute, o, n), o.setGuid(t);});}, w.prototype.makeTopologyObjectsProto = function (e) {var _this4 = this;var t = [];Object.keys(e).forEach(function (r) {var n = e[r],o = n[n.topology],i = _this4.createRunTimeObject(n.topology);i && (_this4._runTimeMap.set(r, i), t.push({ type: n.topology, obj: i, prop: o }), i.setGuid(r));});for (var r = 0; r < t.length; ++r) {this.setObjectProperties(t[r].type, t[r].obj, t[r].prop);}}, w.prototype._collectGeometries = function (e) {this._runTimeMap.forEach(function (t) {void 0 !== t.getGeometryType && e.set(t.getGuid(), t);});}, w.prototype._collectTopologies = function (e) {this._runTimeMap.forEach(function (t) {void 0 !== t.getTopologyType && e.set(t.getGuid(), t);});}, w.prototype.loadModelPSet = function (e, t, r) {var n = e.get(\"geometries\");if (n) {var o = e.get(\"attributes\"),i = e.get(\"topologies\");if (i) return this.makeGeometryObjects(n), o && this.makeAttributeObjects(o), this.makeTopologyObjects(i), this.getHighestObject(t, r);}}, w.prototype.getHighestObject = function (e, t) {var r = void 0,n = 0;return this._runTimeMap.forEach(function (e) {if (10 !== n) {var t = M(e);t > n && t > 0 && (n = t, r = e);}}), e && this._collectGeometries(e), t && this._collectTopologies(t), this._reset(), r;}, w.prototype.loadModelProtoMessage = function (e, t, r) {var n = e.geometries;if (!n) return;var o = e.attributes,i = e.topologies;return i ? (this.makeGeometryObjectsProto(n), o && this.makeAttributeObjectsProto(o), this.makeTopologyObjectsProto(i), this.getHighestObject(t, r)) : void 0;}, w.prototype.loadProtoBinary = function (e, t, r) {var n = e;n instanceof ArrayBuffer && (n = new Uint8Array(n));var o = S.Autodesk.lookupType(\"SolidDef.model_1_0_0\").decode(n);return this.loadModelProtoMessage(o, t, r);}, t.getTopologyRank = M, t.SolidDefLoader = w;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.TopologySetters = void 0;var n = r(85);var o = {},i = function i(e, t, r) {var n = t.attributes;if (n) {e.removeAllAttributes();for (var o = 0; o < n.length; ++o) {var _t9 = r(n[o]);e.addAttribute(_t9);}}};o.setBodyData = function (e, t, r) {for (var n = t.lumps, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setBody(e);}e.setLumps(o), i(e, t, r);}, o.setLumpData = function (e, t, r) {for (var n = t.shells, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setLump(e);}e.setShells(o), i(e, t, r);}, o.setShellData = function (e, t, r) {for (var n = t.faces, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setShell(e);}e.setFaces(o), i(e, t, r);}, o.setFaceData = function (e, t, r) {for (var n = t.loops, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setFace(e);}e.setLoops(o), e.setReversed(t.reversed), e.setSurface(r(t.geometry)), i(e, t, r);}, o.setLoopData = function (e, t, r) {for (var n = t.coedges, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setLoop(e);}e.setCoedges(o), i(e, t, r);}, o.setCoedgeData = function (e, t, r) {e.setEdge(r(t.edge)), e.setReversed(t.reversed), e.setPartner(r(t.partner)), e.getEdge() && !e.getEdge().getCoedge() && e.getEdge().setCoedge(e), i(e, t, r);}, o.setEdgeData = function (e, t, r) {e.setVertex(0, r(t.vertex0)), e.setVertex(1, r(t.vertex1));var o = (0, n.propertyToRange)(t, \"range\");e.sett0(o[0]), e.sett1(o[1]), e.setReversed(t.reversed), e.setPrecision(t.precision), e.setCurve(r(t.geometry)), i(e, t, r);}, o.setVertexData = function (e, t, r) {e.setPrecision(t.precision), e.setPoint(r(t.geometry)), i(e, t, r);}, o.setWireBodyData = function (e, t, r) {for (var n = t.wires, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setWireBody(e);}e.setWires(o), i(e, t, r);}, o.setWireData = function (e, t, r) {for (var n = t.edges, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setWire(e);}e.setEdges(o), i(e, t, r);}, t.TopologySetters = o;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = { setNMIAttributeStr: function setNMIAttributeStr(e, t) {e.typeid = \"autodesk.brep:nmiattributestr-1.0.0\", e.values = { primaryId: t.primaryId, secondaryId: t.secondaryId, approachId: t.approachId, operationIds: t.operationIds };}, setNMIAttributeArr: function setNMIAttributeArr(e, t) {e.typeid = \"autodesk.brep:nmiattributearr-1.0.0\";for (var r = t.tagInfo, n = new Array(r.length), o = 0; o < r.length; ++o) {var i = r[o];n[o] = { primaryId: i.primaryId, secondaryId: i.secondaryId, approachId: i.approachId, operationIds: i.operationIds };}e.values = { tagInfo: n };}, setTextAttribute: function setTextAttribute(e, t) {e.typeid = \"autodesk.brep:textattribute-1.0.0\", e.values = { text: t.text };} };t.AttributeSetters = n;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.saveToProtoBinary = t.saveToProtoMessage = t.SolidDefSaver = void 0;var n = r(45),o = function o() {};o.prototype.setVersion = function (e) {console.warn(\"SolidDefSaver.prototype.setVersion is deprecated,\");};var i = function i(e) {var t = n.Autodesk.lookupType(\"SolidDef.model_1_0_0\"),r = { topologies: {}, geometries: {}, attributes: {} };return e.addToModelObject(r), t.create(r);};t.SolidDefSaver = o, t.saveToProtoMessage = i, t.saveToProtoBinary = function (e) {var t = n.Autodesk.lookupType(\"SolidDef.model_1_0_0\"),r = i(e);return t.encode(r).finish();};}]);});","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".avatar-widget {\\n  width: 0px;\\n  height: 0px;\\n  top: 0px;\\n  left: 0px;\\n  position: absolute;\\n  transition: opacity 0.7s;\\n  opacity: 0;\\n  z-index: 1;\\n  pointer-events: none;\\n  will-change: transform; }\\n  .avatar-widget.visible {\\n    opacity: 0.7;\\n    pointer-events: all; }\\n\\n.avatar-frustum {\\n  border-left: 20px solid transparent;\\n  border-right: 20px solid transparent;\\n  border-top: 40px solid #3590e9;\\n  border-radius: 50%;\\n  opacity: 0.4;\\n  width: 0px;\\n  height: 0px;\\n  position: absolute;\\n  transform-origin: bottom center;\\n  cursor: crosshair;\\n  will-change: transform; }\\n  .avatar-frustum.touch {\\n    border-left: 40px solid transparent;\\n    border-right: 40px solid transparent;\\n    border-top: 80px solid #3590e9; }\\n\\n.avatar-position-fill {\\n  width: 10px;\\n  height: 10px;\\n  /* Move circle center to the tip of the frustum shape */\\n  left: 15px;\\n  /* = (avatarFrustum.border-left - width/2)  */\\n  top: 35px;\\n  /* = (avatarFrustum.border-top  - height/2) */\\n  position: absolute;\\n  border-radius: 50%;\\n  background-color: #3590e9;\\n  box-shadow: 0px 0px 0px 2px #fff; }\\n  .avatar-position-fill.touch {\\n    /* Move circle center to the tip of the frustum shape */\\n    left: 35px;\\n    /* = (avatarFrustum.border-left - width/2)  */\\n    top: 75px;\\n    /* = (avatarFrustum.border-top  - height/2) */ }\\n\\n.avatar-position-hitarea {\\n  position: absolute;\\n  width: 15px;\\n  height: 15px;\\n  left: 5px;\\n  /* avatar-position-fill.width/2 */\\n  top: 5px;\\n  /* avatar-position-fill.height/2 */\\n  border-radius: 50px;\\n  transform: translate(-50%, -50%);\\n  cursor: grab; }\\n  .avatar-position-hitarea.touch {\\n    width: 50px;\\n    height: 50px; }\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"/*\\nhttps://stackoverflow.com/questions/27900053/css-transition-with-visibility-not-working\\n\\nVisibility is an animatable property according to the spec, but transitions on visibility do not work gradually, as one might expect.\\nInstead transitions on visibility delay hiding an element. On the other hand making an element visible works immediately.\\nThis is as it is defined by the spec (in the case of the default timing function) and as it is implemented in the browsers.\\n\\n    ==> transition: visibility 0.7s, opacity 0.7s;\\n*/\\n.canvas-bookmark.adsk-button, .clustered-canvas-bookmark.adsk-button, .declustered-canvas-bookmark.adsk-button {\\n  position: absolute;\\n  left: 0px;\\n  top: 0px;\\n  border-style: none !important;\\n  /* Avoid border on button-hover */\\n  color: white;\\n  margin: none;\\n  padding: 0px;\\n  transition: visibility 0.5s, opacity 0.5s;\\n  opacity: 0;\\n  visibility: hidden; }\\n\\n.canvas-bookmark.adsk-button {\\n  width: 22px;\\n  height: 22px; }\\n\\n.clustered-canvas-bookmark.adsk-button {\\n  width: 29px;\\n  height: 29px; }\\n\\n.declustered-canvas-bookmark.adsk-button {\\n  width: 29px;\\n  height: 29px;\\n  color: lightgrey; }\\n\\n.canvas-bookmark.visible {\\n  opacity: 1;\\n  visibility: visible; }\\n\\n.clustered-canvas-bookmark.visible {\\n  opacity: 1;\\n  visibility: visible; }\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".camera-selector {\\n  width: 0;\\n  height: 0;\\n  border-left: 50px solid transparent;\\n  border-right: 50px solid transparent;\\n  border-top: 100px solid #0696D7;\\n  border-radius: 50%;\\n  transform-origin: bottom center;\\n  position: absolute;\\n  opacity: 0.8;\\n  pointer-events: none;\\n  z-index: 1; }\\n\\n.camera-selector-position {\\n  width: 20px;\\n  height: 20px;\\n  border-radius: 50%;\\n  background-color: #0696D7;\\n  position: absolute;\\n  opacity: 0.8;\\n  pointer-events: none;\\n  z-index: 1;\\n  transform: scale(1, 1);\\n  transition: transform 3s ease-in; }\\n\\n.camera-selector-position--teleporting {\\n  transform: scale(0, 0); }\\n\\n.camera-selector-background {\\n  width: 200px;\\n  height: 200px;\\n  background-color: #0696D7;\\n  opacity: 0.2;\\n  position: absolute;\\n  pointer-events: none;\\n  z-index: 0;\\n  transform: translate(-100px, -100px);\\n  border-radius: 50%; }\\n\\n/* mimic issues UI guidance for now as it was the only extension, featuring guidance so far */\\n.dropme-guidenace-ui {\\n  display: flex;\\n  position: absolute;\\n  left: 50%;\\n  top: 20px;\\n  padding: 10px 20px;\\n  transform: translate(-50%, 0);\\n  align-items: center;\\n  border: 1px solid #9ec8f6;\\n  border-radius: 4px;\\n  background-color: #edf5fd;\\n  color: #039be5;\\n  font-size: 12px;\\n  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.25);\\n  opacity: 1;\\n  z-index: 999;\\n  overflow-y: hidden; }\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"/*\\nhttps://stackoverflow.com/questions/27900053/css-transition-with-visibility-not-working\\n\\nVisibility is an animatable property according to the spec, but transitions on visibility do not work gradually, as one might expect.\\nInstead transitions on visibility delay hiding an element. On the other hand making an element visible works immediately.\\nThis is as it is defined by the spec (in the case of the default timing function) and as it is implemented in the browsers.\\n\\n    ==> transition: visibility 0.7s, opacity 0.7s;\\n*/\\n.minimap3D {\\n  width: 0px;\\n  height: 0px;\\n  position: absolute;\\n  display: flex;\\n  flex-direction: column;\\n  transition: visibility 0.7s, opacity 0.7s;\\n  opacity: 0;\\n  visibility: hidden;\\n  background: rgba(255, 255, 255, 0.4);\\n  overflow: hidden;\\n  /* For side-by-side mode: Make sure that text selection highlighting is disabled on Minimap. Otherwise, fast dragging of the player will\\n       color the whole map in blue */\\n  user-select: none;\\n  border-radius: 4px;\\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.4); }\\n\\n.minimap3D.paddedForToolbar {\\n  right: 70px; }\\n\\n.minimapScrollArea {\\n  width: 100%;\\n  height: 100%;\\n  position: relative; }\\n\\n/* Show map left-aligned and without margin */\\n.minimap3D.side-by-side {\\n  box-sizing: border-box;\\n  box-shadow: 0px 0px 3px rgba(0, 0, 0, 0.5);\\n  z-index: 1;\\n  overflow-x: hidden; }\\n\\n.minimap3D.side-by-side.left-2d-view {\\n  border-left: none;\\n  border-right: solid 2px #979797;\\n  left: 0px; }\\n\\n.minimap3D.visible {\\n  opacity: 1;\\n  visibility: visible; }\\n\\n/* Container for floor image + floor name */\\n.mapContainer {\\n  position: absolute;\\n  left: 0px;\\n  top: 0px;\\n  opacity: 1; }\\n\\n.mapImage {\\n  position: absolute;\\n  left: 0px;\\n  top: 0px;\\n  pointer-events: none; }\\n\\n/* Display floor name at top left */\\n.floorNameLabel {\\n  z-index: 2;\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  opacity: 0.99;\\n  background-color: whitesmoke;\\n  box-shadow: 1px 3px 10px 0 rgba(0, 0, 0, 0.5);\\n  margin: 4px;\\n  border-radius: 5px; }\\n\\n.floorNameLabel.dark {\\n  margin-top: 10px;\\n  left: 50%;\\n  transform: translate(-50%);\\n  border-radius: 28px;\\n  background-color: rgba(50, 50, 50, 0.8); }\\n\\n.floorNameLabel.light {\\n  margin-top: 10px;\\n  left: 50%;\\n  transform: translate(-50%);\\n  border-radius: 28px;\\n  background-color: rgba(255, 255, 255, 0.85);\\n  box-shadow: none; }\\n\\n.floorText {\\n  margin: 5px 5px 5px 5px;\\n  color: black;\\n  white-space: nowrap;\\n  text-overflow: ellipsis;\\n  overflow: hidden; }\\n\\n.floorText.dark {\\n  padding: 0px 15px;\\n  color: #FFFFFF;\\n  font-family: \\\"Artifakt Element\\\", Helvetica, Arial;\\n  font-size: 14px; }\\n\\n.floorText.light {\\n  padding: 0px 15px;\\n  color: #000;\\n  font-family: \\\"Artifakt Element\\\", Helvetica, Arial;\\n  font-size: 14px; }\\n\\n/* Div with text and progressbar - replaces the map image if map computation is running */\\n.minimap-placeholder {\\n  left: 0px;\\n  top: 0px;\\n  position: absolute;\\n  background-color: rgba(255, 255, 255, 0.5);\\n  opacity: 1; }\\n\\n.minimap-progressWidget {\\n  transform: translate(0, -50%);\\n  left: 0px;\\n  top: 50%;\\n  position: relative;\\n  height: fit-content;\\n  width: calc(100% - 60px);\\n  margin-left: 30px;\\n  margin-right: 30px; }\\n\\n.minimap-progressText {\\n  color: black;\\n  text-align: left;\\n  position: relative; }\\n\\n.minimap-progress {\\n  z-index: 10;\\n  width: 100%; }\\n\\n.map-button-bar {\\n  z-Index: 2;\\n  right: 0px;\\n  top: 0px;\\n  position: absolute;\\n  right: 100%;\\n  /* Dock left to mapWidget */\\n  display: flex;\\n  flex-direction: column;\\n  background-color: whitesmoke;\\n  box-shadow: 1px 3px 10px 0 rgba(0, 0, 0, 0.5);\\n  margin-right: 4px;\\n  margin-top: 0px;\\n  /* Toolbar is vertically aligned to the upper mapWidget boundary. This is okay, because the mapWidget already has some margin from the canvas boundary. */\\n  border-radius: 5px; }\\n\\n/* In side-by-side, the upper mapWidget edge is matched with the upper canvas edge. So, we add some marigin - otherwise the toolbar would be \\\"glued\\\" to the upper canvas edge. */\\n.map-button-bar.side-by-side {\\n  margin-top: 4px; }\\n\\n.map-button-bar.side-by-side.left-2d-view {\\n  right: 0px; }\\n\\n.sheetmap-thumbnail {\\n  position: absolute;\\n  overflow: hidden; }\\n\\n.side-by-side .minimap-header {\\n  border-radius: 0; }\\n\\n.minimap-header {\\n  background: #ffffff;\\n  display: flex;\\n  position: initial;\\n  align-items: center;\\n  justify-content: space-between;\\n  border-radius: 4px 4px 0 0;\\n  width: 100%;\\n  z-index: 4;\\n  transform-origin: top;\\n  -moz-box-shadow: 0px 2px 4px -2px rgba(0, 0, 0, 0.5);\\n  -webkit-box-shadow: 0px 2px 4px -2px rgba(0, 0, 0, 0.5);\\n  box-shadow: 0px 2px 4px -2px rgba(0, 0, 0, 0.5); }\\n\\n.adsk-viewing-viewer.light-theme .minimap-header,\\n.adsk-viewing-viewer.bim-theme .minimap-header,\\n.adsk-viewing-viewer.acs-theme .minimap-header {\\n  border-bottom: 1px solid #dcdcdc; }\\n\\n.minimap-title {\\n  font-size: 14px;\\n  text-align: left;\\n  text-align-last: left;\\n  margin-right: 12px;\\n  -webkit-appearance: none;\\n  -moz-appearance: none;\\n  appearance: none;\\n  white-space: nowrap;\\n  overflow: hidden;\\n  text-overflow: ellipsis; }\\n\\n.minimap-dropdown-wrapper {\\n  cursor: pointer;\\n  outline: none;\\n  white-space: nowrap;\\n  flex-grow: 1;\\n  display: flex;\\n  align-items: center;\\n  overflow: hidden;\\n  margin-right: auto; }\\n\\n.minimap-dropdown-wrapper:after {\\n  content: \\\"\\\";\\n  border-width: 6px 5px 0 5px;\\n  border-style: solid;\\n  border-color: #819099 transparent; }\\n\\n.minimap-dropdown {\\n  position: absolute;\\n  top: 40px;\\n  left: 5px;\\n  max-height: 120px;\\n  margin: 0;\\n  width: 90%;\\n  background: #ffffff;\\n  list-style: none;\\n  opacity: 0;\\n  pointer-events: none;\\n  overflow: scroll;\\n  overflow-x: hidden;\\n  border-radius: 3px;\\n  z-index: 10;\\n  box-shadow: 0px 1px 7px rgba(0, 0, 0, 0.3); }\\n\\n.minimap-dropdown li {\\n  display: block;\\n  color: #222222;\\n  text-decoration: none;\\n  border-left: 5px;\\n  padding: 8px 8px 8px 20px;\\n  font-size: 14px;\\n  overflow: hidden;\\n  text-overflow: ellipsis; }\\n\\n.minimap-dropdown li.active {\\n  background: #eef0f2; }\\n\\n.minimap-dropdown li:hover {\\n  background: #f8f9fa; }\\n\\n.minimap-dropdown.active {\\n  opacity: 1;\\n  pointer-events: auto;\\n  padding: 0 0 10px 0; }\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".list-panel {\\n  width: 260px;\\n  min-width: 260px;\\n  height: 260px;\\n  min-height: 260px;\\n  top: 180px;\\n  left: 220px;\\n  border-color: transparent; }\\n\\n.list-panel .itemList {\\n  width: 100%;\\n  display: flex;\\n  flex-direction: column; }\\n\\n.list-panel .listItem {\\n  display: flex;\\n  justify-content: space-between;\\n  text-align: left;\\n  line-height: 35px;\\n  background-color: rgba(0, 0, 0, 0);\\n  border-style: none;\\n  font-family: \\\"ArtifaktElement\\\", \\\"Helvetica Neue\\\", \\\"Segoe UI Semilight\\\", sans-serif;\\n  padding: 0 10px; }\\n\\n.adsk-viewing-viewer.dark-theme .listItem {\\n  color: #f3f7fb; }\\n\\n.adsk-viewing-viewer.light-theme .list-panel .listItem.hover {\\n  background-color: rgba(10, 19, 28, 0.2); }\\n\\n.adsk-viewing-viewer.dark-theme .list-panel .listItem.hover {\\n  background-color: #4a555b; }\\n\\n.list-panel .listItem:focus {\\n  outline: none; }\\n\\n.list-panel .listItem.selected {\\n  color: deepskyblue;\\n  border-style: none; }\\n\\n.list-panel .listItem .textContainer {\\n  -webkit-mask-image: linear-gradient(to left, transparent, black 1em);\\n  mask-image: linear-gradient(to left, transparent, black 1em);\\n  white-space: nowrap;\\n  overflow: hidden;\\n  width: 100%; }\\n\\n.list-panel .listItem .icon {\\n  width: 24px; }\\n\\n.list-panel .listItem.selected .icon::before {\\n  content: '\\\\2713';\\n  margin-left: 8px; }\\n\\n.list-panel-item-warning {\\n  background-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScyNCcgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDggOCc+PHBhdGggZmlsbD0nIzZiNzg3ZicgZD0nTTMuMDkgMGMtLjA2IDAtLjEuMDQtLjEzLjA5bC0yLjk0IDYuODFjLS4wMi4wNS0uMDMuMTMtLjAzLjE5di44MWMwIC4wNS4wNC4wOS4wOS4wOWg2LjgxYy4wNSAwIC4wOS0uMDQuMDktLjA5di0uODFjMC0uMDUtLjAxLS4xNC0uMDMtLjE5bC0yLjk0LTYuODFjLS4wMi0uMDUtLjA3LS4wOS0uMTMtLjA5aC0uODF6bS0uMDkgM2gxdjJoLTF2LTJ6bTAgM2gxdjFoLTF2LTF6JyAvPjwvc3ZnPg==\\\");\\n  width: 24px;\\n  height: 24px;\\n  margin-left: auto;\\n  margin-top: auto;\\n  margin-bottom: auto; }\\n\\n.list-panel .visibility {\\n  right: 0;\\n  top: 0;\\n  width: 35px;\\n  height: 35px;\\n  border: none;\\n  outline: none;\\n  margin: 0;\\n  padding: 0;\\n  background-position: 6px 12px;\\n  background-image: url(\\\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+DQo8c3ZnIHdpZHRoPSIxN3B4IiBoZWlnaHQ9IjEwcHgiIHZpZXdCb3g9IjAgMCAxNyAxMCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4NCiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQ2LjIgKDQ0NDk2KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4NCiAgICA8dGl0bGU+R3JvdXAgMjU8L3RpdGxlPg0KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPg0KICAgIDxkZWZzPjwvZGVmcz4NCiAgICA8ZyBpZD0iU2VsZWN0LSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+DQogICAgICAgIDxnIGlkPSJNb2RlbF9Ccm93c2VyX2hvdmVyIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjYzLjAwMDAwMCwgLTE5NS4wMDAwMDApIj4NCiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjUzLjAwMDAwMCwgNzQuMDAwMDAwKSI+DQogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTE2IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCwgMzYuMDAwMDAwKSI+DQogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDcyLjAwMDAwMCkiPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Im1hcmt1cC1kaXNwbGF5LW9uIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMjIiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iZ3VpZGUiIG9wYWNpdHk9IjAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4LjAwMDAwMCwgMTguMDAwMDAwKSBzY2FsZSgxLCAtMSkgdHJhbnNsYXRlKC0xOC4wMDAwMDAsIC0xOC4wMDAwMDApICIgZmlsbD0iI0ZGOTg5OCI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTQiIHg9IjAiIHk9IjAiIHdpZHRoPSIzNiIgaGVpZ2h0PSIzNiI+PC9yZWN0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJzaG93LW1hcmtlcnMtaWNvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAuMDAwMDAwLCAxMy4wMDAwMDApIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGZpbGw9IiNGRkZGRkYiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9IkxheWVyXzEiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi40NzQsMC44MjM0NjMwNTcgQzEzLjQwOTk4ODMsMS4yMTU3ODg4NiAxNC4yODMzMDE4LDEuNzQzNDE1NzQgMTUuMDY2LDIuMzg5NDYzMDYgQzE1Ljc3NjcxMTYsMy4wMjUzOTQ1MSAxNi4zNzg2NTM3LDMuNzczMjYxOTMgMTYuODQ4LDQuNjAzNDYzMDYgQzE2LjQ5NzQ1OTEsNS41MTE5MjQ3NyAxNS45NjQ0OTk5LDYuMzM4OTMwNDMgMTUuMjgyLDcuMDMzNDYzMDYgQzE0LjUzNjE5MjEsNy43MzAyNjE3MSAxMy42NzgxNDUsOC4yOTYyMDc2OSAxMi43NDQsOC43MDc0NjMwNiBDMTEuMzYxMDM2NSw5LjI5MzUzOTU4IDkuODcxOTM1NjEsOS41ODc2ODI5NyA4LjM3LDkuNTcxNDYzMDYgQzYuODk2MjcwMjEsOS42NTA4OTU4OCA1LjQyMjc0OTI5LDkuNDExNDQ4NzMgNC4wNSw4Ljg2OTQ2MzA2IEMzLjExMzAyOTI4LDguNDg3MzIwMTcgMi4yNTMxMTg1Niw3LjkzODQ0MDk5IDEuNTEyLDcuMjQ5NDYzMDYgQzAuODQyNjYxOTQ4LDYuNTM0MTYwMTUgMC4zMjc5NTI0MTksNS42ODg1NjU5MiAwLDQuNzY1NDYzMDYgQzAuNDU1MjQyNjA0LDMuODYyMzEzMjkgMS4wNTc0NTAzMSwzLjA0MTEyMDk2IDEuNzgyLDIuMzM1NDYzMDYgQzIuNTUyMzY1MDQsMS42NTgzODQzOSAzLjQyNzgxNDI3LDEuMTExMjI4NjIgNC4zNzQsMC43MTU0NjMwNTcgQzUuNjUzNTg1NzEsMC4xNzgzNTEzOTYgNy4wMzgyOTI4MywtMC4wNjE2NjQ1MDQ1IDguNDI0LDAuMDEzNDYzMDU3MyBDOS44MTM2NzUzNCwwLjAxOTA0NzQ5MjggMTEuMTg5MDc0OSwwLjI5NDEyNzQwNiAxMi40NzQsMC44MjM0NjMwNTcgWiBNOC41MzIsOC4wNTk0NjMwNiBDOC45NjAxMDIyOSw4LjA1NTI5NTM2IDkuMzgyODA0ODMsNy45NjM0MDM1IDkuNzc0LDcuNzg5NDYzMDYgQzEwLjE1NjgyNjIsNy42MjE1NjcyNCAxMC41MDQ4MjQyLDcuMzgzNDYzMyAxMC44LDcuMDg3NDYzMDYgQzExLjQwOTE4MDYsNi40NzA2MDIwNyAxMS43NDA2NzExLDUuNjMyMTI1ODggMTEuNzE4LDQuNzY1NDYzMDYgQzExLjcyNjA1ODMsMy45MTc0MTMzNSAxMS4zOTU2NjU0LDMuMTAxMTQ4NDMgMTAuOCwyLjQ5NzQ2MzA2IEMxMC41MDQ4MjQyLDIuMjAxNDYyODIgMTAuMTU2ODI2MiwxLjk2MzM1ODg3IDkuNzc0LDEuNzk1NDYzMDYgQzguOTYzMjAwODEsMS40NTAzMjYwNyA4LjA0Njc5OTE5LDEuNDUwMzI2MDcgNy4yMzYsMS43OTU0NjMwNiBDNi44NTMxNzM4NCwxLjk2MzM1ODg3IDYuNTA1MTc1NzYsMi4yMDE0NjI4MiA2LjIxLDIuNDk3NDYzMDYgQzUuNjAwODE5NDUsMy4xMTQzMjQwNSA1LjI2OTMyODg2LDMuOTUyODAwMjQgNS4yOTIsNC44MTk0NjMwNiBDNS4yOTc2Njg2Nyw1LjI0NzM5NTM2IDUuMzg5NDk1NjMsNS42Njk3OTkzOSA1LjU2Miw2LjA2MTQ2MzA2IEM1LjcyNzU3OTMsNi40NDU1NzAxMyA1Ljk2NTk2NjY2LDYuNzkzOTgyNDQgNi4yNjQsNy4wODc0NjMwNiBDNi41NTgzNDMzMyw3LjM4NDQ2MzMxIDYuOTA2NTQzMzEsNy42MjI3MDU0IDcuMjksNy43ODk0NjMwNiBDNy42ODExOTUxNyw3Ljk2MzQwMzUgOC4xMDM4OTc3MSw4LjA1NTI5NTM2IDguNTMyLDguMDU5NDYzMDYgTDguNTMyLDguMDU5NDYzMDYgWiBNMTAuNDIyLDQuNzY1NDYzMDYgQzEwLjQxNjM1ODgsNC41MjI4NzM5MiAxMC4zNjEyMzI0LDQuMjgzOTkyNjggMTAuMjYsNC4wNjM0NjMwNiBDMTAuMTcyMzE3OCwzLjg0MzUzNDU2IDEwLjA0NDA5MzQsMy42NDIwMzg5NiA5Ljg4MiwzLjQ2OTQ2MzA2IEM5LjcxMTEwOTY4LDMuMzA1MjEyNSA5LjUwOTE2ODc2LDMuMTc2NzA0NjUgOS4yODgsMy4wOTE0NjMwNiBMOC41ODYsMi45Mjk0NjMwNiBMNy44ODQsMy4wOTE0NjMwNiBDNy40NDYzNTgyNiwzLjI3NzM3MzU0IDcuMDk3OTEwNDgsMy42MjU4MjEzMSA2LjkxMiw0LjA2MzQ2MzA2IEM2LjcxMDc1NzY2LDQuNTI4NjMwNTEgNi43MTA3NTc2Niw1LjA1NjI5NTYxIDYuOTEyLDUuNTIxNDYzMDYgQzcuMDg0OTYzNjIsNS45NDkzMjI1NiA3LjQxMjcxNDA0LDYuMjk2MzUyNDMgNy44Myw2LjQ5MzQ2MzA2IEw4LjUzMiw2LjY1NTQ2MzA2IEw5LjIzNCw2LjQ5MzQ2MzA2IEM5LjQ1NDUzMTUzLDYuNDA2OTYzMjEgOS42NTYyMzk3Miw2LjI3ODYwMzQ1IDkuODI4LDYuMTE1NDYzMDYgQzkuOTg5MTA0MjEsNS45NDIxMjA5IDEwLjExNzIwNDgsNS43NDA4MjAwMiAxMC4yMDYsNS41MjE0NjMwNiBDMTAuMzE0Njc2MSw1LjI4NDM1NTU3IDEwLjM2OTk3NzYsNS4wMjYyODIwNCAxMC4zNjgsNC43NjU0NjMwNiBMMTAuNDIyLDQuNzY1NDYzMDYgWiIgaWQ9IlNoYXBlIj48L3BhdGg+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICAgICAgICAgIDwvZz4NCiAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICA8L2c+DQogICAgICAgIDwvZz4NCiAgICA8L2c+DQo8L3N2Zz4=\\\");\\n  background-repeat: no-repeat;\\n  opacity: 0.7;\\n  position: relative; }\\n\\n/* symbol for \\\"visibility toggled off\\\": eye with strike-through. */\\n.list-panel .dim div.visibility {\\n  background-position: 6px 9px;\\n  background-image: url(\\\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+DQo8c3ZnIHdpZHRoPSIxNnB4IiBoZWlnaHQ9IjE1cHgiIHZpZXdCb3g9IjAgMCAxNiAxNSIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4NCiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQ2ICg0NDQyMykgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+DQogICAgPHRpdGxlPm1hcmt1cF9kaXNwbGF5X3R1cm5fb2ZmPC90aXRsZT4NCiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4NCiAgICA8ZGVmcz48L2RlZnM+DQogICAgPGcgaWQ9IlBhZ2UtNiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+DQogICAgICAgIDxnIGlkPSJDYW1lcmEtSW50ZXJhY3Rpb25zLS0tSG92ZXItQ29weSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwNTcuMDAwMDAwLCAtMTIzLjAwMDAwMCkiIGZpbGw9IiNGNEY0RjQiPg0KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTE5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MTAuMDAwMDAwLCAxMTIuMDAwMDAwKSI+DQogICAgICAgICAgICAgICAgPGcgaWQ9Im1hcmt1cC1kaXNwbGF5LW9mZiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjM5LjAwMDAwMCwgMy4wMDAwMDApIj4NCiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Im1hcmt1cF9kaXNwbGF5X3R1cm5fb2ZmIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4LjAwMDAwMCwgOC4wMDAwMDApIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC4zMjIsMC41OTQgQzE0LjA1OCwwLjMzIDEzLjY2MiwwLjMzIDEzLjM5OCwwLjU5NCBMMTAuMzYyLDMuNjMgQzkuNTcsMy40MzIgOC43NzgsMy4yMzQgNy45MiwzLjIzNCBDNC4zNTYsMy4yMzQgMS4zMiw1LjQxMiAwLDguMDUyIEwwLDguMDUyIEMwLjU5NCw5LjI0IDEuNTg0LDEwLjM2MiAyLjc3MiwxMS4yMiBMMC40NjIsMTMuNTMgQzAuMTk4LDEzLjc5NCAwLjE5OCwxNC4xOSAwLjQ2MiwxNC40NTQgQzAuNzI2LDE0LjcxOCAxLjEyMiwxNC43MTggMS4zODYsMTQuNDU0IEwxNC4zMjIsMS41MTggQzE0LjU4NiwxLjI1NCAxNC41ODYsMC44NTggMTQuMzIyLDAuNTk0IEwxNC4zMjIsMC41OTQgWiBNNC43NTIsOC4wNTIgQzQuNzUyLDYuMjcgNi4yMDQsNC44ODQgNy45Miw0Ljg4NCBDOC4yNSw0Ljg4NCA4LjY0Niw0Ljk1IDguOTEsNS4wODIgTDguMDUyLDUuOTQgTDcuODU0LDUuOTQgQzYuNjY2LDUuOTQgNS42NzYsNi45MyA1LjY3Niw4LjExOCBMNS42NzYsOC4zMTYgTDQuODE4LDkuMTc0IEM0LjgxOCw4Ljc3OCA0Ljc1Miw4LjM4MiA0Ljc1Miw4LjA1MiBMNC43NTIsOC4wNTIgWiBNNy45MiwxMC4yMyBDOS4xMDgsMTAuMjMgMTAuMDk4LDkuMjQgMTAuMDk4LDguMDUyIEMxMC4wOTgsNy44NTQgMTAuMDMyLDcuNjU2IDkuOTY2LDcuMzkyIEw3LjI2LDEwLjA5OCBDNy41MjQsMTAuMTY0IDcuNzIyLDEwLjIzIDcuOTIsMTAuMjMgTDcuOTIsMTAuMjMgWiBNMTUuODQsOC4wNTIgQzE1LjE4LDYuNzMyIDE0LjA1OCw1LjU0NCAxMi43MzgsNC42ODYgTDEwLjc1OCw2LjY2NiBDMTAuOTU2LDcuMDYyIDExLjA4OCw3LjU5IDExLjA4OCw4LjA1MiBDMTEuMDg4LDkuODM0IDkuNjM2LDExLjIyIDcuOTIsMTEuMjIgQzcuMzkyLDExLjIyIDYuOTMsMTEuMDg4IDYuNTM0LDEwLjg5IEw1LjA4MiwxMi4zNDIgQzUuOTQsMTIuNjcyIDYuOTMsMTIuODcgNy45MiwxMi44NyBDMTEuNDg0LDEyLjg3IDE0LjUyLDEwLjY5MiAxNS44NCw4LjA1MiBMMTUuODQsOC4wNTIgWiIgaWQ9IlNoYXBlIj48L3BhdGg+DQogICAgICAgICAgICAgICAgICAgIDwvZz4NCiAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICA8L2c+DQogICAgICAgIDwvZz4NCiAgICA8L2c+DQo8L3N2Zz4=\\\");\\n  opacity: 0.3; }\\n\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","try {\n  new window.MouseEvent('test');\n} catch (e) {\n  // Polyfills DOM4 MouseEvent\n  var MouseEvent = function MouseEvent(eventType, params) {\n    params = params || { bubbles: false, cancelable: false };\n    var mouseEvent = document.createEvent(\"MouseEvent\");\n    mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, params.screenX || 0, params.screenY || 0, params.clientX || 0, params.clientY || 0, false, false, false, false, 0, null);\n    return mouseEvent;\n  };\n\n  MouseEvent.prototype = Event.prototype;\n\n  window.MouseEvent = MouseEvent;\n}","!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):t.ResizeObserver=e()}(this,function(){\"use strict\";var t=function(){if(\"undefined\"!=typeof Map)return Map;function t(t,e){var n=-1;return t.some(function(t,i){return t[0]===e&&(n=i,!0)}),n}return function(){function e(){this.__entries__=[]}var n={size:{configurable:!0}};return n.size.get=function(){return this.__entries__.length},e.prototype.get=function(e){var n=t(this.__entries__,e),i=this.__entries__[n];return i&&i[1]},e.prototype.set=function(e,n){var i=t(this.__entries__,e);~i?this.__entries__[i][1]=n:this.__entries__.push([e,n])},e.prototype.delete=function(e){var n=this.__entries__,i=t(n,e);~i&&n.splice(i,1)},e.prototype.has=function(e){return!!~t(this.__entries__,e)},e.prototype.clear=function(){this.__entries__.splice(0)},e.prototype.forEach=function(t,e){void 0===e&&(e=null);for(var n=0,i=this.__entries__;n<i.length;n+=1){var r=i[n];t.call(e,r[1],r[0])}},Object.defineProperties(e.prototype,n),e}()}(),e=\"undefined\"!=typeof window&&\"undefined\"!=typeof document&&window.document===document,n=\"undefined\"!=typeof global&&global.Math===Math?global:\"undefined\"!=typeof self&&self.Math===Math?self:\"undefined\"!=typeof window&&window.Math===Math?window:Function(\"return this\")(),i=\"function\"==typeof requestAnimationFrame?requestAnimationFrame.bind(n):function(t){return setTimeout(function(){return t(Date.now())},1e3/60)},r=2,o=[\"top\",\"right\",\"bottom\",\"left\",\"width\",\"height\",\"size\",\"weight\"],s=\"undefined\"!=typeof MutationObserver,a=function(){this.connected_=!1,this.mutationEventsAdded_=!1,this.mutationsObserver_=null,this.observers_=[],this.onTransitionEnd_=this.onTransitionEnd_.bind(this),this.refresh=function(t,e){var n=!1,o=!1,s=0;function a(){n&&(n=!1,t()),o&&h()}function c(){i(a)}function h(){var t=Date.now();if(n){if(t-s<r)return;o=!0}else n=!0,o=!1,setTimeout(c,e);s=t}return h}(this.refresh.bind(this),20)};a.prototype.addObserver=function(t){~this.observers_.indexOf(t)||this.observers_.push(t),this.connected_||this.connect_()},a.prototype.removeObserver=function(t){var e=this.observers_,n=e.indexOf(t);~n&&e.splice(n,1),!e.length&&this.connected_&&this.disconnect_()},a.prototype.refresh=function(){this.updateObservers_()&&this.refresh()},a.prototype.updateObservers_=function(){var t=this.observers_.filter(function(t){return t.gatherActive(),t.hasActive()});return t.forEach(function(t){return t.broadcastActive()}),t.length>0},a.prototype.connect_=function(){e&&!this.connected_&&(document.addEventListener(\"transitionend\",this.onTransitionEnd_),window.addEventListener(\"resize\",this.refresh),s?(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(document.addEventListener(\"DOMSubtreeModified\",this.refresh),this.mutationEventsAdded_=!0),this.connected_=!0)},a.prototype.disconnect_=function(){e&&this.connected_&&(document.removeEventListener(\"transitionend\",this.onTransitionEnd_),window.removeEventListener(\"resize\",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationEventsAdded_&&document.removeEventListener(\"DOMSubtreeModified\",this.refresh),this.mutationsObserver_=null,this.mutationEventsAdded_=!1,this.connected_=!1)},a.prototype.onTransitionEnd_=function(t){var e=t.propertyName;void 0===e&&(e=\"\"),o.some(function(t){return!!~e.indexOf(t)})&&this.refresh()},a.getInstance=function(){return this.instance_||(this.instance_=new a),this.instance_},a.instance_=null;var c=function(t,e){for(var n=0,i=Object.keys(e);n<i.length;n+=1){var r=i[n];Object.defineProperty(t,r,{value:e[r],enumerable:!1,writable:!1,configurable:!0})}return t},h=function(t){return t&&t.ownerDocument&&t.ownerDocument.defaultView||n},u=_(0,0,0,0);function f(t){return parseFloat(t)||0}function d(t){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];return e.reduce(function(e,n){return e+f(t[\"border-\"+n+\"-width\"])},0)}function p(t){var e=t.clientWidth,n=t.clientHeight;if(!e&&!n)return u;var i,r=h(t).getComputedStyle(t),o=function(t){for(var e={},n=0,i=[\"top\",\"right\",\"bottom\",\"left\"];n<i.length;n+=1){var r=i[n],o=t[\"padding-\"+r];e[r]=f(o)}return e}(r),s=o.left+o.right,a=o.top+o.bottom,c=f(r.width),p=f(r.height);if(\"border-box\"===r.boxSizing&&(Math.round(c+s)!==e&&(c-=d(r,\"left\",\"right\")+s),Math.round(p+a)!==n&&(p-=d(r,\"top\",\"bottom\")+a)),(i=t)!==h(i).document.documentElement){var v=Math.round(c+s)-e,l=Math.round(p+a)-n;1!==Math.abs(v)&&(c-=v),1!==Math.abs(l)&&(p-=l)}return _(o.left,o.top,c,p)}var v=\"undefined\"!=typeof SVGGraphicsElement?function(t){return t instanceof h(t).SVGGraphicsElement}:function(t){return t instanceof h(t).SVGElement&&\"function\"==typeof t.getBBox};function l(t){return e?v(t)?_(0,0,(n=t.getBBox()).width,n.height):p(t):u;var n}function _(t,e,n,i){return{x:t,y:e,width:n,height:i}}var b=function(t){this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=_(0,0,0,0),this.target=t};b.prototype.isActive=function(){var t=l(this.target);return this.contentRect_=t,t.width!==this.broadcastWidth||t.height!==this.broadcastHeight},b.prototype.broadcastRect=function(){var t=this.contentRect_;return this.broadcastWidth=t.width,this.broadcastHeight=t.height,t};var m=function(t,e){var n,i,r,o,s,a,h,u=(i=(n=e).x,r=n.y,o=n.width,s=n.height,a=\"undefined\"!=typeof DOMRectReadOnly?DOMRectReadOnly:Object,h=Object.create(a.prototype),c(h,{x:i,y:r,width:o,height:s,top:r,right:i+o,bottom:s+r,left:i}),h);c(this,{target:t,contentRect:u})},y=function(e,n,i){if(this.activeObservations_=[],this.observations_=new t,\"function\"!=typeof e)throw new TypeError(\"The callback provided as parameter 1 is not a function.\");this.callback_=e,this.controller_=n,this.callbackCtx_=i};y.prototype.observe=function(t){if(!arguments.length)throw new TypeError(\"1 argument required, but only 0 present.\");if(\"undefined\"!=typeof Element&&Element instanceof Object){if(!(t instanceof h(t).Element))throw new TypeError('parameter 1 is not of type \"Element\".');var e=this.observations_;e.has(t)||(e.set(t,new b(t)),this.controller_.addObserver(this),this.controller_.refresh())}},y.prototype.unobserve=function(t){if(!arguments.length)throw new TypeError(\"1 argument required, but only 0 present.\");if(\"undefined\"!=typeof Element&&Element instanceof Object){if(!(t instanceof h(t).Element))throw new TypeError('parameter 1 is not of type \"Element\".');var e=this.observations_;e.has(t)&&(e.delete(t),e.size||this.controller_.removeObserver(this))}},y.prototype.disconnect=function(){this.clearActive(),this.observations_.clear(),this.controller_.removeObserver(this)},y.prototype.gatherActive=function(){var t=this;this.clearActive(),this.observations_.forEach(function(e){e.isActive()&&t.activeObservations_.push(e)})},y.prototype.broadcastActive=function(){if(this.hasActive()){var t=this.callbackCtx_,e=this.activeObservations_.map(function(t){return new m(t.target,t.broadcastRect())});this.callback_.call(t,e,t),this.clearActive()}},y.prototype.clearActive=function(){this.activeObservations_.splice(0)},y.prototype.hasActive=function(){return this.activeObservations_.length>0};var g=\"undefined\"!=typeof WeakMap?new WeakMap:new t,w=function(t){if(!(this instanceof w))throw new TypeError(\"Cannot call a class as a function.\");if(!arguments.length)throw new TypeError(\"1 argument required, but only 0 present.\");var e=a.getInstance(),n=new y(t,e,this);g.set(this,n)};return[\"observe\",\"unobserve\",\"disconnect\"].forEach(function(t){w.prototype[t]=function(){return(e=g.get(this))[t].apply(e,arguments);var e}}),void 0!==n.ResizeObserver?n.ResizeObserver:w});"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvZA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACp9BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjJA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvOA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnfA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3tBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/nBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrKA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5MA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/GA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzMA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7NA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACngBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpLA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5FA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACznBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9SA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACp0BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnNA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACn2DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7OA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpRA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;;;;A","sourceRoot":""}