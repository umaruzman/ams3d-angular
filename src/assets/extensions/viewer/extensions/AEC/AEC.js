/*!
 * LMV v7.42.0
 * 
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.AEC =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/AEC/LibraryExports.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/AEC/Avatar/Avatar.scss":
/*!*******************************************!*\
  !*** ./extensions/AEC/Avatar/Avatar.scss ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./Avatar.scss */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Avatar/Avatar.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/Avatar/AvatarEvents.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/Avatar/AvatarEvents.js ***!
  \***********************************************/
/*! exports provided: AvatarEvents */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AvatarEvents", function() { return AvatarEvents; });
var AvatarEvents = {
  DRAG_START_EVENT: 'dragStart',
  DRAG_MOVE_EVENT: 'dragMove',
  DRAG_END_EVENT: 'dragEnd',
  ROTATE_START_EVENT: 'rotateStart',
  ROTATE_MOVE_EVENT: 'rotateMove',
  ROTATE_END_EVENT: 'rotateEnd' };

/***/ }),

/***/ "./extensions/AEC/Avatar/AvatarExtension.js":
/*!**************************************************!*\
  !*** ./extensions/AEC/Avatar/AvatarExtension.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AvatarExtension; });
/* harmony import */ var _AvatarWidget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AvatarWidget */ "./extensions/AEC/Avatar/AvatarWidget.js");
/* harmony import */ var _SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../SheetSync/SheetTransforms */ "./extensions/AEC/SheetSync/SheetTransforms.js");
/* harmony import */ var _SheetSync_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../SheetSync/SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}



var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.AvatarExtension';

var FOCUS_DURATION = 2.0;

/**
                          // AvatarExtension - A viewer extension that displays an avatar on a 2D sheet, based on a targetViewer's 3D camera.
                          // @param {Viewer3D} [viewer]                            - viewer instance
                          // @param {Object} [options]                             - Configuration options for AvatarExtension
                          */var
AvatarExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(AvatarExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(AvatarExtension);
  function AvatarExtension(viewer, options) {var _this;_classCallCheck(this, AvatarExtension);
    _this = _super.call(this, viewer, options);

    _this.options = _this.options.avatarOptions || _this.options;

    // Auto focus camera on avatar.
    _this.autoFocus = _this.options.autoFocus === undefined ? true : _this.options.autoFocus;

    // Indicates if the avatar is currently out of focus.
    _this.outOfFocus = true;

    // Time to focus the camera on avatar.
    _this.focusDuration = FOCUS_DURATION;

    // Last 3D camera position.
    _this.last3dCameraPos = new THREE.Vector3();

    _this.update = _this.update.bind(_assertThisInitialized(_this));
    _this.onMainMapChanged = _this.onMainMapChanged.bind(_assertThisInitialized(_this));
    _this.on3dCameraChanged = _this.on3dCameraChanged.bind(_assertThisInitialized(_this));
    _this.onSheetCameraChanged = _this.onSheetCameraChanged.bind(_assertThisInitialized(_this));
    _this.onDragStart = _this.onDragStart.bind(_assertThisInitialized(_this));
    _this.onDragEnd = _this.onDragEnd.bind(_assertThisInitialized(_this));return _this;
  }_createClass(AvatarExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this2 = this;var transforms, targetPos;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                  this.viewer.loadExtension('Autodesk.AEC.SheetSyncExtension', this.viewer.config));case 2:this.sheetSyncExt = _context.sent;

                this.targetViewer = this.sheetSyncExt.targetViewer;

                transforms = {
                  mapPixelsToWorld: this.mapPixelsToWorld.bind(this),
                  worldToMapPixels: this.worldToMapPixels.bind(this),
                  mapPixelsToWidget: this.mapPixelsToWidget.bind(this),
                  widgetToMapPixels: this.widgetToMapPixels.bind(this),
                  getMapRotationAngle: this.getCameraRotationAngle.bind(this) };


                this.avatarWidget = new _AvatarWidget__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer.container, this.targetViewer, this.globalManager, transforms, this.options.trackUsage, this.viewer.canvasWrap);

                this.visible = true;

                if (this.autoFocus) {
                  // Set initial center & zoom level according to model bounds.
                  targetPos = this.getFuzzyBoundsCenter();

                  // If fuzzyBounds not ready yet - it means that there are no models ready yet in the target viewer.
                  // in that case, wait for the first loaded model, and them set the initial zoom.
                  if (targetPos) {
                    this.setCameraPosition(targetPos, true);
                  } else {
                    this.targetViewer.addEventListener(av.GEOMETRY_LOADED_EVENT, function () {
                      _this2.focusOnModel();
                    }, { once: true });
                  }
                }

                this.addListeners();
                this.activateTool();case 10:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      this.sheetSyncExt = null;

      this.removeListeners();
      this.deactivateTool();

      this.avatarWidget.destroy();
      this.avatarWidget = null;

      if (this.focusAnim) {
        this.focusAnim.stop();
        this.focusAnim = null;
      }

      return true;
    } }, { key: "activateTool", value: function activateTool()

    {
      if (this.toolActive) {
        return;
      }

      this.toolActive = true;

      this.viewer.toolController.registerTool(this.avatarWidget.tool);
      this.viewer.toolController.activateTool(this.avatarWidget.tool.getName());

      this.avatarWidget.addEventListener(Autodesk.AEC.AvatarEvents.DRAG_START_EVENT, this.onDragStart);
      this.avatarWidget.addEventListener(Autodesk.AEC.AvatarEvents.DRAG_END_EVENT, this.onDragEnd);

      this.updateFocus();
    } }, { key: "deactivateTool", value: function deactivateTool()

    {
      if (!this.toolActive) {
        return;
      }

      this.toolActive = false;

      this.viewer.toolController.deactivateTool(this.avatarWidget.tool.getName());
      this.viewer.toolController.deregisterTool(this.avatarWidget.tool);

      this.avatarWidget.removeEventListener(Autodesk.AEC.AvatarEvents.DRAG_START_EVENT, this.onDragStart);
      this.avatarWidget.removeEventListener(Autodesk.AEC.AvatarEvents.DRAG_END_EVENT, this.onDragEnd);
    } }, { key: "addListeners", value: function addListeners()

    {
      this.targetViewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);
      this.targetViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update); // Whenever a model has changed in this 3D viewer, update the widget accordingly.
      this.targetViewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update); // Whenever a model has changed in this 3D viewer, update the widget accordingly.
      this.targetViewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.on3dCameraChanged); // Whenever the 3D camera moved, update the widget accordingly.
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.update); // Whenever a model has changed in this 2D viewer, update the widget accordingly.
      this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update); // Whenever a model has changed in this 2D viewer, update the widget accordingly.
      this.viewer.addEventListener(av.RENDER_PRESENTED_EVENT, this.update); //  Whenever the 2D camera moved, update the widget accordingly (no viewport change).
      this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this.update); //  Whenever the screen size has been changed.
      this.viewer.addEventListener(_SheetSync_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);
      this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.onSheetCameraChanged); // Whenever the 2d camera moved.
    } }, { key: "removeListeners", value: function removeListeners()

    {
      this.targetViewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.on3dCameraChanged);
      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.viewer.removeEventListener(av.RENDER_PRESENTED_EVENT, this.update);
      this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.update);
      this.viewer.removeEventListener(_SheetSync_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);
      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.onSheetCameraChanged); // Whenever the 2d camera moved.
    } }, { key: "onDragStart", value: function onDragStart()

    {
      if (this.focusAnim) {
        this.focusAnim.stop();
        this.focusAnim = null;
      }
    } }, { key: "onDragEnd", value: function onDragEnd()

    {
      this.outOfFocus = true;
      this.updateFocus();
    } }, { key: "isEnabled", value: function isEnabled()

    {
      return this.sheetSyncExt.isEnabled();
    } }, { key: "onMainMapChanged", value: function onMainMapChanged(_ref)

    {var sheetMap = _ref.sheetMap;
      if (sheetMap) {
        this.update();
      }
    } }, { key: "update", value: function update()

    {
      if (!this.viewer.impl || !this.viewer.model || !this.avatarWidget || !this.sheetSyncExt) {
        return;
      }

      var promise;

      if (this.sheetSyncExt.sheetMap && this.isEnabled() && this.visible) {
        promise = this.avatarWidget.show();
        this.activateTool();
      } else {
        promise = this.avatarWidget.hide();
        this.deactivateTool();
      }

      // Update only if a sheetMap is loaded, otherwise, there won't be any transforms available.
      if (this.sheetSyncExt.sheetMap) {
        this.avatarWidget.update();
      }

      return promise;
    } }, { key: "show", value: function show()

    {
      if (this.visible) {
        return;
      }

      this.visible = true;

      // Returns a promise that should be resolved after the fading animation is over.
      return this.update();
    } }, { key: "hide", value: function hide()

    {
      if (!this.visible) {
        return;
      }

      this.visible = false;

      // Returns a promise that should be resolved after the fading animation is over.
      return this.update();
    } }, { key: "setCameraPosition", value: function setCameraPosition(

    pos, changeZoom) {
      var camera = this.viewer.getCamera();

      // Change x & y values, but keep the same camera distance if changeZoom is off.
      camera.position.set(pos.x, pos.y, changeZoom ? pos.z : camera.position.z);
      camera.target.set(pos.x, pos.y, camera.target.z);

      camera.dirty = true;
    }

    // Map angle is determined according to the viewer's camera rotation.
  }, { key: "getCameraRotationAngle", value: function getCameraRotationAngle() {
      return Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["getCameraRotationAngle"])(this.viewer);
    }

    // Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.
  }, { key: "worldToMapPixels", value: function worldToMapPixels(pos3D) {
      return Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["worldToMapPixels"])(this.sheetSyncExt.sheetMap, pos3D);
    }

    // Convert minimap pixel coords (+ world-z) to 3D world position. Minimap pixels are absolute, i.e. not affected by scrolling.
  }, { key: "mapPixelsToWorld", value: function mapPixelsToWorld(posX, posY, zWorld) {
      return Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(this.sheetSyncExt.sheetMap, posX, posY, zWorld);
    } }, { key: "mapPixelsToWidget", value: function mapPixelsToWidget(

    p) {
      return Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWidget"])(this.sheetSyncExt.sheetMap, this.viewer, p);
    }

    // @param {Vector2} p - transformed in-place from widget pixels to map image pixels
    //                      widget pixel origin is at top-left, i.e., y-axis points down (compatible to mouse events)
    // @param {boolean} clamp - In case the resulting position is outside of the map, clamp the value to fit the maps' border.
  }, { key: "widgetToMapPixels", value: function widgetToMapPixels(p, clamp) {
      clamp = clamp && !this.sheetSyncExt.options.cropToViewport;
      return Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["widgetToMapPixels"])(this.sheetSyncExt.sheetMap, this.viewer, p, clamp);
    } }, { key: "world3DtoWorld2D", value: function world3DtoWorld2D(

    point) {
      var pos = this.worldToMapPixels(point);
      this.mapPixelsToWidget(pos);
      var worldPos = this.viewer.clientToWorld(pos.x, pos.y, undefined, true).point;

      return worldPos;
    }

    // Find avatar position according to current 3D camera location.
  }, { key: "getAvatarPositionOn2DSheet", value: function getAvatarPositionOn2DSheet() {
      return this.world3DtoWorld2D(this.targetViewer.getCamera().position);
    } }, { key: "on3dCameraChanged", value: function on3dCameraChanged()

    {
      this.updateFocus();
      this.update();
    } }, { key: "onSheetCameraChanged", value: function onSheetCameraChanged()

    {
      var navTool = this.viewer.toolController.getTool('pan');
      var isPanning = navTool.isInteractionActive();

      if (isPanning) {
        this.outOfFocus = true;

        // If panning has been made during animation - cancel the animation.
        if (this.focusAnim) {
          this.focusAnim.stop();
          this.focusAnim = null;
        }
      }
    }

    // Zoom 2D camera to avatar position.
  }, { key: "focusOnAvatar", value: function focusOnAvatar() {var _this3 = this;
      this.animateFocus(false, function () {
        _this3.outOfFocus = false;
      });
    }

    // Zoom 2D camera to model bounds.
  }, { key: "focusOnModel", value: function focusOnModel() {var _this4 = this;
      this.animateFocus(true, function () {
        _this4.outOfFocus = true;
      });
    } }, { key: "updateFocus", value: function updateFocus()

    {
      if (!this.sheetSyncExt || !this.sheetSyncExt.sheetMap || !this.autoFocus || this.avatarWidget.tool.isDragging) {
        this.outOfFocus = true;
        return;
      }

      var camera3d = this.targetViewer.getCamera();

      // Focus the 2D camera only if the 3D camera really moved.
      // Really moved <==> changed x or y position (We ignore z by purpose).
      if (this.last3dCameraPos.x === camera3d.position.x && this.last3dCameraPos.y === camera3d.position.y) {
        return;
      }

      if (!this.isAvatarInsideBounds()) {
        this.focusOnModel();
      } else if (this.outOfFocus) {
        // Animate the transition if we are after:
        // - Panning
        // - Manually dragging the avatar
        // - Double clicked to fly to location
        // - Was outside of the model's visible bounds and now got back in
        this.focusOnAvatar();
      } else {
        // Otherwise, the avatar is already focused, and just need to be updated to the last camera movement.
        var pos = this.getAvatarPositionOn2DSheet();
        this.setCameraPosition(pos);
      }

      this.last3dCameraPos = camera3d.position.clone();
    } }, { key: "getFuzzyBoundsCenter", value: function getFuzzyBoundsCenter()

    {
      var bounds3D = this.sheetSyncExt.getFuzzyBox();

      if (bounds3D.empty()) {
        return null;
      }

      var min = this.world3DtoWorld2D(bounds3D.min);
      var max = this.world3DtoWorld2D(bounds3D.max);
      var bounds2D = new THREE.Box3().setFromPoints([min, max]);

      var camera = this.viewer.getCamera();
      var fit = this.viewer.navigation.computeFit(camera.position, camera.target, camera.fov, bounds2D, camera.aspect);

      return fit.position;
    } }, { key: "isAvatarInsideBounds", value: function isAvatarInsideBounds()

    {
      var bounds = this.sheetSyncExt.getFuzzyBox();

      if (bounds.empty()) {
        return false;
      }

      // Ignore height when checking these bounds. We care only about x & y here.
      bounds.min.z = -Infinity;
      bounds.max.z = Infinity;

      var pos = this.targetViewer.getCamera().position;
      return bounds.containsPoint(pos);
    } }, { key: "animateFocus", value: function animateFocus(

    isOutside, onDone) {var _this5 = this;
      if (this.focusAnim) {
        return;
      }

      var camera = this.viewer.getCamera();

      var startPos = camera.position;

      var onTimer = function onTimer(t) {
        if (!_this5.toolActive) {
          return;
        }

        var targetPos = isOutside ? _this5.getFuzzyBoundsCenter() : _this5.getAvatarPositionOn2DSheet();

        if (targetPos) {
          t = Autodesk.Viewing.Private.smootherStep(t);
          var pos = startPos.clone().lerp(targetPos, t);
          _this5.setCameraPosition(pos, isOutside);
        }
      };

      var onFadeEnd = function onFadeEnd() {
        _this5.focusAnim = null;
        onDone && onDone();
      };

      this.focusAnim = Autodesk.Viewing.Private.fadeValue(0, 1, this.focusDuration, onTimer, onFadeEnd);
    } }, { key: "getAutoFocus", value: function getAutoFocus()

    {
      return this.autoFocus;
    } }, { key: "setAutoFocus", value: function setAutoFocus(

    enable) {
      this.autoFocus = enable;
      this.updateFocus();
    } }]);return AvatarExtension;}(Autodesk.Viewing.Extension);


namespace.AvatarExtension = AvatarExtension;
av.theExtensionManager.registerExtension(myExtensionName, AvatarExtension);

/***/ }),

/***/ "./extensions/AEC/Avatar/AvatarTool.js":
/*!*********************************************!*\
  !*** ./extensions/AEC/Avatar/AvatarTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AvatarTool; });
/* harmony import */ var _thirdparty_mouse_event_polyfill_MouseEventPolyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../thirdparty/mouse-event-polyfill/MouseEventPolyfill */ "./thirdparty/mouse-event-polyfill/MouseEventPolyfill.js");
/* harmony import */ var _thirdparty_mouse_event_polyfill_MouseEventPolyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_thirdparty_mouse_event_polyfill_MouseEventPolyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Minimap3D/MinimapMath */ "./extensions/AEC/Minimap3D/MinimapMath.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var GlobalManagerMixin = Autodesk.Viewing.GlobalManagerMixin;
var zAxis = new THREE.Vector3(0, 0, 1);
var FLY_TO_TIME = 0.5; // same as teleportDuration in BimWalk
var
AvatarTool = /*#__PURE__*/function () {
  function AvatarTool(avatarWidget) {_classCallCheck(this, AvatarTool);
    this.avatarWidget = avatarWidget;
    this.targetViewer = avatarWidget.targetViewer;
    this.transforms = avatarWidget.transforms;

    this.setGlobalManager(avatarWidget.globalManager);

    this.dragDirectionStart = this.dragDirectionStart.bind(this);
    this.dragDirectionMove = this.dragDirectionMove.bind(this);
    this.dragDirectionEnd = this.dragDirectionEnd.bind(this);

    this.dragPositionStart = this.dragPositionStart.bind(this);
    this.dragPositionMove = this.dragPositionMove.bind(this);
    this.dragPositionEnd = this.dragPositionEnd.bind(this);

    this.onMouseWheel = this.onMouseWheel.bind(this);

    // when dragging view direction, we lastAngle stores the angle between +y and the line from playerPos to last mouse position.
    this.lastAngle = undefined;

    // Is avatar being dragged.
    this.isDragging = false;

    // Is avatar being rotated.
    this.isRotating = false;

    // Is tool active.
    this.active = false;

    // Tool name.
    this.names = ['avatar-tool'];
  }_createClass(AvatarTool, [{ key: "getNames", value: function getNames()

    {
      return this.names;
    } }, { key: "getName", value: function getName()

    {
      return this.names[0];
    } }, { key: "isActive", value: function isActive()

    {
      return this.active;
    } }, { key: "activate", value: function activate()

    {
      if (this.isActive()) {
        return;
      }

      this.active = true;

      this.avatarWidget.widgetUI.hitArea.addEventListener('mousedown', this.dragPositionStart);
      this.avatarWidget.widgetUI.hitArea.addEventListener('touchstart', this.dragPositionStart);
      this.avatarWidget.widgetUI.addEventListener('mousedown', this.dragDirectionStart);
      this.avatarWidget.widgetUI.addEventListener('touchstart', this.dragDirectionStart);

      if (this.avatarWidget.canvasWrap) {
        this.avatarWidget.widgetUI.hitArea.addEventListener('mousewheel', this.onMouseWheel);
        this.avatarWidget.widgetUI.hitArea.addEventListener('DOMMouseScroll', this.onMouseWheel); // Firefox
        this.avatarWidget.widgetUI.addEventListener('mousewheel', this.onMouseWheel);
        this.avatarWidget.widgetUI.addEventListener('DOMMouseScroll', this.onMouseWheel); // Firefox
      }
    } }, { key: "deactivate", value: function deactivate()

    {
      if (!this.isActive()) {
        return;
      }

      this.active = false;

      this.avatarWidget.widgetUI.hitArea.removeEventListener('mousedown', this.dragPositionStart);
      this.avatarWidget.widgetUI.hitArea.removeEventListener('touchstart', this.dragPositionStart);
      this.avatarWidget.widgetUI.removeEventListener('mousedown', this.dragDirectionStart);
      this.avatarWidget.widgetUI.removeEventListener('touchstart', this.dragDirectionStart);

      if (this.avatarWidget.canvasWrap) {
        this.avatarWidget.widgetUI.hitArea.removeEventListener('mousewheel', this.onMouseWheel);
        this.avatarWidget.widgetUI.hitArea.removeEventListener('DOMMouseScroll', this.onMouseWheel); // Firefox
        this.avatarWidget.widgetUI.removeEventListener('mousewheel', this.onMouseWheel);
        this.avatarWidget.widgetUI.removeEventListener('DOMMouseScroll', this.onMouseWheel); // Firefox
      }

      this.dragPositionEnd();
      this.dragDirectionEnd();
    } }, { key: "onMouseWheel", value: function onMouseWheel(

    e) {
      var newEvent = new MouseEvent(e.type, e);

      newEvent.wheelDelta = e.wheelDelta;
      newEvent.deltaY = e.deltaY;

      this.avatarWidget.canvasWrap.dispatchEvent(newEvent);

      if (newEvent.defaultPrevented) {
        e.preventDefault();
      }
    } }, { key: "screenToMap",

    // Convert event client coords to absolute (=zoom and scroll-independent) pixel-coords on the map.
    value: function screenToMap(e, clamp) {
      if (e.type.indexOf('touch') >= 0) {
        e.clientX = e.touches[0].pageX;
        e.clientY = e.touches[0].pageY;
      }

      // get minimap pixel coords
      var clientRect = this.avatarWidget.container.getBoundingClientRect();

      // get position within map widget
      var p = new THREE.Vector2(e.clientX - clientRect.left, e.clientY - clientRect.top);

      // transform point to mapImage pixels
      this.transforms.widgetToMapPixels(p, clamp);

      return p;
    } }, { key: "dragPositionStart", value: function dragPositionStart(

    e) {
      this.addWindowEventListener('mousemove', this.dragPositionMove);
      this.addWindowEventListener('mouseup', this.dragPositionEnd);
      this.addWindowEventListener('touchmove', this.dragPositionMove);
      this.addWindowEventListener('touchend', this.dragPositionEnd);

      e.stopPropagation();
      e.preventDefault();

      // Make sure that map doesn't scroll/follow while we are moving the avatar
      this.isDragging = true;
      this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.DRAG_START_EVENT });
    } }, { key: "dragPositionMove", value: function dragPositionMove(

    e) {
      // get minimap pixel coords. Clamp x/y to map extent => avoid dragging out of the map
      var _this$screenToMap = this.screenToMap(e, true),x = _this$screenToMap.x,y = _this$screenToMap.y;

      var camera = this.targetViewer.impl.camera;

      // keep z the same as before
      var zWorld = camera.position.z;

      // save current pos
      var oldPosition = camera.position.clone();

      var pos3D = this.transforms.mapPixelsToWorld(x, y, zWorld);

      // move camera to new 3D position
      camera.position.copy(pos3D);

      // apply delta to the target vector
      var delta = camera.position.clone().sub(oldPosition);

      camera.target.add(delta);
      camera.target.z = zWorld;

      this.targetViewer.impl.invalidate(true, true, true);
      this.targetViewer.dispatchEvent({ type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: camera });

      e.stopPropagation();

      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.DRAG_MOVE_EVENT, camera: camera });
    } }, { key: "dragPositionEnd", value: function dragPositionEnd(

    e) {
      this.removeWindowEventListener('mousemove', this.dragPositionMove);
      this.removeWindowEventListener('mouseup', this.dragPositionEnd);
      this.removeWindowEventListener('touchmove', this.dragPositionMove);
      this.removeWindowEventListener('touchend', this.dragPositionEnd);

      e && e.stopPropagation();

      this.isDragging = false;

      // TODO: use LMV generic analytics infrastructure instead.
      if (!this.avatarInteractionTracked) {
        this.avatarInteractionTracked = true;

        if (this.avatarWidget && this.avatarWidget.trackUsage) {
          this.avatarWidget.trackUsage({
            avatar_interaction_tracked: true });

        }
      }

      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.DRAG_END_EVENT });
    }

    // Get targetViewer's camera position on map coordinates.
  }, { key: "getCameraPositionOnMap", value: function getCameraPositionOnMap() {
      var pos3D = this.targetViewer.impl.camera.position;
      var p = this.transforms.worldToMapPixels(pos3D);
      return p;
    } }, { key: "dragDirectionStart", value: function dragDirectionStart(

    e) {
      // remember angle between north and (playerPos, mousePos) at dragStart
      var p1 = this.getCameraPositionOnMap();
      var p2 = this.screenToMap(e);
      this.lastAngle = Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_1__["computeAngle"])(p1, p2);

      this.addWindowEventListener('mousemove', this.dragDirectionMove);
      this.addWindowEventListener('mouseup', this.dragDirectionEnd);
      this.addWindowEventListener('touchmove', this.dragDirectionMove);
      this.addWindowEventListener('touchend', this.dragDirectionEnd);

      e.stopPropagation();
      e.preventDefault();

      this.isRotating = true;
      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.ROTATE_START_EVENT, angle: this.lastAngle });
    } }, { key: "dragDirectionMove", value: function dragDirectionMove(

    e) {
      // compute current angle
      var p1 = this.getCameraPositionOnMap();
      var p2 = this.screenToMap(e);
      var newAngle = Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_1__["computeAngle"])(p1, p2);
      var delta = this.lastAngle - newAngle;

      // apply delta to view direction
      var camera = this.targetViewer.impl.camera;
      var viewVec = camera.target.clone().sub(camera.position);
      viewVec.applyAxisAngle(zAxis, delta);
      viewVec.add(camera.position);
      camera.target.copy(viewVec);

      // Rotate up-vector as well.
      camera.up.applyAxisAngle(zAxis, delta);

      this.targetViewer.impl.syncCamera();
      this.targetViewer.dispatchEvent({ type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: camera });

      this.lastAngle = newAngle;

      e.stopPropagation();

      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.ROTATE_MOVE_EVENT, angle: this.lastAngle });
    } }, { key: "dragDirectionEnd", value: function dragDirectionEnd(

    e) {
      this.removeWindowEventListener('mousemove', this.dragDirectionMove);
      this.removeWindowEventListener('mouseup', this.dragDirectionEnd);
      this.removeWindowEventListener('touchmove', this.dragDirectionMove);
      this.removeWindowEventListener('touch', this.dragDirectionEnd);

      e && e.stopPropagation();

      this.isRotating = false;
      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.ROTATE_END_EVENT, angle: this.lastAngle });
    } }, { key: "convertEventHammerToMouse", value: function convertEventHammerToMouse(

    event) {
      if (event.pointers) {
        event.clientX = event.pointers[0].clientX;
        event.clientY = event.pointers[0].clientY;
      }
    } }, { key: "getCurrentLevel", value: function getCurrentLevel()

    {
      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      if (!levelExt) {
        return;
      }

      return levelExt.getCurrentLevel();
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    e) {var _this = this;
      this.convertEventHammerToMouse(e);

      // get minimap pixel coords
      var _this$screenToMap2 = this.screenToMap(e),x = _this$screenToMap2.x,y = _this$screenToMap2.y;

      // preserve camera-direction
      var camera = this.targetViewer.impl.camera;
      var dir = camera.getWorldDirection();

      // when coming from an overview perspective, we don't want to just see the ground afterwards
      dir.z = Math.max(dir.z, 0.0);

      var zWorld = camera.position.z;

      // choose z based on current level
      var level = this.getCurrentLevel();

      if (level) {
        // Floor plus eye height (Should be 1.80m).
        var height = level.zMin + 1.8 / this.targetViewer.model.getUnitScale();

        // In case the ceiling is lower than 1.80m, we don't want to jump accidentally to the next level,
        // So in that case, just set the camera in the middle of the floor.
        if (height >= level.zMax) {
          height = (level.zMin + level.zMax) / 2;
        }

        if (isFinite(height)) {
          zWorld = height;
        }
      }

      // Compute new camera position
      var pos3D = this.transforms.mapPixelsToWorld(x, y, zWorld);
      var target = pos3D.clone().add(dir);
      var dstView = {
        position: pos3D,
        target: target,
        up: camera.up };


      this.isDragging = true;

      Autodesk.Viewing.Private.flyToView(this.targetViewer, dstView, FLY_TO_TIME, function () {
        _this.isDragging = false;
      });

      e.stopPropagation();
      e.preventDefault();

      return true;
    } }, { key: "handleDoubleTap", value: function handleDoubleTap(

    e) {
      return this.handleDoubleClick(e);
    } }]);return AvatarTool;}();


GlobalManagerMixin.call(AvatarTool.prototype);

/***/ }),

/***/ "./extensions/AEC/Avatar/AvatarWidget.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/Avatar/AvatarWidget.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AvatarWidget; });
/* harmony import */ var _AvatarTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AvatarTool */ "./extensions/AEC/Avatar/AvatarTool.js");
/* harmony import */ var _AvatarEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AvatarEvents */ "./extensions/AEC/Avatar/AvatarEvents.js");
/* harmony import */ var _Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Minimap3D/MinimapMath */ "./extensions/AEC/Minimap3D/MinimapMath.js");
/* harmony import */ var _Avatar_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Avatar.scss */ "./extensions/AEC/Avatar/Avatar.scss");
/* harmony import */ var _Avatar_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Avatar_scss__WEBPACK_IMPORTED_MODULE_3__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


 // IMPORTANT!!

var namespace = AutodeskNamespace('Autodesk.AEC');
var GlobalManagerMixin = Autodesk.Viewing.GlobalManagerMixin;
var av = Autodesk.Viewing;var

AvatarWidget = /*#__PURE__*/function (_Autodesk$Viewing$Eve) {_inherits(AvatarWidget, _Autodesk$Viewing$Eve);var _super = _createSuper(AvatarWidget);
  /**
                                                                                                                                                       * 
                                                                                                                                                       * @param {HTMLElement} container - Div element where the avatar should be located.
                                                                                                                                                       * @param {Viewer3D} targetViewer - Target viewer with a 3D model.
                                                                                                                                                       * @param {GlobalManager} globalManager - Global manager.
                                                                                                                                                       * @param {object} transforms - MUST contain these callbacks:
                                                                                                                                                       *                                      mapPixelsToWorld
                                                                                                                                                       *                                      worldToMapPixels
                                                                                                                                                       *                                      mapPixelsToWidget
                                                                                                                                                       *                                      widgetToMapPixels
                                                                                                                                                       *                                      getMapRotationAngle
                                                                                                                                                       * @param {HTMLElement} canvasWrap - Optional DOM element to catch events that are not consumed by the widget.
                                                                                                                                                       * 
                                                                                                                                                       */
  function AvatarWidget(container, targetViewer, globalManager, transforms, trackUsage, canvasWrap) {var _this;_classCallCheck(this, AvatarWidget);
    _this = _super.call(this);
    _this.container = container;
    _this.targetViewer = targetViewer;
    _this.transforms = transforms;
    _this.trackUsage = trackUsage;
    _this.canvasWrap = canvasWrap;
    _this.setGlobalManager(globalManager);

    _this.widgetUI = _this.createUI();

    _this.tool = new _AvatarTool__WEBPACK_IMPORTED_MODULE_0__["default"](_assertThisInitialized(_this));
    _this.tool.activate();return _this;
  }_createClass(AvatarWidget, [{ key: "createUI", value: function createUI()

    {
      var _document = this.getDocument();

      var widget = _document.createElement('div');
      widget.className = 'avatar-widget';

      this.container.appendChild(widget);

      // Sub-widget to represent view direction
      var frustumWidget = _document.createElement('div');
      frustumWidget.className = 'avatar-frustum';
      widget.appendChild(frustumWidget);
      widget.frustumWidget = frustumWidget;

      // By default, setting left/top to posX/posY would move the top-left corner of the frustum
      // widget to that position. We want to have the tip of the camera there.
      // Note that the offset may change depending on the border sizes in avatar-frustum css class.
      widget.anchorX = 20; // =.avatar-frustum.border-left
      widget.anchorY = 40; // =.avatar-frustum.border-top

      // Filled circle at camera position
      var filledCircle = _document.createElement('div');
      filledCircle.className = 'avatar-position-fill';
      widget.appendChild(filledCircle);
      widget.posCircle = filledCircle;

      // Hit area of the avatar position.
      var hitArea = _document.createElement('div');
      hitArea.className = 'avatar-position-hitarea';
      widget.posCircle.appendChild(hitArea);
      widget.hitArea = hitArea;

      if (av.isTouchDevice()) {
        hitArea.classList.add('touch');
        frustumWidget.classList.add('touch');
        widget.posCircle.classList.add('touch');
        widget.anchorX = 40; // =.avatar-frustum.border-left
        widget.anchorY = 80; // =.avatar-frustum.border-top
      }

      return widget;
    } }, { key: "destroy", value: function destroy()

    {
      this.tool.deactivate();
      this.tool = null;

      this.container.removeChild(this.widgetUI);
      this.widgetUI = null;
    }

    // Show avatar - resolve after animation ends.
  }, { key: "show", value: function show() {
      return this.changeVisibility(true);
    }

    // Hide avatar - resolve after animation ends.
  }, { key: "hide", value: function hide() {
      return this.changeVisibility(false);
    }

    // Change avatar visibility if needed - resolve after animation ends.
  }, { key: "changeVisibility", value: function changeVisibility(show) {var _this2 = this;
      return new Promise(function (resolve) {
        if (show ^ _this2.widgetUI.classList.contains('visible')) {
          show ? _this2.widgetUI.classList.add("visible") : _this2.widgetUI.classList.remove("visible");

          var onTransitionEnd = function onTransitionEnd() {
            _this2.widgetUI.removeEventListener('transitionend', onTransitionEnd);
            resolve();
          };

          _this2.widgetUI.addEventListener('transitionend', onTransitionEnd);
        } else {
          resolve();
        }
      });
    }

    // get camera position in map pixel coords
  }, { key: "getPosition2D", value: function getPosition2D() {
      var pos3D = this.targetViewer.impl.camera.position;
      return this.transforms.worldToMapPixels(pos3D);
    }

    // get camera target in map pixel coords
  }, { key: "getTarget2D", value: function getTarget2D() {
      var target3D = this.targetViewer.impl.camera.target;
      return this.transforms.worldToMapPixels(target3D);
    }

    // Update the avatar position and rotation, according to the targetViewer's camera.
  }, { key: "update", value: function update() {
      // get position and target in pixels within the map
      var pos2D = this.getPosition2D();
      var target2D = this.getTarget2D();

      var playerAngle = Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_2__["computeAngle"])(pos2D, target2D);

      // rotate frustum shape (+ consider map rotation)
      var mapRotationAngle = this.transforms.getMapRotationAngle();
      this.widgetUI.frustumWidget.style.transform = "rotate(".concat(playerAngle + mapRotationAngle, "rad)");

      this.transforms.mapPixelsToWidget(pos2D);

      this.widgetUI.style.transform = "translate(".concat(pos2D.x - this.widgetUI.anchorX, "px, ").concat(pos2D.y - this.widgetUI.anchorY, "px)");
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.tool.isDragging;
    } }, { key: "isRotating", value: function isRotating()

    {
      return this.tool.isRotating;
    } }]);return AvatarWidget;}(Autodesk.Viewing.EventDispatcher);


GlobalManagerMixin.call(AvatarWidget.prototype);
Object.assign(namespace, { AvatarEvents: _AvatarEvents__WEBPACK_IMPORTED_MODULE_1__["AvatarEvents"] });

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CanvasBookmark.css":
/*!**********************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CanvasBookmark.css ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./CanvasBookmark.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/CanvasBookmark/CanvasBookmark.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CanvasBookmark.js":
/*!*********************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CanvasBookmark.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CanvasBookmarkExtension; });
/* harmony import */ var _CanvasBookmarkIcons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasBookmarkIcons.js */ "./extensions/AEC/CanvasBookmark/CanvasBookmarkIcons.js");
/* harmony import */ var _CreateFrustumShape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CreateFrustumShape.js */ "./extensions/AEC/CanvasBookmark/CreateFrustumShape.js");
/* harmony import */ var _HCluster_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HCluster.js */ "./extensions/AEC/CanvasBookmark/HCluster.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var av = Autodesk.Viewing,avp = av.Private,avu = Autodesk.Viewing.UI;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.CanvasBookmarkExtension';

var LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';





var VISIBILITY_PROP = 'canvasBookmarks';

// Name of the overlay scene that we use graphics overlays (frustum shapes)
var OverlayName = 'CanvasBookmark_Extension_Overlay';
var CutPlaneSetName = 'CanvasBookmark_CutPlanes';

// Interpolate between two given Matrix4 transforms. Note that this requires the transforms
// to be invertible combinations of pos/rotate/scale.
var lerpTransforms = function () {
  var startPos = new THREE.Vector3();
  var endPos = new THREE.Vector3();
  var startScale = new THREE.Vector3();
  var endScale = new THREE.Vector3();
  var startRotate = new THREE.Quaternion();
  var endRotate = new THREE.Quaternion();

  var pos = new THREE.Vector3();
  var scale = new THREE.Vector3();
  var rotate = new THREE.Quaternion();

  return function (startMatrix, endMatrix, t, dstTransform) {
    startMatrix.decompose(startPos, startRotate, startScale);
    endMatrix.decompose(endPos, endRotate, endScale);

    pos.lerpVectors(startPos, endPos, t);
    scale.lerpVectors(startScale, endScale, t);
    THREE.Quaternion.slerp(startRotate, endRotate, rotate, t);

    dstTransform.compose(pos, rotate, scale);

    return dstTransform;
  };
}();

// Interpolates between two bboxes. t is in [0,1]
var lerpBoxes = function lerpBoxes(startBox, endBox, t, dstBox) {
  dstBox.min.lerpVectors(startBox.min, endBox.min, t);
  dstBox.max.lerpVectors(startBox.max, endBox.max, t);
  lerpTransforms(startBox.transform, endBox.transform, t, dstBox.transform);
};

// Clone Box3 with attached transform
var cloneBox = function cloneBox(srcBox) {
  var box = srcBox.clone();
  box.transform = srcBox.transform ? srcBox.transform.clone() : new THREE.Matrix4();
  return box;
};

var setButtonVisible = function setButtonVisible(button, value) {

  // Make it detectable if this button is going to change on next anim frame.
  button.visiblityChangePending = true;

  // Delay class change to next anim frame - otherwise css transitions don't work sometimes.
  requestAnimationFrame(function () {
    if (value) {
      button.container.classList.add('visible');
    } else
    {
      button.container.classList.remove('visible');
    }
    button.visiblityChangePending = false;
  });
};var


CanvasBookmarkExtension = /*#__PURE__*/function (_av$Extension) {_inherits(CanvasBookmarkExtension, _av$Extension);var _super = _createSuper(CanvasBookmarkExtension);
  function CanvasBookmarkExtension(viewer, options) {var _this;_classCallCheck(this, CanvasBookmarkExtension);
    _this = _super.call(this, viewer, options);

    _this.viewer = viewer;

    _this.bookmarks = [];
    _this.clusteredBookmarks = [];

    _this.camera = _this.viewer.navigation.getCamera();
    _this.cameraMovedCB = _this.onCameraMoved.bind(_assertThisInitialized(_this));
    _this.onModelTransformChanged = _this.onModelTransformChanged.bind(_assertThisInitialized(_this));
    _this.onVisibilityChangedCB = _this.onVisibilityChanged.bind(_assertThisInitialized(_this));

    // SectionBox animations
    _this.sectionBox = null; // SectionBox as defined by currently hovered bookmark (not changed during anims)
    _this.activeSectionBox = null; // Latest applied SectionBox
    _this.animStartSectionBox = null; // Used only during cutplane animations
    _this.animEndSectionBox = null; // Usually equal to this.sectionBox, but this.sectionBox may be null while animEndSectionBox is always valid during an animation
    _this.sectionBoxAnim = null; // AnimControl - only existing during animations

    // bookmarks visibility logic
    _this.changeBookmarksVisibility = _this.changeBookmarksVisibility.bind(_assertThisInitialized(_this));
    _this.changeBookmarksVisibilityTimeout = null;

    _this._clusteringEnabled = _this.options.clusterfck !== undefined;
    _this._clusteringThreshold = _this.options.clusteringThreshold || 110; // threshold is (icon_width * 5), depends on "THREE.Vector3.distanceTo()"

    // bookmarks clustering
    if (_this._clusteringEnabled) {
      _this.hcluster = new _HCluster_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _this.options.clusterfck,
      function (b1, b2) {
        var _b1 = new THREE.Vector2(b1.currentPosProjected.x, b1.currentPosProjected.y);
        var _b2 = new THREE.Vector2(b2.currentPosProjected.x, b2.currentPosProjected.y);
        return _b2.distanceTo(_b1);
      },
      _this._clusteringThreshold);

    }

    _this._filterOutInvisibleBookmark = _this._filterOutInvisibleBookmark.bind(_assertThisInitialized(_this));

    _this.levelChangedCB = _this.onLevelChanged.bind(_assertThisInitialized(_this));

    _this.extensionLoadedCB = _this.onExtensionLoaded.bind(_assertThisInitialized(_this));

    // Indicates if any frustumShape is currently fading for hover effects.
    _this.isFrustumFading = false;

    // For testing: Callbacks that will be notified once as soon as Minimap has reached stable state
    _this.waitingCallbacks = [];return _this;
  }_createClass(CanvasBookmarkExtension, [{ key: "setBookmarksVisible", value: function setBookmarksVisible(

    visible) {
      this.bookmarks.forEach(function (b) {return setButtonVisible(b.marker, visible);});
      this.clusteredBookmarks.forEach(function (b) {return setButtonVisible(b.marker, visible);});
      if (!visible) {
        this.stopGhosting();
      }
    } }, { key: "onVisibilityChanged", value: function onVisibilityChanged(

    visible) {
      if (this.viewer.prefs) {
        this.viewer.prefs.set(VISIBILITY_PROP, visible);
      }

      this.setBookmarksVisible(visible);

      if (visible) {
        this.updateBookmarkPositions();
      }
    } }, { key: "isVisible", value: function isVisible()

    {
      return this.viewer.prefs && this.viewer.prefs.get(VISIBILITY_PROP);
    } }, { key: "onCameraMoved", value: function onCameraMoved()

    {
      this.setBookmarksVisible(false);
      this.debounceBookmarksVisibility();
    } }, { key: "createTooltip", value: function createTooltip(

    button, geomNode) {
      button.setToolTip(geomNode.name());
      button._toolTipElement.innerHTML = "<b>".concat(geomNode.name(), "</b>");
    } }, { key: "flyToBookmark", value: function flyToBookmark(

    bookmark) {
      var dstView = {
        position: bookmark.pos,
        target: bookmark.target,
        up: bookmark.up };

      this.anim = avp.flyToView(this.viewer, dstView, 1.0);
    } }, { key: "getRelatedModelTransform", value: function getRelatedModelTransform(

    geomNode) {
      var root = geomNode.getRootNode();

      // Find the current visible model that share the same root node with the bookmark's node.
      var relatedModel = this.viewer.getVisibleModels().find(
      function (model) {return model.getDocumentNode().getRootNode() === root;});


      var modelTransform = relatedModel === null || relatedModel === void 0 ? void 0 : relatedModel.getModelToViewerTransform();

      return modelTransform;
    }

    // geomNode is a BubbleNode of type GEOMETRY_NODE
  }, { key: "createBookmark", value: function createBookmark(geomNode) {var _this2 = this;

      // extract camera data (TODO: Add generic utility function to BubbleNode to read camera)
      var camera = geomNode.extractCamera();
      if (!camera) {
        return;
      }

      var pos = camera.position;
      var target = camera.target;

      var modelTransform = this.getRelatedModelTransform(geomNode);

      // Transform pos & target according to the modelToViewerTransform of the related model.
      if (modelTransform) {
        pos.applyMatrix4(modelTransform);
        target.applyMatrix4(modelTransform);
      }

      var dir = new THREE.Vector3(target.x - pos.x, target.y - pos.y, target.z - pos.z).normalize();
      var up = new THREE.Vector3(0, 0, 1);

      // IDs cannot start with numbers and have whitespaces
      var button = new Autodesk.Viewing.UI.Button("b-".concat(geomNode.name().replace(/\s/g, '')));

      // Configure style (TODO: Should move to css class or specified by client app)
      button.container.classList.add('canvas-bookmark');
      button.container.innerHTML = Object(_CanvasBookmarkIcons_js__WEBPACK_IMPORTED_MODULE_0__["createCameraIcon"])();
      setButtonVisible(button, this.isVisible());

      this.createTooltip(button, geomNode);

      this.viewer.container.appendChild(button.container);

      var buttonSize = button.getDimensions();

      var sectionBox = this.findSectionBox(geomNode, geomNode.name());
      var sectionBoxCenter = sectionBox ? sectionBox.center().applyMatrix4(sectionBox.transform) : null;

      var bookmark = {
        marker: button,
        pos: sectionBox ? sectionBoxCenter : pos,
        cameraPos: pos,
        dir: dir,
        up: up,
        target: target,
        name: geomNode.name(),

        // position within the marker that should be centered
        anchorX: buttonSize.width / 2,
        anchorY: buttonSize.height / 2,

        fadeValue: 0.0,
        hovered: false,
        bubbleNode: geomNode,

        clustered: false };


      button.container.addEventListener('mouseenter', function () {_this2.onBookmarkMouseEnter(bookmark);});
      button.container.addEventListener('mouseleave', function () {_this2.onBookmarkMouseLeave(bookmark);});

      button.addEventListener(avu.Button.Event.CLICK, function () {
        // pass to custom handler
        if (_this2.options && _this2.options.onBookmark) {
          _this2.options.onBookmark(bookmark.bubbleNode, camera);
        }
      });

      return bookmark;
    } }, { key: "createClusteredBookmark", value: function createClusteredBookmark(

    flattenCluster, id, visible) {var _this3 = this;
      var button = new Autodesk.Viewing.UI.Button(id);

      button.container.classList.add('clustered-canvas-bookmark');
      button.container.innerHTML = Object(_CanvasBookmarkIcons_js__WEBPACK_IMPORTED_MODULE_0__["createClusteredCameraIcon"])();

      setButtonVisible(button, this.isVisible() && visible);

      this.viewer.container.appendChild(button.container);

      var res = _HCluster_js__WEBPACK_IMPORTED_MODULE_2__["default"].ComputeMeanValueForFlattenCluster(flattenCluster);

      var bookmark = {
        marker: button,
        name: id,

        pos: res.center3D,
        currentPosProjected: res.center2D,

        cluster: flattenCluster,

        fadeValue: 0.0,
        hovered: false,

        folded: true };


      button.container.addEventListener('mouseenter', function () {_this3.onClusteredBookmarkMouseEnter(bookmark);});
      button.container.addEventListener('mouseleave', function () {_this3.onClusteredBookmarkMouseLeave(bookmark);});
      button.addEventListener(avu.Button.Event.CLICK, function () {_this3.onClusteredBookmarkClicked(bookmark);});

      bookmark.marker.container.style.transform = "translate(".concat(res.center2D.x, "px, ").concat(res.center2D.y, "px)");
      this.clusteredBookmarks.push(bookmark);
    } }, { key: "deleteBookmark", value: function deleteBookmark(

    bookmark) {
      this.viewer.container.removeChild(bookmark.marker.container);
      this.hideFrustumShape(bookmark);
    } }, { key: "clearBookmarks", value: function clearBookmarks()

    {var _this4 = this;
      // Cancel any outdated anims or cutplanes
      this.stopSectionBoxAnim();
      this.applySectionBox();

      this.bookmarks.forEach(function (bm) {
        _this4.deleteBookmark(bm);
      });
      this.bookmarks = [];

      this.clusteredBookmarks.forEach(function (bm) {
        _this4.deleteBookmark(bm);
      });
      this.clusteredBookmarks = [];
    } }, { key: "resetBookmarks", value: function resetBookmarks(

    geomNodes) {var _this5 = this;

      this.clearBookmarks();
      if (!geomNodes) {
        return;
      }

      //The bookmarks make use of AECModelData, so we have to make sure we have that loaded.
      av.Document.getAecModelData(geomNodes).then(function () {

        for (var i = 0; i < geomNodes.length; i++) {
          var geomNode = geomNodes[i];
          var bookmark = _this5.createBookmark(geomNode);
          if (bookmark) {
            _this5.bookmarks.push(bookmark);
          }
        }

        _this5.bookmarkData = geomNodes;

        _this5.updateBookmarkPositions();
      });
    }

    // Create bookmarks with correct positions for the current geoOffset
  }, { key: "resetGlobalOffset", value: function resetGlobalOffset(globalOffset) {
      this.options.globalOffset = globalOffset;
      this.resetBookmarks(this.bookmarkData);
    } }, { key: "showFrustumShape", value: function showFrustumShape(

    bookmark) {
      if (bookmark.frustumShape) {
        return;
      }

      bookmark.frustumShape = Object(_CreateFrustumShape_js__WEBPACK_IMPORTED_MODULE_1__["createFrustumShape"])(bookmark.cameraPos, bookmark.dir);
      this.viewer.impl.addOverlay(OverlayName, bookmark.frustumShape);

      bookmark.frustumShape.name = bookmark.bubbleNode.name();

      // Make LMV recompute near/far plane, so that the frustum shape is considered
      // TODO: It would be easier if LMV would do that automatically, but it
      //       updates the camera only when rendering the scene.
      //       => Clarify if we can generally change that.
      this.viewer.impl.updateCameraMatrices();
    } }, { key: "hideFrustumShape", value: function hideFrustumShape(

    bookmark) {
      if (!bookmark.frustumShape) {
        return;
      }

      this.viewer.impl.removeOverlay(OverlayName, bookmark.frustumShape);
      bookmark.frustumShape = null;
    }

    // Controls the frustum fading. fadeValue is in [0,1]
  }, { key: "setFrustumFadeValue", value: function setFrustumFadeValue(bookmark, fadeValue) {
      bookmark.fadeValue = fadeValue;
      if (bookmark.frustumShape) {
        bookmark.frustumShape.setFadeValue(fadeValue);
      }
    }

    // Update fading of the frustum shape based on elpased time in ms.
  }, { key: "updateFrustumShapeFading", value: function updateFrustumShapeFading(bookmark, elapsed) {
      var FadeInDurationMs = 500;
      var FadeOutDurationMs = 500;

      var fadingIn = bookmark.hovered && bookmark.fadeValue < 1.0;
      var fadingOut = !bookmark.hovered && bookmark.fadeValue > 0.0;

      if (!fadingIn && !fadingOut) {
        return false;
      }

      // compute amount of fading change (1.0 = full fade)
      var fadeInDelta = elapsed / FadeInDurationMs;
      var fadeOutDelta = elapsed / FadeOutDurationMs;
      var newValue = bookmark.fadeValue + (fadingIn ? fadeInDelta : -fadeOutDelta);

      newValue = THREE.Math.clamp(newValue, 0, 1);
      this.setFrustumFadeValue(bookmark, newValue);

      // HACK: Use css fade instead
      if (bookmark.marker && bookmark.marker._toolTipElement) {
        bookmark.marker._toolTipElement.style.opacity = Math.min(1, 3 * newValue);
      }

      // remove frustums if not used anymore
      if (!bookmark.hovered && bookmark.fadeValue === 0) {
        this.hideFrustumShape(bookmark);
      }

      this.viewer.impl.invalidate(false, false, true);

      return true;
    } }, { key: "requestTimer", value: function requestTimer()

    {var _this6 = this;
      var _window = this.getWindow();
      this.timerId = _window.requestAnimationFrame(function () {return _this6.onTimer();});
    } }, { key: "onTimer", value: function onTimer()

    {var _this7 = this;
      // get elapsed time in ms
      var curTime = performance.now();
      var elapsed = curTime - this.lastTime;
      this.lastTime = curTime;

      // Track whether any frustum-shape fading is going on
      this.isFrustumFading = false;

      this.bookmarks.forEach(function (bookmark) {
        var fading = _this7.updateFrustumShapeFading(bookmark, elapsed);
        _this7.isFrustumFading = _this7.isFrustumFading || fading;
      });

      // Trigger notification if fading stuff is finished
      if (this.isAllDone()) {
        this.waitingCallbacks.forEach(function (p) {return p();});
        this.waitingCallbacks.length = 0;
      }

      this.requestTimer();
    }

    // Returns an oriented box (THREE.Box3() + attached Matrix4 box.transform)
  }, { key: "findSectionBox", value: function findSectionBox(bubbleNode, name) {
      var viewNode = bubbleNode.search({ type: 'view' });

      if (!viewNode.length || viewNode[0].data.name !== name)
      return null;

      var sb = viewNode[0].data.sectionBox;
      var sbt = viewNode[0].data.sectionBoxTransform;

      if (!sb || !sbt)
      return null;

      var sbTransformMatrix = new THREE.Matrix4().fromArray([
      sbt[0], sbt[1], sbt[2], sbt[3],
      sbt[4], sbt[5], sbt[6], sbt[7],
      sbt[8], sbt[9], sbt[10], sbt[11],
      sbt[12], sbt[13], sbt[14], sbt[15]]);


      var box = new THREE.Box3();
      box.min.set(sb[0], sb[1], sb[2]);
      box.max.set(sb[3], sb[4], sb[5]);
      box.transform = new THREE.Matrix4();

      // Transform box according to the modelToViewerTransform of the related model.
      // Note: The model that the bookmark refers to is not always in memory. However, 
      //   - The transform is always the same for all 3D views of a model.
      //   - Since a CanvasBookmark is shown, at least some view of the same 3D model must be visible
      // Therefore, we can always get the transform here from the visible view of that model.

      var modelTransform = this.getRelatedModelTransform(bubbleNode);

      if (modelTransform) {
        box.transform.multiply(modelTransform);
      }

      box.transform.multiply(sbTransformMatrix);


      return box;
    }

    // The overlay scene contains the frustum shapes and is always visible by default. We only hide it temporarily
    // when baking an image for showin ghost floors
  }, { key: "setOverlaySceneVisible", value: function setOverlaySceneVisible(visible) {
      // Overlay may be null if this is currently unloaded
      var overlay = this.viewer.impl.overlayScenes[OverlayName];
      var scene = overlay && overlay.scene;
      if (scene) {
        scene.visible = visible;
      }
    } }, { key: "getFadeExtension", value: function getFadeExtension()

    {
      return this.viewer.getExtension('Autodesk.CrossFadeEffects');
    }

    // Render models without SectionBox into fading target
  }, { key: "showGhosting", value: function showGhosting() {var _this8 = this;
      // Ghosting is an optional effect that requires the CrossFade extension. If we don't have it,
      // we omit ghosting, i.e., only apply the cutplanes for SectionBox previous.
      var fadeExt = this.getFadeExtension();
      if (!fadeExt) {
        return;
      }

      // Take control over CrossFade effect. Purpose is to avoid conflicts with other effects based on CrossFade. E.g., if we are
      // still showing ghost-floors from LevelsExtension, LevelsExtension will properly clean them up first.
      fadeExt.acquireControl('CanvasBookmarks', function () {return _this8.stopGhosting();});

      // If possible, reuse baked ghosting image from previous bookmark
      if (!this.ghostingActive) {
        this.viewer.impl.setCutPlaneSet(CutPlaneSetName); // disable current SectionBox
        this.setOverlaySceneVisible(false); // make sure that we don't bake Frustum shapes into the screenshot
        fadeExt.renderFadingImage(0); // render snapshot into fading target
        this.applySectionBox(this.activeSectionBox); // recover current SectionBox
        this.setOverlaySceneVisible(true); // show overlay scene again (We don't hide it anywhere else, otherwise we would need to save/restore visibility state)
        this.ghostingActive = true;
      } else {
        // Reuse ghosting from before - just make sure that no fadeOut anim is in-progress
        this.stopGhostFadeOut();
      }
      fadeExt.setCrossFadeOpacity(0, 0.3); // overlay full model with ghost opacity
    } }, { key: "stopGhosting", value: function stopGhosting()

    {
      if (this.ghostingActive) {
        this.stopGhostFadeOut();
        var fadeExt = this.getFadeExtension();
        fadeExt && fadeExt.releaseFadingImage(0);
        this.ghostingActive = false;
      }
    } }, { key: "stopGhostFadeOut", value: function stopGhostFadeOut()

    {
      // skip fade-out animation if in progress
      if (this.ghostFadeAnim) {
        this.ghostFadeAnim.skip();
        this.ghostFadeAnim = null;
      }
    }

    // Fade-out cross-fade target containing the ghosted environment
  }, { key: "fadeOutGhosting", value: function fadeOutGhosting() {
      var fadeExt = this.getFadeExtension();
      if (!this.ghostingActive || !fadeExt) {
        // No ghosting active => nothing to do
        return;
      }

      var ghostAlpha = fadeExt.getCrossFadeOpacity(0);
      this.ghostFadeAnim = avp.fadeValue(ghostAlpha, 0.0, 0.5, function (t) {return fadeExt.setCrossFadeOpacity(0, t);});
    } }, { key: "onBookmarkMouseEnter", value: function onBookmarkMouseEnter(

    bookmark) {
      var sectionBox = this.findSectionBox(bookmark.bubbleNode, bookmark.name);
      if (sectionBox) {
        this.showGhosting();
        this.animateToSectionBox(sectionBox);
      }

      this.showFrustumShape(bookmark);
      bookmark.hovered = true;
    } }, { key: "onBookmarkMouseLeave", value: function onBookmarkMouseLeave(

    bookmark) {
      this.animateToSectionBox(null);
      this.fadeOutGhosting();
      bookmark.hovered = false;
    } }, { key: "onClusteredBookmarkMouseEnter", value: function onClusteredBookmarkMouseEnter(

    bookmark) {
      bookmark.hovered = true;
    } }, { key: "onClusteredBookmarkMouseLeave", value: function onClusteredBookmarkMouseLeave(

    bookmark) {
      bookmark.hovered = false;
    } }, { key: "onClusteredBookmarkClicked", value: function onClusteredBookmarkClicked(

    bookmark) {
      // TODO:
      //   - Zoom + zoom level computation
      //   - "Too many" clustered bookmarks -> (n+1) icon should be "..."

      if (bookmark.folded) {
        var _rotate = function _rotate(vector, center, angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);

          var x = vector.x - center.x;
          var y = vector.y - center.y;

          vector.x = x * c - y * s + center.x;
          vector.y = x * s + y * c + center.y;
        };

        var n = bookmark.cluster.length;
        var alpha = Math.round(360.0 / n);

        var center = new THREE.Vector2(bookmark.currentPosProjected.x, bookmark.currentPosProjected.y);

        var start = new THREE.Vector2(center.x, center.y + 35);

        for (var i = 0; i < n; ++i) {
          var bm = bookmark.cluster[i];

          var current = start.clone();
          _rotate(current, center, i * alpha * Math.PI / 180.0);

          bm.currentPosProjected.x = current.x;
          bm.currentPosProjected.y = current.y;

          bm.marker.container.style.transform = "translate(".concat(current.x, "px, ").concat(current.y, "px)");
          setButtonVisible(bm.marker, true);
        }

        bookmark.marker.container.classList.add('declustered-canvas-bookmark');
      } else
      {
        bookmark.cluster.forEach(function (bm) {
          setButtonVisible(bm.marker, false);
        });

        bookmark.marker.container.classList.remove('declustered-canvas-bookmark');
      }

      bookmark.folded = !bookmark.folded;
    } }, { key: "debounceBookmarksVisibility", value: function debounceBookmarksVisibility()

    {
      if (this.changeBookmarksVisibilityTimeout) {
        clearTimeout(this.changeBookmarksVisibilityTimeout);
      }

      this.changeBookmarksVisibilityTimeout = setTimeout(this.changeBookmarksVisibility, 100);
    } }, { key: "debounceResetBookmarks", value: function debounceResetBookmarks()

    {var _this9 = this;
      if (this.resetBookmarksTimeout) {
        clearTimeout(this.resetBookmarksTimeout);
      }

      this.resetBookmarksTimeout = setTimeout(function () {return _this9.resetBookmarks(_this9.bookmarkData);}, 100);
    } }, { key: "onModelTransformChanged", value: function onModelTransformChanged()

    {
      this.onCameraMoved();
      this.debounceResetBookmarks();
    } }, { key: "changeBookmarksVisibility", value: function changeBookmarksVisibility()

    {
      this.updateBookmarkPositions();
    } }, { key: "updateBookmarkPositions", value: function updateBookmarkPositions()

    {var _this10 = this;
      if (!this.isVisible()) {
        return;
      }

      this.bookmarks.forEach(function (bookmark) {
        // Use cropBox center (if available) or camera position to choose label position
        var sBox = bookmark.bubbleNode.sectionBox;
        var pos3D = sBox ? sBox.center() : bookmark.pos;

        bookmark.currentPos3D = pos3D;

        // In-canvas coordinates
        var pos2D = _this10.project(pos3D);
        pos2D.x -= bookmark.anchorX;
        pos2D.y -= bookmark.anchorY;

        bookmark.currentPosProjected = new THREE.Vector3(pos2D.x, pos2D.y, pos2D.z);
        bookmark.marker.container.style.transform = "translate(".concat(pos2D.x, "px, ").concat(pos2D.y, "px)");
      });

      var clusters = this._clusteringEnabled ? this.hcluster.createClusters(this.bookmarks) : [];
      this.updateClusteredBookmarks(clusters);
    } }, { key: "updateClusteredBookmarks", value: function updateClusteredBookmarks(

    clusters) {var _this11 = this;
      // delete all "cluster" bookmarks since we create them all the time (by design), hiding will not really work
      this.clusteredBookmarks.forEach(function (bookmark) {
        _this11.deleteBookmark(bookmark);
      });
      this.clusteredBookmarks = [];

      // hide all bookmarks and reset "clustered" state
      this.bookmarks.forEach(function (bookmark) {
        setButtonVisible(bookmark.marker, false);
      });

      var floorSelector = this._getFloorSelector();
      var currentLevel = floorSelector && floorSelector.currentFloor;
      if (currentLevel !== undefined) {
        return;
      }

      var visibleBookamrks = this.bookmarks.filter(this._filterOutInvisibleBookmark);
      visibleBookamrks.forEach(function (bookmark) {
        bookmark.clustered = false;
        setButtonVisible(bookmark.marker, true);
      });

      for (var i = 0; i < clusters.length; i++) {
        var c = clusters[i];

        if (c.size > 1) {(function () {
            var flCluster = _HCluster_js__WEBPACK_IMPORTED_MODULE_2__["default"].FlattenCluster(c);

            var clusterBmVisible = false;
            flCluster.forEach(function (bookmark) {
              bookmark.clustered = true;
              if (!clusterBmVisible && bookmark.marker.isVisible()) {
                // if one of the included bookmarks is visible, mark the cluster bookmark as visible one
                clusterBmVisible = true;
              }
              // now, mark the included bookmark as invisible one
              setButtonVisible(bookmark.marker, false);
            });

            // IDs cannot start with some number
            _this11.createClusteredBookmark(flCluster, "c-".concat(flCluster[0].bubbleNode.data.viewableID), clusterBmVisible);})();
        }
      }
    } }, { key: "project", value: function project(

    position) {
      var containerBounds = this.viewer.navigation.getScreenViewport();
      var p = new THREE.Vector3().copy(position);

      var matrix = new THREE.Matrix4();
      matrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);

      p.applyProjection(matrix);

      return new THREE.Vector3(
      Math.round((p.x + 1) / 2 * containerBounds.width),
      Math.round((-p.y + 1) / 2 * containerBounds.height),
      p.z);

    } }, { key: "load", value: function load()

    {

      this.viewer.prefs.add(VISIBILITY_PROP, true);

      this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.cameraMovedCB);
      this.viewer.addEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);

      var floorSelector = this._getFloorSelector();
      if (floorSelector) {
        floorSelector.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.levelChangedCB);
      }

      this.viewer.addEventListener(av.EXTENSION_LOADED_EVENT, this.extensionLoadedCB);

      // handle the case when this extension is loaded after LevelsExtension is loaded,
      // without making this extension known to LevelsExtension
      this.updateBookmarkPositions();

      this.viewer.impl.createOverlayScene(OverlayName);

      // trigger timer-calls for fading animations
      this.lastTime = performance.now();
      this.requestTimer();

      if (!this.updateSettingsPanel) {
        //We need to connect this to an event that happens after the settings panel has been
        //create by the load sequence.
        this.updateSettingsPanel = this.configureSettings.bind(this);
        this.viewer.addEventListener(av.SETTINGS_PANEL_CREATED_EVENT, this.updateSettingsPanel);
      }

      return true;
    } }, { key: "unload", value: function unload()

    {
      this.clearBookmarks();

      this.viewer.impl.removeOverlayScene(OverlayName);

      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.cameraMovedCB);
      this.viewer.removeEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);

      var floorSelector = this._getFloorSelector();
      if (floorSelector) {
        floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.levelChangedCB);
      }

      this.viewer.removeEventListener(av.EXTENSION_LOADED_EVENT, this.extensionLoadedCB);

      // Stop timer for position updates
      if (this.timerId) {
        var _window = this.getWindow();
        _window.cancelAnimationFrame(this.timerId);
        this.timerId = null;
      }

      if (this.updateSettingsPanel) {
        this.viewer.removeEventListener(av.SETTINGS_PANEL_CREATED_EVENT, this.updateSettingsPanel);
        this.updateSettingsPanel = null;
      }

      return true;
    } }, { key: "applySectionBox", value: function applySectionBox(

    box) {
      this.activeSectionBox = box;

      // No box => clear cutplanes
      if (!box) {
        this.viewer.impl.setCutPlaneSet(CutPlaneSetName);
        return;
      }

      var planes = avp.SceneMath.box2CutPlanes(box, box.transform);
      this.viewer.impl.setCutPlaneSet(CutPlaneSetName, planes);
    }

    // get bbox of all visible models
  }, { key: "getModelBox", value: function getModelBox() {
      var mq = this.viewer.impl.modelQueue();
      var models = mq.getModels();

      var box = new THREE.Box3();
      for (var i = 0; i < models.length; i++) {
        box.union(models[i].getBoundingBox());
      }

      return box;
    } }, { key: "stopSectionBoxAnim", value: function stopSectionBoxAnim()

    {
      if (this.sectionBoxAnim) {
        this.sectionBoxAnim.stop();
        this.sectionBoxAnim = null;
      }
    } }, { key: "animateToSectionBox", value: function animateToSectionBox(

    newBox) {var _this12 = this;
      // Nothing to animate
      if (!newBox && !this.activeSectionBox) {
        return;
      }

      // Don't allow overlapping animations
      this.stopSectionBoxAnim();

      var CutPlaneAnimInSeconds = 0.5;

      // Start at latest SectionBox state or with the whole model
      this.animStartBox = this.activeSectionBox ? cloneBox(this.activeSectionBox) : cloneBox(this.getModelBox());
      this.animEndBox = newBox ? cloneBox(newBox) : cloneBox(this.getModelBox());

      // Set target box
      this.sectionBox = newBox;

      // interpolated box used during anim
      var tmpBox = new THREE.Box3();
      tmpBox.transform = new THREE.Matrix4();

      var onUpdate = function onUpdate(t) {
        t = avp.smootherStep(t);
        lerpBoxes(_this12.animStartBox, _this12.animEndBox, t, tmpBox);
        _this12.applySectionBox(tmpBox);
      };

      var onFinished = function onFinished() {
        _this12.applySectionBox(_this12.sectionBox);
        _this12.sectionBoxAnim = null;
      };

      this.sectionBoxAnim = avp.fadeValue(0, 1, CutPlaneAnimInSeconds, onUpdate, onFinished);
    } }, { key: "enableClustering", value: function enableClustering(

    value) {
      if (this._clusteringEnabled !== value) {
        this._clusteringEnabled = value;
        this.updateClusteredBookmarks([]);
      }
    } }, { key: "setClusteringThreshold", value: function setClusteringThreshold(

    value) {
      if (this._clusteringThreshold !== value) {
        this._clusteringThreshold = value;
        this.hcluster.setThreshold(value);
        this.updateClusteredBookmarks([]);
      }
    }

    // Returns true if there are no active transitions, i.e., state is stable and doesn't vary based on timing anymore.    
  }, { key: "isAllDone", value: function isAllDone() {
      // Note: Some aspects are not considered yet, e.g., css-based fading and debounced visibility. For
      //       now, we only address everything that would introduce test instabilities otherwise.
      var sectionBoxAnimActive = this.sectionBoxAnim && this.sectionBoxAnim.isRunning;
      var visChangePending = this.bookmarks.some(function (b) {return b.marker && b.marker.visiblityChangePending;});
      return !sectionBoxAnimActive && !this.isFrustumFading && !visChangePending;
    }

    // Returns a promise that resolves as soon as isAllDone() returns true.
  }, { key: "waitForAllDone", value: function waitForAllDone() {var _this13 = this;

      // Update frustum-fading to check whether there are any changes to process
      this.onTimer();

      if (this.isAllDone()) {
        return Promise.resolve();
      }

      return new Promise(function (resolve) {
        _this13.waitingCallbacks.push(resolve);
      });
    } }, { key: "_filterOutInvisibleBookmark", value: function _filterOutInvisibleBookmark(

    bm) {
      var vp = this.viewer.navigation.getScreenViewport();

      if (bm.currentPosProjected.x < 0 || bm.currentPosProjected.x > vp.width) {
        return false;
      }

      if (bm.currentPosProjected.y < 0 || bm.currentPosProjected.y > vp.height) {
        return false;
      }

      var viewingDirection = this.camera.target.clone().sub(this.camera.position);
      var bookmarkDirection = bm.pos.clone().sub(this.camera.position);
      return viewingDirection.dot(bookmarkDirection) > 0;
    } }, { key: "onLevelChanged", value: function onLevelChanged()

    /*event*/{
      this.updateBookmarkPositions();
    } }, { key: "onExtensionLoaded", value: function onExtensionLoaded(

    event) {
      if (event.extensionId === LEVEL_EXT) {
        this.updateBookmarkPositions();
      }
    } }, { key: "configureSettings", value: function configureSettings()

    {

      //Is it a GUI viewer or not?
      if (!this.viewer.getSettingsPanel)
      return;

      var panel = this.viewer.getSettingsPanel(true);

      if (!panel.is3dMode)
      return;

      var navTab = av.Extensions.ViewerSettingTab.Navigation;
      panel.addLabel(navTab, "Location Icons");

      // add toggle to the hypermodeling tab of the viewer settings
      if (panel && !panel.showLocationIconsChkBoxId) {
        panel.showLocationIconsChkBoxId = panel.addCheckbox(
        navTab,
        "Show location icons",
        "Toggles availability of the location icons when looking at the project model",
        true,
        this.onVisibilityChangedCB,
        VISIBILITY_PROP);

      }
    } }, { key: "_getFloorSelector", value: function _getFloorSelector()

    {
      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      return levelExt && levelExt.floorSelector;
    } }]);return CanvasBookmarkExtension;}(av.Extension);


namespace.CanvasBookmarkExtension = CanvasBookmarkExtension;

Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, CanvasBookmarkExtension);

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CanvasBookmarkIcons.js":
/*!**************************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CanvasBookmarkIcons.js ***!
  \**************************************************************/
/*! exports provided: createCameraIcon, createClusteredCameraIcon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCameraIcon", function() { return createCameraIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createClusteredCameraIcon", function() { return createClusteredCameraIcon; });

function createCameraIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 114 114">',
  '<defs>',
  '<path id="camera-view-icon-3-with-shadow-v3-b" d="M60.934065,73.4602645 C54.1164768,73.4602645 48.5886781,67.9324658 48.5886781,61.1148776 C48.5886781,54.2963836 54.1164768,48.7694907 60.934065,48.7694907 C67.752559,48.7694907 73.2803577,54.2963836 73.2803577,61.1148776 C73.2803577,67.9324658 67.752559,73.4602645 60.934065,73.4602645 M78.7230158,42.834104 C77.2575106,42.9581919 75.7711731,42.808743 74.2984219,42.8748628 C73.4714712,42.9119986 72.9388896,42.637556 72.4470667,41.9817922 C70.947143,39.9827997 69.3693246,38.0417751 67.8621549,36.0491228 C67.287003,35.2873862 66.5959149,34.9939228 65.6521223,35.0029804 C62.0046628,35.0355874 58.354486,35.0401161 54.7070265,35.0002631 C53.7097946,34.9893941 53.0033088,35.3145587 52.4046073,36.1116196 C50.9028721,38.1088007 49.382116,40.0951128 47.7852769,42.0171165 C47.4311283,42.4437253 46.748192,42.7707014 46.1884378,42.8187062 C44.8515493,42.9346424 43.4974514,42.855842 41.9640149,42.855842 C41.9640149,42.2091358 41.9929989,41.6520989 41.9576746,41.0995907 C41.8897433,40.036239 41.3046281,39.4293858 40.2331246,39.4112707 C38.5112919,39.381381 36.7894591,39.3759465 35.0676263,39.4130822 C33.9934056,39.4366318 33.4291227,40.057977 33.3892696,41.1303863 C33.3693431,41.6557219 33.3856466,42.1819632 33.3856466,42.8078372 C31.121269,42.9074698 29.8523117,44.2289606 29,46.07941 L29,75.8722796 C30.0434252,78.4165343 31.9636175,79.1737422 34.6482636,79.1583444 C49.3911736,79.0686751 64.1340835,79.0713923 78.8769935,79.1556272 C81.5299383,79.1710249 83.372236,78.3377339 84.4011692,75.8722796 L84.4011692,46.07941 C83.3332887,43.5523646 81.4058504,42.6067605 78.7230158,42.834104"/>',
  '<filter id="camera-view-icon-3-with-shadow-v3-a" width="125.3%" height="131.7%" x="-12.6%" y="-11.3%" filterUnits="objectBoundingBox">',
  '<feOffset dy="2" in="SourceAlpha" result="shadowOffsetOuter1"/>',
  '<feGaussianBlur in="shadowOffsetOuter1" result="shadowBlurOuter1" stdDeviation="2"/>',
  '<feColorMatrix in="shadowBlurOuter1" values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.1 0"/>',
  '</filter>',
  '<path id="camera-view-icon-3-with-shadow-v3-d" d="M104.440851,57.2204256 C104.440851,83.2997158 83.2997158,104.440851 57.2204256,104.440851 C31.1411354,104.440851 10,83.2997158 10,57.2204256 C10,31.1411354 31.1411354,10 57.2204256,10 C83.2997158,10 104.440851,31.1411354 104.440851,57.2204256 Z"/>',
  '<filter id="camera-view-icon-3-with-shadow-v3-c" width="125.5%" height="125.5%" x="-12.8%" y="-10.6%" filterUnits="objectBoundingBox">',
  '<feMorphology in="SourceAlpha" operator="dilate" radius="5.045" result="shadowSpreadOuter1"/>',
  '<feOffset dy="2" in="shadowSpreadOuter1" result="shadowOffsetOuter1"/>',
  '<feMorphology in="SourceAlpha" radius="5.045" result="shadowInner"/>',
  '<feOffset dy="2" in="shadowInner" result="shadowInner"/>',
  '<feComposite in="shadowOffsetOuter1" in2="shadowInner" operator="out" result="shadowOffsetOuter1"/>',
  '<feGaussianBlur in="shadowOffsetOuter1" result="shadowBlurOuter1" stdDeviation="2"/>',
  '<feColorMatrix in="shadowBlurOuter1" values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.1 0"/>',
  '</filter>',
  '</defs>',
  '<g fill="none" fill-rule="evenodd">',
  '<use fill="#000" filter="url(#camera-view-icon-3-with-shadow-v3-a)" xlink:href="#camera-view-icon-3-with-shadow-v3-b"/>',
  '<use fill="currentColor" xlink:href="#camera-view-icon-3-with-shadow-v3-b"/>',
  '<g>',
  '<use fill="#000" filter="url(#camera-view-icon-3-with-shadow-v3-c)" xlink:href="#camera-view-icon-3-with-shadow-v3-d"/>',
  '<use stroke="currentColor" stroke-width="10.09" xlink:href="#camera-view-icon-3-with-shadow-v3-d"/>',
  '</g>',
  '</g>',
  '</svg>'].
  join('');
}

function createClusteredCameraIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 652 598">',
  '<path fill="currentColor" d="M254.7,94.3A157.6,157.6,0,1,0,412.3,251.9,157.6,157.6,0,0,0,254.7,94.3ZM173.6,281.4a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,173.6,281.4Zm86.6,0a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,260.2,281.4Zm86.7,0a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,346.9,281.4Z"/>',
  '<circle fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="42.87px" cx="256" cy="256" r="221.5" transform="translate(-101.8 200.6) rotate(-36.2)"/>',
  '</svg>'].
  join('');
}

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CreateFrustumShape.js":
/*!*************************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CreateFrustumShape.js ***!
  \*************************************************************/
/*! exports provided: createFrustumShape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFrustumShape", function() { return createFrustumShape; });


// Returns a THREE.Scene to represent the camera frustum
function createFrustumShape(pos, dir) {
  // The frustum shape is a symbol to explain pos and dir - not the exact frustum.
  var FovVert = 17;
  var FovHor = 17;

  // Frustum shape/outline opacity when fully faded in
  var FrustumOpacity = 0.05;
  var LineOpacity = 1.0;

  var radians = THREE.Math.degToRad;
  var dx = Math.sin(radians(FovHor));
  var dy = Math.sin(radians(FovVert));

  // compute z in a way that the results are normalized
  var dz = Math.sqrt(1 - dx * dx - dy * dy);

  // compute directions for the 4 frustum-corners
  var bottomLeft = new THREE.Vector3(-dx, -dy, dz);

  var bottomRight = new THREE.Vector3(dx, -dy, dz);
  var topLeft = new THREE.Vector3(-dx, dy, dz);
  var topRight = new THREE.Vector3(dx, dy, dz);

  // create mesh vertices: 4 corners + origin
  var vertices = new Float32Array([
  bottomLeft.x, bottomLeft.y, bottomLeft.z,
  bottomRight.x, bottomRight.y, bottomRight.z,
  topLeft.x, topLeft.y, topLeft.z,
  topRight.x, topRight.y, topRight.z,
  0, 0, 0]);


  var bl = 0;
  var br = 1;
  var tl = 2;
  var tr = 3;
  var p0 = 4; // index of camera position vertex

  var indices = new Uint32Array([
  p0, br, bl, // bottom face
  p0, tr, br, // right face
  p0, tl, tr, // top face
  p0, bl, tl, // left face
  bl, br, tr, // far face lower tri
  bl, tr, tl // face face upper tri
  ]);

  // Extract vertices to non-indexed, so that we can compute face-normals
  var vertsNonIndexed = new Float32Array(3 * indices.length);
  for (var i = 0; i < indices.length; i++) {
    var index = indices[i];
    vertsNonIndexed[3 * i] = vertices[3 * index];
    vertsNonIndexed[3 * i + 1] = vertices[3 * index + 1];
    vertsNonIndexed[3 * i + 2] = vertices[3 * index + 2];
  }

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute('position', new THREE.BufferAttribute(vertsNonIndexed, 3));

  geometry.computeVertexNormals();

  var material = new THREE.MeshPhongMaterial({
    color: 0x5050FF,
    transparent: true,
    opacity: 0.0, // will change with fade-in
    depthTest: false,
    depthWrite: false,
    blending: THREE.NoBlending });


  var mesh = new THREE.Mesh(geometry, material);

  // create frustum lines
  var lineIndices = new Uint32Array([
  p0, bl,
  p0, br,
  p0, tr,
  p0, tl,
  bl, br,
  br, tr,
  tr, tl,
  tl, bl]);


  var lineGeom = new THREE.BufferGeometry();
  lineGeom.addAttribute('index', new THREE.BufferAttribute(lineIndices, 1));
  lineGeom.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
  lineGeom.isLines = true;

  var lineMaterial = new THREE.LineBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    side: THREE.DoubleSide,
    opacity: 0.0, // will change with fade-in
    depthTest: false,
    depthWrite: false,
    blending: THREE.NoBlending // NOTE: Overlay target is blended anyway. So, using blend here would blend with black.
  });

  var lineMesh = new THREE.Mesh(lineGeom, lineMaterial);

  // Create THREE Scene and add meshes
  var scene = new THREE.Scene();
  scene.add(mesh);
  scene.add(lineMesh);

  // Workaround: Tag geometry as visible - otherwise it is skipped by computeObjectBounds (see Viewer3DImpl).
  // TODO: My guess is that this is a bug in LMV. Once we know for sure that it doesn't break anything
  //       we should change it in LMV instead and don't need to set this manually anymore.
  geometry.visible = true;
  lineGeom.visible = true;

  // Makes it more debugger-friendly (allow you to recognize this shape within LMV)
  mesh.name = 'FrustumGizmo';

  // Set frustum shape size
  // TODO: Consider smarter way to determine size, e.g. consider model units or model box
  var size = 50;
  scene.scale.set(size, size, size);

  // move tip of the frustum to camera position
  scene.position.copy(pos);

  // orient frustum shape to look towards camera direction
  var origin = new THREE.Vector3(0, 0, 0);
  var up = new THREE.Vector3(0, 0, 1);
  var invDir = new THREE.Vector3(-dir.x, -dir.y, -dir.z); // lookat directions in THREE are defined 'towards' an object
  var rotationMatrix = new THREE.Matrix4().lookAt(origin, invDir, up);
  scene.rotation.setFromRotationMatrix(rotationMatrix);

  // Just disable culling - it's not worth to care about computing BoundingSpheres etc.
  scene.frustumCulled = false;
  mesh.frustumCulled = false;
  lineMesh.frustumCulled = false;

  // Attach function to control overall opacity (fadeValue is in [0,1])
  scene.setFadeValue = function (fadeValue) {
    material.opacity = FrustumOpacity * fadeValue;
    lineMaterial.opacity = LineOpacity * fadeValue;
  };

  return scene;
}

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/HCluster.js":
/*!***************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/HCluster.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HCluster; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var

HCluster = /*#__PURE__*/function () {_createClass(HCluster, null, [{ key: "FlattenCluster", value: function FlattenCluster(
    c) {var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      if (c.value) {
        values.push(c.value);
      } else
      {
        HCluster.FlattenCluster(c.left, values);
        HCluster.FlattenCluster(c.right, values);
      }

      return values;
    } }, { key: "ComputeMeanValueForFlattenCluster", value: function ComputeMeanValueForFlattenCluster(

    c) {
      var bbox2D = new THREE.Box3();
      var bbox3D = new THREE.Box3();

      c.forEach(function (b) {
        bbox2D.expandByPoint(b.currentPosProjected);
        bbox3D.expandByPoint(b.currentPos3D);
      });

      return {
        center2D: bbox2D.center(),
        center3D: bbox3D.center() };

    } }]);

  function HCluster(clusterfck, distanceFunc) {var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;_classCallCheck(this, HCluster);
    this._clusterfck = clusterfck;
    this.setDistanceFuncAndThreshold(distanceFunc, threshold);
  }_createClass(HCluster, [{ key: "setDistanceFuncAndThreshold", value: function setDistanceFuncAndThreshold(

    distanceFunc) {var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      this._distanceFunc = distanceFunc;
      this._threshold = threshold;
    } }, { key: "setThreshold", value: function setThreshold(

    threshold) {
      this._threshold = threshold;
    } }, { key: "createClusters", value: function createClusters(

    clusterItems) {
      var clusters = this._clusterfck.hcluster(clusterItems, this._distanceFunc, this._clusterfck.AVERAGE_LINKAGE, this._threshold);
      //console.log(clusters);

      return clusters;
    } }]);return HCluster;}();

/***/ }),

/***/ "./extensions/AEC/DropMe/DropMe.css":
/*!******************************************!*\
  !*** ./extensions/AEC/DropMe/DropMe.css ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./DropMe.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/DropMe/DropMe.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/DropMe/DropMe.js":
/*!*****************************************!*\
  !*** ./extensions/AEC/DropMe/DropMe.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DropMeExtension; });
/* harmony import */ var _DropMeTool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DropMeTool.js */ "./extensions/AEC/DropMe/DropMeTool.js");
/* harmony import */ var _ViewObjectIn3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ViewObjectIn3D.js */ "./extensions/AEC/DropMe/ViewObjectIn3D.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}




var av = Autodesk.Viewing,avu = Autodesk.Viewing.UI;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.DropMeExtension';var

DropMeExtension = /*#__PURE__*/function (_av$Extension) {_inherits(DropMeExtension, _av$Extension);var _super = _createSuper(DropMeExtension);
  function DropMeExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { teleportOnRelease: true };_classCallCheck(this, DropMeExtension);
    _this = _super.call(this, viewer, options);

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.teleportOnRelease = options.teleportOnRelease; // teleportOnRelease used by default, not used on mobile apps.
    _this.viewer = viewer;
    _this._onModelLoaded = _this._onModelLoaded.bind(_assertThisInitialized(_this));
    _this._deactivateTool = _this._deactivateTool.bind(_assertThisInitialized(_this));
    _this._onViewportDataFetched = _this._onViewportDataFetched.bind(_assertThisInitialized(_this));
    _this.onDropOverride = null;
    _this.options = options;
    _this.options.triggerDeactivate = _this._deactivateTool;
    _this.toggleIndex = options.toggleIndex || 0; // at which position at the toolbar to toggle DropMe button
    _this.enableGuidance = options.enableGuidance || false;

    if (_this.options.enableViewIn3d) {
      _this.viewObjectIn3D = new _ViewObjectIn3D_js__WEBPACK_IMPORTED_MODULE_1__["default"](_assertThisInitialized(_this), viewer, _this.options);
    }return _this;
  }_createClass(DropMeExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this2 = this;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                  this.viewer.loadExtension('Autodesk.AEC.ViewportsExtension'));case 2:this.viewportsExtension = _context.sent;
                this.viewportsExtension.addEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this._onViewportDataFetched);

                this.dropMeTool = new _DropMeTool_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer, function () {return _this2._onDrop.apply(_this2, arguments);}, this);

                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._onModelLoaded);
                if (this.viewer.model) {
                  this._initUI(this.viewer.model);
                }return _context.abrupt("return",
                true);case 8:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      this.viewportsExtension.removeEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this._onViewportDataFetched);
      this.viewportsExtension = null;

      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._onModelLoaded);
      this.viewer.toolController.setIsLocked(false);
      this._deactivateTool();
      this._destroyUI();
      return true;
    } }, { key: "_onViewportDataFetched", value: function _onViewportDataFetched()

    {
      // It's ok to assume that there is a single 2D model when using DropMe.
      var model = this.viewer.model;

      if (model) {
        this._onModelLoaded({ model: this.viewer.model });
      }
    } }, { key: "setOnDrop", value: function setOnDrop(

    cb) {
      this.onDropOverride = cb;
    } }, { key: "_destroyUI", value: function _destroyUI()

    {
      this._showDrop(false);

      if (this.dropMeButton) {
        this.dropMeButton.removeFromParent();
        this.dropMeButton = null;
      }

      this.uiInitialized = false;
    } }, { key: "_onDrop", value: function _onDrop(

    pos, dir, mode, bubbleNode) {
      // after drop action had been triggered, we need to deactivate tool as we are transitioning into another view.
      if (this.teleportOnRelease) {
        this.viewer.toolController.setIsLocked(false);
        this._deactivateTool(true);
      }

      console.log("DropMe: 3D camera position is ".concat(JSON.stringify(pos)));
      console.log("DropMe: 3D camera direction is ".concat(JSON.stringify(dir)));
      this.dispatchEvent({ type: DropMeExtension.DROP_ME_EVENT, pos: pos, dir: dir, mode: mode, bubbleNode: bubbleNode });

      if (this.onDropOverride) {
        this.onDropOverride(pos, dir, mode, bubbleNode);
      } else if (this.options.onDrop) {
        this.options.onDrop(pos, dir, mode, bubbleNode);
      } else {
        console.warn('DropMe: No onDrop callback specified ');
      }
    } }, { key: "_onModelLoaded", value: function _onModelLoaded(

    event) {
      if (!this.uiInitialized) {
        this._initUI(event.model);
      } else {
        this._updateUI(event.model);
      }
    } }, { key: "_deactivateTool", value: function _deactivateTool(

    disableButton) {
      // UI might not be initialized yet. E.g., this can happen if the extensionUnload happens
      // before a model was added. In this case, dropMeButton and guidance UI will not exist anyway.
      if (this.uiInitialized) {
        this._showGuidenaceUI(false);

        this.dropMeButton.setState(disableButton ? avu.Button.State.DISABLED : avu.Button.State.INACTIVE);
      }

      this.viewer.toolController.deactivateTool('drop-me');
    } }, { key: "isSupportedModel", value: function isSupportedModel(

    model) {
      if (!(model === null || model === void 0 ? void 0 : model.is2d())) {
        return false;
      }

      var bubbleNode = model.getDocumentNode();

      if (!bubbleNode) {
        return false;
      }

      // onlyTopViewPlans is currently true by default anyway, but it's better to explicitly put it here so it will be clear that we request only top view viewports.
      //
      // Notice that filterAndFlattenViewports returns only the viewports that were already fetched and cached.
      // If other viewports will get added later (from an async provider) - it will trigger a VIEWPORT_DATA_FETCHED_EVENT event and we'll get here again.
      var viewports = this.viewportsExtension.filterAndFlattenViewports(bubbleNode, { onlyTopViewPlans: true });

      return viewports.length;
    } }, { key: "_updateUI", value: function () {var _updateUI2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(

      model) {var toolbar, controlGroup, isSupported;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                toolbar = this.viewer.getToolbar && this.viewer.getToolbar();if (
                toolbar) {_context2.next = 3;break;}return _context2.abrupt("return");case 3:



                this.dropMeButton.removeFromParent();

                controlGroup = toolbar.getControl(this.options.toolbarGroup || av.TOOLBAR.NAVTOOLSID);
                controlGroup.addControl(this.dropMeButton, { index: this.toggleIndex });
                isSupported = this.isSupportedModel(model);
                this._showDrop(isSupported);case 8:case "end":return _context2.stop();}}}, _callee2, this);}));function _updateUI(_x) {return _updateUI2.apply(this, arguments);}return _updateUI;}() }, { key: "_initUI", value: function _initUI(


    model) {var _this3 = this;
      // There is no need for this function when getToolbar doesn't exist (headless viewer).
      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();

      if (!toolbar) {
        return;
      }

      this.dropMeButton = new avu.Button('drop-me-icon');
      this.dropMeButton.icon.innerHTML = createDropMeIcon();

      this.dropMeButton.onClick = function () {
        if (_this3.dropMeTool.active) {
          _this3._deactivateTool();
        } else {
          _this3.dropMeButton.setState(avu.Button.State.ACTIVE);
          // TODO: when we activate tool we might want to forbid interaction with other tools
          _this3.viewer.toolController.activateTool('drop-me');
          _this3._showGuidenaceUI();
        }
      };
      this.uiInitialized = true;

      this._updateUI(model);
    } }, { key: "_showGuidenaceUI", value: function _showGuidenaceUI()

    {var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (!this.enableGuidance)
      return;

      if (show) {
        var _document = this.getDocument();
        this.guidenaceUI = _document.createElement('div');
        this.guidenaceUI.className = 'dropme-guidenace-ui';
        this.guidenaceUI.innerHTML = Autodesk.Viewing.i18n.translate('Click on a location to ground yourself, then select a camera direction');
        this.viewer.container.appendChild(this.guidenaceUI);
      } else {
        if (this.viewer.container.contains(this.guidenaceUI)) {
          this.viewer.container.removeChild(this.guidenaceUI);
        }
      }
    } }, { key: "_showDrop", value: function _showDrop(

    value) {
      if (!this.dropMeButton) {
        return;
      }

      var toolbar = this.viewer.getToolbar();
      var controlGroup = toolbar.getControl(this.options.toolbarGroup || av.TOOLBAR.NAVTOOLSID);

      if (controlGroup && !this.container) {
        this.dropMeButton.setState(value ? avu.Button.State.INACTIVE : avu.Button.State.DISABLED);
      }
      var supportedTooltip = Autodesk.Viewing.i18n.translate('Click a 2D location to view that space in 3D');
      var unsupportedTooltip = Autodesk.Viewing.i18n.translate('Current view is not supported by Place Me');

      this.dropMeButton.setToolTip(value ? supportedTooltip : unsupportedTooltip);
    } }]);return DropMeExtension;}(av.Extension);


var createDropMeIcon = function createDropMeIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">',
  '<g stroke="currentColor" fill="currentColor">',
  '<path d="M67,0c2.4.5,4.8.9,7.1,1.6C87.5,5.3,96.6,16.6,98,31a37.2,37.2,0,0,1-2.1,16.2c-4.7,13-23.6,48.1-31.6,58.2-.3-.2-.6-.3-.8-.5-11.1-17.6-21.9-35.4-30-54.7-4.6-10.9-4.6-21.7.6-32.3S47.5,2.6,58.3.7l3-.7ZM64,47A11.8,11.8,0,1,0,52.3,34.9,12,12,0,0,0,64,47Z"/>',
  '<path d="M12.8,103.4c1.4-8,6.9-12.3,14-14.6s12-2.9,18.1-4.2c1.1-.2,2.4.5,3.4,1.5-4.5,1.1-9.1,1.8-13.5,3.3a35,35,0,0,0-9.6,5c-4,3-4.3,7.5-.7,10.9a28.7,28.7,0,0,0,9.6,6.2,87.3,87.3,0,0,0,59.9.1,28.2,28.2,0,0,0,8.7-5.2c4.9-4.1,4.8-9.7-.8-12.8S90.7,89.3,85,87.3c-1.6-.6-3.4-.6-5.3-1.7,1.1-.4,2.2-1.2,3.2-1.1,7.8.9,15.5,2.2,22.6,6,12,6.4,13,17.9,2.1,26.1-8.1,6.1-17.6,8.5-27.4,10L69.1,128H59.2l-5.2-.7c-9.1-.8-18-2.6-26.4-6.5s-13.4-8.1-14.9-16.8Z"/>',
  '</g>',
  '</svg>'].
  join('');
};

namespace.DropMeExtension = DropMeExtension;
DropMeExtension.POSITION_FOUND_EVENT = 'POSITION_FOUND_EVENT';
DropMeExtension.OBJECT_SELECTED_EVENT = 'OBJECT_SELECTED_EVENT';
DropMeExtension.DROP_ME_EVENT = 'DROP_ME_EVENT';
DropMeExtension.DROP_ME_STARTED_EVENT = 'DROP_ME_STARTED_EVENT';

Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, DropMeExtension);

/***/ }),

/***/ "./extensions/AEC/DropMe/DropMeTool.js":
/*!*********************************************!*\
  !*** ./extensions/AEC/DropMe/DropMeTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DropMeTool; });
/* harmony import */ var _ViewPortOverlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewPortOverlay.js */ "./extensions/AEC/DropMe/ViewPortOverlay.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}



var av = Autodesk.Viewing,avp = av.Private;
var GlobalManagerMixin = av.GlobalManagerMixin;

var DROPME_MODE = { auto: 'Auto', manual: 'Manual' };var

DropMeTool = /*#__PURE__*/function (_av$ToolInterface) {_inherits(DropMeTool, _av$ToolInterface);var _super = _createSuper(DropMeTool);
  function DropMeTool(viewer, onDrop, extension) {var _this;_classCallCheck(this, DropMeTool);
    _this = _super.call(this);

    _this.names = ['drop-me'];
    _this.viewer = viewer;
    _this.setGlobalManager(_this.viewer.globalManager);
    _this.extension = extension;
    _this.options = extension.options;
    if (_this.options.teleportOnRelease === undefined) {
      _this.options.teleportOnRelease = true; // Set true by default
    }
    _this.viewer.toolController.registerTool(_assertThisInitialized(_this));
    _this.onDrop = onDrop;
    _this.active = false;
    _this._movedSinceFirstClick = false;

    _this.init();

    _this.cameraSelectionState = {
      pending: false,
      pos: null,
      target: null,
      inViewport: false,
      initialVp: null };


    _this.teleportationInProgress = 0;

    // 'False' indicates if the user has clicked a first time alredy to choose position, so that the
    // next click will determine view-direction and instantly invoke the transition.
    _this.isFirstClick = true;

    _this.viewPortOverlay = new _ViewPortOverlay_js__WEBPACK_IMPORTED_MODULE_0__["default"](_this.viewer);
    _this.escapeHotkeyId = 'Autodesk.AEC.DropMeToolEsc';return _this;
  }_createClass(DropMeTool, [{ key: "init", value: function init()

    {var _this2 = this;

      this.activate = function () {
        var gestureHandler = _this2.viewer.toolController.getTool("gestures");
        if (gestureHandler) {
          gestureHandler.setGestureParameter('drag', 'threshold', 0);
        }

        var hotkeys = [{
          keycodes: [
          Autodesk.Viewing.KeyCode.ESCAPE],

          onRelease: function onRelease() {return _this2.options.triggerDeactivate();} }];

        _this2.viewer.getHotkeyManager().pushHotkeys(_this2.escapeHotkeyId, hotkeys);
        _this2.viewer.addEventListener(av.MODEL_ADDED_EVENT, _this2.options.triggerDeactivate);
        _this2.viewer.impl.pauseHighlight(true);
        _this2.active = true;
        avp.analytics.track('viewer.place_me');
      };

      this.deactivate = function () {
        var gestureHandler = _this2.viewer.toolController.getTool("gestures");
        if (gestureHandler) {
          gestureHandler.restoreGestureParameterDefault('drag', 'threshold');
        }

        _this2.viewer.getHotkeyManager().popHotkeys(_this2.escapeHotkeyId);
        _this2._cancelTeleportation();
        _this2._destroyCameraSelectorUi();
        _this2.viewer.removeEventListener(av.MODEL_ADDED_EVENT, _this2.options.triggerDeactivate);
        _this2.viewer.impl.pauseHighlight(false);
        _this2.active = false;
        _this2._movedSinceFirstClick = false;
      };

      this.handleButtonDown = function (event) {
        return true;
      };

      this.handleButtonUp = function (event) {
        if (!this._movedSinceFirstClick || this.isFirstClick) {
          return false;
        }
        return true;
      };

      this.handleSingleClick = function (e, isTouch) {
        if (_this2.isFirstClick) {
          var tmpres = _this2._get3DCameraPositionAndVp(e.canvasX, e.canvasY);
          if (tmpres && tmpres.pos) {
            _this2.cameraSelectionState.pos = { x: e.canvasX, y: e.canvasY };
            _this2.cameraSelectionState.pending = true;
            _this2.cameraSelectionState.initialVp = tmpres.vp;

            _this2._createCameraSelectorUi(_this2.cameraSelectionState.pos);

            requestAnimationFrame(function () {
              // We should only trigger animation if mouse has not been moved since the first click.
              if (!_this2._movedSinceFirstClick)
              _this2.cameraSelectorPosition.classList.add('camera-selector-position--teleporting');
            });

            if (tmpres.vp.isTopViewViewport() && !isTouch) {
              // while teleportation is pending this.handleMouseMove will move camera frustum
              _this2._scheduleTeleportation();

              // needed only for scheduled teleportation
              _this2.isFirstClick = false;
              _this2.cursor = 'none';
              _this2.getCursor();
            } else
            {
              _this2._runTeleportation(DROPME_MODE.auto);
            }
          }
        } else
        {
          if (_this2.options.teleportOnRelease) {
            _this2.teleport();
          }
        }

        // As expectation of single click is a teleportation to another view, we simply consume event and do not propogate it further
        return true;
      };

      this.teleport = function () {
        _this2.cameraSelectionState.target = { x: _this2.lastX, y: _this2.lastY };
        _this2._runTeleportation(DROPME_MODE.manual);
        _this2.isFirstClick = _this2.options.teleportOnRelease;
        _this2._movedSinceFirstClick = false;
        _this2._recoverCursor();
      };

      this.handleMouseMove = function (e) {
        if (!_this2.isFirstClick && !_this2._movedSinceFirstClick)
        _this2._movedSinceFirstClick = true;

        if (_this2.cursor)
        _this2._recoverCursor();

        var tmpres = _this2._get3DCameraPositionAndVp(e.canvasX, e.canvasY);

        if (_this2.cameraSelectionState.initialVp && !_this2.isFirstClick) {
          _this2._addVpOverlay(_this2.cameraSelectionState.initialVp);
        } else
        if (tmpres && tmpres.pos) {
          _this2._addVpOverlay(tmpres.vp);
        } else
        {
          _this2.viewPortOverlay.removeOverlay();
        }

        _this2.cameraSelectionState.inViewport = _this2.isFirstClick && tmpres && tmpres.pos || !_this2.isFirstClick;
        _this2.getCursor();

        if (!_this2.cameraSelectionState.pending) {
          return;
        }

        if (_this2.teleportationInProgress) {
          // cancel position animation
          _this2.cameraSelectorPosition.classList.remove('camera-selector-position--teleporting');
          clearTimeout(_this2.teleportationInProgress);
          _this2.teleportationInProgress = 0;
        }

        _this2.lastX = e.canvasX;
        _this2.lastY = e.canvasY;
        var dx = e.canvasX - _this2.cameraSelectionState.pos.x;
        var dy = e.canvasY - _this2.cameraSelectionState.pos.y;
        var angle = Math.atan2(dy, dx) * 180 / Math.PI;

        // In case the mouse moved:
        if (dx !== 0 || dy !== 0) {
          // atan measures the angle to the x-axis, but the frustum gizmo is originally aligned with y.
          angle += 90;
        }

        _this2.cameraSelector.style.transform = "rotate(".concat(angle, "deg)");

        if (!_this2.options.teleportOnRelease) {
          _this2.teleport();
        }

        //console.log(angle);
        return true;
      };

      this.handleSingleTap = function (event) {
        return this.handleSingleClick(event, true);
      };

      this.handleResize = function () {
        // As teleportation is going to be rather short interaction with a short-living UI, we just do not handle screen resize at all for now, but deactivate tool instead.
        _this2.options.triggerDeactivate();
      };

      this.handleSingleTap = function (event, button) {
        if (_this2.isFirstClick) {
          _this2.handleSingleClick(event);
        } else {
          _this2.handleMouseMove(event);
        }
      };

      this.handleGesture = function (event) {
        switch (event.type) {
          case 'dragstart':
            break;
          case 'dragmove':
            return _this2.handleMouseMove(event, 0);
          case 'dragend':
            return true;
          case 'panmove':
          case 'panstart':
          case 'panend':
          case 'pinchmove':
          case 'pinchstart':
          case 'pinchend':
            return true;
          default:
            break;}


        return false;
      };
    } }, { key: "_recoverCursor", value: function _recoverCursor()

    {
      this.cursor = null;
      this.getCursor();
    } }, { key: "getCursor", value: function getCursor()

    {
      if (this.cursor)
      return this.cursor;
      return this.cameraSelectionState.inViewport ? 'cell' : 'default';
    } }, { key: "_addVpOverlay", value: function _addVpOverlay(

    vp) {
      this.viewPortOverlay.removeOverlay();
      var vpRect = vp.getViewportBounds(this.viewer.model.getUnitScale());
      var min = vpRect.min;
      var max = vpRect.max;
      this.viewPortOverlay.addOverlay(min.x, min.y, max.x, max.y);
    }

    // mode is only required for analytics purposes
  }, { key: "_runTeleportation", value: function _runTeleportation(mode) {
      // Use this event in order to show a loading spinner until the drop-me is done.
      this.extension.dispatchEvent({ type: Autodesk.AEC.DropMeExtension.DROP_ME_STARTED_EVENT });

      this._mapToCameraPositionIn3D(mode);

      // Although _mapToCameraPositionIn3D runs async functions, we do want to call triggerDeactivate right now,
      // Since it might take a few seconds until we'll get all the required data in order to load the 3D model.
      // Until then, disable button until dropping into the 3D model.
      this.options.triggerDeactivate(true);
    } }, { key: "_scheduleTeleportation", value: function _scheduleTeleportation()

    {var _this3 = this;
      this.teleportationInProgress = setTimeout(function () {
        _this3._runTeleportation(DROPME_MODE.auto);
      }, 3000); // this timeout is alligned with coresponding rule of camera-selector-position css class
    } }, { key: "_cancelTeleportation", value: function _cancelTeleportation()

    {
      if (this.teleportationInProgress) {
        clearTimeout(this.teleportationInProgress);
        this.teleportationInProgress = 0;
      }
    } }, { key: "_createCameraSelectorUi", value: function _createCameraSelectorUi(

    pos) {
      //console.log(`camera position at ${pos.x}, ${pos.y}`);
      var _document = this.getDocument();
      this.cameraSelectorBackground = _document.createElement('div');
      this.cameraSelectorBackground.className = 'camera-selector-background';
      this.viewer.container.appendChild(this.cameraSelectorBackground);
      this.cameraSelectorBackground.style.top = "".concat(pos.y, "px");
      this.cameraSelectorBackground.style.left = "".concat(pos.x, "px");

      this.cameraSelectorPosition = _document.createElement('div');
      this.cameraSelectorPosition.className = 'camera-selector-position';
      this.viewer.container.appendChild(this.cameraSelectorPosition);
      this.cameraSelectorPosition.style.top = "".concat(pos.y - 10, "px");
      this.cameraSelectorPosition.style.left = "".concat(pos.x - 10, "px");

      this.cameraSelector = _document.createElement('div');
      this.cameraSelector.className = 'camera-selector';
      this.viewer.container.appendChild(this.cameraSelector);
      this.cameraSelector.style.top = "".concat(pos.y - 100, "px");
      this.cameraSelector.style.left = "".concat(pos.x - 50, "px");
    } }, { key: "_destroyCameraSelectorUi", value: function _destroyCameraSelectorUi()

    {
      if (this.viewer.container.contains(this.cameraSelector)) {
        this.viewer.container.removeChild(this.cameraSelector);
      }

      if (this.viewer.container.contains(this.cameraSelectorBackground)) {
        this.viewer.container.removeChild(this.cameraSelectorBackground);
      }

      if (this.viewer.container.contains(this.cameraSelectorPosition)) {
        this.viewer.container.removeChild(this.cameraSelectorPosition);
      }

      this.cameraSelectionState = {
        pending: false,
        pos: null,
        target: null,
        inViewport: false,
        initialVp: null };


      this.isFirstClick = true;

      this.viewPortOverlay.removeOverlay();
    }

    // Given F2D world coords (Vec3), this function returns the viewport that was hit.
  }, { key: "_findViewport", value: function _findViewport(f2dWorldPos) {
      var p2d = new THREE.Vector2(f2dWorldPos.x, f2dWorldPos.y);
      var sheet = this.viewer.model;

      // onlyTopViewPlans is currently true by default anyway, but it's better to explicitly put it here so it will be clear that we request only top view viewports.
      var viewport = this.extension.viewportsExtension.findViewportAtPoint(sheet, p2d, { onlyTopViewPlans: true });

      return viewport;
    } }, { key: "_mapToCameraPositionIn3DForFloorPlan", value: function () {var _mapToCameraPositionIn3DForFloorPlan2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(

      vp, pos, mode) {var _this$options$getMain, _this$options;var sheetNode, main3DNode, target, posGeorefed, dir, x, y, resTarget, targetGeorefed, dirX, dirY, rotAxis;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                sheetNode = this.viewer.model.getDocumentNode();
                main3DNode = (_this$options$getMain = (_this$options = this.options).getMain3DView) === null || _this$options$getMain === void 0 ? void 0 : _this$options$getMain.call(_this$options, sheetNode);

                // Store target here before reaching to the async parts - to make sure that it won't get cleared until we'll need to use it.
                target = this.cameraSelectionState.target;if (

                main3DNode) {_context.next = 7;break;}_context.next = 6;return (
                  vp.get3DNodesForViewport());case 6:main3DNode = _context.sent[0];case 7:


                posGeorefed = pos;if (!

                vp.isMatrixInLocalCoords()) {_context.next = 12;break;}_context.next = 11;return (
                  this._applyModelToViewerTransform(pos, main3DNode));case 11:posGeorefed = _context.sent;case 12:


                dir = new THREE.Vector3(0.0, 1.0, 0.0);

                // in the case of not specified target, use north direction
                if (!target) {_context.next = 26;break;}
                x = target.x;
                y = target.y;

                resTarget = this._get3DCameraPositionAndVp(x, y, true);if (!(
                resTarget && resTarget.pos)) {_context.next = 26;break;}
                targetGeorefed = resTarget.pos;if (!

                vp.isMatrixInLocalCoords()) {_context.next = 23;break;}_context.next = 22;return (
                  this._applyModelToViewerTransform(resTarget.pos, main3DNode));case 22:targetGeorefed = _context.sent;case 23:


                dirX = targetGeorefed.x - posGeorefed.x;
                dirY = targetGeorefed.y - posGeorefed.y;

                if (dirX !== 0 || dirY !== 0) {
                  dir.setX(dirX).setY(dirY);
                  dir.normalize();
                }case 26:



                // mimic natural looking direction which is not really parallel to the ground
                rotAxis = new THREE.Vector3(-dir.y, dir.x, 0.0);
                dir.applyAxisAngle(rotAxis, Math.PI / 18.0); // 10 degrees

                this.onDrop(posGeorefed, dir, mode, main3DNode);case 29:case "end":return _context.stop();}}}, _callee, this);}));function _mapToCameraPositionIn3DForFloorPlan(_x, _x2, _x3) {return _mapToCameraPositionIn3DForFloorPlan2.apply(this, arguments);}return _mapToCameraPositionIn3DForFloorPlan;}()


    // Notice that this path is currently not reachable, since `filterAndFlattenViewports` returns only topViewViewports by default.
    // If a section viewport support is required in the future, just supply different flags to it.
  }, { key: "_mapToCameraPositionIn3DForSection", value: function () {var _mapToCameraPositionIn3DForSection2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(vp, pos, mode) {var _this$options$getMain2, _this$options2;var sheetNode, main3DNode, posGeorefed, dir, rotAxis;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                sheetNode = this.viewer.model.getDocumentNode();
                main3DNode = (_this$options$getMain2 = (_this$options2 = this.options).getMain3DView) === null || _this$options$getMain2 === void 0 ? void 0 : _this$options$getMain2.call(_this$options2, sheetNode);if (

                main3DNode) {_context2.next = 6;break;}_context2.next = 5;return (
                  vp.get3DNodesForViewport());case 5:main3DNode = _context2.sent[0];case 6:


                posGeorefed = pos;if (!
                vp.isMatrixInLocalCoords()) {_context2.next = 11;break;}_context2.next = 10;return (
                  this._applyModelToViewerTransform(pos, main3DNode));case 10:pos = _context2.sent;case 11:


                // by default we are looking into the north direction, in this case "into the screen"
                dir = new THREE.Vector3(0.0, 1.0, 0.0);

                // mimic natural looking direction which is not really parallel to the ground
                rotAxis = new THREE.Vector3(-dir.y, dir.x, 0.0);
                dir.applyAxisAngle(rotAxis, Math.PI / 18.0); // 10 degrees

                this.onDrop(posGeorefed, dir, mode, main3DNode);case 15:case "end":return _context2.stop();}}}, _callee2, this);}));function _mapToCameraPositionIn3DForSection(_x4, _x5, _x6) {return _mapToCameraPositionIn3DForSection2.apply(this, arguments);}return _mapToCameraPositionIn3DForSection;}()


    // if we will come up with a good visualization widget for dir selection for "Section" views
    // the two methods "_mapToCameraPositionIn3DForFloorPlan()" and "_mapToCameraPositionIn3DForSection()"
    // could be unified. we will still have two cases in "if (resTarget && resTarget.pos) {...}" code path
    //   1. FloorPlan: x,y - change, z - constant
    //   2. Section:   x - changes, y,z - constant
  }, { key: "_mapToCameraPositionIn3D", value: function _mapToCameraPositionIn3D() {var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DROPME_MODE.manual;
      var x = this.cameraSelectionState.pos.x;
      var y = this.cameraSelectionState.pos.y;
      var resPos = this._get3DCameraPositionAndVp(x, y);

      if (resPos && resPos.pos && resPos.vp) {
        if (resPos.vp.isTopViewViewport()) {
          this._mapToCameraPositionIn3DForFloorPlan(resPos.vp, resPos.pos, mode);
        } else {
          this._mapToCameraPositionIn3DForSection(resPos.vp, resPos.pos, DROPME_MODE.auto);
        }

      }
    } }, { key: "_get3DCameraPositionAndVp", value: function _get3DCameraPositionAndVp(

    x, y) {var useInitialVp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var vpVec = this.viewer.impl.clientToViewport(x, y);
      var point = this.viewer.impl.intersectGroundViewport(vpVec);

      // if no viewport can be found for the current mouse position on a second click, try to use initial viewport
      var hitViewport = this._findViewport(point) || useInitialVp && this.cameraSelectionState.initialVp;
      if (!hitViewport) {
        // Clicked outside of the viewport
        // DropMe tool remains active and allows user to pick another point
        return null;
      }

      // Get unitScale for current sheet
      var sheetUnitScale = this.viewer.model.getUnitScale();

      // Apply 2D->3D transform to get 3D world coords
      var vpTransform = hitViewport.get2DTo3DMatrix(sheetUnitScale);
      var pWorld = point.clone().applyMatrix4(vpTransform);

      // Derive z from level metadata
      var level = hitViewport.findLevelForViewport();
      var isFloorPlan = hitViewport.isFloorPlan();

      // Only add additional 1.75m to a floorPlan viewport type.
      // Other types not necessarily located at the floor height and changing their elevation might result in incorrect position.
      if (level && isFloorPlan) {
        var avatarHeight = 5.74147; // 1.75m
        pWorld.z = level.elevation + avatarHeight;
      }

      return {
        pos: pWorld,
        vp: hitViewport };

    }

    // Default function that extracts refPointTransform from the root node.
  }, { key: "_applyModelToViewerTransform", value: function () {var _applyModelToViewerTransform2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(pos, bubbleNode) {var vec, matrix, root;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                vec = pos.clone();

                // Skip refPoint transform if wanted
                if (!this.options.useLocalModelCoords) {_context3.next = 3;break;}return _context3.abrupt("return",
                vec);case 3:if (!(




                bubbleNode && this.options.getTransformForNode)) {_context3.next = 7;break;}_context3.next = 6;return (


                  this.options.getTransformForNode(bubbleNode));case 6:matrix = _context3.sent;case 7:


                if (!matrix) {
                  // This extension requires AEC model data, so there should always be a refPoint tranform
                  root = this.viewer.model.getDocumentNode().getRootNode();
                  matrix = root.extractRefPointTransform();
                }

                vec.applyMatrix4(matrix);return _context3.abrupt("return",

                vec);case 10:case "end":return _context3.stop();}}}, _callee3, this);}));function _applyModelToViewerTransform(_x7, _x8) {return _applyModelToViewerTransform2.apply(this, arguments);}return _applyModelToViewerTransform;}() }]);return DropMeTool;}(av.ToolInterface);



GlobalManagerMixin.call(DropMeTool.prototype);

/***/ }),

/***/ "./extensions/AEC/DropMe/ViewObjectIn3D.js":
/*!*************************************************!*\
  !*** ./extensions/AEC/DropMe/ViewObjectIn3D.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewObjectIn3D; });
/* harmony import */ var _levels_LevelUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../levels/LevelUtils */ "./extensions/AEC/levels/LevelUtils.js");
/* harmony import */ var _DropMe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DropMe.js */ "./extensions/AEC/DropMe/DropMe.js");
function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;
var avp = av.Private;
/*
                      //   This file contains the logic of choosing the right position to watch a selected object in the 3D scene.
                      //   The logic of choosing the right position is created in steps:
                      //   1) Creating 8 different positions around the selected object.
                      //   2) Check if there are intersections between the optional positions to the selected object.
                      //      Choose the ones which have the least intersections, and ignore positions which looks on very narrow sides of the object
                      //      (like in doors and walls).
                      //   3) From the chosen positions, check more intersections between the position and different points on the object.
                      //      Choose the one with the least intersections. If there are more then one with the same - choose the closest.
                      //   If this logic is happening after the geometry was already loaded, we check intersections with raycast and actual geometries.
                      //   If it happens before geometry was loaded we will wait for the bounding-boxes and check intersections with them.
                      //   
                      //   While waiting for the geometry to load, there is an interval that is eliminating objects that are hiding the object during the
                      //   waiting time.
                      */var

ViewObjectIn3D = /*#__PURE__*/function () {

  function ViewObjectIn3D(dropMeExt, viewer, options) {var _this = this;_classCallCheck(this, ViewObjectIn3D);

    this.viewer = viewer;
    this.dropMeExt = dropMeExt;
    this.options = options;
    this._onModelAdded = this._onModelAdded.bind(this);
    this._onGeometryLoaded = this._onGeometryLoaded.bind(this);
    this._onModelUnloaded = this._onModelUnloaded.bind(this);
    this._onAggregatedSelectionChanged = this._onAggregatedSelectionChanged.bind(this);

    this.viewer.registerContextMenuCallback('ViewObjectIn3D', function (menu, status) {
      var is2d = _this.viewer.model.is2d();
      var isSupported = _this.options.enableViewIn3d && _this.dropMeExt.isSupportedModel(_this.viewer.model);
      var selected = isSupported && _this.viewer.getAggregateSelection();
      if (is2d && selected && selected.length === 1 && selected[0].selection.length === 1) {
        _this.pos3dFrom2d = _this._getSelected3dPosFrom2d(selected[0].selection[0], selected[0].model);
        menu.push({
          title: "View in 3D",
          target: function target() {return _this.selectObject(selected[0].selection[0]);} });

      }
    });
  }_createClass(ViewObjectIn3D, [{ key: "selectObject", value: function selectObject(

    selectedObjectID) {
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._onModelAdded, { once: true });
      this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this._onGeometryLoaded);
      this.viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this._onModelUnloaded);
      this.viewer.addEventListener(av.AGGREGATE_SELECTION_CHANGED_EVENT, this._onAggregatedSelectionChanged);
      this.selectedObjectID = selectedObjectID;
      this.dropMeExt.dispatchEvent({ type: _DropMe_js__WEBPACK_IMPORTED_MODULE_1__["default"].OBJECT_SELECTED_EVENT, selectedObjectID: selectedObjectID });
      if (this.options.onDrop) {var _this$options$getMain, _this$options;
        var sheetNode = this.viewer.model.getDocumentNode();
        var main3DNode = (_this$options$getMain = (_this$options = this.options).getMain3DView) === null || _this$options$getMain === void 0 ? void 0 : _this$options$getMain.call(_this$options, sheetNode);
        this.options.onDrop(undefined, undefined, undefined, main3DNode);
      }
      avp.analytics.track('viewer.view_in_3d');
    }

    // If another object was selected while waiting for the model to load, stop other selections.
  }, { key: "_onAggregatedSelectionChanged", value: function _onAggregatedSelectionChanged(selection) {
      var selected = selection.selections && selection.selections.length === 1 && selection.selections[0];
      var dbId = selected.dbIdArray && selected.dbIdArray.length === 1 && selected.dbIdArray[0];
      if (dbId === this.selectedObjectID || !selection.selections.length) {
        return;
      }

      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);
      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this._onGeometryLoaded);
      this.viewer.removeEventListener(av.AGGREGATE_SELECTION_CHANGED_EVENT, this._onAggregatedSelectionChanged);
      this.chosenPos = null;
      this.selectedObjectID = null;
    } }, { key: "_onModelAdded", value: function _onModelAdded(_ref)

    {var _this2 = this;var model = _ref.model;
      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);

      if (!this.selectedObjectID || !model.is3d()) {
        return;
      }

      this._waitForAllModels().then(function () {return _this2._placeMeToObject();});
    } }, { key: "_onModelUnloaded", value: function _onModelUnloaded()

    {
      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);
    } }, { key: "_placeMeToObject", value: function _placeMeToObject()

    {var _this3 = this;

      this.isGeometryLoaded = this._loadingAllGeometriesDone();

      // Get the objects bounding boxes
      var boxes = this._getAllBoundingBoxes();
      this.selectionBox = boxes[this.selectedObjectID];

      if (!this.selectionBox) {
        // In case the selected object doesn't have a bounding box, locate the camera
        // based on the 2D position and size of the selected object.
        if (this.pos3dFrom2d) {
          // look forward along the y axis
          var target = this.pos3dFrom2d.clone().add(new THREE.Vector3(0, 1, 0));
          this.dropMeExt.dispatchEvent({
            type: _DropMe_js__WEBPACK_IMPORTED_MODULE_1__["default"].POSITION_FOUND_EVENT,
            position: this.pos3dFrom2d,
            target: target,
            isPosFrom2dTo3dMatrix: true });

          if (this.options.onHandleViewIn3D) {
            this.options.onHandleViewIn3D(this.pos3dFrom2d, target, true);
          }
        }
        return;
      } else {
        this._setBoundingBoxPoints();

        // Separate the selected object's bounding box
        this.selectionCenter = this.selectionBox.center();
        delete boxes[this.selectedObjectID];
      }

      // Create 8 optional positions around the selected target
      var optionalPositionsObjects = this._createCandidates();

      // Create a list of relatively close objects, so we don't check intersections with
      // un-relevant objects and decrease performance.
      var closeBoxesKeys = this._getCloseBoxesKeys(boxes);

      // Choose the position options which have the least interferences
      var betterOptions = this._getBetterCandidates(optionalPositionsObjects, boxes, closeBoxesKeys);

      // Choose the best option from the betterOptions
      this.chosenPos = this._chooseBestCandidate(betterOptions, boxes, closeBoxesKeys);

      // console.log('Chosen Position >> ', this.chosenPos.index, this.chosenPos);

      var applySelectionCB = function applySelectionCB() {return _this3._applySelections(_this3.chosenPos);};
      // Notify about the chosen position
      this.dropMeExt.dispatchEvent({
        type: _DropMe_js__WEBPACK_IMPORTED_MODULE_1__["default"].POSITION_FOUND_EVENT,
        position: this.chosenPos.position,
        target: this.selectionCenter,
        applySelectionCB: applySelectionCB });

      if (this.options.onHandleViewIn3D) {
        this.options.onHandleViewIn3D(this.chosenPos.position, this.selectionCenter, false, applySelectionCB);
      }

      if (!this.isGeometryLoaded) {
        this._waitForAllInstanceTrees().then(function () {
          _this3.hidingObjectInterval && clearInterval(_this3.hidingObjectInterval);
          _this3.hidingObjectInterval = setInterval(function () {return _this3._hideCurrentIntersections();}, ViewObjectIn3D.HIDING_INTERVAL_FREQUENCY);
        });
      }
    } }, { key: "_getAllBoundingBoxes", value: function _getAllBoundingBoxes()

    {
      var boxes = {};
      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; i++) {
        var fragmentList = models[i].getFragmentList();
        boxes = Object.assign(boxes, this._getBoundingBoxes(fragmentList));
      }
      return boxes;
    } }, { key: "_getBoundingBoxes", value: function _getBoundingBoxes(

    fragmentList) {
      var boxes = {};
      var tmpBox = new THREE.Box3();
      for (var fragId = 0; fragId < fragmentList.fragments.length; fragId++) {
        var dbid = fragmentList.fragments.fragId2dbId[fragId];
        if (!boxes[dbid]) {
          boxes[dbid] = new THREE.Box3();
        }
        fragmentList.getWorldBounds(fragId, tmpBox);
        boxes[dbid].union(tmpBox);
      }

      return boxes;
    } }, { key: "_createCandidates", value: function _createCandidates()

    {

      var height = this._getHeight(this.selectionCenter.z);
      this.maxDistance = Number.MIN_VALUE;

      // Checks if the object has a very wide side relatively to it's other side so we can ignore
      // angles that look at it from the narrower side.
      var rightVec = this.viewer.navigation.getWorldRightVector();
      var upVec = this.viewer.navigation.getWorldUpVector();
      var frontVec = upVec.cross(rightVec);
      var size = this.selectionBox.size();

      var rightSide = Math.abs(size.clone().multiply(rightVec).length());
      var frontSide = Math.abs(size.clone().multiply(frontVec).length());

      var widerVector;
      var wideSide = Math.max(rightSide, frontSide);
      var narrowSide = Math.min(rightSide, frontSide);
      if (wideSide / narrowSide > ViewObjectIn3D.COVERAGE_FACTOR)
      widerVector = wideSide === rightSide ? rightVec : frontVec;

      // Set the camera to be Perspective before calling this.viewer.navigation.computeFit
      // so we will get the right positions for bimwalk.
      this.viewer.navigation.toPerspective();

      var options = [];
      for (var index = 0; index < ViewObjectIn3D.NUMBER_OF_POSITION; ++index) {
        var angle = index / (ViewObjectIn3D.NUMBER_OF_POSITION / 2) * Math.PI;

        // get a positon that fits the the selected object to view
        var newPos = this.selectionCenter.clone().add(new THREE.Vector3(Math.cos(angle), -Math.sin(angle), 0));
        var fov = this.viewer.navigation.getVerticalFov();
        var camera = this.viewer.getCamera();
        var aspect = camera.aspect;
        var optionalPositionObject = this.viewer.navigation.computeFit(newPos, this.selectionCenter, fov, this.selectionBox, aspect);var
        position = optionalPositionObject.position;

        // get the camera a bit further from the object
        var direction = position.clone().sub(this.selectionCenter);
        position.add(direction.clone().multiplyScalar(0.1));

        // set the height
        position.z = height;

        // If the wider side dot eye vector is greater then 0.8 we would like to ignore this position. 
        var dot = widerVector && direction.normalize().dot(widerVector);
        var ignore = dot && Math.abs(dot) > Math.cos(THREE.Math.degToRad(ViewObjectIn3D.IGNORE_ANGLE));

        // create a ray from the optional position towards the selected target and compute distances
        var newDiff = this.selectionCenter.clone().sub(position.clone());
        var dir = newDiff.clone().normalize();
        var ray = new THREE.Ray(position.clone(), dir.clone());
        var intersectionPos = ray.intersectBox(this.selectionBox);
        var distanceToTarget = intersectionPos && intersectionPos.sub(position).length();
        var distanceToCenterTarget = newDiff.length();

        // this.maxDistance is used to remove un-relevant objects from calculations to improve performance
        this.maxDistance = Math.max(this.maxDistance, distanceToTarget, distanceToCenterTarget);

        // When the bounding box's size is 0 in one or more dimensions, the ray can miss the object, and in that case we eliminate this option.
        distanceToTarget && !ignore && options.push({
          index: index,
          position: position,
          ray: ray,
          distanceToTarget: distanceToTarget,
          distanceToCenterTarget: distanceToCenterTarget,
          selectionID: this.selectedObjectID,
          intersections: [],
          cornerIntersections: [],
          cornerIntersectionsToHide: [] });

      }

      return options;
    } }, { key: "_getClientViewBoundingBox", value: function _getClientViewBoundingBox(

    camera) {
      var clientBB = new THREE.Box3();
      for (var k = 0; k < this.boundingBoxPoints.length; k++) {
        var vec = this.boundingBoxPoints[k];
        var point = this.viewer.impl.worldToClient(vec, camera);
        if (clientBB.min.x > point.x) clientBB.min.x = point.x;
        if (clientBB.max.x < point.x) clientBB.max.x = point.x;
        if (clientBB.min.y > point.y) clientBB.min.y = point.y;
        if (clientBB.max.y < point.y) clientBB.max.y = point.y;
      }
      return clientBB;
    } }, { key: "_setBoundingBoxPoints", value: function _setBoundingBoxPoints()

    {
      this.boundingBoxPoints = [];
      for (var k = 0; k < 8; k++) {
        var vec = new THREE.Vector3();
        vec.x = !!(k & 0x1) === false ? this.selectionBox.max.x : this.selectionBox.min.x;
        vec.y = !!(k & 0x2) === false ? this.selectionBox.max.y : this.selectionBox.min.y;
        vec.z = !!(k & 0x4) === false ? this.selectionBox.max.z : this.selectionBox.min.z;
        this.boundingBoxPoints.push(vec);
      }
    } }, { key: "_getCloseBoxesKeys", value: function _getCloseBoxesKeys(

    boxes) {var _this4 = this;
      return Object.keys(boxes).filter(function (key) {
        var center = boxes[key].center();
        var diff = center.clone().sub(_this4.selectionCenter);
        var dist = diff.length();
        return dist < _this4.maxDistance * ViewObjectIn3D.DISTANCE_FACTOR;
      });
    }

    // Choose the position options which have the least interferences
  }, { key: "_getBetterCandidates", value: function _getBetterCandidates(optionalPositionsObjects, boxes, closeBoxesKeys) {var _this5 = this;

      var betterOptions = [];
      var minIntersects = Number.POSITIVE_INFINITY;var _loop = function _loop(

      i) {
        var posObj = optionalPositionsObjects[i];

        // This check is done on the object's bounding boxes and is used in cases when the geometry is not loaded yet.
        if (!_this5.isGeometryLoaded) {
          // Intersections between the camera's position and the object's bounding box
          posObj.intersections = _this5._getIntersectionsOfRayWithBoundingBoxes(posObj, posObj.ray, minIntersects, boxes, closeBoxesKeys);
        } else {
          var candidates = [];
          posObj.intersections = [];
          _this5.viewer.impl.rayIntersect(posObj.ray, false, false, false, candidates);
          var distToObject = _this5._getClosestIntersectionWithSelectedObject(candidates);
          if (!distToObject) {
            // If no intersection with object, use the distance to it's center.
            distToObject = posObj.distanceToCenterTarget;
          } else {
            // If there is an intersection with object - use it, instead of the not-always-accurate the distance to the bounding-box.
            posObj.distanceToTarget = distToObject;
          }

          // Consider only intersections that are closer than the selected object's intersection.
          candidates.forEach(function (item) {
            if (item.dbId !== _this5.selectedObjectID && posObj.intersections.indexOf(item.dbId) === -1 && item.distance < distToObject) {
              posObj.intersections.push(item.dbId);
            }
          });
        }

        // Make a list of the optional positions that have the least objects interfering
        if (posObj.intersections.length === minIntersects) {
          betterOptions.push(posObj);
        } else if (posObj.intersections.length < minIntersects) {
          betterOptions = [posObj];
          minIntersects = posObj.intersections.length;
        }};for (var i = 0; i < optionalPositionsObjects.length; ++i) {_loop(i);
      }

      return betterOptions;
    }

    // Choose the best option from the betterOptions
  }, { key: "_chooseBestCandidate", value: function _chooseBestCandidate(betterOptions, boxes, closeBoxesKeys) {var _this6 = this;

      var chosenPos;
      var minIntersections = Number.MAX_VALUE;
      betterOptions.forEach(function (posObj) {

        chosenPos = chosenPos || posObj;

        // Create rays from the optional position to 8 corenrs of the selected object's bounding box
        // and store the intersections
        for (var k = 0; k < _this6.boundingBoxPoints.length; k++) {
          var vec = _this6.boundingBoxPoints[k];

          // Choose a point that is slightly towards the center of the object
          var offset = vec.clone().sub(_this6.selectionCenter).multiplyScalar(0.1);
          vec.sub(offset);

          // To Do: If geometry is already loaded: find a better way to choose more points on the object.

          var dir = vec.clone().sub(posObj.position).normalize();
          var ray = new THREE.Ray(posObj.position.clone(), dir);

          var cornerIntersections = [];

          if (!_this6.isGeometryLoaded) {
            cornerIntersections = _this6._getIntersectionsOfRayWithBoundingBoxes(posObj, ray, minIntersections, boxes, closeBoxesKeys);
          } else {var _ret = function () {
              _this6.viewer.impl.rayIntersect(ray, false, false, false, cornerIntersections);
              var distToObject = _this6._getClosestIntersectionWithSelectedObject(cornerIntersections);
              // If no intersection with the selected object, don't check intersections with other objects for this corner.
              if (!distToObject) {
                return "continue";
              }

              // Consider only objects that are closer then the selected object's intersection.
              cornerIntersections = cornerIntersections.filter(function (intersection) {return intersection.dbId !== _this6.selectedObjectID && intersection.distance <= distToObject;});
              cornerIntersections = cornerIntersections.map(function (intersection) {return intersection.dbId;});}();if (_ret === "continue") continue;
          }

          // This list is made for help choosing the right position.
          // Make the array of corner intersections to be of unique ones.
          if (cornerIntersections.length) {var _posObj$cornerInterse;
            (_posObj$cornerInterse = posObj.cornerIntersections).push.apply(_posObj$cornerInterse, _toConsumableArray(cornerIntersections));
            posObj.cornerIntersections = _toConsumableArray(new Set(posObj.cornerIntersections));
            // No need to continiune checking in case there are more intersections then the minimum (of the current chosen one).
            if (posObj.cornerIntersections.length > minIntersections) break;
          }

          // This is a list of objects to hide in case this optional position will be chosen.
          // We would like to hide only objects that were intersected with the front parts of the bounding box.
          if (_this6.isGeometryLoaded) {
            var vecDir = vec.clone().sub(_this6.selectionCenter);
            var eyeDot = vecDir.dot(posObj.ray.direction);
            if (eyeDot > 0 && cornerIntersections.length) {var _posObj$cornerInterse2;
              (_posObj$cornerInterse2 = posObj.cornerIntersectionsToHide).push.apply(_posObj$cornerInterse2, _toConsumableArray(cornerIntersections));
              posObj.cornerIntersectionsToHide = _toConsumableArray(new Set(posObj.cornerIntersections));
            }
          }
        }

        var count = posObj.cornerIntersections.length;
        if (_this6._isInsideOtherObject(posObj, boxes, closeBoxesKeys)) {
          count++;
        }

        // Choose the option with the least corner intersections.
        // If it is the same, choose the one that is closest to the center of the object.
        // If it is the same, choose the one that is closer to intersection with the object / it's boundng-box.
        if (count < minIntersections) {
          minIntersections = count;
          chosenPos = posObj;
        } else if (count === minIntersections) {
          if (posObj.distanceToCenterTarget === chosenPos.distanceToCenterTarget) {
            if (posObj.distanceToTarget < chosenPos.distanceToTarget) {
              chosenPos = posObj;
            }
          } else if (posObj.distanceToCenterTarget < chosenPos.distanceToCenterTarget) {
            chosenPos = posObj;
          }
        }
      });

      return chosenPos;
    } }, { key: "_getIntersectionsOfRayWithBoundingBoxes", value: function _getIntersectionsOfRayWithBoundingBoxes(

    candidate, ray, minimumIntersections, boxes, keys) {
      var intersections = [];
      var l = keys.length;

      for (var i = 0; i < l; ++i)
      {
        var dbid = keys[i];
        var box = boxes[dbid];
        var parsedDbId = parseInt(dbid);
        var vec = box && ray.intersectBox(box);
        var distToBox = vec && candidate.position.clone().sub(vec).length();

        if (distToBox) {
          if (distToBox < candidate.distanceToTarget) {
            intersections.push(parsedDbId);
            if (intersections.length > minimumIntersections) break;
          }
        }
      }

      return intersections;
    } }, { key: "_isInsideOtherObject", value: function _isInsideOtherObject(

    candidate, boxes, dbids) {
      for (var i = 0; i < dbids.length; ++i)
      {
        var dbid = dbids[i];
        var box = boxes[dbid];
        var isContain = box.containsPoint(candidate.position);
        if (isContain)
        return true;
      }

      return false;
    } }, { key: "_getClosestIntersectionWithSelectedObject", value: function _getClosestIntersectionWithSelectedObject(

    intersections) {var _this7 = this;
      var selectionDist = intersections.filter(function (intersection) {return intersection.dbId === _this7.selectedObjectID;});
      var min = Number.MAX_VALUE;
      if (!selectionDist[0]) {
        return null;
      }
      for (var j = 0; j < selectionDist.length; j++) {
        if (selectionDist[j].distance < min) {
          min = selectionDist[j].distance;
        }
      }
      return min;
    } }, { key: "_hideCurrentIntersections", value: function _hideCurrentIntersections(

    withCorners) {

      if (!this.chosenPos) {
        return;
      }

      var needsUpdate = false;
      var candidates = [];
      this.viewer.impl.rayIntersect(this.chosenPos.ray, false, false, false, candidates);
      needsUpdate = this._hideIntersectionsCandidates(candidates, true);

      // When geometry finnished loading we will check intersections towards the corners of object
      if (withCorners) {
        needsUpdate = this._hideCornersIntersections() || needsUpdate;
      }

      if (needsUpdate) {
        this.viewer.impl.invalidate(true, true, true);
      }
    } }, { key: "_hideCornersIntersections", value: function _hideCornersIntersections()

    {
      var needsUpdate = false;
      for (var k = 0; k < this.boundingBoxPoints.length; k++) {
        var vec = this.boundingBoxPoints[k];
        for (var i = 0; i < ViewObjectIn3D.NUMBER_OF_CORNER_INTERSECTIONS; i++) {
          var cornerCandidates = [];
          var offset = vec.clone().sub(this.selectionCenter).multiplyScalar(i / ViewObjectIn3D.NUMBER_OF_CORNER_INTERSECTIONS);
          vec.sub(offset);
          var dir = vec.clone().sub(this.chosenPos.position).normalize();
          var ray = new THREE.Ray(this.chosenPos.position.clone(), dir);
          this.viewer.impl.rayIntersect(ray, false, false, false, cornerCandidates);

          needsUpdate = this._hideIntersectionsCandidates(cornerCandidates) || needsUpdate;
        }
      }

      return needsUpdate;
    } }, { key: "_hideIntersectionsCandidates", value: function _hideIntersectionsCandidates(

    candidates, isCenterIntersection) {
      var length = candidates.length;
      var needsUpdate = false;
      var distToObject;
      if (length > 1) {
        distToObject = this._getClosestIntersectionWithSelectedObject(candidates);
        if (isCenterIntersection && distToObject && !this._isSelected(this.selectedObjectID) && this.allTreesLoaded()) {
          this.viewer.select(this.selectedObjectID);
        }
        if (isCenterIntersection || distToObject) {
          for (var i = 0; i < length; i++) {
            var item = candidates[i];
            if (item.dbId !== this.selectedObjectID && item.distance < (distToObject || this.chosenPos.distanceToCenterTarget)) {
              this.viewer.hide(item.dbId);
              needsUpdate = true;
            }
          }
        }
      }
      return needsUpdate;
    } }, { key: "_isSelected", value: function _isSelected(

    dbId) {
      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; ++i) {
        if (models[i].selector.isSelected(dbId)) {
          return true;
        }
      }
      return false;
    }

    // Select the selected object and hide the covering objects
  }, { key: "_applySelections", value: function _applySelections(chosenPos) {

      if (!chosenPos || !this.allTreesLoaded()) {
        return;
      }

      if (!this._isSelected(chosenPos.selectionID)) {
        this.viewer.select(chosenPos.selectionID);
      }

      if (this.isGeometryLoaded) {
        this._hideCurrentIntersections(true);
      } else {

        for (var i = 0; i < chosenPos.intersections.length; ++i) {
          this.viewer.hide(chosenPos.intersections[i]);
        }

        for (var _i = 0; _i < chosenPos.cornerIntersectionsToHide.length; ++_i) {
          this.viewer.hide(chosenPos.cornerIntersectionsToHide[_i]);
        }
      }
    }

    // get camera's position height from level's height + avatar's height
  }, { key: "_getHeight", value: function _getHeight(elevation) {
      var units = this.viewer.model.getData().metadata['distance unit'].value || 'foot';
      var unitScale = Autodesk.Viewing.Private.convertUnits(units, 'm', 1, 1);
      var avatarHeight = 1.8 / unitScale; // this.bimwalkExt.tool.navigator.get('cameraDistanceFromFloor')

      var aec = this.viewer.model.getDocumentNode().getAecModelData();
      var placementTf = this.viewer.model.myData.placementWithOffset;

      var floors = Object(_levels_LevelUtils__WEBPACK_IMPORTED_MODULE_0__["aecModelDataToLevels"])(aec, placementTf);
      if (!floors.length) {
        return this.selectionBox.min.z + avatarHeight;
      }

      var level;
      if (elevation < floors[0].zMin) {
        level = floors[0];
      } else
      if (elevation > floors[floors.length - 1].zMax) {
        level = floors[floors.length - 1];
      } else
      {
        level = floors.find(function (f) {return f.zMin <= elevation && f.zMax >= elevation;});
      }

      return level.zMin + avatarHeight;
    } }, { key: "_pending3DLoaders", value: function _pending3DLoaders()

    {
      return !!this.viewer.impl.loaders.filter(function (loader) {return loader.is3d();}).length;
    } }, { key: "_loadingAllGeometriesDone", value: function _loadingAllGeometriesDone()

    {
      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; ++i) {
        var loaded = models[i].isLoadDone();
        if (!loaded) {
          return false;
        }
      }
      return !this._pending3DLoaders();
    } }, { key: "_waitForAllModels", value: function _waitForAllModels()

    {var _this8 = this;

      return new Promise(function (resolve, reject) {

        var allRootModelLoaded = function allRootModelLoaded() {
          var models = _this8.viewer.getVisibleModels();
          for (var i = 0; i < models.length; ++i) {
            if (!models[i].modelRootLoaded) {
              return false;
            }
          }
          return !_this8._pending3DLoaders();
        };

        var cb = function cb(event) {
          if (allRootModelLoaded()) {
            resolve();
          } else {
            _this8.viewer.addEventListener(av.MODEL_ROOT_LOADED_EVENT, cb, { once: true });
          }
        };

        cb();
      });
    } }, { key: "allTreesLoaded", value: function allTreesLoaded()

    {
      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; ++i) {
        if (!models[i].getInstanceTree()) {
          return false;
        }
      }
      return !this._pending3DLoaders();
    } }, { key: "_waitForAllInstanceTrees", value: function _waitForAllInstanceTrees()

    {var _this9 = this;

      return new Promise(function (resolve, reject) {

        var cb = function cb(event) {
          if (_this9.allTreesLoaded()) {
            resolve();
          } else {
            _this9.viewer.addEventListener(av.OBJECT_TREE_CREATED_EVENT, cb, { once: true });
          }
        };

        cb();
      });
    } }, { key: "_onGeometryLoaded", value: function _onGeometryLoaded()

    {var _this10 = this;

      if (!this._loadingAllGeometriesDone()) {
        return;
      }

      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this._onGeometryLoaded);
      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);

      if (!this.selectedObjectID || !this.chosenPos) {
        return;
      }

      // In case gemotry was loaded before the instance tree, it will not be possible to select the object.
      // We will wait until the instance tree is loaded in order to select the object.
      this._waitForAllInstanceTrees().then(function () {

        // Select the right object again (clearSelection is called onGeometryLoaded)
        _this10.viewer.clearSelection();
        if (!_this10._isSelected(_this10.selectedObjectID)) {
          _this10.viewer.select(_this10.selectedObjectID);
        }

        // Now that the geometey is loaded we can check with a raycast if objects have to be hidden
        _this10._hideCurrentIntersections(true);

        _this10.viewer.impl.invalidate(true, true, true);

        _this10.chosenPos = null;
        _this10.selectedObjectID = null;
      });
    }

    // In cases the object is does not exist in the 3d view, we will locate the camera on the coordinations
    // taken based on the 2d position of the selected object.
  }, { key: "_getSelected3dPosFrom2d", value: function _getSelected3dPosFrom2d(selectedID, model) {
      var bounds = this.viewer.impl.computeSelectionBounds([selectedID], model);
      var point = this.viewer.impl.worldToClient(bounds.center());
      var obj = this.dropMeExt.dropMeTool._get3DCameraPositionAndVp(point.x, point.y);
      return obj && obj.pos;
    } }]);return ViewObjectIn3D;}();


// The frequency of checking objects to hide.
ViewObjectIn3D.HIDING_INTERVAL_FREQUENCY = 300;

// When geometry is already loaded we want to check intersections so we can hide them.
// In order to hide as much covering objects as possible we take the 8 bounding box's corners and
// raycast towards NUMBER_OF_CORNER_INTERSECTIONS points on the way between the center and the corners
ViewObjectIn3D.NUMBER_OF_CORNER_INTERSECTIONS = 10;

// In order to reduce calculations of rey-box intersections we remove from the iteration boxes that are far away
// from the chosen object (more than DISTANCE_FACTOR times the the distance between the camera and the object)
ViewObjectIn3D.DISTANCE_FACTOR = 3;

// In case of narrow objects like doors and walls, when one side is wider then the other by more then COVERAGE_FACTOR times
//  we would like to ignore positions that looks at the object from its narrow side.
ViewObjectIn3D.COVERAGE_FACTOR = 4.0;

// When the angle between the camera's direction and to wider side of the object is less hen IGNORE_ANGLE dgrees
// Ignore this position
ViewObjectIn3D.IGNORE_ANGLE = 35;

// The number of position candidates we create around the chosen object.
ViewObjectIn3D.NUMBER_OF_POSITION = 8;

/***/ }),

/***/ "./extensions/AEC/DropMe/ViewPortOverlay.js":
/*!**************************************************!*\
  !*** ./extensions/AEC/DropMe/ViewPortOverlay.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewPortOverlay; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing,avp = av.Private;var

ViewPortOverlay = /*#__PURE__*/function () {
  function ViewPortOverlay(viewer) {_classCallCheck(this, ViewPortOverlay);
    this.viewer = viewer;
    this.overlayName = 'DropMeViewPortOverlay';
  }_createClass(ViewPortOverlay, [{ key: "addOverlay", value: function addOverlay(

    xMin, yMin, xMax, yMax) {
      this.viewer.impl.createOverlayScene(this.overlayName);

      var mesh = this._createMesh(xMin, yMin, xMax, yMax);
      this.viewer.impl.addOverlay(this.overlayName, mesh);
    } }, { key: "removeOverlay", value: function removeOverlay()

    {
      this.viewer.impl.removeOverlayScene(this.overlayName);
    } }, { key: "_createMesh", value: function _createMesh(

    xMin, yMin, xMax, yMax) {
      var vpId = 0;
      var dbId = -1;
      var layer = 0;
      var borderColor = 0x99d79606;
      var lineWidth = 0.1;
      var totalDist = 0;

      var vbb = new avp.VertexBufferBuilder(false, undefined, 4);

      // add border
      vbb.addSegment(xMin, yMin, xMax, yMin, totalDist, lineWidth, borderColor, dbId, layer, vpId);
      vbb.addSegment(xMax, yMin, xMax, yMax, totalDist, lineWidth, borderColor, dbId, layer, vpId);
      vbb.addSegment(xMax, yMax, xMin, yMax, totalDist, lineWidth, borderColor, dbId, layer, vpId);
      vbb.addSegment(xMin, yMax, xMin, yMin, totalDist, lineWidth, borderColor, dbId, layer, vpId);

      var meshData = vbb.toMesh();
      var mdata = {
        mesh: meshData,
        is2d: true,
        packId: '0',
        meshIndex: 1 };


      avp.BufferGeometryUtils.meshToGeometry(mdata);
      var geom = mdata.geometry;

      var materialParams = {
        skipEllipticals: true,
        skipCircles: true,
        skipTriangleGeoms: true,
        useInstancing: false };


      var matman = this.viewer.impl.matman();
      var matName = matman.create2DMaterial(this.viewer.impl.model, materialParams);
      var material = matman.findMaterial(this.viewer.impl.model, matName);

      var mesh = new THREE.Mesh(geom, material);
      return mesh;
    } }]);return ViewPortOverlay;}();

/***/ }),

/***/ "./extensions/AEC/Hypermodeling/Hypermodeling.js":
/*!*******************************************************!*\
  !*** ./extensions/AEC/Hypermodeling/Hypermodeling.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HypermodelingExtension; });
/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
/* harmony import */ var _levels_LevelUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../levels/LevelUtils */ "./extensions/AEC/levels/LevelUtils.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


var LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';

var namespace = AutodeskNamespace('Autodesk.AEC');
var extensionName = 'Autodesk.AEC.Hypermodeling';

/**
                                                   * The hypermodeling extension allows placing Revit 2D sheets at their correct location in the 3D model
                                                   * This relies on the 2D-3D transform available from AEC model data, and as such is limited to a certain
                                                   * type of sheets, namely floor plans (see {@link supports2DTo3DTransform})
                                                   *
                                                   * Future work: allow placing any sheet (such as PDFs) manually
                                                   *              Open the 3D model from the sheet model (inverse workflow from the current one)
                                                   */var
HypermodelingExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(HypermodelingExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(HypermodelingExtension);
  function HypermodelingExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, HypermodelingExtension);
    _this = _super.call(this, viewer, options);

    _this.loadedSheets = {};
    _this.sheetsPerLevelCache = {};
    _this.zPositionPerLevel = {};
    _this.onModelRootLoaded = _this.onModelRootLoaded.bind(_assertThisInitialized(_this));
    _this.onModelChanged = _this.onModelChanged.bind(_assertThisInitialized(_this));return _this;
  }_createClass(HypermodelingExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var model3D;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (




                  this.viewer.loadExtension(LEVEL_EXT));case 2:this.levelExtension = _context.sent;

                this.addListeners();

                // Currently this extension works only for extending a 3D model with 2D sheets.
                // Could be extended to support the opposite workflow.
                model3D = Object(_levels_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["chooseMainModel"])(this.viewer);
                this.init(model3D);return _context.abrupt("return",

                true);case 7:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "onModelChanged", value: function onModelChanged(_ref)


    {var model = _ref.model;
      if (model.is2d()) {
        return;
      }

      var model3D = Object(_levels_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["chooseMainModel"])(this.viewer);
      if (model3D !== this.model3D) {
        this.unloadAll();
        this.init(model3D);
      }
    } }, { key: "init", value: function init(

    model3D) {
      this.loadedSheets = {};
      this.sheetsPerLevelCache = {};
      this.zPositionPerLevel = {};
      this.floorSelector = this.levelExtension.floorSelector;

      this.model3D = model3D;
      if (!model3D) {
        return;
      }

      this.rootNode = this.model3D.getDocumentNode().getRootNode();
      this.document = this.rootNode.getDocument();
      this.aec = this.rootNode.getAecModelData();
    } }, { key: "unload", value: function unload()

    {
      this.removeListeners();

      this.unloadAll();

      this.floorSelector = null;
      this.model3D = null;
      this.rootNode = null;
      this.document = null;
      this.aec = null;

      return true;
    } }, { key: "addListeners", value: function addListeners()

    {
      this.viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, this.onModelRootLoaded);
      this.viewer.addEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.onModelChanged);
      this.viewer.addEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.onModelChanged);
    } }, { key: "removeListeners", value: function removeListeners()

    {
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, this.onModelRootLoaded);
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.onModelChanged);
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.onModelChanged);
    } }, { key: "getHashNameForViewportAndLevel", value: function getHashNameForViewportAndLevel(

    viewport, levelIndex) {
      return viewport.viewportGuid + '.' + levelIndex;
    } }, { key: "onModelRootLoaded", value: function onModelRootLoaded(_ref2)

    {var model = _ref2.model;
      if (model.is3d()) {
        return;
      }

      // Since this is an async event, and multiple sheets might be loading at the same time, have to make sure
      // we get the relevant level data for the correct one.
      var hash = model.loader.options.customHash;
      var loadedSheet = this.loadedSheets[hash];
      if (!loadedSheet || !loadedSheet.loading) {
        Autodesk.Viewing.Private.logger.warn('Model root loaded called for sheet not being loaded');
        return;
      }

      // Only after the model root has being loaded can we fetch the unit scale.
      // And this is just in time to set the placement transform before it's used
      // to create the meshes.
      var sheetUnitScale = model.getUnitScale();
      var vpTransform = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].get2DTo3DMatrix(loadedSheet.viewport, sheetUnitScale);

      var level = this.floorSelector.floorData[loadedSheet.levelIndex];

      var placementTf = this.model3D.getModelToViewerTransform();
      if (placementTf) {
        vpTransform.multiplyMatrices(placementTf, vpTransform);
      }
      // Move an inch so it matches the floor. Reverses the hack in LevelUtils.js.
      // Add another tenth of an inch to avoid z-fighting with the floor (no particular reason for this number,
      // might be possible to lower it)
      // Add another small value per level to avoid z-fighting in overlapping sheets
      if (!this.zPositionPerLevel.hasOwnProperty(loadedSheet.levelIndex)) {
        this.zPositionPerLevel[loadedSheet.levelIndex] = 0;
      } else {
        this.zPositionPerLevel[loadedSheet.levelIndex] += 0.001;
      }
      var zOffsetHack = 1 / 12 + 1 / 120 + this.zPositionPerLevel[loadedSheet.levelIndex];

      var pos = new THREE.Vector3();
      pos.setFromMatrixPosition(vpTransform);
      //The level's zMin already contains the transform, so it's ok to overwrite.
      pos.z = level.zMin + zOffsetHack;
      vpTransform.setPosition(pos);

      model.setPlacementTransform(vpTransform);
    }

    /**
       * Returns the sheets available for the desired level index.
       * @param {number} levelIndex
       * @returns {array} - the sheets corresponding to the input level index
       */ }, { key: "getAvailableSheetsForLevel", value: function getAvailableSheetsForLevel(
    levelIndex) {var _this2 = this;
      if (this.sheetsPerLevelCache[levelIndex]) {
        return this.sheetsPerLevelCache[levelIndex];
      }

      var level = this.floorSelector.floorData[levelIndex];

      var viewports = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].findViewportsForLevel(this.aec, level.guid);

      viewports = viewports.filter(_common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].supports2DTo3DTransform);

      if (viewports.length === 0) {
        Autodesk.Viewing.Private.logger.warn('No supported viewports for current level');
        return [];
      }

      var sheets = [];
      var box = new THREE.Box3();

      viewports.forEach(function (viewport) {
        var geometries = _this2.rootNode.search({ type: 'geometry', role: '2d', guid: viewport.sheetGuid });
        if (geometries.length) {
          box.set(viewport.sectionBox.min, viewport.sectionBox.max);
          var transform = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(viewport.sectionBox.transform);
          box.applyMatrix4(transform);
          var size = box.size();
          sheets.push({ viewport: viewport, node: geometries[0], boxSize: size.x * size.y });
        }
      });

      // Sort viewports by size, give priority to one with largest extent
      // This might not work well in the future because it depends on the sectionBox being correct, and this is only
      // true when `isCropBoxActive` is set during export from Revit. Right now this is the only supported situation
      // (see supports2DTo3DTransform), but it might change in the future.
      // TODO make sorting an option (with maybe other types of sort such as title)
      sheets.sort(function (a, b) {return b.boxSize - a.boxSize;});

      this.sheetsPerLevelCache[levelIndex] = sheets;

      return sheets;
    }

    /**
       * Loads a sheet corresponding to a level
       * @param {number} levelIndex
       * @param {number} [sheetIndex=0] - the index of the sheet according to the order returned by {@link getAvailableSheetsForLevel}
       * @param {function} [cb=null] - an optional callback to run after the sheet has been loaded
       */ }, { key: "loadSheetFromLevel", value: function loadSheetFromLevel(
    levelIndex) {var _this3 = this;var sheetIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var sheets = this.getAvailableSheetsForLevel(levelIndex);

      if (!sheets.length) {
        return;
      }

      var selectedSheet = sheets[sheetIndex];
      var hash = this.getHashNameForViewportAndLevel(selectedSheet.viewport, levelIndex);
      var node = selectedSheet.node;

      if (this.loadedSheets[hash]) {
        var loadedSheet = this.loadedSheets[hash];
        if (!loadedSheet.loading) {
          // If already loaded just make sure sheet is visible
          this.viewer.showModel(loadedSheet.model);
        }
        cb && cb({ hash: hash, model: loadedSheet.model });
        return;
      }

      var options = {
        isAEC: true,
        useConsolidation: false,
        preserveView: true,
        keepCurrentModels: true,
        disable3DModelLayers: true,
        disablePrecomputedNodeBoxes: true,
        noShadow: true,
        doNotCut: true,
        customHash: hash };


      if (this.options.hidePaper) {
        options.modelSpace = true;
        options.bgColor = 0x0;
      }

      this.loadedSheets[hash] = { node: node, levelIndex: levelIndex, sheetIndex: sheetIndex, viewport: selectedSheet.viewport, loading: true };

      this.viewer.loadDocumentNode(this.document, node, options).then(function (model) {
        // Check if sheet hasn't been unloaded in the meantime
        if (!_this3.loadedSheets[hash]) {
          cb && cb({});
          return;
        }

        _this3.loadedSheets[hash].loading = false;
        _this3.loadedSheets[hash].model = model;
        // When loading the 2D sheet on a 3D model, the visible bounds z length is larger than it should be
        // Force a recalculation so that we get a correct value (needed for the SheetRenderContext)
        model.invalidateBBoxes();
        cb && cb({ hash: hash, model: model });
      });
    } }, { key: "findLoadedSheetsFromLevelIndex", value: function findLoadedSheetsFromLevelIndex(

    levelIndex) {
      var ret = []; // There might be more than one sheet loaded per level
      for (var sheet in this.loadedSheets) {
        if (this.loadedSheets[sheet].levelIndex === levelIndex) {
          ret.push(sheet);
        }
      }

      return ret;
    } }, { key: "findLoadedSheetFromLevelAndSheetIndex", value: function findLoadedSheetFromLevelAndSheetIndex(

    levelIndex, sheetIndex) {
      for (var sheet in this.loadedSheets) {
        if (this.loadedSheets[sheet].levelIndex === levelIndex && this.loadedSheets[sheet].sheetIndex === sheetIndex) {
          return sheet;
        }
      }
    } }, { key: "unloadSheet", value: function unloadSheet(

    hash) {
      var sheet = this.loadedSheets[hash];
      if (!sheet) {
        return;
      }

      this.viewer.unloadDocumentNode(sheet.node);
      delete this.loadedSheets[hash];
    } }, { key: "hideModel", value: function hideModel(

    hash) {
      var sheet = this.loadedSheets[hash];

      if (sheet) {
        if (sheet.model) {
          this.viewer.hideModel(sheet.model);
        } else if (sheet.loading) {
          this.unloadSheet(hash);
        }
      }
    } }, { key: "hideSheetFromLevel", value: function hideSheetFromLevel(

    levelIndex, sheetIndex) {
      var sheet = this.findLoadedSheetFromLevelAndSheetIndex(levelIndex, sheetIndex);
      if (sheet) {
        this.hideModel(sheet);
      }
    } }, { key: "hideAllSheetsFromLevel", value: function hideAllSheetsFromLevel(

    levelIndex) {var _this4 = this;
      var sheets = this.findLoadedSheetsFromLevelIndex(levelIndex);
      sheets.forEach(function (sheet) {
        _this4.hideModel(sheet);
      });
    } }, { key: "unloadSheetsFromLevel", value: function unloadSheetsFromLevel(

    levelIndex) {var _this5 = this;
      var sheets = this.findLoadedSheetsFromLevelIndex(levelIndex);
      sheets.forEach(function (sheet) {
        _this5.unloadSheet(sheet);
      });
    } }, { key: "unloadAll", value: function unloadAll()

    {
      for (var sheet in this.loadedSheets) {
        this.viewer.unloadDocumentNode(this.loadedSheets[sheet].node);
      }

      this.loadedSheets = {};
    } }]);return HypermodelingExtension;}(Autodesk.Viewing.Extension);


namespace.HypermodelingExtension = HypermodelingExtension;
Autodesk.Viewing.theExtensionManager.registerExtension(extensionName, HypermodelingExtension);

/***/ }),

/***/ "./extensions/AEC/LibraryExports.js":
/*!******************************************!*\
  !*** ./extensions/AEC/LibraryExports.js ***!
  \******************************************/
/*! exports provided: FloorSelector, ListPanel, ListPanelEvents, LevelsExtension, HyperlinkTracker, HyperlinkExtension, DropMeExtension, CanvasBookmarkExtension, Minimap3DExtension, AecModelData, Locations, AvatarExtension, SheetSyncExtension, TopViewRendererExtension, Hypermodeling, ViewportsExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ui_ListPanel_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui/ListPanel.css */ "./extensions/AEC/ui/ListPanel.css");
/* harmony import */ var _ui_ListPanel_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ui_ListPanel_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _DropMe_DropMe_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DropMe/DropMe.css */ "./extensions/AEC/DropMe/DropMe.css");
/* harmony import */ var _DropMe_DropMe_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_DropMe_DropMe_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _CanvasBookmark_CanvasBookmark_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CanvasBookmark/CanvasBookmark.css */ "./extensions/AEC/CanvasBookmark/CanvasBookmark.css");
/* harmony import */ var _CanvasBookmark_CanvasBookmark_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_CanvasBookmark_CanvasBookmark_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _levels_FloorSelector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./levels/FloorSelector.js */ "./extensions/AEC/levels/FloorSelector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FloorSelector", function() { return _levels_FloorSelector_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _levels_LevelsExtension_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./levels/LevelsExtension.js */ "./extensions/AEC/levels/LevelsExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LevelsExtension", function() { return _levels_LevelsExtension_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _hyperlinks_HyperlinkTracker_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hyperlinks/HyperlinkTracker.js */ "./extensions/AEC/hyperlinks/HyperlinkTracker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HyperlinkTracker", function() { return _hyperlinks_HyperlinkTracker_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _hyperlinks_HyperlinkExtension_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hyperlinks/HyperlinkExtension.js */ "./extensions/AEC/hyperlinks/HyperlinkExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HyperlinkExtension", function() { return _hyperlinks_HyperlinkExtension_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _ui_ListPanel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui/ListPanel */ "./extensions/AEC/ui/ListPanel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ListPanel", function() { return _ui_ListPanel__WEBPACK_IMPORTED_MODULE_7__["ListPanel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ListPanelEvents", function() { return _ui_ListPanel__WEBPACK_IMPORTED_MODULE_7__["ListPanelEvents"]; });

/* harmony import */ var _DropMe_DropMe_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DropMe/DropMe.js */ "./extensions/AEC/DropMe/DropMe.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DropMeExtension", function() { return _DropMe_DropMe_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _CanvasBookmark_CanvasBookmark_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CanvasBookmark/CanvasBookmark.js */ "./extensions/AEC/CanvasBookmark/CanvasBookmark.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasBookmarkExtension", function() { return _CanvasBookmark_CanvasBookmark_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _Minimap3D_Minimap3D_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Minimap3D/Minimap3D.js */ "./extensions/AEC/Minimap3D/Minimap3D.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Minimap3DExtension", function() { return _Minimap3D_Minimap3D_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _Hypermodeling_Hypermodeling__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Hypermodeling/Hypermodeling */ "./extensions/AEC/Hypermodeling/Hypermodeling.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Hypermodeling", function() { return _Hypermodeling_Hypermodeling__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AecModelData", function() { return _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _Locations_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Locations/index.js */ "./extensions/AEC/Locations/index.js");
/* harmony import */ var _Locations_index_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_Locations_index_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "Locations", function() { return _Locations_index_js__WEBPACK_IMPORTED_MODULE_13___default.a; });
/* harmony import */ var _Avatar_AvatarExtension_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Avatar/AvatarExtension.js */ "./extensions/AEC/Avatar/AvatarExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AvatarExtension", function() { return _Avatar_AvatarExtension_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _SheetSync_SheetSyncExtension_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SheetSync/SheetSyncExtension.js */ "./extensions/AEC/SheetSync/SheetSyncExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SheetSyncExtension", function() { return _SheetSync_SheetSyncExtension_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _SheetSync_TopViewRenderer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./SheetSync/TopViewRenderer */ "./extensions/AEC/SheetSync/TopViewRenderer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TopViewRendererExtension", function() { return _SheetSync_TopViewRenderer__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _Viewports_ViewportsExtension_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Viewports/ViewportsExtension.js */ "./extensions/AEC/Viewports/ViewportsExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ViewportsExtension", function() { return _Viewports_ViewportsExtension_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });



// Each one of these CSS imports gets injected into the HTML's headers inside its own <style>.






















/***/ }),

/***/ "./extensions/AEC/Locations/LocationsCommon.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/Locations/LocationsCommon.js ***!
  \*****************************************************/
/*! exports provided: getPointLocations, parseLocationsMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointLocations", function() { return getPointLocations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseLocationsMetadata", function() { return parseLocationsMetadata; });
/* harmony import */ var _Edit2D_EditShapes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Edit2D/EditShapes */ "./extensions/Edit2D/EditShapes.js");


// Return true if locationA is a descendant of locationB.
function isDescendant(locationA, locationB) {
  if (!locationA || !locationB) {
    return false;
  }

  if (locationA === locationB) {
    return true;
  }

  return isDescendant(locationA.parent, locationB);
};

// Given a point and location list, return all the locations that the point is inside of them.
function getPointLocations(point, locations) {
  var candidates = [];

  // For each location on the list, check if we have an intersection.
  // In case of overlap, push both candidates.
  for (var i = 0; i < locations.length; i++) {
    var location = locations[i];

    if (location.polygon.hitTest(point.x, point.y)) {
      candidates.push(location);
    }
  }

  // If one candidate is a parent of another, keep only the descendant.
  for (var _i = 0; _i < candidates.length - 1; _i++) {
    for (var j = _i + 1; j < candidates.length; j++) {
      if (isDescendant(candidates[_i], candidates[j])) {
        // Note the we remove the location node only from the candidates array - we are not deleting the parent itself.
        candidates[j] = null;
      } else if (isDescendant(candidates[j], candidates[_i])) {
        candidates[_i] = null;
      }
    }
  }

  // Filter the candidates that we removed in previous step.
  candidates = candidates.filter(function (e) {return e;});

  return candidates;
};

// Given locations metadata array, return a new array of the form [{ metadata, polygon, parent }].
function parseLocationsMetadata(locationsMetadata) {
  var locationsMap = {};

  var locations = locationsMetadata.map(function (metadata) {
    if (metadata.area) {
      if (metadata.area.format === 'Svg') {
        var polygon = _Edit2D_EditShapes__WEBPACK_IMPORTED_MODULE_0__["Shape"].fromSVG(metadata.area.geometry);
        polygon.name = metadata.name;

        // Depends on the API that is being used, "id" attribute can be located in a different place.
        // When using `getTreeDocuments` API, the id will be located under `node` object.
        // When using `node:search` API, the id will be located on the root.
        var id = metadata.node && metadata.node.id || metadata.id;

        var location = {
          id: id,
          metadata: metadata,
          polygon: polygon,
          parent: undefined };


        locationsMap[id] = location;

        return location;
      }
    }
  }).filter(function (e) {return e;});

  // The location list the we get from the BE is flat.
  // Traverse and link every location to its parent.
  locations.forEach(function (location) {
    // Depends on the API that is being used, "parentId" attribute can be located in a different place.
    // When using `getTreeDocuments` API, the parentId will be located under `node` object.
    // When using `node:search` API, the parentId will be located on the root.
    var parentId = location.metadata.node && location.metadata.node.parentId || location.metadata.parentId;
    location.parent = locationsMap[parentId];
  });

  return locations;
};

/***/ }),

/***/ "./extensions/AEC/Locations/LocationsService.js":
/*!******************************************************!*\
  !*** ./extensions/AEC/Locations/LocationsService.js ***!
  \******************************************************/
/*! exports provided: fetch2dLocations */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetch2dLocations", function() { return fetch2dLocations; });
function createRequest(requestType, url, contentType, token, onSuccess, onError) {
  var xhr = new XMLHttpRequest();

  xhr.open(requestType, url);

  if (contentType) {
    xhr.setRequestHeader('Content-Type', contentType);
  }

  xhr.setRequestHeader('Access-Control-Allow-Origin', '*');
  xhr.setRequestHeader('Authorization', 'Bearer ' + token);

  xhr.onload = function (event) {
    if (event.currentTarget.status === 201 || event.currentTarget.status === 200 || event.currentTarget.status === 204) {
      onSuccess(event.currentTarget.responseText);
    } else {
      onError();
    }
  };

  xhr.onerror = onError;
  xhr.ontimeout = onError;
  xhr.onabort = onError;

  return xhr;
};

function getApiSuffix(urlEnv) {
  switch (urlEnv) {
    case 'qa':
      return '-qa';
    case 'dev':
    case 'local':
      return '-dev';
    default:
      return '';}

}

function getApiEndpoint(urlEnv) {
  switch (urlEnv) {
    case 'staging':
    case 'qa':
    case 'dev':
    case 'local':
      return 'https://developer-stg.api.autodesk.com';
    default:
      return 'https://developer.api.autodesk.com';}

}

function fetch2dLocations(getAccessToken, containerId, documentLineageUrn, urlEnv) {
  return new Promise(function (resolve, reject) {
    getAccessToken(function (token) {
      if (!token) {
        return reject('Invalid access token.');
      }

      var endpoint = getApiEndpoint(urlEnv);
      var suffix = getApiSuffix(urlEnv);
      var api = "bim360/locations".concat(suffix, "/v2");
      var treeId = 'default'; // Currently this is the only treeId that's supported.
      var url = "".concat(endpoint, "/").concat(api, "/containers/").concat(containerId, "/trees/").concat(treeId, "/nodes:search");
      var results = [];

      // Handle fetching with pagination.
      function doFetch(url) {
        function onSuccess(response) {
          var responseJson = JSON.parse(response);
          results = results.concat(responseJson.results);

          if (responseJson.pagination.next) {
            doFetch(endpoint + responseJson.pagination.next);
          } else {
            resolve(results);
          }
        }

        var xhr = createRequest('POST', url, 'application/json', token, onSuccess, reject);

        var body = {
          documentUrns: [documentLineageUrn] };


        xhr.send(JSON.stringify(body));
      }

      doFetch(url);
    });
  });
};

/***/ }),

/***/ "./extensions/AEC/Locations/index.js":
/*!*******************************************!*\
  !*** ./extensions/AEC/Locations/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var av = Autodesk.Viewing;
var avel = AutodeskNamespace('Autodesk.AEC.Locations');

function _export(m, ns) {
  for (var prop in m) {
    if (m.hasOwnProperty(prop)) {
      //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)
      module.exports[prop] = m[prop];

      //Export into the desired viewer namespace
      ns[prop] = m[prop];
    }
  }
}

_export(__webpack_require__(/*! ./LocationsService */ "./extensions/AEC/Locations/LocationsService.js"), avel);
_export(__webpack_require__(/*! ./LocationsCommon */ "./extensions/AEC/Locations/LocationsCommon.js"), avel);

var LOCATIONS_2D_CONTEXT_NAME = 'locations-2d-context';
var FILL_ALPHA = 0.2;
var FILL_ALPHA_HOVER = 0.5;

var POLYGON_STYLE = {
  fillColor: "rgb(205, 234, 247)",
  fillAlpha: FILL_ALPHA,
  lineColor: "rgb(0, 110, 175)",
  lineWidth: 2 };


var LABEL_CONTAINER_STYLE = {
  background: "#FFFFFF",
  borderRadius: "17px",
  display: "flex",
  flexDirection: "row",
  padding: "5px 9px",
  boxShadow: "none",
  zIndex: 0 };


var LABEL_STYLE = {
  color: "#006EAF",
  fontSize: "12px",
  lineHeight: "12px",
  alignSelf: "center" };


var LABEL_SHADOW = "0px 4px 14px rgba(12, 44, 84, 0.15), 0px 0px 2px rgba(12, 44, 84, 0.25)";

/**
                                                                                               * 2D locations library extension
                                                                                               */var
LocationsExtension = /*#__PURE__*/function (_av$Extension) {"use strict";_inherits(LocationsExtension, _av$Extension);var _super = _createSuper(LocationsExtension);
  function LocationsExtension(viewer, options) {var _this;_classCallCheck(this, LocationsExtension);
    _this = _super.call(this, viewer, options);

    _this.onModelAdded = _this.onModelAdded.bind(_assertThisInitialized(_this));return _this;
  }_createClass(LocationsExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var LocationLabel;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:


                this.locations = [];_context.next = 3;return (

                  this.viewer.loadExtension("Autodesk.Edit2D"));case 3:this.edit2dExtension = _context.sent;

                this.edit2dContext = this.edit2dExtension.registerTools(
                LOCATIONS_2D_CONTEXT_NAME);


                // Class definition has to be located here, only after loading Edit2D, since it extends a member of the namespace.
                LocationLabel = /*#__PURE__*/function (_Autodesk$Edit2D$Fade) {_inherits(LocationLabel, _Autodesk$Edit2D$Fade);var _super2 = _createSuper(LocationLabel);function LocationLabel() {_classCallCheck(this, LocationLabel);return _super2.apply(this, arguments);}_createClass(LocationLabel, [{ key: "apply", value: function apply(
                    label, shape, layer) {
                      _get(_getPrototypeOf(LocationLabel.prototype), "apply", this).call(this, label, shape, layer);
                      if (!label.styleInitialized) {
                        label.styleInitialized = true;
                        Object.assign(label.container.style, LABEL_CONTAINER_STYLE);
                        Object.assign(label.textDiv.style, LABEL_STYLE);
                      }

                      if (label.hoverStyle ^ shape.hover) {
                        label.hoverStyle = !!shape.hover;
                        label.container.style.boxShadow = shape.hover ?
                        LABEL_SHADOW :
                        "none";
                      }
                    } }]);return LocationLabel;}(Autodesk.Edit2D.FadeOutStyleRule);


                this.shapeLabelRule = new Autodesk.Edit2D.ShapeLabelRule(
                this.edit2dContext.layer,
                function (shape) {return shape.name;},
                undefined,
                new LocationLabel());


                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);

                this.onModelAdded();return _context.abrupt("return",

                true);case 10:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      this.edit2dExtension && this.edit2dExtension.unregisterTools(LOCATIONS_2D_CONTEXT_NAME);

      this.shapeLabelRule.dtor();
      this.shapeLabelRule = null;
      this.edit2dExtension = null;
      this.edit2dContext = null;

      this.locations = [];

      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);

      return true;
    } }, { key: "onModelAdded", value: function onModelAdded()

    {var _this$viewer$model;
      // Since Leaflet coordinates are normalized, and locations are being saved in page coordinates,
      // we need to set transformation for the locations layer - so it will be displayed correctly.
      if (!((_this$viewer$model = this.viewer.model) === null || _this$viewer$model === void 0 ? void 0 : _this$viewer$model.isPageCoordinates())) {
        var normalize = Autodesk.Viewing.PDFUtils.getLeafletNormalizingMatrix(
        this.viewer);


        if (!normalize) {
          return;
        }

        var pageDimensions = this.viewer.model.getMetadata("page_dimensions");
        var scale = new THREE.Matrix4();
        scale.makeScale(pageDimensions.page_width, pageDimensions.page_height, 1);

        var layerToWorld = new THREE.Matrix4();
        layerToWorld.multiplyMatrices(scale, normalize);
        layerToWorld.getInverse(layerToWorld);

        this.edit2dContext.setMatrix(layerToWorld);
      }
    }

    /**
       * Set locations array.
       */ }, { key: "setLocations", value: function setLocations(
    locations) {
      this.locations = locations;

      // In case showAllLocations was called before setLocations (because of slow network for example),
      // Make sure to call it again, this time with the locations data.
      if (this.allLocationsVisible) {
        this.showAllLocations();
      }
    }

    /**
       * Get locations array.
       */ }, { key: "getLocations", value: function getLocations()
    {
      return this.locations;
    }

    /**
       * Get location item by id.
       */ }, { key: "getLocationById", value: function getLocationById(
    id) {
      var location = this.locations.find(function (item) {return item.id === id;});

      if (!location) {
        console.warn("Cant find location: ", id);
      }

      return location;
    }

    /**
       * Show location by id.
       */ }, { key: "showLocationById", value: function showLocationById(
    id) {
      var location = this.getLocationById(id);
      this.showLocationItem(location);
    }

    /**
       * Hide location by id.
       */ }, { key: "hideLocationById", value: function hideLocationById(
    id) {
      var location = this.getLocationById(id);
      this.hideLocationItem(location);
    }

    /**
       * Show location item.
       */ }, { key: "showLocationItem", value: function showLocationItem(
    location) {
      if (location) {
        var polygon = location.polygon;

        // Update polygon style
        Object.assign(polygon.style, POLYGON_STYLE);

        if (!this.edit2dContext.layer.findShapeById(polygon.id)) {
          this.edit2dContext.layer.addShape(polygon);
        }
      }
    }

    /**
       * Hide location item.
       */ }, { key: "hideLocationItem", value: function hideLocationItem(
    location) {
      if (location) {
        var polygon = location.polygon;
        this.edit2dContext.layer.removeShape(polygon);
      }
    }

    /**
       * Show all locations.
       */ }, { key: "showAllLocations", value: function showAllLocations()
    {var _this2 = this;
      // Disable autoUpdate for this batch operation.
      // Call update only onces at the end.
      this.edit2dContext.layer.autoUpdate = false;

      this.locations.forEach(function (location) {
        _this2.showLocationItem(location);
      });

      this.edit2dContext.layer.autoUpdate = true;
      this.edit2dContext.layer.update();

      this.allLocationsVisible = true;
    }

    /**
       * Hide all locations.
       */ }, { key: "hideAllLocations", value: function hideAllLocations()
    {var _this3 = this;
      // Disable autoUpdate for this batch operation.
      // Call update only onces at the end.
      this.edit2dContext.layer.autoUpdate = false;

      this.locations.forEach(function (location) {
        _this3.hideLocationItem(location);
      });

      this.edit2dContext.layer.autoUpdate = true;
      this.edit2dContext.layer.update();

      this.allLocationsVisible = false;
    } }, { key: "getLocationIdsAtPoint", value: function getLocationIdsAtPoint(

    point) {
      var intersectedLocations = Autodesk.AEC.Locations.getPointLocations(
      point,
      this.locations);


      return intersectedLocations.map(function (location) {return location.id;});
    } }, { key: "onMouseMove", value: function onMouseMove(

    event) {
      var rect = this.viewer.impl.getCanvasBoundingClientRect();

      var point = this.viewer.clientToWorld(
      event.clientX - rect.left,
      event.clientY - rect.top,
      undefined,
      true).
      point;

      if (!this.viewer.model.isPageCoordinates()) {
        // Locations are stored using page coordinate system.
        // In case we are viewing a Leaflet document, the point position has to be converted into the same coordinate system.
        point = Autodesk.Viewing.PDFUtils.leafletToPdfWorld(this.viewer, point);

        if (!point) {
          return;
        }
      }

      var locationIds = this.getLocationIdsAtPoint(point);

      // Hover only first location if available.
      var singleLocationIdArray = locationIds.slice(0, 1);

      this.hoverLocationsByIds(singleLocationIdArray);
    }

    /**
       * Hover locations according to ids.
       */ }, { key: "hoverLocationsByIds", value: function hoverLocationsByIds(
    ids) {
      var dirty = false;

      this.locations.forEach(function (location) {
        var polygon = location.polygon;
        if (ids.indexOf(location.id) !== -1) {
          if (!polygon.hover) {
            polygon.style.fillAlpha = FILL_ALPHA_HOVER;
            polygon.hover = true;
            dirty = true;
          }
        } else {
          if (polygon.hover) {
            polygon.style.fillAlpha = FILL_ALPHA;
            polygon.hover = false;
            dirty = true;
          }
        }
      });

      if (dirty) {
        this.edit2dContext.layer.update();
      }
    } }]);return LocationsExtension;}(av.Extension);


// The ExtensionManager requires an extension to be registered.
av.theExtensionManager.registerExtension('Autodesk.AEC.LocationsExtension', LocationsExtension);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/Minimap3D.css":
/*!************************************************!*\
  !*** ./extensions/AEC/Minimap3D/Minimap3D.css ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./Minimap3D.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Minimap3D/Minimap3D.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/Minimap3D/Minimap3D.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/Minimap3D/Minimap3D.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Minimap3DExtension; });
/* harmony import */ var _Minimap3DLayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Minimap3DLayout */ "./extensions/AEC/Minimap3D/Minimap3DLayout.js");
/* harmony import */ var _SheetSync_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../SheetSync/SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}




var av = Autodesk.Viewing;
var avp = av.Private;
var Empty2DModelLoader = avp.Empty2DModelLoader;

var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.Minimap3DExtension';

var BIMWALK_EXT = 'Autodesk.BimWalk';
var AVATAR_EXT = 'Autodesk.AEC.AvatarExtension';
var TOP_VIEW_EXT = 'Autodesk.AEC.TopViewRendererExtension';
var LEVEL_EXT = "Autodesk.AEC.LevelsExtension";
var SHEET_SYNC_EXT = "Autodesk.AEC.SheetSyncExtension";

var VISIBILITY_PROP = 'miniMap3D';var

Minimap3DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Minimap3DExtension, _av$Extension);var _super = _createSuper(Minimap3DExtension);
  function Minimap3DExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, Minimap3DExtension);
    _this = _super.call(this, viewer, options);

    _this.mapViewerHighlightEnabled = options.mapViewerHighlightEnabled || false; // By default, mapViewer highlight (hover) is off.
    _this.mapViewerSelectionEnabled = options.mapViewerSelectionEnabled || false; // By default, mapViewer 2D object selection is off.

    _this.update = _this.update.bind(_assertThisInitialized(_this));
    _this.onModelAdded = _this.onModelAdded.bind(_assertThisInitialized(_this));
    _this.onVisibilityChanged = _this.onVisibilityChanged.bind(_assertThisInitialized(_this));

    // Resize animation duration in seconds.
    _this.resizeDuration = 0.3;return _this;
  }_createClass(Minimap3DExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this$levelExt;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (




                  this.viewer.loadExtension(LEVEL_EXT));case 2:this.levelExt = _context.sent;

                this.loaded = true;

                this.viewer.prefs.add(VISIBILITY_PROP, true);

                if (!this.configureSettings()) {
                  if (!this.updateSettingsPanel) {
                    //We need to connect this to an event that happens after the settings panel has been
                    //create by the load sequence.
                    this.updateSettingsPanel = this.configureSettings.bind(this);
                    this.viewer.addEventListener(av.SETTINGS_PANEL_CREATED_EVENT, this.updateSettingsPanel);
                  }
                }

                this.viewer.addEventListener(av.TOOL_CHANGE_EVENT, this.update);
                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);

                if ((_this$levelExt = this.levelExt) === null || _this$levelExt === void 0 ? void 0 : _this$levelExt.floorSelector) {
                  this.levelExt.floorSelector.addEventListener(Autodesk.AEC.FloorSelector.FLOOR_DATA_CHANGED, this.update);
                }

                this.activate();return _context.abrupt("return",

                true);case 11:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      this.loaded = false;

      this.deactivate();

      if (this.updateSettingsPanel) {
        this.viewer.removeEventListener(av.SETTINGS_PANEL_CREATED_EVENT, this.updateSettingsPanel);
        this.updateSettingsPanel = null;
      }

      this.viewer.removeEventListener(av.TOOL_CHANGE_EVENT, this.update);
      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);

      this.levelExt = null;

      // Make sure that we don't leak models
      return true;
    } }, { key: "onModelAdded", value: function onModelAdded()

    {
      // In case the viewer is now on 2D mode, destroy the mapViewer, since it's not relevant anymore.
      // By destroying mapViewer, it will unload all of it's minimap related extensions as well.

      this.viewer.impl.is2d ? this.deactivate() : this.activate();
    } }, { key: "activate", value: function activate()

    {
      if (this.active) {
        return;
      }

      this.update();

      this.active = true;
    } }, { key: "deactivate", value: function deactivate()

    {var _this$levelExt2;
      if (!this.active) {
        return;
      }

      this.active = false;

      if (this.mapViewer) {
        this.mapViewer.finish();
        this.sheetSyncExtension = null;
        this.mapViewer = null;
      }

      if (this.layout) {
        this.layout.destroy && this.layout.destroy();
        this.layout = null;
      }

      if ((_this$levelExt2 = this.levelExt) === null || _this$levelExt2 === void 0 ? void 0 : _this$levelExt2.floorSelector) {
        this.levelExt.floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.FLOOR_DATA_CHANGED, this.update);
      }
    }

    // Check if minimap is enabled in viewer config & BIM-Walk is active.
  }, { key: "isEnabled", value: function isEnabled() {var _bimWalkExt$tool, _this$levelExt3, _this$levelExt3$floor, _this$levelExt3$floor2;
      // Check if minimap pref is setting panel is enabled.
      var prefEnabled = this.viewer.prefs && this.viewer.prefs.get(VISIBILITY_PROP);

      // Check if bim walk is active.
      var bimWalkExt = this.viewer.getExtension(BIMWALK_EXT);
      var bimWalkEnabled = bimWalkExt === null || bimWalkExt === void 0 ? void 0 : (_bimWalkExt$tool = bimWalkExt.tool) === null || _bimWalkExt$tool === void 0 ? void 0 : _bimWalkExt$tool.active;

      // Only if there is a valid floorData (based on AecModelData), the minimap can work.
      // If enableWithoutAecModelData is given, the minimap can still work, but without level-based sectioning - which means that we'll always see the roof.
      var hasAecData = this.options.enableWithoutAecModelData || ((_this$levelExt3 = this.levelExt) === null || _this$levelExt3 === void 0 ? void 0 : (_this$levelExt3$floor = _this$levelExt3.floorSelector) === null || _this$levelExt3$floor === void 0 ? void 0 : (_this$levelExt3$floor2 = _this$levelExt3$floor.floorData) === null || _this$levelExt3$floor2 === void 0 ? void 0 : _this$levelExt3$floor2.length) > 0;

      return prefEnabled && (bimWalkEnabled && hasAecData || this.options.minimapDebugMode);
    } }, { key: "onVisibilityChanged", value: function onVisibilityChanged(

    visible) {
      if (this.viewer.prefs) {
        this.viewer.prefs.set(VISIBILITY_PROP, visible);
      }

      this.update();
    } }, { key: "initLayoutIfNeeded", value: function initLayoutIfNeeded()

    {
      if (this.layout) {
        return;
      }

      // Default layout is Minimap3DLayout. An optional LayoutClass can be used instead.
      var LayoutClass = this.options.LayoutClass || _Minimap3DLayout__WEBPACK_IMPORTED_MODULE_0__["default"];
      this.layout = new LayoutClass(this);
    } }, { key: "initMapViewerIfNeeded", value: function initMapViewerIfNeeded()

    {var _this$options$autoFoc,_this2 = this;
      if (this.mapViewer) {
        return;
      }

      var container = this.layout.getMapViewerContainer();

      if (this.options.getMapViewer) {
        // Get mapViewer using an external callback.
        // Important! if you create a viewer of your own, make sure to initialize it with { webglInitParams: { alpha: true }.
        // Otherwise, you won't be able to see the 3D top view.
        this.mapViewer = this.options.getMapViewer(container);

      } else {
        // Generate a new mapViewer.       
        var ViewerClass = this.options.MapViewerClass || Autodesk.Viewing.Viewer3D;

        this.mapViewer = new ViewerClass(container, {});

        // Map viewer has to have a transparent background in order to support topViewRenderer on the back. This is why `alpha:true` is mandatory.
        this.mapViewer.start(undefined, undefined, undefined, undefined, { webglInitParams: { alpha: true } });
      }

      // Load SheetSync, Avatar & topViewRenderer extensions.
      this.mapViewer.config.extensions = this.mapViewer.config.extensions || [];

      this.mapViewer.config.sheetSyncOptions = {
        targetViewer: this.viewer,
        cropToViewport: true,
        hideSheetWhenNotFocused: true,
        autoSwitchSheet: true,
        hidePaper: true,
        useCustomModel: this.options.useCustomModel,
        showSheet: this.options.showSheet,
        loadDocumentNode: this.options.loadDocumentNode,
        unloadModel: this.options.unloadModel,
        minimapDebugMode: this.options.minimapDebugMode };


      this.mapViewer.config.avatarOptions = {
        trackUsage: this.options.trackUsage,
        autoFocus: (_this$options$autoFoc = this.options.autoFocus) !== null && _this$options$autoFoc !== void 0 ? _this$options$autoFoc : !this.options.minimapDebugMode };


      this.mapViewer.config.topViewRendererOptions = {
        minimapDebugMode: this.options.minimapDebugMode };


      if (this.mapViewer.config.extensions.indexOf(AVATAR_EXT) === -1) {
        this.mapViewer.config.extensions.push(AVATAR_EXT);
      }

      if (this.mapViewer.config.extensions.indexOf(TOP_VIEW_EXT) === -1) {
        this.mapViewer.config.extensions.push(TOP_VIEW_EXT);
      }

      this.mapViewer.disableHighlight(!this.mapViewerHighlightEnabled);
      this.mapViewer.disableSelection(!this.mapViewerSelectionEnabled);

      this.mapViewer.getExtensionAsync(SHEET_SYNC_EXT).then(function (sheetSyncExtension) {
        _this2.sheetSyncExtension = sheetSyncExtension;
      });

      this.mapViewer.addEventListener(_SheetSync_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_1__["SheetSyncEvents"].SHEET_VISIBILITY_CHANGED_EVENT, this.update);

      // Load an empty model to initialize extensions and enable camera.
      this.mapViewer.loadModel("Dummy", { fileLoader: Empty2DModelLoader, headlessViewer: true });
    } }, { key: "update", value: function update()

    {
      if (this.isEnabled()) {
        this.initLayoutIfNeeded();
        this.initMapViewerIfNeeded();
      }

      if (this.layout && this.layout.update) {
        this.layout.update();
      }
    } }, { key: "configureSettings", value: function configureSettings()

    {

      //Is it a GUI viewer or not?
      if (!this.viewer.getSettingsPanel)
      return false;

      var panel = this.viewer.getSettingsPanel();

      if (!panel || !panel.is3dMode)
      return false;

      var navTab = av.Extensions.ViewerSettingTab.Navigation;
      panel.addLabel(navTab, "3D Mini-map");

      // add toggle to the hypermodeling tab of the viewer settings
      if (!panel.showMinimapChkBoxId) {
        panel.showMinimapChkBoxId = panel.addCheckbox(
        navTab,
        "Show 3D mini-map",
        "Toggles availability of the 3D mini-map when using first person mode",
        true,
        this.onVisibilityChanged,
        VISIBILITY_PROP);

      }

      return true;
    }

    // Toggle between auto-generated map image and sheets. Note that sheets may not be available for a level.
    // In this case, we fall back to the default map.
  }, { key: "setSheetMapEnabled", value: function setSheetMapEnabled(enabled) {
      if (this.sheetSyncExtension) {
        this.sheetSyncExtension.setShowSheet(enabled);
        this.update();
      }
    } }, { key: "getSheetMapEnabled", value: function getSheetMapEnabled()

    {var _this$sheetSyncExtens;
      return (_this$sheetSyncExtens = this.sheetSyncExtension) === null || _this$sheetSyncExtens === void 0 ? void 0 : _this$sheetSyncExtens.getShowSheet();
    } }, { key: "setSideBySideEnabled", value: function setSideBySideEnabled(

    enabled) {var _this$layout;
      if ((_this$layout = this.layout) === null || _this$layout === void 0 ? void 0 : _this$layout.setSideBySideEnabled) {
        this.layout.setSideBySideEnabled(enabled);
      }
    } }, { key: "setSideBySideSplit", value: function setSideBySideSplit(

    value) {var _this$layout2;
      if ((_this$layout2 = this.layout) === null || _this$layout2 === void 0 ? void 0 : _this$layout2.setSideBySideSplit) {
        this.layout.setSideBySideSplit(value);
      }
    } }, { key: "isSheetVisible", value: function isSheetVisible()

    {var _this$sheetSyncExtens2;
      return (_this$sheetSyncExtens2 = this.sheetSyncExtension) === null || _this$sheetSyncExtens2 === void 0 ? void 0 : _this$sheetSyncExtens2.isSheetVisible();
    } }, { key: "waitForRotationDone", value: function () {var _waitForRotationDone = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var topViewRendererExt;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:


                topViewRendererExt = this.mapViewer.getExtension(TOP_VIEW_EXT);_context2.next = 3;return (
                  topViewRendererExt.waitForRotationDone());case 3:case "end":return _context2.stop();}}}, _callee2, this);}));function waitForRotationDone() {return _waitForRotationDone.apply(this, arguments);}return waitForRotationDone;}() }, { key: "hideAvatarAndWait", value: function () {var _hideAvatarAndWait = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {var avatarExt;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:



                avatarExt = this.mapViewer.getExtension(AVATAR_EXT);_context3.next = 3;return (
                  avatarExt.hide());case 3:case "end":return _context3.stop();}}}, _callee3, this);}));function hideAvatarAndWait() {return _hideAvatarAndWait.apply(this, arguments);}return hideAvatarAndWait;}() }, { key: "expandSheetMap", value: function () {var _expandSheetMap = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {var sheetNodePromise, viewerState, sheetNode;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:



                // First, request sheetNode in the background (it might take time only if it wasn't loaded before).
                sheetNodePromise = this.sheetSyncExtension.sheetMap.getSheetNode();

                this.sheetSyncExtension.expandCropBounds(this.resizeDuration);
                this.sheetSyncExtension.changePaperVisibility(true);_context4.next = 5;return (
                  this.layout.expandSheetMap(this.resizeDuration));case 5:_context4.next = 7;return (
                  this.waitForRotationDone());case 7:
                this.sheetSyncExtension.setSheetOpaque(this.resizeDuration);_context4.next = 10;return (
                  this.hideAvatarAndWait());case 10:
                viewerState = this.mapViewer.getState();_context4.next = 13;return (

                  sheetNodePromise);case 13:sheetNode = _context4.sent;_context4.next = 16;return (



                  this.options.onExpand(sheetNode, this.sheetSyncExtension.getCustomHash()));case 16:
                this.viewer.restoreState(viewerState, undefined, true);case 17:case "end":return _context4.stop();}}}, _callee4, this);}));function expandSheetMap() {return _expandSheetMap.apply(this, arguments);}return expandSheetMap;}() }]);return Minimap3DExtension;}(av.Extension);



namespace.Minimap3DExtension = Minimap3DExtension;

Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, Minimap3DExtension);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/Minimap3DLayout.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/Minimap3D/Minimap3DLayout.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Minimap3DLayout; });
/* harmony import */ var _MinimapDropdown_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MinimapDropdown.js */ "./extensions/AEC/Minimap3D/MinimapDropdown.js");
/* harmony import */ var _MinimapSideBySideButton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MinimapSideBySideButton */ "./extensions/AEC/Minimap3D/MinimapSideBySideButton.js");
/* harmony import */ var _MinimapExpandButton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MinimapExpandButton */ "./extensions/AEC/Minimap3D/MinimapExpandButton.js");
/* harmony import */ var _SheetSync_TopViewRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../SheetSync/TopViewRenderer */ "./extensions/AEC/SheetSync/TopViewRenderer.js");
/* harmony import */ var _thirdparty_resize_observer_polyfill_ResizeObserver_min_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../thirdparty/resize-observer-polyfill/ResizeObserver.min.js */ "./thirdparty/resize-observer-polyfill/ResizeObserver.min.js");
/* harmony import */ var _thirdparty_resize_observer_polyfill_ResizeObserver_min_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_thirdparty_resize_observer_polyfill_ResizeObserver_min_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Minimap3DLocales__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Minimap3DLocales */ "./extensions/AEC/Minimap3D/Minimap3DLocales.js");
/* harmony import */ var _Minimap3D_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Minimap3D.css */ "./extensions/AEC/Minimap3D/Minimap3D.css");
/* harmony import */ var _Minimap3D_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_Minimap3D_css__WEBPACK_IMPORTED_MODULE_6__);
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}






// eslint-disable-next-line no-unused-vars
 // IMPORTANT!!

var av = Autodesk.Viewing;
var GlobalManagerMixin = av.GlobalManagerMixin;

var BIMWALK_EXT = 'Autodesk.BimWalk';

// int value to string, e.g. 50 => "50px" - to used for style assignments.
var toPixels = function toPixels(val) {
  return val.toString() + 'px';
};

// int value to string, e.g. 50 => "50%" - to used for style assignments.
var toPercent = function toPercent(val) {
  return val.toString() + "%";
};

var DEFAULT_LEVEL_GUID = 'd53d4fd9-1bc6-4549-9084-1caed451e96f'; // Default Revit level guid.
var
Minimap3DLayout = /*#__PURE__*/function () {
  function Minimap3DLayout(minimap3DExtension) {_classCallCheck(this, Minimap3DLayout);
    this.minimap3DExtension = minimap3DExtension;
    this.viewer = this.minimap3DExtension.viewer;
    this.options = minimap3DExtension.options;

    this.setGlobalManager(this.viewer.globalManager);

    minimap3DExtension.extendLocalization(_Minimap3DLocales__WEBPACK_IMPORTED_MODULE_5__["locales"]);

    this.sideBySideOptions = this.options.sideBySideOptions || {};

    // By default, show header.
    this.showHeader = this.options.showHeader === undefined ? true : this.options.showHeader;

    this.update = this.update.bind(this);

    // Map widget size
    this.mapWidgetWidth = 300;
    this.mapWidgetHeight = 300;

    // Offset in pixels for the minimap's layout from its side (left of right).
    this.sideOffset = this.options.sideOffset !== undefined ? this.options.sideOffset : 10;

    // Map widget position
    this.mapWidgetTop = 0;

    if (this.sideBySideOptions.left2DView) {
      this.mapWidgetLeft = 0;
      this.mapWidgetRight = undefined;
    } else {
      this.mapWidgetLeft = undefined;
      this.mapWidgetRight = 0;
    }

    // Params for choosing mapWidget size based on canvas size
    this.relMapWidgetSizeLongEdge = 0.25; // Restrict to max 25% of the canvas along the longer axis with
    this.relMapWidgetSizeShortEdge = 0.37; // Restrict to max 37% of the canvas along the shorter axis (more tolerance here, to keep map useful for widescreen)

    // Dropdown for levels, only instantiated when there are levels
    this.dropdown = null;

    // Toggle between..
    //  - Small map on top-right of the screen (false)
    //  - Large map that fills left half of the screen (true)
    this.sideBySideEnabled = this.sideBySideOptions.sideBySideDefault || false;

    // Indicates if layout is currently configured for side-by-side view
    // (always false when map is hidden, because viewer needs to be resized to full width then)
    this.sideBySide = false;

    // Indicates if layout is currently configured for expanded view (full viewer)
    this.expanded = false;

    // Percent of viewer width that we reserve for minimap in side-by-side mode. 
    // E.g. 40 => Minimap gets 40%, Main canvas gets 60%
    this.sideBySideSplit = this.sideBySideOptions.sideBySideSplit || 40;

    this.init();
  }_createClass(Minimap3DLayout, [{ key: "setMinimapVisible", value: function setMinimapVisible(

    visible) {var _this = this;
      if (this.visible === visible) {
        return;
      }

      this.visible = visible;

      // While switching sheets, mapWidget might be null
      if (!this.mapWidget)
      return;

      // Trigger css anim. Note that doing this synchronously would skip the animation.
      var _window = this.getWindow();
      _window.requestAnimationFrame(function () {
        // Since the callback is async, we need to make sure the extension is still loaded when we get here (UI might be destroyed already).
        if (!_this.mapWidgetRoot) {
          return;
        }

        if (visible) {
          _this.mapWidgetRoot.classList.add('visible');
        } else {
          _this.mapWidgetRoot.classList.remove('visible');
        }

        _this.viewer.getExtension("Autodesk.ViewCubeUi", function (ext) {
          ext.displayViewCube(!visible);
          ext.displayHomeButton(!visible);
        });
      });

      // Make sure that we reserve space for the minimap as soon as we start fade-in
      this.updateBimWalkInfoButtonPos();

      // Apply side-by-side layout immediately when starting to fade in. On fade-out, we
      // delay this until the fade-out transition is done (see transitionend-handler in initWidgets)
      if (visible) {
        this.updateSideBySide();
      }
    } }, { key: "initWidgets", value: function initWidgets()

    {var _this2 = this;
      var _document = this.getDocument();

      // Optional: add extra css class
      var classPostfix = this.options.additionalWrapperCss ? ' ' + this.options.additionalWrapperCss : '';

      // Root div for the minimap. This is only used for the toolbar: Since it is left outside the Minimap bounds, it cannot be inside the mapWidget directly,
      // because the mapWidget uses overflow:hidden to implement scrolling.
      this.mapWidgetRoot = _document.createElement('div');
      this.mapWidgetRoot.style.width = toPixels(this.mapWidgetWidth);
      this.mapWidgetRoot.style.height = toPixels(this.mapWidgetHeight);
      this.mapWidgetRoot.className = "minimap3D ".concat(classPostfix, " ");
      this.mapWidgetRoot.classList.add('adsk-viewing-viewer');
      this.mapWidgetRoot.classList.add(this.viewer.theme);

      this.mapWidgetHeader = _document.createElement('div');
      this.mapWidgetHeader.className = 'minimap-header';
      this.mapWidgetHeader.classList.add('adsk-viewing-viewer');
      this.mapWidgetHeader.classList.add('adsk-control-group');
      this.mapWidgetHeader.classList.add(this.viewer.theme);

      if (this.showHeader) {
        this.mapWidgetRoot.appendChild(this.mapWidgetHeader);
      }

      // Div showing the minimap
      this.mapWidget = _document.createElement('div');
      this.mapWidget.className = 'minimapScrollArea';
      this.mapWidgetRoot.appendChild(this.mapWidget);

      if (this.showHeader) {
        // IE11 doesn't support canvas blending well.
        // For that reason, we decided to hide the sheet-map overlay in IE11.
        if (_SheetSync_TopViewRenderer__WEBPACK_IMPORTED_MODULE_3__["default"].isSheetMapSupported() && this.options.onExpand) {
          this.expandButton = new _MinimapExpandButton__WEBPACK_IMPORTED_MODULE_2__["default"](this);
        }

        this.initDropdownIfNeeded();
        this.sideBySideButton = new _MinimapSideBySideButton__WEBPACK_IMPORTED_MODULE_1__["default"](this);
      }

      // hidden until level map is set
      this.setMinimapVisible(false);

      // Whenver the mapWidget finished fading in or out, we might need to re-adjust
      // the position of the annoying Info button of BimWalk to avoid overlapping.
      this.mapWidgetRoot.addEventListener('transitionend', function () {
        _this2.updateBimWalkInfoButtonPos();
        _this2.updateSideBySide();
      });
    }

    // Dropdown might be initialized only later, after all other widgets were already initialized, since
    // the floorData might arrive only later.
  }, { key: "initDropdownIfNeeded", value: function initDropdownIfNeeded() {var _this$minimap3DExtens, _this$minimap3DExtens2;
      if (!this.showHeader || this.dropdown) {
        return;
      }

      var floorData = (_this$minimap3DExtens = this.minimap3DExtension.levelExt) === null || _this$minimap3DExtens === void 0 ? void 0 : (_this$minimap3DExtens2 = _this$minimap3DExtens.floorSelector) === null || _this$minimap3DExtens2 === void 0 ? void 0 : _this$minimap3DExtens2.floorData;
      var isDefaultRevitLevel = (floorData === null || floorData === void 0 ? void 0 : floorData.length) === 1 && floorData[0].guid === DEFAULT_LEVEL_GUID;

      // In case there are no levels, or only Revit's default level - don't create levels dropdown.
      if ((floorData === null || floorData === void 0 ? void 0 : floorData.length) > 0 && !isDefaultRevitLevel) {
        this.dropdown = new _MinimapDropdown_js__WEBPACK_IMPORTED_MODULE_0__["default"](this);

        // If the dropdown was added just now, make sure that the sideBySide button is added only after it (to the right).
        if (this.sideBySideButton) {
          this.sideBySideButton.dtor();
          this.sideBySideButton = new _MinimapSideBySideButton__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        }
      }
    } }, { key: "destroyWidgets", value: function destroyWidgets()

    {
      if (this.widgetAnimation) {
        this.widgetAnimation.stop();
        this.widgetAnimation = null;
      }

      if (this.mapWidgetRoot.parentElement) {
        this.mapWidgetRoot.parentElement.removeChild(this.mapWidgetRoot);
      }

      this.mapWidgetRoot = null;
      this.mapWidget = null;
      this.mapWidgetHeader = null;

      if (this.dropdown) {
        this.dropdown.dtor();
        this.dropdown = null;
      }

      if (this.expandButton) {
        this.expandButton.dtor();
        this.expandButton = null;
      }

      if (this.sideBySideButton) {
        this.sideBySideButton.dtor();
        this.sideBySideButton = null;
      }
    } }, { key: "init", value: function init()

    {var _this3 = this;
      this.initWidgets();

      this.initialViewerWidth = this.viewer.container.clientWidth;
      this.initialViewerHeight = this.viewer.container.clientHeight;

      this.resizeObserver = new _thirdparty_resize_observer_polyfill_ResizeObserver_min_js__WEBPACK_IMPORTED_MODULE_4___default.a(function () {
        _this3.updateSideBySide(true);
      });

      this.resizeObserver.observe(this.viewer.clientContainer);

      // choose widget size based on current canvas size
      this.updateMapSize(true);

      this.viewer.clientContainer.appendChild(this.mapWidgetRoot);
    } }, { key: "destroy", value: function destroy()

    {
      this.destroyWidgets();

      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
        this.resizeObserver = null;
      }

      // Restore viewer to its default dimensions.
      this.restoreViewerContainerStyle();
    } }, { key: "getClientContainerWidth", value: function getClientContainerWidth()

    {
      // In case clientContainer doesn't have a definite width, use the viewer's initial width.
      // This scenario can happen when the clientContainer div doesn't have style at all - and the viewer's width is independent of the window width.
      return this.viewer.clientContainer.clientWidth || this.initialViewerWidth;
    } }, { key: "getClientContainerHeight", value: function getClientContainerHeight()

    {
      // In case clientContainer doesn't have a definite height, use the viewer's initial height.
      // This scenario can happen when the clientContainer div doesn't have style at all - and the viewer's height is independent of the window size.
      return this.viewer.clientContainer.clientHeight || this.initialViewerHeight;
    } }, { key: "updateToolbar", value: function updateToolbar()

    {
      this.sideBySideButton && this.sideBySideButton.update();
      this.expandButton && this.expandButton.update();
    } }, { key: "update", value: function update()

    {
      this.initDropdownIfNeeded();

      if (this.minimap3DExtension.isEnabled()) {
        this.setMinimapVisible(true);
      } else {
        this.setMinimapVisible(false);
      }

      this.updateToolbar();
      this.updateSideBySide();
    } }, { key: "setWidgetSize", value: function setWidgetSize(

    w, h, top, left, right, headerHeight) {
      this.mapWidgetWidth = w;
      this.mapWidgetHeight = h;
      this.mapWidgetTop = top;
      this.mapWidgetLeft = left;
      this.mapWidgetRight = right;

      this.mapWidgetRoot.style.width = toPixels(w);
      this.mapWidgetRoot.style.height = toPixels(h);
      this.mapWidgetRoot.style.top = toPixels(top);
      this.mapWidgetRoot.style.left = left !== undefined ? toPixels(left) : 'initial';
      this.mapWidgetRoot.style.right = right !== undefined ? toPixels(right) : 'initial';

      if (headerHeight !== undefined) {
        this.mapWidgetHeader.style.height = toPixels(headerHeight);
        this.mapWidgetHeader.style.opacity = toPercent(headerHeight / this.getInitialHeaderHeight() * 100);
      }

      if (this.minimap3DExtension.mapViewer) {
        this.minimap3DExtension.mapViewer.resize();
      }

      this.update();
    } }, { key: "setViewerSize", value: function setViewerSize(

    width, height, left, right, top) {
      this.viewer.container.style.width = toPixels(width);
      this.viewer.container.style.height = toPixels(height);
      this.viewer.container.style.left = toPixels(left);
      this.viewer.container.style.right = toPixels(right);
      this.viewer.container.style.top = toPixels(top);

      // keep canvas/camera in-sync, because we changed container size
      this.viewer.resize();

      this.update();
    }

    // Update mapWidget size based on canvas size
  }, { key: "updateMapSize", value: function updateMapSize(immediate, duration) {
      var canvasWidth = this.getClientContainerWidth();
      var canvasHeight = this.getClientContainerHeight();

      var width, height, top, left, right, showHeader;

      if (this.expanded) {
        width = canvasWidth;
        height = canvasHeight;
        top = 0;

        if (this.sideBySideOptions.left2DView) {
          left = 0;
        } else {
          right = 0;
        }

        showHeader = false;
      } else if (this.sideBySide) {
        // Fill x percent of the parent widget (x = sideBySideSplit)
        if (this.verticalSideBySide) {
          width = canvasWidth;
          height = canvasHeight * (this.sideBySideSplit / 100);
        } else {
          width = canvasWidth * (this.sideBySideSplit / 100);
          height = canvasHeight;
        }

        top = 0;

        if (this.sideBySideOptions.left2DView) {
          left = 0;
        } else {
          right = 0;
        }

        showHeader = true;
      } else {
        // Default mode: Small map on top-right of the screen
        var longEdge = Math.max(canvasWidth, canvasHeight);
        var shortEdge = Math.min(canvasWidth, canvasHeight);
        var minimapWidthToHeightRatio = 0.66;
        // Restrict mapSize to not exceed a certain percentage of canvas width/height
        width = Math.min(this.relMapWidgetSizeLongEdge * longEdge, this.relMapWidgetSizeShortEdge * shortEdge);
        height = width * minimapWidthToHeightRatio + this.mapWidgetHeader.clientHeight; // make the minimap ratio 2:3, and include the height for the header
        top = 10;

        if (this.sideBySideOptions.left2DView) {
          left = this.sideOffset;
        } else {
          right = this.sideOffset;
        }

        showHeader = true;
      }

      if (immediate && !this.widgetAnimation) {
        return this.setWidgetSize(width, height, top, left, right);
      } else {
        return this.animateWidgetSize(width, height, top, left, right, showHeader, duration);
      }
    } }, { key: "getInitialHeaderHeight", value: function getInitialHeaderHeight()

    {
      if (!this.headerHeight) {
        this.headerHeight = this.mapWidgetHeader.clientHeight;
      }

      return this.headerHeight;
    } }, { key: "animateWidgetSize", value: function animateWidgetSize(

    targetWidth, targetHeight, targetTop, targetLeft, targetRight) {var _this4 = this;var showHeader = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;var duration = arguments.length > 6 ? arguments[6] : undefined;
      var startWidth = this.mapWidgetWidth;
      var startHeight = this.mapWidgetHeight;
      var startTop = this.mapWidgetTop;
      var startLeft = this.mapWidgetLeft;
      var startRight = this.mapWidgetRight;
      var startHeaderHeight = this.mapWidgetHeader.clientHeight;
      duration = duration || this.minimap3DExtension.resizeDuration;

      if (this.widgetAnimation) {
        this.widgetAnimation.stop();
        this.widgetAnimation = null;
      }

      var onTimer = function onTimer(t) {
        t = Autodesk.Viewing.Private.smootherStep(t);

        var width = Autodesk.Viewing.Private.lerp(startWidth, targetWidth, t);
        var height = Autodesk.Viewing.Private.lerp(startHeight, targetHeight, t);
        var top = Autodesk.Viewing.Private.lerp(startTop, targetTop, t);
        var left = targetLeft !== undefined ? Autodesk.Viewing.Private.lerp(startLeft || 0, targetLeft, t) : undefined;
        var right = targetRight !== undefined ? Autodesk.Viewing.Private.lerp(startRight || 0, targetRight, t) : undefined;
        var headerHeight = Autodesk.Viewing.Private.lerp(startHeaderHeight, showHeader ? _this4.getInitialHeaderHeight() + (10 - targetTop) * 2 : 0, t);

        _this4.setWidgetSize(
        width,
        height,
        top,
        left,
        right,
        headerHeight);

      };

      return new Promise(function (resolve) {
        var onAnimEnd = function onAnimEnd() {
          _this4.widgetAnimation = null;
          resolve();
        };

        _this4.widgetAnimation = Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onAnimEnd);
      });
    }

    // Relocate BimWalk info button to avoid overlap with Map widget
  }, { key: "updateBimWalkInfoButtonPos", value: function updateBimWalkInfoButtonPos() {
      var bimWalk = this.viewer.getExtension(BIMWALK_EXT);
      var button = bimWalk && bimWalk.getInfoButton();
      if (!button) {
        return;
      }

      // If the infor icon is hidden, we don't need all the mess. Hopefully this will get the default
      // state if others remove the info button as well
      if (bimWalk.options.disableBimWalkInfoIcon) {
        return;
      }


      // Only reserve space minimap is visible or about to fade in.
      var _window = this.getWindow();
      var style = _window.getComputedStyle(this.mapWidgetRoot);
      var visible = this.visible || style.opacity > 0;
      var reservedWidth = visible ? this.mapWidgetWidth : 0;

      // Shifting the info button is not needed in side-by-side mode,
      // because the map widget is outside the viewer canvas in this case.
      if (this.sideBySide) {
        reservedWidth = 0;
      }

      // Includes space between InfoButton and MapWidget + Space between MapWidget and right canvas boundary
      var Margin = 20;
      var right = reservedWidth + Margin;
      button.style.right = toPixels(right);
    } }, { key: "setSideBySideEnabled", value: function setSideBySideEnabled(

    value) {
      this.sideBySideEnabled = value;
      this.updateSideBySide();
    } }, { key: "setSideBySideSplit", value: function setSideBySideSplit(

    value) {
      this.sideBySideSplit = value;
      this.updateSideBySide(true);
      this.updateBimWalkInfoButtonPos();
    } }, { key: "animateViewerSize", value: function animateViewerSize(

    targetWidth, targetHeight, targetLeft, targetRight, targetTop, duration) {var _this5 = this;
      var startWidth = this.viewer.container.clientWidth;
      var startHeight = this.viewer.container.clientHeight;
      var startLeft = this.viewer.container.clientLeft;
      var startRight = this.viewer.container.clientRight;
      var startTop = this.viewer.container.clientTop;

      if (this.viewerResizeAnimation) {
        this.viewerResizeAnimation.stop();
        this.viewerResizeAnimation = null;
      }

      duration = duration || this.minimap3DExtension.resizeDuration;

      var onTimer = function onTimer(t) {
        t = Autodesk.Viewing.Private.smootherStep(t);

        var width = Autodesk.Viewing.Private.lerp(startWidth, targetWidth, t);
        var height = Autodesk.Viewing.Private.lerp(startHeight, targetHeight, t);
        var top = Autodesk.Viewing.Private.lerp(startTop, targetTop, t);
        var left = Autodesk.Viewing.Private.lerp(startLeft, targetLeft, t);
        var right = Autodesk.Viewing.Private.lerp(startRight, targetRight, t);

        _this5.setViewerSize(
        width,
        height,
        left,
        right,
        top);

      };

      return new Promise(function (resolve) {
        var onAnimEnd = function onAnimEnd() {
          _this5.viewerResizeAnimation = null;
          resolve();
        };

        _this5.viewerResizeAnimation = Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onAnimEnd);
      });
    }

    // Make sure that side-by-side layout is activated if and only if minimap is visible
  }, { key: "updateSideBySide", value: function updateSideBySide(force) {

      var wasSideBySide = this.sideBySide;
      this.sideBySide = this.visible && this.sideBySideEnabled;

      if (!force && wasSideBySide === this.sideBySide) {
        return;
      }

      var targetWidth, targetHeight, targetLeft, targetRight, targetTop;

      var clientHeight = this.getClientContainerHeight();
      var clientWidth = this.getClientContainerWidth();

      if (this.sideBySide) {
        this.mapWidgetRoot.classList.add('side-by-side');

        if (clientWidth >= clientHeight) {
          targetWidth = (100 - this.sideBySideSplit) / 100 * clientWidth;
          targetHeight = clientHeight;

          if (this.sideBySideOptions.left2DView) {
            targetLeft = this.sideBySideSplit / 100 * clientWidth;
            targetRight = 0;
          } else {
            targetLeft = 0;
            targetRight = this.sideBySideSplit / 100 * clientWidth;
          }

          targetTop = 0;

          if (this.sideBySideOptions.left2DView) {
            this.mapWidgetRoot.classList.add('left-2d-view');
          }

          this.verticalSideBySide = false;
        } else {
          targetWidth = clientWidth;
          targetHeight = (100 - this.sideBySideSplit) / 100 * clientHeight;
          targetLeft = 0;
          targetRight = 0;
          targetTop = this.sideBySideSplit / 100 * clientHeight;

          this.verticalSideBySide = true;
        }

        if (this.sideBySideOptions.onSideBySideUpdated) {
          this.sideBySideOptions.onSideBySideUpdated(this.sideBySideSplit);
        }
      } else {
        targetWidth = clientWidth;
        targetHeight = clientHeight;
        targetLeft = 0;
        targetRight = 0;
        targetTop = 0;

        this.mapWidgetRoot.classList.remove('side-by-side');
        this.mapWidgetRoot.classList.remove('left-2d-view');
      }

      if (force) {
        this.setViewerSize(targetWidth, targetHeight, targetLeft, targetRight, targetTop);
      } else {
        this.animateViewerSize(targetWidth, targetHeight, targetLeft, targetRight, targetTop);
      }

      this.updateMapSize(force);
    }

    // Restores default state of container for 3D Minimap and Design Diff Extensions
  }, { key: "restoreViewerContainerStyle", value: function restoreViewerContainerStyle() {
      if (this.viewerResizeAnimation) {
        this.viewerResizeAnimation.stop();
        this.viewerResizeAnimation = null;
      }

      this.viewer.container.style.width = "100%";
      this.viewer.container.style.height = "100%";
      this.viewer.container.style.left = "";
      this.viewer.container.style.right = "";
      this.viewer.container.style.top = "";

      // Update viewer size.
      this.viewer.resize();
    } }, { key: "getMapViewerContainer", value: function getMapViewerContainer()

    {
      return this.mapWidget;
    } }, { key: "expandSheetMap", value: function expandSheetMap(

    duration) {
      if (this.expanded) {
        return;
      }

      this.expanded = true;

      this.mapWidgetHeader.style.pointerEvents = 'none';

      this.setSideBySideEnabled(false);

      return this.updateMapSize(false, duration);
    } }]);return Minimap3DLayout;}();


GlobalManagerMixin.call(Minimap3DLayout.prototype);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/Minimap3DLocales.js":
/*!******************************************************!*\
  !*** ./extensions/AEC/Minimap3D/Minimap3DLocales.js ***!
  \******************************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../res/locales/en/nobundle-minimap3D.loc.json */ "./res/locales/en/nobundle-minimap3D.loc.json");
var _res_locales_en_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/en/nobundle-minimap3D.loc.json */ "./res/locales/en/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_en_GB_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../res/locales/en-GB/nobundle-minimap3D.loc.json */ "./res/locales/en-GB/nobundle-minimap3D.loc.json");
var _res_locales_en_GB_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_1___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/en-GB/nobundle-minimap3D.loc.json */ "./res/locales/en-GB/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_cs_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../res/locales/cs/nobundle-minimap3D.loc.json */ "./res/locales/cs/nobundle-minimap3D.loc.json");
var _res_locales_cs_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_2___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/cs/nobundle-minimap3D.loc.json */ "./res/locales/cs/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_de_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../res/locales/de/nobundle-minimap3D.loc.json */ "./res/locales/de/nobundle-minimap3D.loc.json");
var _res_locales_de_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_3___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/de/nobundle-minimap3D.loc.json */ "./res/locales/de/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_es_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../res/locales/es/nobundle-minimap3D.loc.json */ "./res/locales/es/nobundle-minimap3D.loc.json");
var _res_locales_es_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/es/nobundle-minimap3D.loc.json */ "./res/locales/es/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_fr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../res/locales/fr/nobundle-minimap3D.loc.json */ "./res/locales/fr/nobundle-minimap3D.loc.json");
var _res_locales_fr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/fr/nobundle-minimap3D.loc.json */ "./res/locales/fr/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_fr_CA_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../res/locales/fr-CA/nobundle-minimap3D.loc.json */ "./res/locales/fr-CA/nobundle-minimap3D.loc.json");
var _res_locales_fr_CA_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_6___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/fr-CA/nobundle-minimap3D.loc.json */ "./res/locales/fr-CA/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_it_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../res/locales/it/nobundle-minimap3D.loc.json */ "./res/locales/it/nobundle-minimap3D.loc.json");
var _res_locales_it_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_7___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/it/nobundle-minimap3D.loc.json */ "./res/locales/it/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_ja_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../res/locales/ja/nobundle-minimap3D.loc.json */ "./res/locales/ja/nobundle-minimap3D.loc.json");
var _res_locales_ja_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_8___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/ja/nobundle-minimap3D.loc.json */ "./res/locales/ja/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_ko_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../res/locales/ko/nobundle-minimap3D.loc.json */ "./res/locales/ko/nobundle-minimap3D.loc.json");
var _res_locales_ko_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_9___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/ko/nobundle-minimap3D.loc.json */ "./res/locales/ko/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_pl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../res/locales/pl/nobundle-minimap3D.loc.json */ "./res/locales/pl/nobundle-minimap3D.loc.json");
var _res_locales_pl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_10___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/pl/nobundle-minimap3D.loc.json */ "./res/locales/pl/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_pt_BR_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../res/locales/pt-BR/nobundle-minimap3D.loc.json */ "./res/locales/pt-BR/nobundle-minimap3D.loc.json");
var _res_locales_pt_BR_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_11___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/pt-BR/nobundle-minimap3D.loc.json */ "./res/locales/pt-BR/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_ru_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../res/locales/ru/nobundle-minimap3D.loc.json */ "./res/locales/ru/nobundle-minimap3D.loc.json");
var _res_locales_ru_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_12___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/ru/nobundle-minimap3D.loc.json */ "./res/locales/ru/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_tr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../res/locales/tr/nobundle-minimap3D.loc.json */ "./res/locales/tr/nobundle-minimap3D.loc.json");
var _res_locales_tr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_13___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/tr/nobundle-minimap3D.loc.json */ "./res/locales/tr/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_zh_HANS_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../res/locales/zh-HANS/nobundle-minimap3D.loc.json */ "./res/locales/zh-HANS/nobundle-minimap3D.loc.json");
var _res_locales_zh_HANS_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_14___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/zh-HANS/nobundle-minimap3D.loc.json */ "./res/locales/zh-HANS/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_zh_HANT_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../res/locales/zh-HANT/nobundle-minimap3D.loc.json */ "./res/locales/zh-HANT/nobundle-minimap3D.loc.json");
var _res_locales_zh_HANT_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_15___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/zh-HANT/nobundle-minimap3D.loc.json */ "./res/locales/zh-HANT/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_zh_HK_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../res/locales/zh-HK/nobundle-minimap3D.loc.json */ "./res/locales/zh-HK/nobundle-minimap3D.loc.json");
var _res_locales_zh_HK_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_16___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/zh-HK/nobundle-minimap3D.loc.json */ "./res/locales/zh-HK/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_nl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../../res/locales/nl/nobundle-minimap3D.loc.json */ "./res/locales/nl/nobundle-minimap3D.loc.json");
var _res_locales_nl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_17___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/nl/nobundle-minimap3D.loc.json */ "./res/locales/nl/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_sv_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../../res/locales/sv/nobundle-minimap3D.loc.json */ "./res/locales/sv/nobundle-minimap3D.loc.json");
var _res_locales_sv_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_18___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/sv/nobundle-minimap3D.loc.json */ "./res/locales/sv/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_da_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../../res/locales/da/nobundle-minimap3D.loc.json */ "./res/locales/da/nobundle-minimap3D.loc.json");
var _res_locales_da_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_19___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/da/nobundle-minimap3D.loc.json */ "./res/locales/da/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_no_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../../res/locales/no/nobundle-minimap3D.loc.json */ "./res/locales/no/nobundle-minimap3D.loc.json");
var _res_locales_no_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_20___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/no/nobundle-minimap3D.loc.json */ "./res/locales/no/nobundle-minimap3D.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */
























var locales = {
  en: _res_locales_en_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_0__,
  'en-GB': _res_locales_en_GB_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_1__,
  cs: _res_locales_cs_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_2__,
  de: _res_locales_de_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_3__,
  es: _res_locales_es_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_4__,
  fr: _res_locales_fr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_5__,
  "fr-CA": _res_locales_fr_CA_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_6__,
  it: _res_locales_it_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_7__,
  ja: _res_locales_ja_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_8__,
  ko: _res_locales_ko_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_9__,
  pl: _res_locales_pl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_10__,
  "pt-BR": _res_locales_pt_BR_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_11__,
  ru: _res_locales_ru_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_12__,
  tr: _res_locales_tr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_13__,
  "zh-HANS": _res_locales_zh_HANS_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_14__,
  "zh-HANT": _res_locales_zh_HANT_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_15__,
  "zh-HK": _res_locales_zh_HK_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_16__,
  nl: _res_locales_nl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_17__,
  sv: _res_locales_sv_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_18__,
  da: _res_locales_da_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_19__,
  no: _res_locales_no_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_20__ };

/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapDropdown.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapDropdown.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MinimapDropdown; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var av = Autodesk.Viewing;
var analytics = av.Private.analytics;
var GlobalManagerMixin = av.GlobalManagerMixin;
var BIMWALK_EXT = "Autodesk.BimWalk";
var LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';var

MinimapDropdown = /*#__PURE__*/function () {
  function MinimapDropdown(parent) {var _this = this;_classCallCheck(this, MinimapDropdown);
    var DROPDOWN_HEIGHT = 50;
    this.parent = parent;
    this.viewer = parent.viewer;
    this.setGlobalManager(this.viewer.globalManager);
    this.dropdownWrapper = null;
    this.parentContainer = parent.mapWidgetHeader;
    this.onClickOptionHandler = this.onClickOption.bind(this);

    this.createWrapper(DROPDOWN_HEIGHT);

    var floorData = this.getFloorDataFromLevelExtension();
    this.createDropdown(floorData);

    if (floorData.length === 0) {
      this.dropdownWrapper.classList.add("hidden");
    }

    this.onLevelChanged = this.onLevelChanged.bind(this);

    this.viewer.addEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.onLevelChanged);

    this.viewer.getExtensionAsync(LEVEL_EXT).then(function (levelExt) {
      levelExt.floorSelector.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, _this.onLevelChanged);
      _this.onLevelChanged();
    });
  }_createClass(MinimapDropdown, [{ key: "createWrapper", value: function createWrapper(

    dropdownHeight) {
      var _document = this.getDocument();
      var wrapper = _document.createElement("div");
      wrapper.classList.add("minimap-dropdown-wrapper");
      wrapper.id = 'minimap-dropdown-wrapper';
      wrapper.style.height = dropdownHeight;

      if (!this.parent.expandButton) {
        wrapper.style.paddingLeft = '14px';
      }

      this.parentContainer.appendChild(wrapper);

      this.dropdownWrapper = wrapper;
    } }, { key: "createDropdown", value: function createDropdown(

    floorData) {var _this2 = this;
      var _document = this.getDocument();
      this.titleElement = _document.createElement("div");
      this.titleElement.classList.add("minimap-title");
      this.dropdownWrapper.appendChild(this.titleElement);
      this.createDropdownOptions(floorData);

      this.dropdownWrapper.addEventListener("click", function (event) {
        _this2.dropdownElement.classList.toggle("active");
        event.stopPropagation();
      });
    } }, { key: "onClickOption", value: function onClickOption(

    e) {
      var _document = this.getDocument();
      this.titleElement.id = e.target.id;
      var bimWalk = this.viewer.getExtension(BIMWALK_EXT);
      bimWalk.jumpToFloor(e.target.id);
      var event = _document.createEvent("Event");

      event.initEvent("change", true, true);

      analytics.track('viewer.3d_minimap.levels');

      this.titleElement.dispatchEvent(event);

      Array.from(this.dropdownElement.children).forEach(function (e) {return (
          e.classList.remove("active"));});

      this.dropdownWrapper.classList.toggle("active");
      e.target.classList.toggle("active");
    } }, { key: "createDropdownOptions", value: function createDropdownOptions(

    floorData) {
      var _document = this.getDocument();
      this.dropdownElement &&
      this.dropdownWrapper.removeChild(this.dropdownElement);

      this.dropdownElement = _document.createElement("ul");
      this.dropdownElement.classList.add("minimap-dropdown");
      this.dropdownElement.id = 'minimap-dropdown';
      this.dropdownWrapper.appendChild(this.dropdownElement);

      // Reordering floors in 3D minimap to match the order in Levels Panel
      for (var i = floorData.length - 1; i >= 0; i--) {
        this.createNewOption(floorData[i].name, i);
      }
    } }, { key: "createNewOption", value: function createNewOption(

    name, id) {
      var _document = this.getDocument();
      var optionElement = _document.createElement("li");

      optionElement.appendChild(_document.createTextNode(name));
      optionElement.setAttribute("id", id);
      optionElement.onclick = this.onClickOptionHandler;
      this.dropdownElement.appendChild(optionElement);
    } }, { key: "onLevelChanged", value: function onLevelChanged()

    {
      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      var level = levelExt.getCurrentLevel();

      if (level) {
        var floorData = this.getFloorDataFromLevelExtension();
        this.update(level.index, floorData);
      }
    } }, { key: "getFloorDataFromLevelExtension", value: function getFloorDataFromLevelExtension()

    {var _levelExt$floorSelect;
      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      if (levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect = levelExt.floorSelector) === null || _levelExt$floorSelect === void 0 ? void 0 : _levelExt$floorSelect.floorData) {
        return levelExt.floorSelector.floorData;
      }
      return [];
    } }, { key: "update", value: function update(

    floorIndex, floorData) {
      if (floorData.length === 0) {
        this.dropdownWrapper.classList.add("hidden");
      } else {
        this.dropdownWrapper.classList.remove("hidden");
      }
      this.createDropdownOptions(floorData);
      if (floorIndex >= 0 && floorData[floorIndex]) {
        var floor = floorData[floorIndex];
        this.dropdownWrapper.style.display = "flex";

        this.setSelectedValue(floor.name);

        Array.from(this.dropdownElement.children).forEach(function (element) {
          element.classList.remove("active");
          if (element.textContent === floor.name) {
            element.classList.add("active");
          }
        });
      }
    } }, { key: "setSelectedValue", value: function setSelectedValue(

    valueToSet) {
      this.titleElement.textContent = valueToSet;
    } }, { key: "dtor", value: function dtor()

    {var _levelExt$floorSelect2;
      this.viewer.removeEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.onLevelChanged);

      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect2 = levelExt.floorSelector) === null || _levelExt$floorSelect2 === void 0 ? void 0 : _levelExt$floorSelect2.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.onLevelChanged);

      this.dropdownWrapper.parentNode.removeChild(this.dropdownWrapper);
      this.dropdownWrapper = null;
    } }]);return MinimapDropdown;}();


GlobalManagerMixin.call(MinimapDropdown.prototype);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapExpandButton.js":
/*!*********************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapExpandButton.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MinimapExpandButton; });
/* harmony import */ var _adjustButtonStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adjustButtonStyle */ "./extensions/AEC/Minimap3D/adjustButtonStyle.js");
/* harmony import */ var _resources_Icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources/Icons */ "./extensions/AEC/Minimap3D/resources/Icons.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing;
var avu = av.UI;

var GlobalManagerMixin = av.GlobalManagerMixin;var

MinimapExpandButton = /*#__PURE__*/function () {
  function MinimapExpandButton(parent) {_classCallCheck(this, MinimapExpandButton);
    this.parent = parent;
    this.parentElement = parent.mapWidgetHeader;
    this.viewer = parent.viewer;
    this.setGlobalManager(parent.viewer.globalManager);

    this.expandButton = new avu.Button("Minimap_Expand");
    this.expandButton.setGlobalManager(this.globalManager);
    this.expandButton.onClick = function () {return (
        parent.minimap3DExtension.expandSheetMap());};
    this.expandButton.icon.innerHTML = _resources_Icons__WEBPACK_IMPORTED_MODULE_1__["expandIcon"];
    this.expandButton.icon.style.width = "20px";
    this.expandButton.icon.style.height = "20px";
    this.parentElement.appendChild(this.expandButton.container);

    Object(_adjustButtonStyle__WEBPACK_IMPORTED_MODULE_0__["default"])(this.expandButton, false);

    // Set icons and tooltips
    this.update();
  }_createClass(MinimapExpandButton, [{ key: "update", value: function update()

    {
      this.expandButton.setState(
      this.parent.minimap3DExtension.isSheetVisible() ?
      avu.Button.State.INACTIVE :
      avu.Button.State.DISABLED);


      // Set tooltips based on current states
      var Expand = Autodesk.Viewing.i18n.translate("Go to 2D");
      this.expandButton.setToolTip(Expand);
    } }, { key: "dtor", value: function dtor()

    {
      this.viewer = null;
    } }]);return MinimapExpandButton;}();


GlobalManagerMixin.call(MinimapExpandButton.prototype);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapMath.js":
/*!*************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapMath.js ***!
  \*************************************************/
/*! exports provided: worldToMapPixels, mapPixelsToWorld, posIsInsideMap, setCameraFromFrustumCorners, setTopView, compute3DTo2DMatrix, motionSmoothing, rotateAround, expandToSquare, boundsToUnitQuad, computeAngle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "worldToMapPixels", function() { return worldToMapPixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapPixelsToWorld", function() { return mapPixelsToWorld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "posIsInsideMap", function() { return posIsInsideMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCameraFromFrustumCorners", function() { return setCameraFromFrustumCorners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTopView", function() { return setTopView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compute3DTo2DMatrix", function() { return compute3DTo2DMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "motionSmoothing", function() { return motionSmoothing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAround", function() { return rotateAround; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandToSquare", function() { return expandToSquare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundsToUnitQuad", function() { return boundsToUnitQuad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeAngle", function() { return computeAngle; });
// Utility functions used by Minimap


// Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.
var worldToMapPixels = function worldToMapPixels(pos3D, mapMatrix, mapWidth, mapHeight) {
  var p = pos3D.clone().applyProjection(mapMatrix);
  var res = new THREE.Vector2(
  (p.x + 1) / 2 * mapWidth,
  (-p.y + 1) / 2 * mapHeight);

  return res;
};

var mapPixelsToWorld = function mapPixelsToWorld(posX, posY, zWorld, mapMatrixInv, mapWidth, mapHeight) {
  // convert pixels to normalized viewport coords in [-1,1]
  var vx = 2 * (posX / mapWidth) - 1.0;
  var vy = 2 * (posY / mapHeight) - 1.0;

  // Beware of the annoying y-flip
  var p = new THREE.Vector3(vx, -vy, 0.0).applyProjection(mapMatrixInv);
  p.z = zWorld;
  return p;
};

// Checks whether the given 3D position would appear inside the map for the given mapMatrix.
//  @param {Vector3} pos3D
//  @param {Matrix4} mapMatrix
//  @returns {bool}
var _tmpVec = null;
var posIsInsideMap = function posIsInsideMap(pos3D, mapMatrix) {

  _tmpVec = _tmpVec || new THREE.Vector3();

  // Compute position in map space [-1, 1] that we would get when using this map
  var mapPos = _tmpVec.copy(pos3D).applyProjection(mapMatrix);

  // Check if camera position is inside
  return Math.abs(mapPos.x) < 1.0 && Math.abs(mapPos.y) < 1.0;
};

// Configures the ortho-camera from given 3 points, so that:
//  p0: appears at lower-left corner
//  p1: appears at lower-right corner
//  p2: appears at upper-left corner
//
// We assume that camera target.z is already set and on the sheet-plane level
var setCameraFromFrustumCorners = function setCameraFromFrustumCorners(camera, p0, p1, p2) {

  // up-vector: p2-p0
  camera.up.x = p2.x - p0.x;
  camera.up.y = p2.y - p0.y;

  // position
  camera.position.x = 0.5 * (p1.x + p2.x);
  camera.position.y = 0.5 * (p1.y + p2.y);

  var frustumHeight = camera.up.length();

  // normalize up-vector
  camera.up.multiplyScalar(1.0 / frustumHeight);

  // For LMV ortho-cameras...
  // - The vertical frustum height is identical with the orthoScale 
  // - The orthoScale is determined by the distance between position and target
  // - For sheets, the view direction is always -z and zoom is manipulated by changing pos.z while having a constant target.z
  // Therefore, we obtain the desired frustum height by:
  var targetDist = frustumHeight;
  camera.position.z = camera.target.z + targetDist;

  // keep horizontal target position in sync
  camera.target.x = camera.position.x;
  camera.target.y = camera.position.y;

  // This updates the camera quaternion. Without this, modifying the up-vector would not have any effect.
  Autodesk.Viewing.Navigation.prototype.orient(camera, camera.target, camera.position, camera.up);

  camera.dirty = true;
};

var setTopView = function setTopView(camera, bbox, zMin, zMax, orthoScale) {

  var center = THREE.Box3.prototype.center.call(bbox);

  // set camera pos to upper face center
  camera.position.copy(center);
  camera.position.z = zMax;

  // target distance defines orthoScale, which finally
  // defines the height of the orthoCam frustum in world-space
  camera.target.copy(camera.position);
  camera.target.z -= orthoScale;
  camera.isPerspective = false;

  // set up-vector for view from top
  camera.up.set(0, 1, 0);
  camera.worldup.set(0, 1, 0);

  // Configure near/far to see only zMin/zMax range
  camera.near = 0;
  camera.far = zMax - zMin;

  // This makes sure that compute3DTo2DMatrix() produces always the same resuts, no matter whether we do it before or after rendering.
  camera.updateCameraMatrices();
};

// Computes a Matrix4 that transforms from 3D model position to
// normalized viewport coords ([-1,1]^2) on the minimap.
var compute3DTo2DMatrix = function compute3DTo2DMatrix(camera, dstMatrix) {
  dstMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
};

// Helper function to smoothen movement of scroll position and zoomScale.
//  @param {number} dist      - distance to move to reach target directly. Must be >=0.
//  @param {number} elapsed   - elapsed time in seconds
//  @param {number} maxSpeed  - maximum allowed distance units per second
//  @param {number} lastSpeed - motion speed according to last cycle (delta / elapsed)
//  @param {number} acc       - acceleration speed (in distance units per s^2)
//  @returns {number} Result is a distance <=dist, which is slowed down if needed for smoother movement.
var motionSmoothing = function motionSmoothing(dist, elapsed, maxSpeed, lastSpeed, acc) {

  // Limit max scroll speed and avoid too sudden acceleration compared to last cycle
  var speed = Math.min(maxSpeed, lastSpeed + acc * elapsed);

  // Slow down with constant deceleration when approaching the target position:
  //
  //   With a constant acceleration a for a time of t seconds, we have:
  //     speed    = t*a
  //     distance = 0.5 * a * t^2
  //
  // To scroll a given distance d with constant acceleration a, the time needed is:
  //   t = sqrt(2*d / a)
  //
  // The speed reached at that point is:
  //   s = a * sqrt(2*d / a)
  //
  // Therefore, s as given above gives us the speed that we must have if distance d
  // to the target if we want to stop at the target given a constant deceleration of a.
  var slowDownSpeed = acc * Math.sqrt(2 * dist / acc);
  speed = Math.min(slowDownSpeed, speed);

  // restrict distance based on computed speed limit
  var maxDist = speed * elapsed;
  return Math.min(dist, maxDist);
};

// Rotates p around the center point. Works for Vector3 in xy too.
//  @param {Vector2} p
//  @param {Vector2} center
//  @param {number}  angle  - counterclockwise angle in radians
var rotateAround = function rotateAround(p, center, angle) {

  var c = Math.cos(angle);
  var s = Math.sin(angle);

  var x = p.x - center.x;
  var y = p.y - center.y;

  p.x = x * c - y * s + center.x;
  p.y = x * s + y * c + center.y;
};

// Expands rect in-place by expanding the smallest axis around the center.
//  @param {Box2} rect
var expandToSquare = function expandToSquare(rect) {

  // determine scale factor from max-axis of sheet bounds
  var diag = rect.size();
  var center = rect.center();

  var radius = 0.5 * Math.max(diag.x, diag.y);

  rect.min.set(center.x - radius, center.y - radius);
  rect.max.set(center.x + radius, center.y + radius);
};

// Rescales a point p within srcBounds to [0.1]^2. Works in-place.
//  @param {Vector2} p
//  @param {Box2} srcBounds
var boundsToUnitQuad = function boundsToUnitQuad(p, srcBounds) {
  var diagX = srcBounds.max.x - srcBounds.min.x;
  var diagY = srcBounds.max.y - srcBounds.min.y;

  p.x -= srcBounds.min.x;
  p.y -= srcBounds.min.y;

  p.x /= diagX;
  p.y /= diagY;
};

// Compute rotation angle for camera view-cone on map.
//  @param {THREE.Vector2} pos    - camera position     in minimap pixel space
//  @param {THREE.Vector2} target - camera target point in minimap pixel space
//  @returns {number}  Rotation angle in radians to transform a originally up-facing div located
//                     in a way that it points towards (p2-p1).
var computeAngle = function computeAngle(pos, target) {
  var dx = target.x - pos.x;
  var dy = target.y - pos.y;
  var angle = Math.atan2(dy, dx);

  // atan measures the angle to the x-axis, but we want it to work for divs originally aligned with +y.
  angle += Math.PI / 2;

  return angle;
};



/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapSideBySideButton.js":
/*!*************************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapSideBySideButton.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MinimapSideBySideButton; });
/* harmony import */ var _adjustButtonStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adjustButtonStyle */ "./extensions/AEC/Minimap3D/adjustButtonStyle.js");
/* harmony import */ var _resources_Icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources/Icons */ "./extensions/AEC/Minimap3D/resources/Icons.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing;
var avu = av.UI;

var GlobalManagerMixin = av.GlobalManagerMixin;var

MinimapSideBySideButton = /*#__PURE__*/function () {
  function MinimapSideBySideButton(parent) {_classCallCheck(this, MinimapSideBySideButton);
    this.parent = parent;
    this.parentElement = parent.mapWidgetHeader;
    this.setGlobalManager(parent.viewer.globalManager);
    // Create toggle to switch between small map and side-by-side map
    this.sideBySideButton = new avu.Button("Minimap_SideBySide");
    this.sideBySideButton.setGlobalManager(this.globalManager);
    this.sideBySideButton.onClick = function () {return (
        parent.setSideBySideEnabled(!parent.sideBySideEnabled));};
    this.sideBySideButton.icon.innerHTML = _resources_Icons__WEBPACK_IMPORTED_MODULE_1__["sideBySideIcon"];
    this.sideBySideButton.icon.style.width = "20px";
    this.sideBySideButton.icon.style.height = "20px";
    this.parentElement.appendChild(this.sideBySideButton.container);

    // Create alternative icon that we show in side-by-side mode
    var _document = this.getDocument();
    this.shrinkIcon = _document.createElement("div");
    this.shrinkIcon.innerHTML = _resources_Icons__WEBPACK_IMPORTED_MODULE_1__["minimapIcon"];
    this.shrinkIcon.style.width = "20px";
    this.shrinkIcon.style.height = "20px";
    this.sideBySideButton.container.appendChild(this.shrinkIcon);

    Object(_adjustButtonStyle__WEBPACK_IMPORTED_MODULE_0__["default"])(this.sideBySideButton, true);

    // Set icons and tooltips
    this.update();
  }_createClass(MinimapSideBySideButton, [{ key: "setSideBySideButtonDisabled", value: function setSideBySideButtonDisabled(

    disable) {
      this.sideBySideButtonDisabled = disable;
    } }, { key: "update", value: function update()

    {
      var sideBySideIsEnabled = this.parent.sideBySideEnabled;
      // Show expand/collapse icon depending on current state
      this.shrinkIcon.style.display = sideBySideIsEnabled ? "block" : "none";
      this.sideBySideButton.icon.style.display = sideBySideIsEnabled ?
      "none" :
      "block";

      this.sideBySideButton.setState(
      this.sideBySideButtonDisabled ?
      avu.Button.State.DISABLED :
      avu.Button.State.INACTIVE);


      // Set tooltips based on current states
      var SideBySide = Autodesk.Viewing.i18n.translate("Side by side");
      var Minimap = Autodesk.Viewing.i18n.translate("Small map");
      this.sideBySideButton.setToolTip(sideBySideIsEnabled ? Minimap : SideBySide);
    } }, { key: "dtor", value: function dtor()

    {
      this.parentElement.removeChild(this.sideBySideButton.container);
      this.sideBySideButton = null;
      this.shrinkIcon = null;
    } }]);return MinimapSideBySideButton;}();


GlobalManagerMixin.call(MinimapSideBySideButton.prototype);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/SheetMap.js":
/*!**********************************************!*\
  !*** ./extensions/AEC/Minimap3D/SheetMap.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetMap; });
/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} //
// SheetMap is used by Minimap in order to display a sheet in an own viewer instance - instead of a pre-rendered image containg the automatically generated map.
//

var

SheetMapConfig = /*#__PURE__*/function () {
  function SheetMapConfig(viewport, mapMatrix, levelGuid) {_classCallCheck(this, SheetMapConfig);
    // {object}: viewport on the sheet, as obtained from AecModelData
    this.viewport = viewport;

    // {Matrix4} transforms from 3D world coords to sheetmap coords in [-1,1]^2
    this.mapMatrix = mapMatrix;
    this.mapMatrixInv = new THREE.Matrix4().getInverse(mapMatrix);

    // {string}
    this.levelGuid = levelGuid;

    // {SheetMapThumbnail}
    this.thumbnail = undefined;
  }_createClass(SheetMapConfig, [{ key: "getSheetNode", value: function () {var _getSheetNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:if (


                this._sheetNode) {_context.next = 4;break;}_context.next = 3;return (
                  this.viewport.getParentSheetNode());case 3:this._sheetNode = _context.sent;case 4:return _context.abrupt("return",


                this._sheetNode);case 5:case "end":return _context.stop();}}}, _callee, this);}));function getSheetNode() {return _getSheetNode.apply(this, arguments);}return getSheetNode;}() }]);return SheetMapConfig;}();var



SheetMap = /*#__PURE__*/function () {function SheetMap() {_classCallCheck(this, SheetMap);}_createClass(SheetMap, null, [{ key: "computeMapMatrix",

    // Computes a mapMatrix based on a viewport on a sheet. The matrix transforms from 3D model coordinates to 
    // normalized map coords in [-1,1]^2.
    //  @param {Object} viewport - Viewport data obtained from AECModelData.json    
    //  @param {av.Model} model3D  - A currently visible 3D model of the Revit document for which we found the sheet.
    //  @returns THREE.Matrix4
    value: function computeMapMatrix(viewport, model3D) {

      // We map from model coords via sheet coords to finally [-1,1]^2.
      //
      // The functions getViewportBounds() and get3DTo2DMatrix() work in sheet-space, so that they require
      // the sheetUnitScale - which we don't know before loading the sheet.
      //
      // But, since we finally map the viewport to [-1,1] anyway, a uniform scaling of the sheet has no impact on 
      // the final map matrix anyway. So we can assume a dummy unitScale of 1.0 here.
      var DummyUnitScale = 1.0;

      var sheetRegion = viewport.getViewportBounds(DummyUnitScale);

      // Create matrix to map sheetRegion to [-1,1]^2
      var sheetToMap = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].remapRectangle(
      sheetRegion.min.x, sheetRegion.min.y, sheetRegion.max.x, sheetRegion.max.y, // from: SheetRegion
      -1, -1, 1, 1 // to: [0,1]^2
      );

      var modelToSheet = viewport.get3DTo2DMatrix(DummyUnitScale);
      var mapMatrix = new THREE.Matrix4().multiplyMatrices(sheetToMap, modelToSheet);

      if (viewport.isMatrixInLocalCoords()) {
        // The mapMatrix computed so far maps local model coordinates to map coordinates. 
        // Finally, we want to map from local LMV coordinates. Therefore, the final transform
        // must revert any load-time transforms first.
        var modelTransform = model3D.getInverseModelToViewerTransform();

        if (modelTransform) {
          mapMatrix.multiply(modelTransform);
        }
      }

      return mapMatrix;
    }

    // Creates sheetMap configurations for all sheetMaps that are found on the current floor.
    //  @param {av.Model[]} models - 3D models in which we search for viewports/sheets
    //  @param {string}     levelGuid
    //  @returns {SheetMapConfig[]} 
  }, { key: "createSheetMapConfigs", value: function createSheetMapConfigs(models3D, levelGuid, viewportsExtension) {

      // Find all viewports that would be suitable as a floor map. 
      var maps = [];

      for (var i = 0; i < models3D.length; i++) {

        // Find viewports for levelGuid in the document of mapModel[i]
        var model3D = models3D[i];
        var bubbleNode = model3D.getDocumentNode();

        if (!bubbleNode) {
          continue;
        }

        var modelViewports = viewportsExtension.findViewportsInLevel(model3D, levelGuid);

        // For each viewport...
        for (var j = 0; j < modelViewports.length; j++) {

          var viewport = modelViewports[j];

          // Compute mapMatrix for this viewport
          var mapMatrix = SheetMap.computeMapMatrix(viewport, model3D);

          // We found a candidate (viewport, sheet) pair
          var map = new SheetMapConfig(viewport, mapMatrix, levelGuid);

          maps.push(map);
        }
      }

      return maps;
    } }]);return SheetMap;}();

/***/ }),

/***/ "./extensions/AEC/Minimap3D/SheetThumbnail.js":
/*!****************************************************!*\
  !*** ./extensions/AEC/Minimap3D/SheetThumbnail.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetMapThumbnail; });
/* harmony import */ var _MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;

// Use the largest we can get from DS
var DsThumbnailSize = 400;
var GeneratedThumbnailSize = 1500;

var getThumbnailCropRegion = function getThumbnailCropRegion(sheetBox, viewport) {var sheetUnitScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0254;

  // Thumbnails are square and contain empty pixels to expand the rectangle to a square.
  // Therefore, the whole thumbnail image does not match the sheet bounds exactly,
  // but actually corresponds to the square containing it.
  Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["expandToSquare"])(sheetBox);

  // Actually, we shouldn't care about sheetUnitScale here. We only
  // need it because Revit extractor gives us viewport bounds and sheet bounds in different coordinate systems. 
  // Unfortunately, we have to guess the sheetUnitScale here, because we cannot load all sheets first just to get the unitScale.
  //
  // TODO: If we provide the viewport boundary in sheet coordinates in Revit extractor, we don't need this hack anymore.

  // get viewport bounds in sheet coords (usually inches)    
  var viewportBounds = viewport.getViewportBounds(sheetUnitScale).clone();

  // map from sheetBox to thumbnail pixels
  Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["boundsToUnitQuad"])(viewportBounds.min, sheetBox);
  Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["boundsToUnitQuad"])(viewportBounds.max, sheetBox);

  return viewportBounds;
};

// Applies css styling on image element, so that the given cropRegion fits the parent div
//
// @param {Box2}  cropRegion - in [0,1]^2, relative to the full image
// @param {Image} image      - html image element
var cropImage = function cropImage(image, cropRegion) {
  var _document = av.getGlobal().document;
  var canvas = _document.createElement("canvas");
  var ctx = canvas.getContext("2d");

  // compute size of crop region (relative to full image)
  var cropWidthRatio = cropRegion.max.x - cropRegion.min.x;
  var cropHeightRatio = cropRegion.max.y - cropRegion.min.y;

  var destWidth = cropWidthRatio * image.width;
  var destHeight = cropHeightRatio * image.height;

  canvas.width = destWidth;
  canvas.height = destHeight;

  ctx.drawImage(
  image,
  cropRegion.min.x * image.width, (1 - cropRegion.max.y) * image.height,
  destWidth, destHeight,
  0, 0,
  destWidth, destHeight);


  var texImage = new Image();
  texImage.src = canvas.toDataURL();

  return texImage;
};

// Sheetmap thumbnails are embedded in the minimap to display for which regions inside the minimap a sheetmap is available. 
// A sheetmap thumbnail is a sheet thumbnail that is cropped down to a single viewport and embedded into the main map.
var SheetMapThumbnail = /*#__PURE__*/function () {

  // @param {SheetMapConfig} sheetMapConfig - Config object for the sheet to be represented by this thumbnail
  function SheetMapThumbnail(sheetMapConfig, viewer, onThumbnailReady) {var _this = this;_classCallCheck(this, SheetMapThumbnail);
    this.sheetMapConfig = sheetMapConfig;

    this.viewer = viewer;

    this.thumbnailImage = null;

    this.thumbnailRefined = false;

    this.onThumbnailReady = onThumbnailReady;

    this.img = new Image();
    this.img.onload = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var sheetNode, viewNode, viewBoxValues, sheetBox, cropRegion;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
                _this.sheetMapConfig.getSheetNode());case 2:sheetNode = _context.sent;

              // get full sheet bounds from viewbox
              viewNode = sheetNode.search({ type: 'view' })[0];

              // We can't crop the thumbnail without knowing the sheet's original dimensions.
              // The problem is that the thumbnail is always square - and the sheet isn't.
              // Even if we know the exact dimensions of the viewport - it's not enough in order to decide how to crop the squared thumbnail.
              if (viewNode) {_context.next = 6;break;}return _context.abrupt("return");case 6:



              viewBoxValues = viewNode.getViewBox();
              sheetBox = new THREE.Box2();
              sheetBox.min.set(viewBoxValues[0], viewBoxValues[1]);
              sheetBox.max.set(viewBoxValues[2], viewBoxValues[3]);
              cropRegion = getThumbnailCropRegion(sheetBox, _this.sheetMapConfig.viewport);

              _this.cropThumbnail(_this.img, cropRegion);case 12:case "end":return _context.stop();}}}, _callee);}));

  }_createClass(SheetMapThumbnail, [{ key: "cropThumbnail", value: function cropThumbnail(

    img, cropRegion) {var _this2 = this;
      var croppedThumbnail = cropImage(img, cropRegion);

      croppedThumbnail.onload = function () {
        _this2.thumbnailImage = croppedThumbnail;
        _this2.onThumbnailReady(_this2.sheetMapConfig);
      };
    } }, { key: "onThumbnailDownloaded", value: function onThumbnailDownloaded(

    blobUrl) {
      // Verify that the thumbnail wasn't generated locally meanwhile.
      if (!this.thumbnailRefined) {
        this.img.src = blobUrl;
      }
    }

    // Creates a div containing the thumbnail of a given sheet node as an image element.
  }, { key: "requestThumbnail", value: function () {var _requestThumbnail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var _this3 = this;var sheetNode, root, doc, options, url, onReceive;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (

                  this.sheetMapConfig.getSheetNode());case 2:sheetNode = _context2.sent;

                // get thumbnail url
                root = sheetNode.getRootNode();
                doc = root.getDocument();

                options = doc.getThumbnailOptions(sheetNode.data, DsThumbnailSize, DsThumbnailSize);

                // takes care of local bubbles
                if (sheetNode.data.thumbnailUrn) {
                  options.urn = sheetNode.getDocument().getFullPath(sheetNode.data.thumbnailUrn);
                  options.responseType = 'blob';
                  Autodesk.Viewing.Private.ViewingService.getThumbnail(Autodesk.Viewing.initLoadContext(), options.urn, function (response) {
                    var reader = new FileReader();
                    reader.onload = function (e) {
                      _this3.onThumbnailDownloaded(e.target.result);
                    };
                    reader.readAsDataURL(response);

                  },
                  function (error) {console.warn("Failed to load sheet thumbnail. Error: ".concat(error, ", Urn: ").concat(options.urn, ", SheetName: ").concat(sheetNode.name()));},
                  options);
                } else if (Autodesk.Viewing.endpoint.getUseCookie()) {
                  // Set derivative service Url directly and use cookie for credentials
                  url = doc.getThumbnailPath(sheetNode.data, DsThumbnailSize, DsThumbnailSize);
                  this.onThumbnailDownloaded(url);
                } else {
                  // When not using a cookie for credentials, we have to request the thumbnails using ViewingService.
                  onReceive = function onReceive(error, blob) {

                    // Display a warning if overlay thumbnail will not show up
                    if (error) {
                      console.warn("Failed to load sheet thumbnail. Error: ".concat(error, ", Urn: ").concat(options.urn, ", SheetName: ").concat(sheetNode.name()));
                      return;
                    }

                    // assign imageUrl 
                    var blobUrl = av.getGlobal().URL.createObjectURL(blob);
                    _this3.onThumbnailDownloaded(blobUrl);
                  };

                  // Request thumbnail from DS
                  Autodesk.Viewing.Document.requestThumbnailWithSecurity(options, onReceive);
                }case 7:case "end":return _context2.stop();}}}, _callee2, this);}));function requestThumbnail() {return _requestThumbnail.apply(this, arguments);}return requestThumbnail;}()


    // Takes a screenshot of the 2D sheet, and replace the low-res thumbnail with it.
  }, { key: "refineThumbnail", value: function refineThumbnail() {var _this4 = this;

      // Make sure that we do the screenshot only once per sheetMap
      if (this.thumbnailRefined) {
        return;
      }

      this.thumbnailRefined = true;

      // Align camera to capture the whole sheet
      var box = this.viewer.model.getBoundingBox(true);

      // Setup camera for the snapshot
      var camera = new Autodesk.Viewing.UnifiedCamera(GeneratedThumbnailSize, GeneratedThumbnailSize);
      camera.setViewFromBox(box, true);

      var onScreenshotDone = function onScreenshotDone(imageUrl) {
        _this4.img.src = imageUrl;

        _this4.img.onload = function () {
          var cropRegion = getThumbnailCropRegion(box, _this4.sheetMapConfig.viewport, _this4.viewer.model.getUnitScale());
          _this4.cropThumbnail(_this4.img, cropRegion);
        };
      };

      var options = {
        camera: camera };


      this.viewer.impl.getScreenShotProgressive(GeneratedThumbnailSize, GeneratedThumbnailSize, onScreenshotDone, options);
    } }]);return SheetMapThumbnail;}();

/***/ }),

/***/ "./extensions/AEC/Minimap3D/adjustButtonStyle.js":
/*!*******************************************************!*\
  !*** ./extensions/AEC/Minimap3D/adjustButtonStyle.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Some customizations for LMV buttons
/* harmony default export */ __webpack_exports__["default"] = (function (button, rightTooltip) {
  //Default LMV buttons are too large for the minimap
  button.container.style.width = "20px";
  button.container.style.height = "20px";
  button.container.style.padding = "3px 8px";

  // The icon class adds a top-padding of 3 which broke the centering of the button.
  button.icon.classList.remove("adsk-button-icon");

  // Show tooltips left of the buttons and vertically centered.
  // The default behavior would place the tooltip outside of canvas and minimap,
  // so that they would not be visible.
  button.setToolTip(""); // Init tooltip element
  var tts = button._toolTipElement.style;
  tts.bottom = "0px";
  tts.top = "auto";
  tts.height = "fit-content";

  if (rightTooltip) {
    tts.left = "auto";
    tts.right = "130%";
  } else {
    tts.top = "40px";
  }

  tts.zIndex = 3;
});

/***/ }),

/***/ "./extensions/AEC/Minimap3D/resources/Icons.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/Minimap3D/resources/Icons.js ***!
  \*****************************************************/
/*! exports provided: expandIcon, sideBySideIcon, minimapIcon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandIcon", function() { return expandIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sideBySideIcon", function() { return sideBySideIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimapIcon", function() { return minimapIcon; });
var expandIcon = [
'<svg viewBox="2 2 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">',
'<path d="M20 10V17C20 17.5523 19.5523 18 19 18H5C4.44772 18 4 17.5523 4 17V7C4 6.44772 4.44772 6 5 6H16M20 10L16 6M20 10H17C16.4477 10 16 9.55228 16 9V6" stroke="currentColor"/>',
'<path d="M13 9H7V15.5H12V13" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>',
'<path d="M11.5 15.5H16V12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>',
'<path d="M10 9V11.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>',
"</svg>"].
join("");

var sideBySideIcon = [
'<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">',
'<rect width="24" height="24" fill="none"/>',
'<rect x="3" y="5" width="18" height="14" rx="2" stroke="currentColor" stroke-width="1.5"/>',
'<rect x="13.5" y="7.5" width="5" height="9" rx="0.5" fill="currentColor" stroke="currentColor"/>',
'</svg>'].
join("");

var minimapIcon = [
'<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">',
'<rect width="24" height="24" fill="none"/>',
'<rect x="3" y="5" width="18" height="14" rx="2" stroke="currentColor" stroke-width="1.5"/>',
'<rect x="13.5" y="7.5" width="5" height="3.16667" rx="0.5" fill="currentColor" stroke="currentColor"/>',
"</svg>"].
join("");



/***/ }),

/***/ "./extensions/AEC/SheetSync/NearFarOverlay.js":
/*!****************************************************!*\
  !*** ./extensions/AEC/SheetSync/NearFarOverlay.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NearFarOverlay; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var OVERLAY_SCENE = 'camera-near-far-overlay-scene';

var EPSILON = 0.001;
var PLANE_WIDTH = 200; // px
var PLANE_HEIGHT = 4; // px

// Useful for debugging - displays the camera's near & far planes on the minimap.
var NearFarOverlay = /*#__PURE__*/function () {
  function NearFarOverlay(topViewViewer, targetViewer) {_classCallCheck(this, NearFarOverlay);
    this.topViewViewer = topViewViewer;
    this.targetViewer = targetViewer;

    this.topViewViewer.impl.createOverlayScene(OVERLAY_SCENE);

    this.planeGeometry = new THREE.PlaneBufferGeometry(1, 1);
    this.nearPlane = this.createMesh(0x005BCE); // Blu-ish
    this.farPlane = this.createMesh(0xe8b22c); // Yellow-ish

    this.show();
    this.update();

    this.update = this.update.bind(this);
    this.targetViewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.update);
    this.topViewViewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.update);
  }_createClass(NearFarOverlay, [{ key: "createMesh", value: function createMesh(

    color) {
      var material = new THREE.MeshBasicMaterial({
        color: color,
        opacity: 1,
        transparent: false,
        depthTest: false,
        depthWrite: false,
        side: THREE.DoubleSide });


      var mesh = new THREE.Mesh(this.planeGeometry, material);

      return mesh;
    } }, { key: "show", value: function show()

    {
      this.topViewViewer.impl.addOverlay(OVERLAY_SCENE, this.nearPlane);
      this.topViewViewer.impl.addOverlay(OVERLAY_SCENE, this.farPlane);
    } }, { key: "hide", value: function hide()

    {
      this.topViewViewer.impl.removeOverlay(OVERLAY_SCENE, this.nearPlane);
      this.topViewViewer.impl.removeOverlay(OVERLAY_SCENE, this.farPlane);
    } }, { key: "getScale", value: function getScale(

    pixelSize) {
      var worldHeight = this.topViewViewer.getCamera().orthoScale;
      var viewport = this.topViewViewer.navigation.getScreenViewport();
      var scale = pixelSize * worldHeight / viewport.height;

      return scale;
    } }, { key: "update", value: function update()

    {
      var camera = this.targetViewer.getCamera();

      var eyeDir = camera.target.clone().sub(camera.position).normalize();
      var angle = Math.atan2(camera.target.y - camera.position.y, camera.target.x - camera.position.x) + THREE.Math.degToRad(90);

      var pixelToWorld = this.getScale(1); // 1 pixel world scale
      var z = this.topViewViewer.getCamera().position.z - EPSILON;

      // Update near plane mesh
      var nearPos = camera.position.clone().add(eyeDir.clone().multiplyScalar(camera.near));
      nearPos.z = z;
      this.nearPlane.position.copy(nearPos);
      this.nearPlane.scale.set(pixelToWorld * PLANE_WIDTH, pixelToWorld * PLANE_HEIGHT, 1);
      this.nearPlane.rotation.set(0, 0, angle);

      // Update far plane mesh
      var farPos = camera.position.clone().add(eyeDir.clone().multiplyScalar(camera.far));
      farPos.z = z;
      this.farPlane.position.copy(farPos);
      this.farPlane.scale.set(pixelToWorld * PLANE_WIDTH, pixelToWorld * PLANE_HEIGHT, 1);
      this.farPlane.rotation.set(0, 0, angle);

      this.topViewViewer.impl.invalidate(false, false, true);
    } }, { key: "destroy", value: function destroy()

    {
      this.planeGeometry.dispose();
      this.planeGeometry = null;

      this.topViewViewer.impl.removeOverlayScene(OVERLAY_SCENE);

      this.targetViewer.removeEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.update);
      this.topViewViewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.update);

      this.topViewViewer = null;
      this.targetViewer = null;
    } }]);return NearFarOverlay;}();

/***/ }),

/***/ "./extensions/AEC/SheetSync/SheetSyncConstants.js":
/*!********************************************************!*\
  !*** ./extensions/AEC/SheetSync/SheetSyncConstants.js ***!
  \********************************************************/
/*! exports provided: SheetSyncEvents, SHEET_OPACITY, FADE_DURATION, ROTATION_DURATION, WAIT_BEFORE_ROTATION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SheetSyncEvents", function() { return SheetSyncEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHEET_OPACITY", function() { return SHEET_OPACITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FADE_DURATION", function() { return FADE_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROTATION_DURATION", function() { return ROTATION_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WAIT_BEFORE_ROTATION", function() { return WAIT_BEFORE_ROTATION; });
var SheetSyncEvents = {
  MAIN_MAP_CHANGED_EVENT: 'mapChanged',
  CHANGING_SHEET_EVENT: 'changingSheet',
  SHEET_VISIBILITY_CHANGED_EVENT: 'sheetVisibilityChanged' };


var SHEET_OPACITY = 0.8; // When sheet is displayed on top of top view screenshot, it should be half transparent.
var FADE_DURATION = 0.7; // Time to fade sheet's opacity. Value matches "transition: opacity 0.7s" inside Avatar.scss
var ROTATION_DURATION = 2.0; // Time to rotate a sheet in order for it to face upwards.
var WAIT_BEFORE_ROTATION = 1.0; // Time to rotate a sheet in order for it to face upwards.

/***/ }),

/***/ "./extensions/AEC/SheetSync/SheetSyncExtension.js":
/*!********************************************************!*\
  !*** ./extensions/AEC/SheetSync/SheetSyncExtension.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetSyncExtension; });
/* harmony import */ var _Minimap3D_SheetMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Minimap3D/SheetMap */ "./extensions/AEC/Minimap3D/SheetMap.js");
/* harmony import */ var _TopViewRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TopViewRenderer */ "./extensions/AEC/SheetSync/TopViewRenderer.js");
/* harmony import */ var _Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Minimap3D/MinimapMath */ "./extensions/AEC/Minimap3D/MinimapMath.js");
/* harmony import */ var _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
/* harmony import */ var _SheetVisibilityManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SheetVisibilityManager */ "./extensions/AEC/SheetSync/SheetVisibilityManager.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}





var av = Autodesk.Viewing;
var avp = av.Private;
var Empty2DModelLoader = avp.Empty2DModelLoader;

var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.SheetSyncExtension';

/**
                                                         // SheetSyncExtension - A viewer extension that syncs between a 3D model and its corresponding 2D sheet.
                                                         //                      Works only when BimWalk is active. Whenever the player changes position, the 2D sheet will be updated according to the correct viewport.
                                                         //
                                                         // @param {Viewer3D} [viewer]                       - viewer instance
                                                         // @param {Object} [options]                        - Configuration options for SheetSyncExtension
                                                         // @param {Viewer3D} [options.targetViewer]         - Target viewer instance.
                                                         // @param {bool} [options.cropToViewport]           - When enabled, the viewport that's related to the 3D camera will be cropped.
                                                         // @param {bool} [options.hideSheetWhenNotFocused]  - When enabled, when the 3D camera is not inside the sheet's viewport, the sheet will disappear.
                                                         // @param {function} [options.autoSwitchSheet]      - Automatically load sheet when map has been changed.
                                                         // @param {function} [options.loadDocumentNode]     - Optional item loading API.
                                                         // @param {function} [options.unloadModel]          - Optional item unloading loading API.
                                                         // @param {Viewer3D} [options.hidePaper]            - Hide the white paper from the 2D sheet.
                                                         // @param {Viewer3D} [options.useCustomModel]       - Use a specific 3D model to sync, instead of using all visible models by default.
                                                         */var
SheetSyncExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(SheetSyncExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(SheetSyncExtension);
  function SheetSyncExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, SheetSyncExtension);
    _this = _super.call(this, viewer, options);

    _this.options = _this.options.sheetSyncOptions || _this.options;
    _this.targetViewer = _this.options.targetViewer;

    // SheetMap that is relevant to the current camera position.
    _this.sheetMap = null;

    // Models in 3D target viewer that we are going to sync to.
    _this.targetModels = [];

    // Cache for all sheetMapConfigs.
    _this.mapCache = {};

    // Cache for fuzzyBox per model id.
    _this.modelIdToFuzzyBox = [];

    // [modelKey -> boolean] map that represents if a sheet model is being currently loaded.
    _this.isModelLoadingMap = {};

    // Whether to show 2D sheet. Show sheet by default.
    var showSheet = _this.options.showSheet !== undefined ? _this.options.showSheet : true;
    _this.setShowSheet(showSheet);

    // Controller of 2D sheet visibility and crop.
    _this.sheetVisibilityManager = new _SheetVisibilityManager__WEBPACK_IMPORTED_MODULE_4__["default"](_this.viewer, _this.options);

    _this.onNavigationToolChanged = _this.onNavigationToolChanged.bind(_assertThisInitialized(_this));
    _this.onSheetGeometryLoaded = _this.onSheetGeometryLoaded.bind(_assertThisInitialized(_this));
    _this.on3dGeometryLoaded = _this.on3dGeometryLoaded.bind(_assertThisInitialized(_this));
    _this.updateSheetAppearance = _this.updateSheetAppearance.bind(_assertThisInitialized(_this));
    _this.isCameraInsideMap = _this.isCameraInsideMap.bind(_assertThisInitialized(_this));
    _this.onModelTransformChanged = _this.onModelTransformChanged.bind(_assertThisInitialized(_this));
    _this.update = _this.update.bind(_assertThisInitialized(_this));
    _this.onViewportDataFetched = _this.onViewportDataFetched.bind(_assertThisInitialized(_this));return _this;
  }_createClass(SheetSyncExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                  this.targetViewer.loadExtension('Autodesk.AEC.ViewportsExtension'));case 2:this.viewportsExtension = _context.sent;

                this.targetViewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.onNavigationToolChanged);

                this.onNavigationToolChanged();return _context.abrupt("return",

                true);case 6:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      this.deactivate();

      this.viewportsExtension = null;

      // Clear cut planes if needed, and update opacity.
      this.sheetVisibilityManager.setVisibilityImmediate(true);
      this.sheetVisibilityManager.updateCrop(null);

      // Restore paper for all sheets.
      this.changePaperVisibility(true);

      this.sheetMap = null;
      this.targetModels = [];

      this.targetViewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.onNavigationToolChanged); // This listener should be removed specifically here, not inside removeListeners.

      return true;
    } }, { key: "onViewportDataFetched", value: function onViewportDataFetched()

    {
      this.invalidateSheetMaps();
    } }, { key: "changePaperVisibility", value: function changePaperVisibility(

    show, models) {
      // Nothing to change in case hidePaper was never set.
      if (!this.options.hidePaper) {
        return;
      }

      models = models || this.viewer.getAllModels();

      models.forEach(function (model) {
        model.changePaperVisibility(show);
      });

      this.viewer.impl.invalidate(true);
    } }, { key: "activate", value: function activate()

    {
      if (this.active) {
        return;
      }

      this.active = true;

      this.addListeners();

      this.on3dGeometryLoaded();

      // Make sure all papers are hidden if needed.
      this.changePaperVisibility(false);
    } }, { key: "deactivate", value: function deactivate()

    {
      if (!this.active) {
        return;
      }

      this.active = false;

      this.sheetMap = null;

      this.removeListeners();
    } }, { key: "addListeners", value: function addListeners()

    {var _levelExt$floorSelect, _levelExt$floorSelect2;
      this.targetViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.targetViewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.targetViewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.update);
      this.targetViewer.addEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);
      this.targetViewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.on3dGeometryLoaded);
      this.targetViewer.addEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.updateSheetAppearance);
      this.viewer.addEventListener(av.MODEL_ROOT_LOADED, this.onSheetGeometryLoaded);
      this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.viewer.addEventListener(av.TEXTURES_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.viewer.addEventListener(_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.updateSheetAppearance);

      this.viewportsExtension.addEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this.onViewportDataFetched);

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect = levelExt.floorSelector) === null || _levelExt$floorSelect === void 0 ? void 0 : _levelExt$floorSelect.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);
      levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect2 = levelExt.floorSelector) === null || _levelExt$floorSelect2 === void 0 ? void 0 : _levelExt$floorSelect2.addEventListener(Autodesk.AEC.FloorSelector.FLOOR_DATA_CHANGED, this.onViewportDataFetched);

    } }, { key: "removeListeners", value: function removeListeners()

    {var _levelExt$floorSelect3, _levelExt$floorSelect4;
      this.targetViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.targetViewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.update);
      this.targetViewer.removeEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);
      this.targetViewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.on3dGeometryLoaded);
      this.targetViewer.removeEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.updateSheetAppearance);
      this.viewer.removeEventListener(av.MODEL_ROOT_LOADED, this.onSheetGeometryLoaded);
      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.viewer.removeEventListener(av.TEXTURES_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.viewer.removeEventListener(_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.updateSheetAppearance);

      this.viewportsExtension.removeEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this.onViewportDataFetched);

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect3 = levelExt.floorSelector) === null || _levelExt$floorSelect3 === void 0 ? void 0 : _levelExt$floorSelect3.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);
      levelExt === null || levelExt === void 0 ? void 0 : (_levelExt$floorSelect4 = levelExt.floorSelector) === null || _levelExt$floorSelect4 === void 0 ? void 0 : _levelExt$floorSelect4.removeEventListener(Autodesk.AEC.FloorSelector.FLOOR_DATA_CHANGED, this.onViewportDataFetched);
    } }, { key: "isEnabled", value: function isEnabled()

    {var _this$targetViewer$ge;
      return this.targetViewer.getActiveNavigationTool() === 'bimwalk' || ((_this$targetViewer$ge = this.targetViewer.getExtension('Autodesk.AEC.Minimap3DExtension')) === null || _this$targetViewer$ge === void 0 ? void 0 : _this$targetViewer$ge.isEnabled());
    } }, { key: "onNavigationToolChanged", value: function onNavigationToolChanged()

    {
      if (this.isEnabled()) {
        this.activate();
      } else {
        this.deactivate();
      }

      this.update();
    }

    // Update sheet's opacity and crop bounds.
  }, { key: "updateSheetAppearance", value: function updateSheetAppearance() {
      if (!this.isSheetMapLoaded(this.sheetMap) || !this.isMapOnCurrentLevel(this.sheetMap)) {
        this.sheetVisibilityManager.setVisibilityImmediate(false);
        this.sheetVisibilityManager.updateCrop(null);
      } else {
        var visible = this.showSheet && this.isCameraInsideMap(this.sheetMap) && this.isEnabled();
        this.sheetVisibilityManager.updateSheetAppearance(this.sheetMap, visible);
      }
    }

    // Get a union of all targetModel's fuzzy-boxes.
  }, { key: "getFuzzyBox", value: function getFuzzyBox() {
      var fuzzyBoxRes = new THREE.Box3();

      // sum up fuzzy boxes of all map models
      for (var i = 0; i < this.targetModels.length; i++) {

        var model = this.targetModels[i];

        // get bbox from cache if possible
        var bbox = this.modelIdToFuzzyBox[model.id];

        if (!bbox) {
          // compute fuzzybox and add it to cache
          bbox = model.getFuzzyBox();

          if (model.isLoadDone()) {
            this.modelIdToFuzzyBox[model.id] = bbox;
          }
        }

        fuzzyBoxRes.union(bbox);
      }

      return fuzzyBoxRes;
    }

    // Generate a dummy sheetMap, according to the entire 3D model bounding box.
    // Initially, the map should fully fit the canvas.
  }, { key: "generateDummyMap", value: function generateDummyMap() {
      // If sheetmap already set, no need to generate dummy map.
      if (this.sheetMap) {
        return;
      }

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      var currentLevel = levelExt && levelExt.getCurrentLevel();
      var zRange = currentLevel && levelExt.getZRange(currentLevel.index);

      var modelFuzzyBox = this.getFuzzyBox();

      if (modelFuzzyBox.empty()) {
        return;
      }

      // If no level zRange is specified, use the zRange enclosing all visible models
      var zMin = zRange ? zRange.zMin : modelFuzzyBox.min.z;
      var zMax = zRange ? zRange.zMax : modelFuzzyBox.max.z;

      modelFuzzyBox.min.z = 0;
      modelFuzzyBox.max.z = 0;

      var renderer = this.viewer.impl.renderer();
      var canvasWidth = renderer.settings.logicalWidth;
      var canvasHeight = renderer.settings.logicalHeight;

      var camera = new av.UnifiedCamera(canvasWidth, canvasHeight);
      Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_2__["setTopView"])(camera, modelFuzzyBox, zMin, zMax, modelFuzzyBox.size().y);

      var mapMatrix = new THREE.Matrix4();
      var mapMatrixInv = new THREE.Matrix4();
      Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_2__["compute3DTo2DMatrix"])(camera, mapMatrix);
      mapMatrixInv.getInverse(mapMatrix);

      var min = this.viewer.clientToWorld(0, 0, undefined, true).point;
      var max = this.viewer.clientToWorld(canvasWidth, canvasHeight, undefined, true).point;

      var viewportBounds = new THREE.Box3().setFromPoints([min, max]);

      this.sheetMap = {
        viewportBounds: viewportBounds,
        mapMatrix: mapMatrix,
        mapMatrixInv: mapMatrixInv,
        viewport: {
          getGuid: function getGuid() {return 'dummyViewportGuid';},
          getSheetName: function getSheetName() {return 'dummySheetName';},
          getSheetUrn: function getSheetUrn() {return 'dummySheetUrn';} } };



      this.viewer.dispatchEvent({ type: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, sheetMap: this.sheetMap });

      this.update();
    } }, { key: "on3dGeometryLoaded", value: function on3dGeometryLoaded()

    {
      this.updateTargetModels();

      // No target models yet.
      if (!this.targetModels) {
        return;
      }

      this.generateDummyMap();

      this.update();
    }

    // Hide sheet's paper.
  }, { key: "onSheetGeometryLoaded", value: function onSheetGeometryLoaded(_ref) {var model = _ref.model;
      this.changePaperVisibility(false, [model]);
      this.update();
    } }, { key: "invalidateSheetMaps", value: function invalidateSheetMaps()

    {var _this2 = this;
      Object.keys(this.mapCache).forEach(function (guid) {
        // Create a new mapMatrix according to the transformed models.
        var newMaps = _Minimap3D_SheetMap__WEBPACK_IMPORTED_MODULE_0__["default"].createSheetMapConfigs(_this2.targetModels, guid, _this2.viewportsExtension);

        newMaps.forEach(function (newMap) {
          var map = _this2.mapCache[guid].find(function (m) {return m.viewport.getGuid() === newMap.viewport.getGuid();});

          // It's important to keep the original maps, and change only the matrix,
          // since there is additional attributes that already assigned to the map instances(i.e.thumbnail).
          if (map) {var _map$thumbnail;
            map.mapMatrix = newMap.mapMatrix;
            map.mapMatrixInv = newMap.mapMatrixInv;

            // Mark the thumbnail mesh as dirty, so in ThumbnailOverlay it will be repositioned.
            if ((_map$thumbnail = map.thumbnail) === null || _map$thumbnail === void 0 ? void 0 : _map$thumbnail.mesh) {
              map.thumbnail.mesh.dirty = true;
            }
          } else {
            // New map detected.
            // Calculate viewport bounds and store it as part of the sheetMap.
            newMap.viewportBounds = newMap.viewport.getViewportBounds(_this2.viewer.model.getUnitScale());
            _this2.mapCache[guid].push(newMap);
          }
        });
      });

      this.update();

      // This is needed in order to sync the camera of the TopViewRenderer, as it was a new sheetMap.
      this.viewer.dispatchEvent({ type: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, sheetMap: this.sheetMap });
    } }, { key: "onModelTransformChanged", value: function onModelTransformChanged(_ref2)

    {var model = _ref2.model;
      // If model is not part of targetModels - skip.
      if (!this.targetModels.includes(model)) {
        return;
      }

      // Clear fuzzyBox cache for the transformed model, so it will get calculated again.
      this.modelIdToFuzzyBox[model.id] = null;

      this.invalidateSheetMaps();
    } }, { key: "updateTargetModels", value: function updateTargetModels()

    {
      if (!this.options.useCustomModel) {
        // Filter only 3D models.
        var models = this.targetViewer.getVisibleModels().filter(function (m) {return m.is3d();});
        this.setTargetModels(models);
      }
    } }, { key: "setTargetModels", value: function setTargetModels(

    models) {
      this.targetModels = models;
    } }, { key: "getSheetNodeKey", value: function getSheetNodeKey(

    map) {
      var key = map && "".concat(map.viewport.getSheetUrn(), "_").concat(map.viewport.getSheetName());
      return key;
    } }, { key: "isLoadingSheetNode", value: function isLoadingSheetNode(

    map) {
      var key = this.getSheetNodeKey(map);
      return key && this.isModelLoadingMap[key];
    } }, { key: "shouldSwitchSheet", value: function shouldSwitchSheet()

    {
      var showSheet = this.showSheet;
      var isAutoSwitchEnabled = this.options.autoSwitchSheet;
      var isDifferentSheetLoaded = !this.isSheetMapLoaded(this.sheetMap);
      var isCameraInside = this.isCameraInsideMap(this.sheetMap);
      var isAlreadyLoading = this.isLoadingSheetNode(this.sheetMap);
      var isMinimapDebugMode = this.options.minimapDebugMode;

      return isAutoSwitchEnabled && isDifferentSheetLoaded && showSheet && isCameraInside && !isAlreadyLoading && !isMinimapDebugMode;
    } }, { key: "getCurrentLevel", value: function getCurrentLevel()

    {
      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');

      if (!levelExt) {
        return;
      }

      return levelExt.getCurrentLevel();
    } }, { key: "update", value: function update()

    {
      if (!this.viewer.model) {
        return;
      }

      var level = this.getCurrentLevel();

      if (!level) {
        return;
      }

      if (!this.isEnabled()) {
        return;
      }

      this.updateTargetModels();

      this.updateSheetMaps();

      this.updateSheetAppearance();

      this.switchSheetIfNeededDebounce();
    } }, { key: "switchSheetIfNeededDebounce", value: function switchSheetIfNeededDebounce()

    {
      if (this.debounceTimeout) {
        clearTimeout(this.debounceTimeout);
      }

      this.debounceTimeout = setTimeout(this.switchSheetIfNeeded.bind(this), 300);
    }

    // Return a custom hash that encapsulates the current sheet map viewer id.
  }, { key: "getCustomHash", value: function getCustomHash() {
      return "sheetsync_".concat(this.viewer.id);
    } }, { key: "switchSheetIfNeeded", value: function () {var _switchSheetIfNeeded = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var _this3 = this;var previousModel, sheetMap, sheetNode, doc, initialOpacity, loadFunction, unloadFunction, key;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:if (!


                this.shouldSwitchSheet()) {_context2.next = 16;break;}
                this.viewer.dispatchEvent({ type: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].CHANGING_SHEET_EVENT });

                // Load sheet
                previousModel = this.viewer.model;
                sheetMap = this.sheetMap;_context2.next = 6;return (
                  this.sheetMap.getSheetNode());case 6:sheetNode = _context2.sent;if (!(


                sheetMap !== this.sheetMap)) {_context2.next = 9;break;}return _context2.abrupt("return");case 9:



                doc = sheetNode.getRootNode().getDocument();
                initialOpacity = this.options.hideSheetWhenNotFocused ? 0.0 : 1.0;
                loadFunction = this.options.loadDocumentNode || this.viewer.loadDocumentNode.bind(this.viewer);
                unloadFunction = this.options.unloadModel || this.viewer.unloadModel.bind(this.viewer);
                key = this.getSheetNodeKey(sheetMap);
                this.isModelLoadingMap[key] = true;
                // There are some critical flags here:
                // loadAsHidden - We have to first load the model is hidden, and only then show it. The reason is because we
                //                have to make sure that `renderer.enter2DMode()` will be called, and it won't get called if there is more the one loaded model.
                //                Without calling `enter2DMode`, there is a chance for different rendering errors.
                //
                // keepCurrentModels - In order to prevent tearDown of the viewer, a thing that will cause the navigation to stop,
                //                     we have to first load the new model (as hidden), then hide the previous model, and then show the new one.
                // preserveView - Keeps the camera in the same spot.
                loadFunction(doc, sheetNode, { opacity: initialOpacity, preserveView: true, keepCurrentModels: true, loadAsHidden: true, customHash: this.getCustomHash() }).
                catch(function (error) {
                  return 
                  // Thiwanka
                  // console.error("Failed to load sheet: ", sheetNode.name(), ": ", error);
                }).
                then(function (model) {
                  // if (previousModel && previousModel !== model) {
                  //   console.log("unloaded");
                  //   // In case the previous model was the initial empty model - just unload it. There is no reason to support caching it.
                  //   if (previousModel.loader instanceof Empty2DModelLoader) {
                  //     _this3.viewer.unloadModel(previousModel);
                  //   } else {
                  //     unloadFunction(previousModel);
                  //   }
                  // }

                  _this3.isModelLoadingMap[key] = false;
                  
                  if (model)
                    _this3.viewer.showModel(model, true);

                  // In case we loaded a leaflet, we don't want to restrict zoom in/out when viewing in the minimap.
                  // Therefore, we revert the constraints that are being set up in viewer.initializeFirstModelPresets.
                  _this3.viewer.navigation.setConstraints2D();

                  _this3.sheetVisibilityManager.setVisibilityImmediate(false);

                  if (model) {
                    // Update viewportBounds with model unit scale.
                    sheetMap.viewportBounds = sheetMap.viewport.getViewportBounds(model.getUnitScale());
                    sheetMap.model = model;
                  }

                  _this3.update();
                  _this3.viewer.dispatchEvent({ type: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, sheetMap: sheetMap });
                });case 16:case "end":return _context2.stop();}}}, _callee2, this);}));function switchSheetIfNeeded() {return _switchSheetIfNeeded.apply(this, arguments);}return switchSheetIfNeeded;}()



    // we can't just shallow compare the instances, because SheetMap.createSheetMapConfigs returns a new pointer each time.
    // Instead, we compare the viewportGuid, that stays the same.
  }, { key: "isSheetMapsEqual", value: function isSheetMapsEqual(map1, map2) {
      return (map1 === null || map1 === void 0 ? void 0 : map1.viewport.getGuid()) === (map2 === null || map2 === void 0 ? void 0 : map2.viewport.getGuid());
    } }, { key: "isMapOnCurrentLevel", value: function isMapOnCurrentLevel(

    map) {
      if (!map) {
        return false;
      }

      var currentLevel = this.getCurrentLevel();

      // Different level.
      if (!currentLevel || map.levelGuid !== currentLevel.guid) {
        return false;
      }

      return true;
    } }, { key: "isSheetMapLoaded", value: function isSheetMapLoaded(

    map) {
      return (map === null || map === void 0 ? void 0 : map.model) === this.viewer.model;
    }

    // Is current 3D camera is inside a loaded map.
  }, { key: "isCameraInsideMap", value: function isCameraInsideMap(map) {
      if (!map) {
        return false;
      }

      if (!this.isMapOnCurrentLevel(map)) {
        return false;
      }

      // Relevant sheet is not currently loaded.
      if (!this.options.autoSwitchSheet && !this.isSheetMapLoaded(map)) {
        return false;
      }

      return Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_2__["posIsInsideMap"])(this.targetViewer.getCamera().position, map.mapMatrix);
    }

    // Update current sheet map according to current level.
  }, { key: "updateSheetMaps", value: function updateSheetMaps() {
      var maps;

      var currentLevel = this.getCurrentLevel();

      if (!this.mapCache[currentLevel.guid]) {
        // Find maps that are relevant to these models, and for the current level.
        maps = _Minimap3D_SheetMap__WEBPACK_IMPORTED_MODULE_0__["default"].createSheetMapConfigs(this.targetModels, currentLevel.guid, this.viewportsExtension);

        var currentModel = this.viewer.model;
        var currentBubbleNode = currentModel.getDocumentNode();

        maps.forEach(function (map) {
          // Calculate viewport bounds and store it as part of the sheetMap.
          map.viewportBounds = map.viewport.getViewportBounds(currentModel.getUnitScale());

          // If the current loaded model is the map's model.
          if (map.viewport.getSheetName() === currentBubbleNode.name() && map.viewport.getSheetUrn() === currentBubbleNode.urn(true)) {
            map.model = currentModel;
          }
        });

        this.mapCache[currentLevel.guid] = maps;
      } else {
        maps = this.mapCache[currentLevel.guid];
      }

      // In case we didn't find another map - keep it only if cropToViewport.
      // Otherwise, it can cause a confusion when the avatar is floating above a viewport that it doesn't really belongs to.
      // In that case, unset the map.
      var map = maps.find(this.isCameraInsideMap) || (this.options.cropToViewport ? this.sheetMap : undefined);

      var mapChanged = !this.isSheetMapsEqual(this.sheetMap, map);

      this.sheetMap = map;

      if (mapChanged) {
        this.viewer.dispatchEvent({ type: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, sheetMap: this.sheetMap });
      }
    } }, { key: "setShowSheet", value: function setShowSheet(

    show) {
      if (!show || _TopViewRenderer__WEBPACK_IMPORTED_MODULE_1__["default"].isSheetMapSupported()) {
        this.showSheet = show;

        if (this.active) {
          this.update();
        }
      }
    } }, { key: "getShowSheet", value: function getShowSheet()

    {
      return this.showSheet;
    } }, { key: "isSheetVisible", value: function isSheetVisible()

    {
      return (
        this.showSheet &&
        this.isSheetMapLoaded(this.sheetMap) &&
        this.sheetVisibilityManager.isSheetVisible() &&
        this.viewer.model.isLoadDone());

    } }, { key: "expandCropBounds", value: function expandCropBounds(

    duration) {
      this.sheetVisibilityManager.expandCropBounds(this.sheetMap, duration);
    } }, { key: "setSheetOpaque", value: function setSheetOpaque(

    duration) {
      this.sheetVisibilityManager.setSheetOpaque(duration);
    } }]);return SheetSyncExtension;}(Autodesk.Viewing.Extension);

Object.assign(namespace, { SheetSyncEvents: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"] });
namespace.SheetSyncExtension = SheetSyncExtension;
av.theExtensionManager.registerExtension(myExtensionName, SheetSyncExtension);

/***/ }),

/***/ "./extensions/AEC/SheetSync/SheetTransforms.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/SheetSync/SheetTransforms.js ***!
  \*****************************************************/
/*! exports provided: worldToMapPixels, mapPixelsToWorld, mapPixelsToSheet, mapPixelsToWidget, widgetToMapPixels, getCameraRotationAngle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "worldToMapPixels", function() { return worldToMapPixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapPixelsToWorld", function() { return mapPixelsToWorld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapPixelsToSheet", function() { return mapPixelsToSheet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapPixelsToWidget", function() { return mapPixelsToWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "widgetToMapPixels", function() { return widgetToMapPixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCameraRotationAngle", function() { return getCameraRotationAngle; });
/* harmony import */ var _Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Minimap3D/MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");


// Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.
function worldToMapPixels(sheetMap, pos3D) {
  var size = sheetMap.viewportBounds.size();
  return _Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["worldToMapPixels"](pos3D, sheetMap.mapMatrix, size.x, size.y);
};

// Convert minimap pixel coords (+ world-z) to 3D world position. Minimap pixels are absolute, i.e. not affected by scrolling.
function mapPixelsToWorld(sheetMap, posX, posY, zWorld) {
  var size = sheetMap.viewportBounds.size();
  return _Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["mapPixelsToWorld"](posX, posY, zWorld, sheetMap.mapMatrixInv, size.x, size.y);
};

function mapPixelsToSheet(sheetMap, p) {
  // Widget pixel origin is at top-left, i.e., y-axis points down.
  // For that reason, we have to flip the y coordinate.
  p.y = sheetMap.viewportBounds.size().y - p.y;

  var min = sheetMap.viewportBounds.min;
  p.x += min.x;
  p.y += min.y;
};

// @param {Vector2} p - point in map-pixel space:             Value range is [0, 0] x [viewportSize.width, viewportSize.height]
// Converts p to a relative pixel-position in the map widget: Value range is [0, 0] x [viewerWidth, viewerHeight]
function mapPixelsToWidget(sheetMap, viewer, p) {
  mapPixelsToSheet(sheetMap, p);
  p.copy(viewer.worldToClient(p));
};

var EPSILON = 0.001;

// @param {Vector2} p               - transformed in-place from viewer pixels to map image pixels
//                                    widget pixel origin is at top-left, i.e., y-axis points down (compatible to mouse events)
// @param {boolean} clamp           - In case the resulting position is outside of the map, clamp the value to fit the maps' border.
// @param {boolena} usePixelCenter  - By default (true), input widget coordinates are assumed to be integer pixel coordinates as you get
//                                    from events. Therefore, pixel (0,0) is actually interpreted as the pixel midpoint
//                                    of pixel (0,0).
//
//                                    If usePixelCenter is false, the input is interpreted as a floating-point position
//                                    in pixel-space [0, widgetWidth] x [0, widgetHeight] instead. I.e., (0,0) corresponds
//                                    to the accurate minPoint of pixel (0,0).
function widgetToMapPixels(sheetMap, viewer, p, clamp) {var usePixelCenter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

  // Note: The clientToViewport conversion assumes client coords as integer pixel coords. So, it always adds
  //       0.5 pixels offset in x/y to hit the pixel center. If this is not wanted, we have to add
  //       the pixel-offset first.
  var clientX = p.x;
  var clientY = p.y;

  if (!usePixelCenter) {
    clientX -= 0.5;
    clientY -= 0.5;
  }

  // We can't use viewer.clientToWorld, because we do want to support the case where p is outside of the paper.
  p.copy(viewer.clientToWorld(clientX, clientY, undefined, true).point);

  var min = sheetMap.viewportBounds.min;
  p.x -= min.x;
  p.y -= min.y;

  // Widget pixel origin is at top-left, i.e., y-axis points down.
  // For that reason, we have to flip the y coordinate.
  p.y = sheetMap.viewportBounds.size().y - p.y;

  if (clamp) {
    var size = sheetMap.viewportBounds.size();
    p.x = THREE.Math.clamp(p.x, EPSILON, size.x - EPSILON);
    p.y = THREE.Math.clamp(p.y, EPSILON, size.y - EPSILON);
  }
};

function getCameraRotationAngle(viewer) {
  var upVec = viewer.navigation.getCameraUpVector();
  return Math.atan2(upVec.y, upVec.x) - 0.5 * Math.PI;
};

/***/ }),

/***/ "./extensions/AEC/SheetSync/SheetVisibilityManager.js":
/*!************************************************************!*\
  !*** ./extensions/AEC/SheetSync/SheetVisibilityManager.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetVisibilityManager; });
/* harmony import */ var _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var INFINITE_BOX = new THREE.Box3().setFromPoints([new THREE.Vector3(-1e20, -1e20, -1e20), new THREE.Vector3(1e20, 1e20, 1e20)]);

/**
                                                                                                                                  // SheetVisibilityManager - Manage the visibility of the sheet - opacity and crop.
                                                                                                                                  */var
SheetVisibilityManager = /*#__PURE__*/function () {
  function SheetVisibilityManager(viewer, options) {_classCallCheck(this, SheetVisibilityManager);
    this.viewer = viewer;
    this.options = options;
  }

  // Update sheet's opacity and crop bounds.
  _createClass(SheetVisibilityManager, [{ key: "updateSheetAppearance", value: function updateSheetAppearance(sheetMap, visible) {var _this = this;
      var model = this.viewer.model;

      if (!model) {
        return;
      }

      var targetOpacity = visible ? _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_0__["SHEET_OPACITY"] : 0.0;
      var viewportBounds = sheetMap && sheetMap.viewportBounds;

      if (visible) {
        this.updateCrop(visible, viewportBounds);
      }

      this.animateOpacity(this.viewer.model, targetOpacity, function () {
        _this.updateCrop(visible, viewportBounds);
      });
    }

    // Set sheet visibility immediately.
  }, { key: "setVisibilityImmediate", value: function setVisibilityImmediate(visible) {var _this2 = this;
      var models = this.viewer.getAllModels();

      models.forEach(function (model) {
        if (model.fadeAnim) {
          model.fadeAnim.stop();
          model.fadeAnim = null;
        }

        _this2.setModelOpacity(model, visible ? 1.0 : 0.0);
      });
    }

    // Animate sheet's opacity.
  }, { key: "animateOpacity", value: function animateOpacity(model, targetValue, onFadeDone) {var _this3 = this;var duration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_0__["FADE_DURATION"];
      if (!model) {
        return;
      }

      if (model.fadeAnim) {
        model.fadeAnim.stop();
        model.fadeAnim = null;
      }

      var startVal = model.opacity || 0.0;

      var onTimer = function onTimer(t) {
        t = Autodesk.Viewing.Private.smootherStep(t);
        var opacity = Autodesk.Viewing.Private.lerp(startVal, targetValue, t);
        _this3.setModelOpacity(model, opacity);
      };

      var onFadeEnd = function onFadeEnd() {
        model.fadeAnim = null;
        onFadeDone && onFadeDone();
      };

      model.fadeAnim = Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onFadeEnd);
      model.fadeAnim.targetValue = targetValue;
    }

    // Change all sheet's materials to be in with a given opacity.
  }, { key: "setModelOpacity", value: function setModelOpacity(model, value) {
      if (!this.options.hideSheetWhenNotFocused) {
        return;
      }

      if (model) {
        var materialsManager = this.viewer.impl.matman();
        var materials = materialsManager.getModelMaterials(model).mats;

        var changed = false;

        Object.keys(materials).forEach(function (key) {
          if (materials[key].uniforms && materials[key].uniforms.opacity && materials[key].uniforms.opacity.value !== value) {
            materials[key].uniforms.opacity.value = value;
            changed = true;
          }
        });

        model.opacity = value;

        if (changed) {
          this.viewer.dispatchEvent({
            type: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_0__["SheetSyncEvents"].SHEET_VISIBILITY_CHANGED_EVENT,
            model: model,
            value: value });


          this.viewer.impl.invalidate(true);
        }
      }
    } }, { key: "expandCropBounds", value: function expandCropBounds(

    sheetMap) {var _this4 = this;var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_0__["FADE_DURATION"];
      var startBounds = sheetMap.viewportBounds;
      var modelBounds = this.viewer.model.getBoundingBox();

      var box = new THREE.Box2();

      var onTimer = function onTimer(t) {
        t = Autodesk.Viewing.Private.smootherStep(t);
        box.min.lerpVectors(startBounds.min, modelBounds.min, t);
        box.max.lerpVectors(startBounds.max, modelBounds.max, t);
        _this4.updateCrop(true, box);
      };

      Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer);
    }

    // Update the crop according to given viewport bounds.
  }, { key: "updateCrop", value: function updateCrop(visible) {var bounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INFINITE_BOX;
      if (this.options.cropToViewport) {
        var model = this.viewer.model;

        if (!model) {
          return;
        }

        if (!model.latestCropBounds) {
          model.latestCropBounds = new THREE.Box3();
        }

        var cropBounds;
        if (visible) {
          cropBounds = bounds;
        } else {
          // put the cut planes in infinity.
          // This is more efficient then removing the cutplanes from all the materials.
          cropBounds = INFINITE_BOX;
        }

        if (!model.latestCropBounds.equals(cropBounds)) {
          model.latestCropBounds = cropBounds.clone();
          this.viewer.impl.setViewportBounds(model, cropBounds.empty() ? null : cropBounds);
        }
      }
    } }, { key: "isSheetVisible", value: function isSheetVisible()

    {var _this$viewer, _this$viewer$model;
      return ((_this$viewer = this.viewer) === null || _this$viewer === void 0 ? void 0 : (_this$viewer$model = _this$viewer.model) === null || _this$viewer$model === void 0 ? void 0 : _this$viewer$model.opacity) !== 0;
    } }, { key: "setSheetOpaque", value: function setSheetOpaque(

    duration) {var _this5 = this;
      this.animateOpacity(this.viewer.model, 1.0, undefined, duration);

      var onTimer = function onTimer(t) {
        t = Autodesk.Viewing.Private.smootherStep(t);
        var opacity = Autodesk.Viewing.Private.lerp(0, 1, t);
        _this5.viewer.impl && _this5.viewer.setBackgroundOpacity(opacity);
      };

      Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer);
    } }]);return SheetVisibilityManager;}();

/***/ }),

/***/ "./extensions/AEC/SheetSync/ThumbnailsOverlay.js":
/*!*******************************************************!*\
  !*** ./extensions/AEC/SheetSync/ThumbnailsOverlay.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ThumbnailsOverlay; });
/* harmony import */ var _SheetTransforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SheetTransforms */ "./extensions/AEC/SheetSync/SheetTransforms.js");
/* harmony import */ var _Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Minimap3D/MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
/* harmony import */ var _Minimap3D_SheetThumbnail__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Minimap3D/SheetThumbnail */ "./extensions/AEC/Minimap3D/SheetThumbnail.js");
/* harmony import */ var _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var OVERLAY_SCENE = 'thumbnail-overlay-scene';
var EPSILON = 0.0001;

// ThumbnailsOverlay - An overlay of sheet thumbnails.
// For every sheet on the current level, a request for DS will be made in order to get its thumbnail.
// The thumbnail will be displayed as a plane as an overlay on top of the top-view 3D rendering.
//
// In case that the 2D sheet is fully displayed, a (sort of) high-res snapshot of the sheet will be taken,
// and will be used as the thumbnail texture.
var ThumbnailsOverlay = /*#__PURE__*/function () {
  function ThumbnailsOverlay(viewer, sheetSyncExt) {_classCallCheck(this, ThumbnailsOverlay);
    this.viewer = viewer;
    this.sheetSyncExt = sheetSyncExt;

    this.planeGeometry = new THREE.PlaneBufferGeometry(1, 1);

    this.viewer.impl.createOverlayScene(OVERLAY_SCENE);
    this.createThumbnailMesh = this.createThumbnailMesh.bind(this);
  }

  // Create a plane, position it in the correct place in the scene, and assign the thumbnail texture to it.
  _createClass(ThumbnailsOverlay, [{ key: "createThumbnailMesh", value: function createThumbnailMesh(map) {
      if (!this.viewer) return;
      var mesh = map.thumbnail.mesh;

      if (!mesh) {
        var material = new THREE.MeshBasicMaterial({
          opacity: 0.0, // Initially, thumbnail should be hidden.
          transparent: true });


        mesh = new THREE.Mesh(this.planeGeometry, material);

        this.setMeshTransform(mesh, map);
        map.thumbnail.mesh = mesh;

        var texture = new THREE.Texture();
        texture.minFilter = THREE.LinearFilter;
        mesh.material.map = texture;
      }

      // Update texture.
      mesh.material.map.image = map.thumbnail.thumbnailImage;
      mesh.material.map.needsUpdate = true;

      this.update();
    } }, { key: "setMeshTransform", value: function setMeshTransform(

    mesh, map) {
      var minWorld = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_0__["mapPixelsToWorld"])(map, map.viewportBounds.min.x, map.viewportBounds.min.y, 0);
      var maxWorld = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_0__["mapPixelsToWorld"])(map, map.viewportBounds.max.x, map.viewportBounds.max.y, 0);
      var p2 = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_0__["mapPixelsToWorld"])(map, map.viewportBounds.max.x, map.viewportBounds.min.y, 0);

      var angle = Math.atan2(p2.y - minWorld.y, p2.x - minWorld.x);
      var box = new THREE.Box3().setFromPoints([minWorld, maxWorld]);
      var boxCenter = box.center();
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__["rotateAround"])(minWorld, boxCenter, -angle);
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__["rotateAround"])(maxWorld, boxCenter, -angle);

      box.setFromPoints([minWorld, maxWorld]);

      var meshSize = box.size();
      var mapSize = map.viewportBounds.size();

      // Height of the plane is camera position minus epsilon, in order to make sure the plane is inside the frustum.
      var center = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_0__["mapPixelsToWorld"])(map, mapSize.x / 2, mapSize.y / 2, this.viewer.getCamera().position.z - EPSILON);

      mesh.position.copy(center);
      mesh.rotation.set(0, 0, angle);
      mesh.scale.set(meshSize.x, meshSize.y, 1);
      mesh.dirty = false;
    } }, { key: "showThumbnail", value: function showThumbnail(

    thumbnail) {
      if (thumbnail && thumbnail.mesh) {
        if (this.viewer.impl.overlayScenes[OVERLAY_SCENE].scene.children.indexOf(thumbnail.mesh) === -1) {
          this.viewer.impl.addOverlay(OVERLAY_SCENE, thumbnail.mesh);
          this.animateOpacity(thumbnail, 0.5);
        }
      }
    } }, { key: "hideThumbnail", value: function hideThumbnail(

    thumbnail, immediate) {var _this = this;
      if (thumbnail && thumbnail.mesh) {
        if (this.viewer.impl.overlayScenes[OVERLAY_SCENE].scene.children.indexOf(thumbnail.mesh) !== -1) {
          if (immediate) {
            this.viewer.impl.removeOverlay(OVERLAY_SCENE, thumbnail.mesh);
            thumbnail.mesh.material.opacity = 0;
          } else {
            this.animateOpacity(thumbnail, 0.0, function () {
              _this.viewer.impl.removeOverlay(OVERLAY_SCENE, thumbnail.mesh);
            });
          }
        }
      }
    } }, { key: "animateOpacity", value: function animateOpacity(

    thumbnail, targetValue, onDone) {var _this2 = this;
      if (thumbnail.fadeAnim) {
        if (thumbnail.fadeAnim.targetValue === targetValue) {
          return;
        }

        thumbnail.fadeAnim.stop();
        thumbnail.fadeAnim = null;
      }

      var startVal = thumbnail.mesh.material.opacity;

      var onTimer = function onTimer(t) {
        // In case viewer was destroyed during animation.
        if (!_this2.viewer) {
          return;
        }

        t = Autodesk.Viewing.Private.smootherStep(t);
        var opacity = Autodesk.Viewing.Private.lerp(startVal, targetValue, t);
        _this2.setThumbnailOpacity(thumbnail, opacity);
      };

      var onFadeEnd = function onFadeEnd() {
        thumbnail.fadeAnim = null;
        onDone && onDone();
      };

      thumbnail.fadeAnim = Autodesk.Viewing.Private.fadeValue(0, 1, _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["FADE_DURATION"], onTimer, onFadeEnd);
      thumbnail.fadeAnim.targetValue = targetValue;
    } }, { key: "setThumbnailOpacity", value: function setThumbnailOpacity(

    thumbnail, value) {
      if (thumbnail.mesh.material.opacity !== value) {
        thumbnail.mesh.material.opacity = value;
        this.viewer.impl.invalidate(false, false, true);
      }
    } }, { key: "requestThumbnailDebounce", value: function requestThumbnailDebounce(

    map) {var _this3 = this;
      if (this.debounceTimeout) {
        clearTimeout(this.debounceTimeout);
      }

      this.debounceTimeout = setTimeout(function () {
        if (!_this3.sheetSyncExt) return;

        map.thumbnail = new _Minimap3D_SheetThumbnail__WEBPACK_IMPORTED_MODULE_2__["default"](map, _this3.sheetSyncExt.viewer, _this3.createThumbnailMesh);

        if (!_this3.tryRefineThumbnail(map)) {
          map.thumbnail.requestThumbnail();
        }
      }, 300);
    } }, { key: "tryRefineThumbnail", value: function tryRefineThumbnail(

    map) {
      if (this.sheetSyncExt.isSheetMapLoaded(map) &&
      this.sheetSyncExt.viewer.model.isLoadDone(true) &&
      this.sheetSyncExt.viewer.model.opacity === _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SHEET_OPACITY"]) {

        map.thumbnail.refineThumbnail();
        return true;
      }

      return false;
    }

    // Verify all the thumbnails are displayed correctly.
  }, { key: "update", value: function update() {var _this4 = this;
      var sheetMaps = this.sheetSyncExt.mapCache;
      var currentLevel = this.sheetSyncExt.getCurrentLevel();

      if (!currentLevel) {
        return;
      }

      var showSheetEnabled = this.sheetSyncExt.getShowSheet();

      Object.keys(sheetMaps).forEach(function (levelGuid) {
        var levelMaps = sheetMaps[levelGuid];
        var sameLevel = levelGuid === currentLevel.guid;
        levelMaps.forEach(function (map) {var _map$thumbnail, _map$thumbnail$mesh;
          var showThumbnail = sameLevel && showSheetEnabled && !_this4.sheetSyncExt.isCameraInsideMap(map);

          if (sameLevel) {
            if (!map.thumbnail) {
              // Thumbnail was not fetched yet - initialize thumbnail object and request thumbnail image.
              // Update when loaded.
              _this4.requestThumbnailDebounce(map);
            } else if (!map.thumbnail.thumbnailRefined) {
              _this4.tryRefineThumbnail(map);
            }
          }

          // Update transform if model transform was changed.
          if ((_map$thumbnail = map.thumbnail) === null || _map$thumbnail === void 0 ? void 0 : (_map$thumbnail$mesh = _map$thumbnail.mesh) === null || _map$thumbnail$mesh === void 0 ? void 0 : _map$thumbnail$mesh.dirty) {
            _this4.setMeshTransform(map.thumbnail.mesh, map);
          }

          if (showThumbnail) {
            // If thumbnail mesh is ready - add it to the overlay scene if it's not there already.
            _this4.showThumbnail(map.thumbnail);
          } else {
            // Thumbnail mesh is ready, but should be hidden because it's not on the current level -
            // Remove it from the overlay scene if it's there.
            _this4.hideThumbnail(map.thumbnail, levelGuid !== currentLevel.guid);
          }
        });
      });
    } }, { key: "destroy", value: function destroy()

    {
      this.planeGeometry.dispose();
      this.planeGeometry = null;

      this.viewer.impl.removeOverlayScene(OVERLAY_SCENE);

      this.sheetSyncExt = null;
      this.viewer = null;
    } }]);return ThumbnailsOverlay;}();

/***/ }),

/***/ "./extensions/AEC/SheetSync/TopViewRenderer.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/SheetSync/TopViewRenderer.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TopViewRenderer; });
/* harmony import */ var _Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Minimap3D/MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
/* harmony import */ var _SheetTransforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SheetTransforms */ "./extensions/AEC/SheetSync/SheetTransforms.js");
/* harmony import */ var _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
/* harmony import */ var _ThumbnailsOverlay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ThumbnailsOverlay */ "./extensions/AEC/SheetSync/ThumbnailsOverlay.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}




var av = Autodesk.Viewing;
var ProgressState = av.ProgressState;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.TopViewRendererExtension';

var tempVec3 = new THREE.Vector3();
var tempVec2 = new THREE.Vector2();
var box = new THREE.Box3();

/**
                            // TopViewRenderer - A viewer extension renders a 3D top view of a target model.
                            //                   It is highly recommended to use LeechViewer for the target viewer - otherwise the 3D model will be loaded again,
                            //                   and no shared resources will be used.
                            //
                            // @param {Viewer3D} [viewer]                       - viewer instance
                            // @param {Object} [options]                        - Configuration options for TopViewRenderer
                            */var
TopViewRenderer = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(TopViewRenderer, _Autodesk$Viewing$Ext);var _super = _createSuper(TopViewRenderer);
  function TopViewRenderer(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, TopViewRenderer);
    _this = _super.call(this, viewer, options);

    _this.options = _this.options.topViewRendererOptions || _this.options;

    // [modelKey -> boolean] map that represents if a model is being currently loaded on the topViewViewer.
    _this.isModelLoadingMap = {};

    // Time to wait before start rotating to sheet origin.
    _this.waitBeforeRotation = _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__["WAIT_BEFORE_ROTATION"];

    // Rotation speed.
    _this.rotationDuration = _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__["ROTATION_DURATION"];

    _this.onBeginScene = _this.onBeginScene.bind(_assertThisInitialized(_this));
    _this.update = _this.update.bind(_assertThisInitialized(_this));
    _this.onMainMapChanged = _this.onMainMapChanged.bind(_assertThisInitialized(_this));
    _this.onResize = _this.onResize.bind(_assertThisInitialized(_this));
    _this.rotateToSheet = _this.rotateToSheet.bind(_assertThisInitialized(_this));
    _this.onSheetGeometryLoaded = _this.onSheetGeometryLoaded.bind(_assertThisInitialized(_this));

    // Callbacks to be invoked at the end of rotation
    _this.pendingFinishedCallbacks = [];return _this;
  }_createClass(TopViewRenderer, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this2 = this;var NearFarOverlay, modelQueue, originalReset;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                  this.viewer.loadExtension('Autodesk.AEC.SheetSyncExtension', this.viewer.config));case 2:this.sheetSyncExt = _context.sent;

                this.targetViewer = this.sheetSyncExt.targetViewer;

                this.initTopViewViewer();

                if (this.options.minimapDebugMode) {
                  NearFarOverlay = __webpack_require__(/*! ./NearFarOverlay */ "./extensions/AEC/SheetSync/NearFarOverlay.js").default;
                  this.nearFarOverlay = new NearFarOverlay(this.topViewViewer, this.targetViewer);

                  modelQueue = this.topViewViewer.impl.modelQueue();
                  originalReset = modelQueue.reset.bind(modelQueue);

                  modelQueue.reset = function () {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
                    // In order to present frustum culling in the top view minimap, we need to "steal" the target viewer's camera when calculating the frustum.
                    args[0] = _this2.targetViewer.getCamera();
                    originalReset.apply(void 0, args);
                  };

                } else {
                  this.thumbnailsOverlay = new _ThumbnailsOverlay__WEBPACK_IMPORTED_MODULE_3__["default"](this.topViewViewer, this.sheetSyncExt);
                }

                this.addListeners();case 7:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "initTopViewViewer", value: function initTopViewViewer()


    {var _this$targetViewer$co;
      var container = this.viewer.container;
      var sharedResources = this.targetViewer.sharedResources;

      var config = {};
      if ((_this$targetViewer$co = this.targetViewer.config) === null || _this$targetViewer$co === void 0 ? void 0 : _this$targetViewer$co.profileSettings) {
        config.profileSettings = Object.assign({}, this.targetViewer.config.profileSettings);
      }

      // In case targetViewer is a LeechViewer, create a leechViewer and use the shared resources.
      if (sharedResources) {
        this.topViewViewer = Autodesk.Viewing.createLeechViewer(container, config, sharedResources, Autodesk.Viewing.Viewer3D);
      } else {
        // Otherwise, it's unfortunate, and you'll have to create a regular Viewer3D, without resource sharing.
        console.warn('TopViewRenderer - It is highly recommended using LeechViewer as your target viewer when using this extension.');
        this.topViewViewer = new Autodesk.Viewing.Viewer3D(container, config);
      }

      this.viewer.container.insertBefore(this.topViewViewer.container, this.viewer.container.firstChild);
      this.topViewViewer.container.style.zIndex = -1;
      this.topViewViewer.container.style.pointerEvents = 'none';
      this.topViewViewer.container.style.transition = 'opacity 0.7s'; // Value matches "FADE_DURATION" inside SheetSyncConstants.js
      this.topViewViewer.container.style.backgroundColor = 'transparent';
      this.topViewViewer.start(undefined, undefined, undefined, undefined, { webglInitParams: { alpha: true } });
      this.topViewViewer.impl.skipCameraUpdate = true; // Used in order to set near-far values manually.
      this.topViewViewer.setBackgroundOpacity(0);

      this.backgroundColorBackup = this.viewer.container.style.backgroundColor;
      this.viewer.container.style.backgroundColor = 'transparent';
      this.backgroundOpacityBackup = this.viewer.impl.glrenderer().getClearAlpha();
      this.viewer.setBackgroundOpacity(0);

      if (!TopViewRenderer.isSheetMapSupported()) {
        this.viewer.canvasWrap.style.opacity = 0;
      }
    } }, { key: "destroyTopViewViewer", value: function destroyTopViewViewer()

    {
      if (this.topViewViewer) {
        this.topViewViewer.finish();
        this.topViewViewer = null;
        this.viewer.container.style.backgroundColor = this.backgroundColorBackup;
        this.viewer.setBackgroundOpacity(this.backgroundOpacityBackup);

        // Restore canvas wrap visibility.
        if (!TopViewRenderer.isSheetMapSupported()) {
          this.viewer.canvasWrap.style.opacity = 1;
        }
      }
    } }, { key: "unload", value: function unload()

    {
      this.removeListeners();

      if (this.thumbnailsOverlay) {
        this.thumbnailsOverlay.destroy();
        this.thumbnailsOverlay = null;
      }

      if (this.nearFarOverlay) {
        this.nearFarOverlay.destroy();
        this.nearFarOverlay = null;
      }

      this.destroyTopViewViewer();

      if (this.rotationAnim) {
        this.rotationAnim.stop();
        this.rotationAnim = null;
      }

      this.rotationTimeout && clearTimeout(this.rotationTimeout);

      this.viewer = null;
      this.targetViewer = null;
      this.sheetSyncExt = null;

      this.pendingFinishedCallbacks = [];

      return true;
    } }, { key: "addListeners", value: function addListeners()

    {
      this.targetViewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);
      this.targetViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.targetViewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.targetViewer.addEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.update);
      this.viewer.addEventListener(av.PROGRESS_UPDATE_EVENT, this.onBeginScene);
      this.viewer.addEventListener(av.RENDER_SCENE_PART, this.update);
      this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this.onResize);
      this.viewer.addEventListener(_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);
      this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.topViewViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update);

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      levelExt && levelExt.floorSelector && levelExt.floorSelector.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);

      // In minimap debug mode - we need to render the minimap even when there is no actual movement in the top view.
      // This is needed in order to update the frustum according to target viewer.
      if (this.options.minimapDebugMode) {
        this.targetViewer.addEventListener(av.PROGRESS_UPDATE_EVENT, this.onBeginScene);
      }
    } }, { key: "removeListeners", value: function removeListeners()

    {
      this.targetViewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.targetViewer.removeEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.update);
      this.viewer.removeEventListener(av.PROGRESS_UPDATE_EVENT, this.onBeginScene);
      this.viewer.removeEventListener(av.RENDER_SCENE_PART, this.update);
      this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.onResize);
      this.viewer.removeEventListener(_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);
      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.topViewViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      levelExt && levelExt.floorSelector && levelExt.floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);

      if (this.options.minimapDebugMode) {
        this.targetViewer.removeEventListener(av.PROGRESS_UPDATE_EVENT, this.onBeginScene);
      }
    }

    // Make sure that when the main 2D viewer is resizing - topViewViewer updates as well.
  }, { key: "onResize", value: function onResize(_ref) {var width = _ref.width,height = _ref.height;
      this.topViewViewer.impl.resize(width, height, true);
      this.update();
    } }, { key: "onMainMapChanged", value: function onMainMapChanged()

    {
      this.syncCamera();
      this.update();
      this.validateRotation();
    } }, { key: "onSheetGeometryLoaded", value: function onSheetGeometryLoaded()

    {
      this.validateRotation();
    } }, { key: "validateRotation", value: function validateRotation()

    {
      this.rotationTimeout && clearTimeout(this.rotationTimeout);
      this.rotationTimeout = setTimeout(this.rotateToSheet, this.waitBeforeRotation * 1000);
    } }, { key: "isDraggingAvatar", value: function isDraggingAvatar()

    {
      var avatarExt = this.viewer.getExtension('Autodesk.AEC.AvatarExtension');
      var isDraggingAvatar = !avatarExt || !avatarExt.avatarWidget || avatarExt.avatarWidget.isDragging();

      return isDraggingAvatar;
    } }, { key: "rotateToSheet", value: function rotateToSheet()

    {var _this3 = this;
      if (!this.viewer) {
        return;
      }

      // Rotate only if sheet is shown. Otherwise there is no reason to rotate.
      if (!this.sheetSyncExt.getShowSheet()) {
        return;
      }

      if (this.rotationAnim) {
        this.rotationAnim.stop();
        this.rotationAnim = null;
      }

      // In case the avatar is currently being dragged - don't rotate yet, cause it's annoying.
      if (this.isDraggingAvatar()) {
        // Postpone rotation to the next timeout.
        this.validateRotation();
        return;
      }

      var startAngle = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["getCameraRotationAngle"])(this.viewer);

      // Find shortest rotation (keep angle between -PI and PI)
      if (startAngle < -Math.PI) {
        startAngle += 2 * Math.PI;
      } else if (startAngle > Math.PI) {
        startAngle -= 2 * Math.PI;
      }

      // No rotation needed.
      if (startAngle === 0) {
        return;
      }

      var onTimer = function onTimer(t) {
        t = Autodesk.Viewing.Private.smootherStep(t);
        var rotation = startAngle * (1 - t);
        var camera = _this3.viewer.getCamera();
        camera.up.set(0, 1, 0);
        Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(camera.up, tempVec3, rotation);
        camera.dirty = true;
        camera.updateCameraMatrices();
      };

      var onRotationEnd = function onRotationEnd() {
        _this3.rotationAnim = null;

        _this3.pendingFinishedCallbacks.forEach(function (cb) {return cb();});
        _this3.pendingFinishedCallbacks = [];
      };

      this.rotationAnim = Autodesk.Viewing.Private.fadeValue(0, 1, this.rotationDuration, onTimer, onRotationEnd);
    } }, { key: "waitForRotationDone", value: function waitForRotationDone()

    {var _this4 = this;
      var promise = new Promise(function (resolve) {
        // In case there is no active rotation, resolve immediately.
        if (!_this4.rotationAnim) {
          return resolve();
        }

        // Otherwise, wait for rotation callback to be called.
        _this4.pendingFinishedCallbacks.push(resolve);
      });

      return promise;
    }

    // Sync top view whenever the 2d sheet starts rendering.
  }, { key: "onBeginScene", value: function onBeginScene(_ref2) {var percent = _ref2.percent,state = _ref2.state;
      if (percent === 0 && state === ProgressState.RENDERING) {
        this.update();
      }
    }

    // Jump the camera to make the illusion that we keep the same position, scale and rotation while switching to a different sheetMap.
  }, { key: "syncCamera", value: function syncCamera() {
      if (!this.sheetSyncExt || !this.sheetSyncExt.sheetMap || !this.viewer.model || !this.worldBoundingBox) {
        return;
      }

      var camera = this.viewer.getCamera();
      var map = this.sheetSyncExt.sheetMap;

      var viewportLowerLeft = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(map, map.viewportBounds.min.x, map.viewportBounds.min.y, 0);
      var viewportLowerRight = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(map, map.viewportBounds.max.x, map.viewportBounds.min.y, 0);

      var angle = Math.atan2(viewportLowerRight.y - viewportLowerLeft.y, viewportLowerRight.x - viewportLowerLeft.x);

      // Rotate bounding box according to the map's rotation.
      var center = this.worldBoundingBox.center();
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(this.worldBoundingBox.min, center, angle);
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(this.worldBoundingBox.max, center, angle);

      var p0 = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["worldToMapPixels"])(map, this.worldBoundingBox.min.clone());
      var p1 = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["worldToMapPixels"])(map, new THREE.Vector3(this.worldBoundingBox.min.x, this.worldBoundingBox.max.y, 0));
      var p2 = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["worldToMapPixels"])(map, this.worldBoundingBox.max.clone());

      p0.z = 0;
      p1.z = 0;
      p2.z = 0;

      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToSheet"])(map, p0);
      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToSheet"])(map, p2);
      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToSheet"])(map, p1);

      box.setFromPoints([p0, p2]);

      camera.setViewFromBox(box, true);

      var worldAngle = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["getCameraRotationAngle"])(this.topViewViewer);
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(camera.up, tempVec3, worldAngle - angle);

      camera.dirty = true;
      camera.updateCameraMatrices();

      this.viewer.impl.invalidate(true);

      // Restart rotation if it's during rotation.
      if (this.rotationAnim) {
        this.rotateToSheet();
      }
    }

    // Setup a virtual camera according to sheetMap's bounds.
    // This camera should be used in the 3D scene in order to create a top view screenshot.
  }, { key: "updateTopViewViewerCamera", value: function updateTopViewViewerCamera() {
      // If there is no 2D model loaded, worldBounds are infinity, and it will cause calculation errors here.
      // For this reason, we have to wait until there is a loaded model.
      if (!this.viewer.model) {
        return;
      }

      var currentLevel = this.sheetSyncExt.getCurrentLevel();

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      var zRangeMax = currentLevel ? levelExt.getZRange(currentLevel.index).zMax : Infinity;

      var renderer = this.viewer.impl.renderer();
      var canvasWidth = renderer.settings.logicalWidth;
      var canvasHeight = renderer.settings.logicalHeight;
      var up = this.viewer.getCamera().up.clone();

      // Normally, widgetToMapPixels is used with event pixel coords (which are integer in x/y). 
      // Here, we need the input coords to be interpreted as accurate float-positions within [0, widgetWidth] x [0, widgetHeight] instead.
      // Otherwise, we get a half-pixel shift when computing the camera.
      var usePixelCenter = false;

      // get position within map widget
      var p0 = tempVec2.set(0, canvasHeight); // lower-left corner
      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["widgetToMapPixels"])(this.sheetSyncExt.sheetMap, this.viewer, p0, false, usePixelCenter);
      var p0World = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(this.sheetSyncExt.sheetMap, p0.x, p0.y, 0);

      var p1 = tempVec2.set(canvasWidth, canvasHeight); // lower-right corner
      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["widgetToMapPixels"])(this.sheetSyncExt.sheetMap, this.viewer, p1, false, usePixelCenter);
      var p1World = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(this.sheetSyncExt.sheetMap, p1.x, p1.y, 0);

      var p2 = tempVec2.set(canvasWidth, 0); // upper-right corner
      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["widgetToMapPixels"])(this.sheetSyncExt.sheetMap, this.viewer, p2, false, usePixelCenter);
      var p2World = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(this.sheetSyncExt.sheetMap, p2.x, p2.y, 0);

      // First set the box in order to get its center. It's needed for calculating the rotation.
      box.setFromPoints([p0World, p2World]);
      var center = box.center();

      // calculate world angle according the world direction from lower left corner, to lower right corner.
      var cameraAngle = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["getCameraRotationAngle"])(this.viewer);
      var worldAngle = Math.atan2(p1World.y - p0World.y, p1World.x - p0World.x);

      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(p0World, center, -worldAngle);
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(p2World, center, -worldAngle);
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(up, tempVec3, worldAngle - cameraAngle);

      // Bounding box rotated according to camera rotation.
      box.setFromPoints([p0World, p2World]);

      // Save worldBoundingBox for later use - in order to sync the camera position.
      this.worldBoundingBox = box.clone();

      var worldBounds = this.targetViewer.impl.getVisibleBounds();

      // The near and far plans are determined according to these values.
      var zMax = Math.min(zRangeMax, worldBounds.max.z);
      var zMin = worldBounds.min.z;

      // Set camera according to the bounding box.
      var camera = this.topViewViewer.getCamera();
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["setTopView"])(camera, box, zMin, zMax, box.size().y);

      // Rotate 3D camera's up vector according to world angle.
      camera.up.copy(up);
      camera.updateCameraMatrices();
      camera.dirty = true;
    } }, { key: "unloadIrrelevant3DModels", value: function unloadIrrelevant3DModels()

    {var _this5 = this;
      if (!this.sheetSyncExt.targetModels) {
        return;
      }

      var visibleModelsKeys = this.sheetSyncExt.targetModels.map(function (model) {return model.getModelKey();});

      this.topViewViewer.getVisibleModels().forEach(function (model) {
        var key = model.getModelKey();
        if (visibleModelsKeys.indexOf(key) === -1) {
          _this5.topViewViewer.unloadModel(model);
          _this5.isModelLoadingMap[key] = false;
        }
      });
    } }, { key: "loadRelevant3DModels", value: function loadRelevant3DModels()

    {var _this6 = this;
      if (!this.sheetSyncExt.targetModels) {
        return;
      }

      var visibleModelsKeys = this.topViewViewer.getVisibleModels().map(function (model) {return model.getModelKey();});

      this.sheetSyncExt.targetModels.forEach(function (model) {
        var key = model.getModelKey();

        if (visibleModelsKeys.indexOf(key) === -1 && !_this6.isModelLoadingMap[key]) {
          _this6.isModelLoadingMap[key] = true;
          var loadOptions = model.getData().loadOptions;
          _this6.topViewViewer.loadDocumentNode(
          model.getDocumentNode().getRootNode().getDocument(),
          model.getDocumentNode(),
          {
            keepCurrentModels: true,
            preserveView: true,
            globalOffset: loadOptions.globalOffset,
            applyRefPoint: loadOptions.applyRefPoint,
            placementTransform: loadOptions.placementTransform,
            applyPlacementInModelUnits: loadOptions.applyPlacementInModelUnits }).

          then(function () {
            // Set topView render config.
            var config = _this6.targetViewer.impl.renderer().getConfig();
            config.renderEdges = true;
            config.envMapBackground = null;
            config.aoEnabled = false;
            config.antialias = true;
            config.envMap = null; // Can't share this resource between viewers.
            _this6.topViewViewer.impl.renderer().applyConfig(config);
            _this6.topViewViewer.setBackgroundOpacity(0);
          });
        }
      });
    } }, { key: "hideTopViewViewer", value: function hideTopViewViewer()

    {
      if (this.topViewViewer) this.topViewViewer.container.style.opacity = 0;
    } }, { key: "showTopViewViewer", value: function showTopViewViewer()

    {
      if (this.topViewViewer) this.topViewViewer.container.style.opacity = 1;
    } }, { key: "update", value: function update()

    {var _this$thumbnailsOverl;
      if (!this.sheetSyncExt || !this.sheetSyncExt.sheetMap || !this.viewer || !this.targetViewer || !this.topViewViewer) {
        this.hideTopViewViewer();
        return;
      }

      this.showTopViewViewer();

      // Remove unused 3D models from topViewViewer.
      this.unloadIrrelevant3DModels();

      // Load relevant 3D models to toViewViewer.
      this.loadRelevant3DModels();

      // Update top view camera, according to the current sheet map.
      this.updateTopViewViewerCamera();

      (_this$thumbnailsOverl = this.thumbnailsOverlay) === null || _this$thumbnailsOverl === void 0 ? void 0 : _this$thumbnailsOverl.update();
    }

    // IE11 & iOS don't support canvas blending.
    // For that reason, we decided to hide the sheet-map overlay in these browsers.
  }], [{ key: "isSheetMapSupported", value: function isSheetMapSupported() {
      return !(Autodesk.Viewing.isIE11Only || Autodesk.Viewing.isIOSDevice());
    } }]);return TopViewRenderer;}(Autodesk.Viewing.Extension);


namespace.TopViewRenderer = TopViewRenderer;
av.theExtensionManager.registerExtension(myExtensionName, TopViewRenderer);

/***/ }),

/***/ "./extensions/AEC/Viewports/Providers/AecModelDataViewportProvider.js":
/*!****************************************************************************!*\
  !*** ./extensions/AEC/Viewports/Providers/AecModelDataViewportProvider.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AecModelDataViewportProvider; });
/* harmony import */ var _ViewportTypes_AecModelDataViewport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewportTypes/AecModelDataViewport */ "./extensions/AEC/Viewports/ViewportTypes/AecModelDataViewport.js");
/* harmony import */ var _ViewportProviderInterface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ViewportProviderInterface */ "./extensions/AEC/Viewports/Providers/ViewportProviderInterface.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

AecModelDataViewportProvider = /*#__PURE__*/function (_ViewportProviderInte) {_inherits(AecModelDataViewportProvider, _ViewportProviderInte);var _super = _createSuper(AecModelDataViewportProvider);function AecModelDataViewportProvider() {_classCallCheck(this, AecModelDataViewportProvider);return _super.apply(this, arguments);}_createClass(AecModelDataViewportProvider, [{ key: "fetchViewports",
    /**
                                                                                                                                                                                                                                                                                                                                                                                                              * Fetch viewports for a given bubble.
                                                                                                                                                                                                                                                                                                                                                                                                              * 
                                                                                                                                                                                                                                                                                                                                                                                                              * @param {Autodesk.Viewing.BubbleNode} bubbleNode - bubbleNode.
                                                                                                                                                                                                                                                                                                                                                                                                              * 
                                                                                                                                                                                                                                                                                                                                                                                                              * @returns {Promise<[Viewport]>} Promise with array of viewports.
                                                                                                                                                                                                                                                                                                                                                                                                              */value: function () {var _fetchViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(
      bubbleNode) {var rootNode, aecModelData, viewportsRaw, viewports;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                rootNode = bubbleNode.getRootNode();
                aecModelData = rootNode.getAecModelData();

                viewportsRaw = bubbleNode.is2D() ?
                Autodesk.AEC.AecModelData.findViewportsOnSheet(bubbleNode) :
                aecModelData === null || aecModelData === void 0 ? void 0 : aecModelData.viewports;if (

                viewportsRaw) {_context.next = 5;break;}return _context.abrupt("return",
                []);case 5:


                viewports = viewportsRaw.map(function (viewportRaw) {
                  // Since viewport name is not extracted to AecModelData - we use the sheet's name for now.
                  var sheetNode = rootNode.search({ guid: viewportRaw.sheetGuid })[0];

                  if (!sheetNode) {
                    console.warn("Shouldn't happen - couldn't find corresponding sheet.");
                    return;
                  }

                  var name = sheetNode.name();
                  var urn = rootNode.urn();

                  // Since viewport name is not included in AecModelData - we use the sheet's name for now.
                  var sheetName = name;

                  return new _ViewportTypes_AecModelDataViewport__WEBPACK_IMPORTED_MODULE_0__["default"](viewportRaw, name, urn, sheetName, { aecModelData: aecModelData, sheetNode: sheetNode });
                });return _context.abrupt("return",

                viewports);case 7:case "end":return _context.stop();}}}, _callee);}));function fetchViewports(_x) {return _fetchViewports.apply(this, arguments);}return fetchViewports;}()


    /**
                                                                                                                                                                                             * @returns {string} Name of viewport provider
                                                                                                                                                                                             */ }, { key: "getProviderName", value: function getProviderName()
    {
      return 'AecModelDataViewportProvider';
    } }]);return AecModelDataViewportProvider;}(_ViewportProviderInterface__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/AEC/Viewports/Providers/AlignmentServiceViewportProvider.js":
/*!********************************************************************************!*\
  !*** ./extensions/AEC/Viewports/Providers/AlignmentServiceViewportProvider.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignmentServiceViewportProvider; });
/* harmony import */ var _ViewportTypes_AlignmentServiceViewport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewportTypes/AlignmentServiceViewport */ "./extensions/AEC/Viewports/ViewportTypes/AlignmentServiceViewport.js");
/* harmony import */ var _ViewportProviderInterface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ViewportProviderInterface */ "./extensions/AEC/Viewports/Providers/ViewportProviderInterface.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

AlignmentServiceViewportProvider = /*#__PURE__*/function (_ViewportProviderInte) {_inherits(AlignmentServiceViewportProvider, _ViewportProviderInte);var _super = _createSuper(AlignmentServiceViewportProvider);
  /** @param options:
                                                                                                                                                                                                                  *                   Must include a service (AlignmentService)
                                                                                                                                                                                                                  *                   Must include a getVersionUrn function that given a lineageUrn returns the latest versionUrn
                                                                                                                                                                                                                  *                   Must include a loadDocument function that fetches the document for a model
                                                                                                                                                                                                                  * 
                                                                                                                                                                                                                  */
  function AlignmentServiceViewportProvider(options) {var _this;_classCallCheck(this, AlignmentServiceViewportProvider);
    _this = _super.call(this, options);

    _this.service = _this.options.service;
    _this.getVersionUrn = _this.options.getVersionUrn;
    _this.loadDocument = _this.options.loadDocument;

    if (!_this.service || !_this.getVersionUrn || !_this.loadDocument) {
      console.error('One of AlignmentServiceViewportProvider callbacks is missing.');
      throw 'AlignmentServiceViewportProvider callbacks is missing';
    }

    _this.fetch3DNodeForViewport = _this.fetch3DNodeForViewport.bind(_assertThisInitialized(_this));
    _this.fetchSheetNodeForViewport = _this.fetchSheetNodeForViewport.bind(_assertThisInitialized(_this));return _this;
  }

  /**
     * Fetch viewports for a given bubble.
     * 
     * @param {Autodesk.Viewing.BubbleNode} bubbleNode - bubbleNode.
     * 
     * @returns {Promise<[Viewport]>} Promise with array of viewports.
     */_createClass(AlignmentServiceViewportProvider, [{ key: "fetchViewports", value: function () {var _fetchViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(
      bubbleNode) {var viewports;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
                  bubbleNode.is2D() ? this.fetchViewportsFromBubble2D(bubbleNode) : this.fetchViewportsForBubble3D(bubbleNode));case 2:viewports = _context.sent;return _context.abrupt("return",

                viewports);case 4:case "end":return _context.stop();}}}, _callee, this);}));function fetchViewports(_x) {return _fetchViewports.apply(this, arguments);}return fetchViewports;}()


    /**
                                                                                                                                                                                                   * @returns {string} Name of viewport provider
                                                                                                                                                                                                   */ }, { key: "getProviderName", value: function getProviderName()
    {
      return 'AlignmentServiceViewportProvider';
    }

    // Fetches viewports for a model and save it in cache, using the provided service
  }, { key: "fetchViewportsFromBubble2D", value: function () {var _fetchViewportsFromBubble2D = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(bubbleNode) {var _this2 = this;var viewableName2D, lineageUrn2D, versionUrn2D, versionUrn2DEncoded, viewportsRaw, viewports;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                viewableName2D = bubbleNode.name();

                // Given lineageUrn, get latest versionUrn.
                lineageUrn2D = bubbleNode.lineageUrn();_context2.next = 4;return (
                  this.getVersionUrn(lineageUrn2D));case 4:versionUrn2D = _context2.sent;
                versionUrn2DEncoded = Autodesk.Viewing.Private.toUrlSafeBase64(versionUrn2D);_context2.next = 8;return (

                  this.service.loadRegions(versionUrn2DEncoded, viewableName2D));case 8:viewportsRaw = _context2.sent;if (!(

                !viewportsRaw || !viewportsRaw.length)) {_context2.next = 11;break;}return _context2.abrupt("return",
                []);case 11:


                viewports = viewportsRaw.map(function (viewportRaw) {return (
                    // Since viewport name is not included in the service - we use the sheet's name for now.
                    _this2._createViewport(viewportRaw, viewableName2D, versionUrn2DEncoded, viewableName2D));});return _context2.abrupt("return",


                viewports);case 13:case "end":return _context2.stop();}}}, _callee2, this);}));function fetchViewportsFromBubble2D(_x2) {return _fetchViewportsFromBubble2D.apply(this, arguments);}return fetchViewportsFromBubble2D;}() }, { key: "fetchViewportsForBubble3D", value: function () {var _fetchViewportsForBubble3D = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(


      bubbleNode) {var lineageUrn3D, viewableName3D, relationships, relatedViewports, i, relationship, relatedModel, _relatedModel$id$spli, _relatedModel$id$spli2, lineageUrn2D, rest, nameAndRegion, _nameAndRegion$split, _nameAndRegion$split2, name2D, regionId, versionUrn2D, versionUrn2DEncoded, viewportRaw, viewport;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                lineageUrn3D = bubbleNode.lineageUrn();
                viewableName3D = bubbleNode.name();_context3.prev = 2;_context3.next = 5;return (




                  this.service.getRelationships(Autodesk.AlignmentService.RelationshipEntityTypes.Model3D, lineageUrn3D, viewableName3D));case 5:relationships = _context3.sent;_context3.next = 12;break;case 8:_context3.prev = 8;_context3.t0 = _context3["catch"](2);

                console.warn('getRelationships Error: ' + _context3.t0);return _context3.abrupt("return",
                []);case 12:


                relatedViewports = [];

                i = 0;case 14:if (!(i < relationships.length)) {_context3.next = 38;break;}
                relationship = relationships[i];
                relatedModel = relationship.entities.find(function (e) {return e.type === Autodesk.AlignmentService.RelationshipEntityTypes.Region;});if (

                relatedModel) {_context3.next = 20;break;}
                console.warn('Related model not found');return _context3.abrupt("continue", 35);case 20:_relatedModel$id$spli =



                relatedModel.id.split('?'), _relatedModel$id$spli2 = _slicedToArray(_relatedModel$id$spli, 2), lineageUrn2D = _relatedModel$id$spli2[0], rest = _relatedModel$id$spli2[1];
                nameAndRegion = rest.slice(Autodesk.AlignmentService.RelationshipIdPrefix.Name.length);_nameAndRegion$split =
                nameAndRegion.split(Autodesk.AlignmentService.RelationshipIdPrefix.Region), _nameAndRegion$split2 = _slicedToArray(_nameAndRegion$split, 2), name2D = _nameAndRegion$split2[0], regionId = _nameAndRegion$split2[1];

                // Given lineageUrn, get latest versionUrn.
                _context3.next = 25;return this.getVersionUrn(lineageUrn2D);case 25:versionUrn2D = _context3.sent;
                versionUrn2DEncoded = Autodesk.Viewing.Private.toUrlSafeBase64(versionUrn2D);_context3.next = 29;return (

                  this.service.loadRegion(versionUrn2DEncoded, name2D, regionId));case 29:viewportRaw = _context3.sent;if (

                viewportRaw) {_context3.next = 33;break;}
                console.warn('Viewport not found.', versionUrn2DEncoded, name2D, regionId);return _context3.abrupt("continue", 35);case 33:



                // Since viewport name is not included in the service - we use the sheet's name for now.
                viewport = this._createViewport(viewportRaw, name2D, versionUrn2DEncoded, name2D);

                relatedViewports.push(viewport);case 35:i++;_context3.next = 14;break;case 38:return _context3.abrupt("return",


                relatedViewports);case 39:case "end":return _context3.stop();}}}, _callee3, this, [[2, 8]]);}));function fetchViewportsForBubble3D(_x3) {return _fetchViewportsForBubble3D.apply(this, arguments);}return fetchViewportsForBubble3D;}() }, { key: "fetchSheetNodeForViewport", value: function () {var _fetchSheetNodeForViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(


      viewport) {var result;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:_context4.next = 2;return (
                  this._fetchBubbleNode(viewport.getSheetUrn(), viewport.getSheetName()));case 2:result = _context4.sent;return _context4.abrupt("return",
                result);case 4:case "end":return _context4.stop();}}}, _callee4, this);}));function fetchSheetNodeForViewport(_x4) {return _fetchSheetNodeForViewport.apply(this, arguments);}return fetchSheetNodeForViewport;}() }, { key: "fetch3DNodeForViewport", value: function () {var _fetch3DNodeForViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(


      viewport) {var _relationship;var lineageUrn2D, viewableName2D, regionId, relationship, _yield$this$service$g, _yield$this$service$g2, relatedModel, _relatedModel$id$spli3, _relatedModel$id$spli4, lineageUrn3D, name3D, versionUrn3D, urn3DEncoded, name, node;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
                lineageUrn2D = viewport.getSheetLineageUrn();
                viewableName2D = viewport.getSheetName();
                regionId = viewport.getGuid();_context5.prev = 3;_context5.next = 6;return (




                  this.service.getRelationships(Autodesk.AlignmentService.RelationshipEntityTypes.Region, lineageUrn2D, viewableName2D, regionId));case 6:_yield$this$service$g = _context5.sent;_yield$this$service$g2 = _slicedToArray(_yield$this$service$g, 1);relationship = _yield$this$service$g2[0];_context5.next = 15;break;case 11:_context5.prev = 11;_context5.t0 = _context5["catch"](3);

                console.warn('No relationship found. Error: ' + _context5.t0);throw _context5.t0;case 15:



                relatedModel = (_relationship = relationship) === null || _relationship === void 0 ? void 0 : _relationship.entities.find(function (e) {return e.type === Autodesk.AlignmentService.RelationshipEntityTypes.Model3D;});if (

                relatedModel) {_context5.next = 18;break;}throw (
                  'No related model found for sheet-model transition');case 18:_relatedModel$id$spli3 =


                relatedModel.id.split('?'), _relatedModel$id$spli4 = _slicedToArray(_relatedModel$id$spli3, 2), lineageUrn3D = _relatedModel$id$spli4[0], name3D = _relatedModel$id$spli4[1];

                // Given lineageUrn, get latest versionUrn.
                _context5.next = 21;return this.getVersionUrn(lineageUrn3D);case 21:versionUrn3D = _context5.sent;

                // Encode versionUrn
                urn3DEncoded = Autodesk.Viewing.toUrlSafeBase64(versionUrn3D);

                name = decodeURIComponent(name3D.slice(Autodesk.AlignmentService.RelationshipIdPrefix.Name.length));_context5.next = 26;return (

                  this._fetchBubbleNode(urn3DEncoded, name));case 26:node = _context5.sent;return _context5.abrupt("return",



                [node]);case 28:case "end":return _context5.stop();}}}, _callee5, this, [[3, 11]]);}));function fetch3DNodeForViewport(_x5) {return _fetch3DNodeForViewport.apply(this, arguments);}return fetch3DNodeForViewport;}() }, { key: "_createViewport", value: function _createViewport(


    viewportRaw, viewportName, urn2D, sheetName) {
      var options = {
        fetch3DNodeForViewport: this.fetch3DNodeForViewport,
        fetchSheetNodeForViewport: this.fetchSheetNodeForViewport };


      return new _ViewportTypes_AlignmentServiceViewport__WEBPACK_IMPORTED_MODULE_0__["default"](viewportRaw, viewportName, urn2D, sheetName, options);
    } }, { key: "_fetchBubbleNode", value: function () {var _fetchBubbleNode2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(

      urn, name) {var doc, rootNode, nodes;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:_context6.prev = 0;_context6.next = 3;return (



                  this.loadDocument(urn));case 3:doc = _context6.sent;_context6.next = 9;break;case 6:_context6.prev = 6;_context6.t0 = _context6["catch"](0);throw (

                  'Could not load document');case 9:


                rootNode = doc.getRoot();
                nodes = rootNode.search({ type: 'geometry', name: name });return _context6.abrupt("return",

                nodes[0]);case 12:case "end":return _context6.stop();}}}, _callee6, this, [[0, 6]]);}));function _fetchBubbleNode(_x6, _x7) {return _fetchBubbleNode2.apply(this, arguments);}return _fetchBubbleNode;}() }]);return AlignmentServiceViewportProvider;}(_ViewportProviderInterface__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/AEC/Viewports/Providers/ViewportProviderInterface.js":
/*!*************************************************************************!*\
  !*** ./extensions/AEC/Viewports/Providers/ViewportProviderInterface.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportProviderInterface; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var ViewportProviderInterface = /*#__PURE__*/function () {
  function ViewportProviderInterface() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, ViewportProviderInterface);
    this.options = options;
  }

  /**
     * Fetch viewports for a given bubble.
     * 
     * @param {Autodesk.Viewing.BubbleNode} bubbleNode - bubbleNode.
     * 
     * @returns {Promise<[Viewport]>} Promise with array of viewports.
     */_createClass(ViewportProviderInterface, [{ key: "fetchViewports", value: function () {var _fetchViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(
      bubbleNode) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:throw (
                  "fetchViewports not implemented");case 1:case "end":return _context.stop();}}}, _callee);}));function fetchViewports(_x) {return _fetchViewports.apply(this, arguments);}return fetchViewports;}()


    /**
                                                                                                                                                                                                                      * @returns {string} Name of viewport provider
                                                                                                                                                                                                                      */ }, { key: "getProviderName", value: function getProviderName()
    {
      throw "getProviderName not implemented";
    } }]);return ViewportProviderInterface;}();

/***/ }),

/***/ "./extensions/AEC/Viewports/ViewportTypes/AecModelDataViewport.js":
/*!************************************************************************!*\
  !*** ./extensions/AEC/Viewports/ViewportTypes/AecModelDataViewport.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AecModelDataViewport; });
/* harmony import */ var _ViewportInterface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewportInterface */ "./extensions/AEC/Viewports/ViewportTypes/ViewportInterface.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var AecModelData = Autodesk.AEC.AecModelData;var

AecModelDataViewport = /*#__PURE__*/function (_ViewportInterface) {_inherits(AecModelDataViewport, _ViewportInterface);var _super = _createSuper(AecModelDataViewport);

  function AecModelDataViewport() {var _this;_classCallCheck(this, AecModelDataViewport);for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
    _this = _super.call.apply(_super, [this].concat(args));

    _this.sheetNode = _this.options.sheetNode;
    _this.aecModelData = _this.options.aecModelData;return _this;
  }_createClass(AecModelDataViewport, [{ key: "getGuid", value: function getGuid()

    {
      return this.viewportRaw.viewportGuid;
    } }, { key: "isMatrixInLocalCoords", value: function isMatrixInLocalCoords()

    {
      return true;
    }

    // Viewports in AecModelData are being stored in Feet, regardless of the model's actual units.
    // For this reason, unitScale must be provided whenever calling getViewportBounds, get2DTo3DMatrix & get3DTo2DMatrix.
    // Unfortunately, unitScale can't be provided in the construction of the class, since this info doesn't exist in the bubble nor inside AecModelData.
    // We discover the model's units only after it is loaded.
  }, { key: "getViewportBounds", value: function getViewportBounds(unitScale) {
      if (!unitScale) {
        console.error('Unit scale must be provided');
        return null;
      }

      return AecModelData.getViewportBounds(this.viewportRaw, unitScale);
    } }, { key: "get2DTo3DMatrix", value: function get2DTo3DMatrix(

    unitScale) {
      if (!unitScale) {
        console.error('Unit scale must be provided');
        return null;
      }

      var matrix = AecModelData.get2DTo3DMatrix(this.viewportRaw, unitScale);

      // For floorPlans, override the height with the level elevation.
      if (this.isFloorPlan()) {
        var level = this.findLevelForViewport();

        // Take elevation from level
        if (level) {
          var zOffsetHack = 1 / 120; // Offset to place slightly above floor
          var pos = new THREE.Vector3();
          pos.setFromMatrixPosition(matrix);
          pos.z = level.elevation + zOffsetHack;
          matrix = matrix.clone().setPosition(pos);
        }
      }

      return matrix;
    } }, { key: "getParentSheetNode", value: function () {var _getParentSheetNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:return _context.abrupt("return",


                this.sheetNode);case 1:case "end":return _context.stop();}}}, _callee, this);}));function getParentSheetNode() {return _getParentSheetNode.apply(this, arguments);}return getParentSheetNode;}() }, { key: "get3DNodesForViewport", value: function () {var _get3DNodesForViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var views;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:



                views = this.sheetNode.getRootNode().search(Autodesk.Viewing.BubbleNode.MODEL_NODE);

                if (!views.length) {
                  console.error("That shouldn't happen - No AEC views");
                }return _context2.abrupt("return",

                views);case 3:case "end":return _context2.stop();}}}, _callee2, this);}));function get3DNodesForViewport() {return _get3DNodesForViewport.apply(this, arguments);}return get3DNodesForViewport;}() }, { key: "findLevelForViewport", value: function findLevelForViewport()


    {
      return AecModelData.findLevelForViewport(this.aecModelData, this.viewportRaw);
    } }, { key: "isViewportInLevel", value: function isViewportInLevel(

    level) {
      var linkedLevelGuid = AecModelData.getLinkedLevel(this.viewportRaw);
      return level.guid === linkedLevelGuid;
    } }, { key: "supports2DTo3DTransform", value: function supports2DTo3DTransform()

    {
      return AecModelData.supports2DTo3DTransform(this.viewportRaw);
    } }, { key: "isTopViewViewport", value: function isTopViewViewport()

    {
      return AecModelData.TopViewViewportTypes.includes(this.viewportRaw.viewType);
    } }, { key: "isFloorPlan", value: function isFloorPlan()

    {
      return this.viewportRaw.viewType === 'FloorPlan';
    } }]);return AecModelDataViewport;}(_ViewportInterface__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/AEC/Viewports/ViewportTypes/AlignmentServiceViewport.js":
/*!****************************************************************************!*\
  !*** ./extensions/AEC/Viewports/ViewportTypes/AlignmentServiceViewport.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignmentServiceViewport; });
/* harmony import */ var _ViewportInterface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewportInterface */ "./extensions/AEC/Viewports/ViewportTypes/ViewportInterface.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var

AlignmentServiceViewport = /*#__PURE__*/function (_ViewportInterface) {_inherits(AlignmentServiceViewport, _ViewportInterface);var _super = _createSuper(AlignmentServiceViewport);

  function AlignmentServiceViewport() {var _this;_classCallCheck(this, AlignmentServiceViewport);for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
    _this = _super.call.apply(_super, [this].concat(args));

    _this.fetchSheetNodeForViewport = _this.options.fetchSheetNodeForViewport;
    _this.fetch3DNodeForViewport = _this.options.fetch3DNodeForViewport;return _this;
  }_createClass(AlignmentServiceViewport, [{ key: "getGuid", value: function getGuid()

    {
      return this.viewportRaw.regionId;
    } }, { key: "isMatrixInLocalCoords", value: function isMatrixInLocalCoords()

    {
      return false;
    } }, { key: "getViewportBounds", value: function getViewportBounds()

    {
      return this.viewportRaw.boundingBox;
    } }, { key: "get2DTo3DMatrix", value: function get2DTo3DMatrix()

    {
      return this.viewportRaw.transform;
    } }, { key: "getParentSheetNode", value: function () {var _getParentSheetNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:


                if (!this.parentSheetNodePromise) {
                  this.parentSheetNodePromise = this.fetchSheetNodeForViewport(this);
                }return _context.abrupt("return",

                this.parentSheetNodePromise);case 2:case "end":return _context.stop();}}}, _callee, this);}));function getParentSheetNode() {return _getParentSheetNode.apply(this, arguments);}return getParentSheetNode;}() }, { key: "get3DNodesForViewport", value: function () {var _get3DNodesForViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:return _context2.abrupt("return",



                this.fetch3DNodeForViewport(this));case 1:case "end":return _context2.stop();}}}, _callee2, this);}));function get3DNodesForViewport() {return _get3DNodesForViewport.apply(this, arguments);}return get3DNodesForViewport;}() }, { key: "findLevelForViewport", value: function findLevelForViewport()


    {
      if (!this.isTopViewViewport()) {
        return null;
      }

      // Generate synthetic level data.
      return { elevation: this.getElevation() };
    } }, { key: "isViewportInLevel", value: function isViewportInLevel(

    level) {
      if (!this.isTopViewViewport()) {
        return false;
      }

      var z = this.getElevation();

      // Notice that both matrix and level are in world coordinates.
      return z > level.zMin && z < level.zMax;
    } }, { key: "supports2DTo3DTransform", value: function supports2DTo3DTransform()

    {
      return true;
    } }, { key: "isTopViewViewport", value: function isTopViewViewport()

    {
      if (this._topViewViewport === undefined) {
        var matrix = this.get2DTo3DMatrix();
        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        var z = new THREE.Vector3(0, 0, 1);

        var direction = z.clone().applyMatrix3(normalMatrix);
        var angle = direction.angleTo(z);

        // Support upside down viewports
        if (angle >= Math.PI) {
          angle -= Math.PI;
        }

        var AngleThreshold = 0.05;
        this._topViewViewport = Math.abs(angle) < AngleThreshold;
      }

      return this._topViewViewport;
    } }, { key: "isFloorPlan", value: function isFloorPlan()

    {
      // Assume all top-view manually aligned viewports are floor plans.
      return this.isTopViewViewport();
    } }]);return AlignmentServiceViewport;}(_ViewportInterface__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/AEC/Viewports/ViewportTypes/ViewportInterface.js":
/*!*********************************************************************!*\
  !*** ./extensions/AEC/Viewports/ViewportTypes/ViewportInterface.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportInterface; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var ViewportInterface = /*#__PURE__*/function () {
  function ViewportInterface(viewportRaw) {var viewportName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';var sheetUrn = arguments.length > 2 ? arguments[2] : undefined;var sheetName = arguments.length > 3 ? arguments[3] : undefined;var options = arguments.length > 4 ? arguments[4] : undefined;_classCallCheck(this, ViewportInterface);
    this.viewportRaw = viewportRaw;
    this.viewportName = viewportName;
    this.sheetUrn = sheetUrn;
    this.lineageUrn = Autodesk.Viewing.BubbleNode.parseLineageUrnFromEncodedUrn(sheetUrn);
    this.sheetName = sheetName;
    this.options = options;
  }

  // Unique viewport guid.
  _createClass(ViewportInterface, [{ key: "getGuid", value: function getGuid() {
      throw "getGuid not implemented";
    }

    // Is matrix in model-local coordinates, or world coordinates.
  }, { key: "isMatrixInLocalCoords", value: function isMatrixInLocalCoords() {
      throw "isMatrixInLocalCoords not implemented";
    }

    // Sheet's version urn that the viewport is part of.
  }, { key: "getSheetUrn", value: function getSheetUrn() {
      return this.sheetUrn;
    }

    // Sheet's lineage urn that the viewport is part of.
  }, { key: "getSheetLineageUrn", value: function getSheetLineageUrn() {
      return this.lineageUrn;
    }

    // Sheet name that the viewport is part of.
  }, { key: "getSheetName", value: function getSheetName() {
      return this.sheetName;
    }

    // Viewport name.
  }, { key: "getName", value: function getName() {
      return this.viewportName;
    }

    // Box2 - viewport bounds.
  }, { key: "getViewportBounds", value: function getViewportBounds() {var unitScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      throw "getViewportBounds not implemented";
    }

    // 2D to 3D transform.
  }, { key: "get2DTo3DMatrix", value: function get2DTo3DMatrix() {var unitScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      throw "get2DTo3DMatrix not implemented";
    }

    // 3D to 2D transform.
  }, { key: "get3DTo2DMatrix", value: function get3DTo2DMatrix() {var unitScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var matrix = this.get2DTo3DMatrix(unitScale).clone();
      matrix.getInverse(matrix);

      return matrix;
    }

    // Get 2D sheet BubbleNode containing the given viewport.
  }, { key: "getParentSheetNode", value: function () {var _getParentSheetNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:throw (
                  "getParentSheetNode not implemented");case 1:case "end":return _context.stop();}}}, _callee);}));function getParentSheetNode() {return _getParentSheetNode.apply(this, arguments);}return getParentSheetNode;}()


    // Get 3D BubbleNodes related to the given viewport.
  }, { key: "get3DNodesForViewport", value: function () {var _get3DNodesForViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:throw (
                  "get3DNodesForViewport not implemented");case 1:case "end":return _context2.stop();}}}, _callee2);}));function get3DNodesForViewport() {return _get3DNodesForViewport.apply(this, arguments);}return get3DNodesForViewport;}()


    // Find a level containing the given viewport.
  }, { key: "findLevelForViewport", value: function findLevelForViewport() {
      throw "findLevelForViewport not implemented";
    }

    // Given a level, check if viewport is inside it.
  }, { key: "isViewportInLevel", value: function isViewportInLevel(level) {
      throw "isViewportInLevel not implemented";
    }

    // Does the viewport supports 2D to 3D transform.
  }, { key: "supports2DTo3DTransform", value: function supports2DTo3DTransform() {
      throw "supports2DTo3DTransform not implemented";
    }

    // Does the viewport faces up (top view).
  }, { key: "isTopViewViewport", value: function isTopViewViewport() {
      throw "isTopViewViewport not implemented";
    }

    // Does the viewport represents a floor plan.
  }, { key: "isFloorPlan", value: function isFloorPlan() {
      throw "isFloorPlan not implemented";
    }

    // Returns viewport Z position.
  }, { key: "getElevation", value: function getElevation() {
      return this.get2DTo3DMatrix().elements[14];
    } }]);return ViewportInterface;}();

/***/ }),

/***/ "./extensions/AEC/Viewports/ViewportsExtension.js":
/*!********************************************************!*\
  !*** ./extensions/AEC/Viewports/ViewportsExtension.js ***!
  \********************************************************/
/*! exports provided: ViewportsExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewportsExtension", function() { return ViewportsExtension; });
/* harmony import */ var _Providers_ViewportProviderInterface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Providers/ViewportProviderInterface */ "./extensions/AEC/Viewports/Providers/ViewportProviderInterface.js");
/* harmony import */ var _Providers_AecModelDataViewportProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Providers/AecModelDataViewportProvider */ "./extensions/AEC/Viewports/Providers/AecModelDataViewportProvider.js");
/* harmony import */ var _Providers_AlignmentServiceViewportProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Providers/AlignmentServiceViewportProvider */ "./extensions/AEC/Viewports/Providers/AlignmentServiceViewportProvider.js");
/* harmony import */ var _ViewportTypes_AlignmentServiceViewport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ViewportTypes/AlignmentServiceViewport */ "./extensions/AEC/Viewports/ViewportTypes/AlignmentServiceViewport.js");
/* harmony import */ var _ViewportTypes_AecModelDataViewport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ViewportTypes/AecModelDataViewport */ "./extensions/AEC/Viewports/ViewportTypes/AecModelDataViewport.js");
/* harmony import */ var _levels_LevelUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../levels/LevelUtils */ "./extensions/AEC/levels/LevelUtils.js");
/* harmony import */ var _levels_Level__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../levels/Level */ "./extensions/AEC/levels/Level.js");
/* harmony import */ var _ViewportsLocales__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ViewportsLocales */ "./extensions/AEC/Viewports/ViewportsLocales.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}








var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.AEC');
var extensionName = 'Autodesk.AEC.ViewportsExtension';

var MAX_INT_32 = 2147483647;
/**
                              * Viewports Extension is a centralized place that manages all of the viewports associated with models.
                              * By default, viewports from AecModelData will be fetched and cached.
                              * Any other viewport providers can be added (Alignment Service for example).
                              *
                              * @example
                              *   viewer.loadExtension('Autodesk.AEC.ViewportsExtension', options)
                              *
                              * @memberof Autodesk.Viewing.Extensions
                              * @alias Autodesk.Viewing.Extensions.Viewports
                              * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
                              * @class
                              */
var ViewportsExtension = /*#__PURE__*/function (_av$Extension) {_inherits(ViewportsExtension, _av$Extension);var _super = _createSuper(ViewportsExtension);

  function ViewportsExtension(viewer, options) {var _this;_classCallCheck(this, ViewportsExtension);
    _this = _super.call(this, viewer, options);

    av.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.name = 'Viewports';

    _this.onModelAdded = _this.onModelAdded.bind(_assertThisInitialized(_this));
    _this.onViewportDataCreated = _this.onViewportDataCreated.bind(_assertThisInitialized(_this));return _this;
  }_createClass(ViewportsExtension, [{ key: "load", value: function load()

    {
      _get(_getPrototypeOf(ViewportsExtension.prototype), "load", this).call(this);

      this.extendLocalization(_ViewportsLocales__WEBPACK_IMPORTED_MODULE_7__["locales"]);

      this.cache = this.getCache();

      if (!this.cache.viewports) {
        this.cache.viewports = {};
      }

      this.providers = {};

      // Load AecModelDataViewportProvider by default.
      this.addViewportProvider(new _Providers_AecModelDataViewportProvider__WEBPACK_IMPORTED_MODULE_1__["default"]());

      this.addEventListeners();

      this.fetchViewportsForAllModels();

      return true;
    } }, { key: "unload", value: function unload()

    {
      _get(_getPrototypeOf(ViewportsExtension.prototype), "unload", this).call(this);

      this.providers = null;

      this.removeEventListeners();
      return true;
    } }, { key: "addViewportProvider", value: function addViewportProvider(

    provider) {
      if (!this.providers[provider.getProviderName()]) {
        this.providers[provider.getProviderName()] = provider;
      }

      // Update viewports for all existing models.
      // Don't worry, if viewports already fetched for a given model & provider - it will be skipped.
      this.fetchViewportsForAllModels();
    } }, { key: "removeViewportProvider", value: function removeViewportProvider(

    provider) {
      delete this.providers[provider.getProviderName()];
    } }, { key: "fetchViewportsForAllModels", value: function fetchViewportsForAllModels()

    {var _this2 = this;
      var models = this.viewer.getAllModels();
      models.forEach(function (model) {return _this2.fetchViewports(model.getDocumentNode());});
    } }, { key: "addEventListeners", value: function addEventListeners()

    {
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);
      this.addEventListener(ViewportsExtension.Events.VIEWPORT_DATA_CREATED_EVENT, this.onViewportDataCreated);
    } }, { key: "removeEventListeners", value: function removeEventListeners()

    {
      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);
      this.removeEventListener(ViewportsExtension.Events.VIEWPORT_DATA_CREATED_EVENT, this.onViewportDataCreated);
    } }, { key: "onModelAdded", value: function onModelAdded(_ref)

    {var model = _ref.model;
      this.fetchViewports(model.getDocumentNode());
    }

    // Generate artificial levels based on viewports.
  }, { key: "generateLevelsFromViewports", value: function () {var _generateLevelsFromViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(bubbleNode) {var viewports, levels, LevelHeightThreshold, i, _i, currentElevation, nextElevation;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
                  this.getViewportsAsync(bubbleNode));case 2:viewports = _context.sent;if (

                viewports) {_context.next = 5;break;}return _context.abrupt("return",
                []);case 5:


                levels = [];
                LevelHeightThreshold = 1;

                viewports.sort(function (v1, v2) {return v1.getElevation() - v2.getElevation();});

                for (i = 0; i < viewports.length - 1; i++) {
                  // Don't generate more than one level per height.
                  // In case two viewports have about the same height, create a single level based on the first one.
                  if (Math.abs(viewports[i].getElevation() - viewports[i + 1].getElevation()) < LevelHeightThreshold) {
                    viewports.splice(i + 1, 1);
                    i--;
                  }
                }

                for (_i = 0; _i < viewports.length; _i++) {
                  currentElevation = viewports[_i].getElevation();
                  nextElevation = undefined;

                  // Topmost level - we don't know its height, so we'll assume it's REALLY tall.
                  if (_i === viewports.length - 1) {
                    nextElevation = MAX_INT_32; // Equivalent to the top level values in AecModelData levels.
                  } else {
                    // For every other level, calculate its height according to the next level on top of it.
                    nextElevation = viewports[_i + 1].getElevation();
                  }

                  levels.push(
                  new _levels_Level__WEBPACK_IMPORTED_MODULE_6__["default"](
                  _i,
                  _i.toString(), "".concat(
                  Autodesk.Viewing.i18n.translate('Level'), " #").concat(_i + 1),
                  currentElevation - _levels_LevelUtils__WEBPACK_IMPORTED_MODULE_5__["zOffsetHack"],
                  nextElevation));


                }return _context.abrupt("return",

                levels);case 11:case "end":return _context.stop();}}}, _callee, this);}));function generateLevelsFromViewports(_x) {return _generateLevelsFromViewports.apply(this, arguments);}return generateLevelsFromViewports;}() }, { key: "onViewportDataCreated", value: function onViewportDataCreated(_ref2)


    {var _this3 = this;var models = _ref2.models;
      models.forEach(function (model) {
        // Invalidate cache and refetch the viewports data
        var key = model.getModelKey();
        if (_this3.cache.viewports[key]) {
          delete _this3.cache.viewports[key];

          // Refetch viewports.
          _this3.onModelAdded({ model: model });
        }
      });
    }

    // Fetch and get viewports for a given bubble.
    // In case that the viewports were previously requested - don't worry, you'll get them from cache.
  }, { key: "getViewportsAsync", value: function () {var _getViewportsAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(bubbleNode, filterOptions) {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (
                  this.fetchViewports(bubbleNode));case 2:return _context2.abrupt("return",
                this.filterAndFlattenViewports(bubbleNode, filterOptions));case 3:case "end":return _context2.stop();}}}, _callee2, this);}));function getViewportsAsync(_x2, _x3) {return _getViewportsAsync.apply(this, arguments);}return getViewportsAsync;}()


    // Returns only from what's already cached
  }, { key: "getViewports", value: function getViewports(bubbleNode, filterOptions) {
      return this.filterAndFlattenViewports(bubbleNode, filterOptions);
    }

    // Filter viewports according to given flags, and organize them in a flat array.
    // filterOptions:
    //          - filter2DTo3DTransformSupport: filter only viewports that support 2D to 3D transform.
    //          - onlyTopViewPlans: filter only top view viewports.
    //          - filterCB: additional filter callback.
  }, { key: "filterAndFlattenViewports", value: function filterAndFlattenViewports(bubbleNode) {var _filterOptions$filter, _filterOptions$onlyTo;var filterOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var filter2DTo3DTransformSupport = (_filterOptions$filter = filterOptions.filter2DTo3DTransformSupport) !== null && _filterOptions$filter !== void 0 ? _filterOptions$filter : true;
      var onlyTopViewPlans = (_filterOptions$onlyTo = filterOptions.onlyTopViewPlans) !== null && _filterOptions$onlyTo !== void 0 ? _filterOptions$onlyTo : true;
      var filterCB = filterOptions.filterCB;

      var key = bubbleNode.getModelKey();
      var viewportsPerProvider = this.cache.viewports[key];

      if (!viewportsPerProvider) {
        return [];
      }

      var viewports = Object.values(viewportsPerProvider).flat();

      if (filter2DTo3DTransformSupport) {
        viewports = viewports.filter(function (viewport) {return viewport.supports2DTo3DTransform();});
      }

      if (onlyTopViewPlans) {
        viewports = viewports.filter(function (viewport) {return viewport.isTopViewViewport();});
      }

      if (filterCB) {
        viewports = viewports.filter(filterCB);
      }

      return viewports;
    }

    // Fetch viewports for a given bubbleNode.
  }, { key: "fetchViewports", value: function () {var _fetchViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(bubbleNode) {var _this4 = this;var key;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
                key = bubbleNode.getModelKey();
                if (!this.cache.viewports[key]) {
                  this.cache.viewports[key] = {};
                }

                // Wait for all providers to finish before returning from function,
                // but run each provider in parallel so nothing is blocked.
                _context4.next = 4;return Promise.all(Object.values(this.providers).map( /*#__PURE__*/function () {var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(provider) {var providerName, viewports;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                            providerName = provider.getProviderName();

                            // Fetch viewports only if they are not in cache yet.
                            if (_this4.cache.viewports[key][providerName]) {_context3.next = 11;break;}
                            // Add a placeholder in cache so it won't fetch viewports multiple times for the
                            // same provider (in case of multiple calls to fetchViewports)
                            _this4.cache.viewports[key][providerName] = [];

                            // Save the current promise to be returned on subsequent fetchViewports calls,
                            // so that we don't return those calls until data is ready
                            _this4.cache.viewports[key][providerName].pendingPromise = provider.fetchViewports(bubbleNode);_context3.next = 6;return (
                              _this4.cache.viewports[key][providerName].pendingPromise);case 6:viewports = _context3.sent;

                            delete _this4.cache.viewports[key][providerName].pendingPromise;

                            if (viewports.length) {
                              _this4.cache.viewports[key][providerName] = viewports;
                              _this4.fireEvent({ type: ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, viewports: viewports });
                            }_context3.next = 14;break;case 11:if (!
                            _this4.cache.viewports[key][providerName].pendingPromise) {_context3.next = 14;break;}_context3.next = 14;return (
                              _this4.cache.viewports[key][providerName].pendingPromise);case 14:case "end":return _context3.stop();}}}, _callee3);}));return function (_x5) {return _ref3.apply(this, arguments);};}()));case 4:case "end":return _context4.stop();}}}, _callee4, this);}));function fetchViewports(_x4) {return _fetchViewports.apply(this, arguments);}return fetchViewports;}()




    // Given a viewport array, a sheet and a point on that sheet, this function returns the viewport containing it.
    // If multiple viewports overlap, we choose the one where (x,y) is "most inside", i.e., 
    // where the distance from the viewport edges is largest.
    //
    //  @param {av.Model}         sheet
    //  @param {Vector2}          point            - Point in sheet world-coords.
    //  @param {Object}           filterOptions
    //
    //  @returns {Viewport|null} 
  }, { key: "findViewportAtPoint", value: function findViewportAtPoint(sheet, point, filterOptions) {
      var viewports = this.filterAndFlattenViewports(sheet.getDocumentNode(), filterOptions);

      // Couple each viewport with viewport bounds 
      viewports = viewports.map(function (vp) {
        return {
          viewport: vp,
          bounds: vp.getViewportBounds(sheet.getUnitScale()) };

      });

      // Reduce to viewports containing the given point
      var containsPoint = function containsPoint(vp) {var _vp$bounds;return (_vp$bounds = vp.bounds) === null || _vp$bounds === void 0 ? void 0 : _vp$bounds.containsPoint(point);};

      viewports = viewports.filter(containsPoint);

      // Point may be outside of all viewports
      if (!viewports.length) {
        return null;
      }

      // Viewports may overlap. For this case, we need a heuristic metric
      // to choose the best match. For this, we use the
      // distance to the viewport boundary edges.
      var distanceFromEdge = function distanceFromEdge(box, p) {
        return Math.min(
        Math.min(p.x - box.min.x, box.max.x - p.x),
        Math.min(p.y - box.min.y, box.max.y - p.y));

      };

      // Pick the viewport that minimizes distanceFromEdge
      var getBestMatch = function getBestMatch(vp1, vp2) {
        var d1 = distanceFromEdge(vp1.bounds, point);
        var d2 = distanceFromEdge(vp2.bounds, point);
        return d2 > d1 ? vp2 : vp1;
      };

      return viewports.reduce(getBestMatch).viewport;
    }

    // Given a level guid, find all viewports that are contained in this level.
    //
    //  @param {av.Model}         model3D          - A 3D model that contains levels & viewports.
    //  @param {String}           levelGuid        - Level guid
    //
    //  @returns {Array<Viewport>} 
  }, { key: "findViewportsInLevel", value: function findViewportsInLevel(model3D, levelGuid) {
      var levelExt = this.viewer.getExtension('Autodesk.AEC.LevelsExtension');

      if (!levelExt) {
        return [];
      }

      var levels = levelExt.floorSelector.floorData;
      var level = levels.find(function (level) {return level.guid === levelGuid;});

      // No matching level for the given level guid.
      if (!level) {
        return [];
      }

      var viewports = this.getViewports(model3D.getDocumentNode(), {
        filterCB: function filterCB(viewport) {return viewport.isViewportInLevel(level);} });


      return viewports;
    } }]);return ViewportsExtension;}(av.Extension);


namespace.ViewportsExtension = ViewportsExtension;

// Events
ViewportsExtension.Events = {
  VIEWPORT_DATA_FETCHED_EVENT: 'viewportDataFetched',
  VIEWPORT_DATA_CREATED_EVENT: 'viewportDataCreated' };


// Exports
ViewportsExtension.ViewportProviderInterface = _Providers_ViewportProviderInterface__WEBPACK_IMPORTED_MODULE_0__["default"];
ViewportsExtension.AecModelDataViewportProvider = _Providers_AecModelDataViewportProvider__WEBPACK_IMPORTED_MODULE_1__["default"];
ViewportsExtension.AlignmentServiceViewportProvider = _Providers_AlignmentServiceViewportProvider__WEBPACK_IMPORTED_MODULE_2__["default"];
ViewportsExtension.AlignmentServiceViewport = _ViewportTypes_AlignmentServiceViewport__WEBPACK_IMPORTED_MODULE_3__["default"];
ViewportsExtension.AecModelDataViewport = _ViewportTypes_AecModelDataViewport__WEBPACK_IMPORTED_MODULE_4__["default"];

av.theExtensionManager.registerExtension(extensionName, ViewportsExtension);

/***/ }),

/***/ "./extensions/AEC/Viewports/ViewportsLocales.js":
/*!******************************************************!*\
  !*** ./extensions/AEC/Viewports/ViewportsLocales.js ***!
  \******************************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../res/locales/en/nobundle-viewports.loc.json */ "./res/locales/en/nobundle-viewports.loc.json");
var _res_locales_en_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/en/nobundle-viewports.loc.json */ "./res/locales/en/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_en_GB_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../res/locales/en-GB/nobundle-viewports.loc.json */ "./res/locales/en-GB/nobundle-viewports.loc.json");
var _res_locales_en_GB_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_1___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/en-GB/nobundle-viewports.loc.json */ "./res/locales/en-GB/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_cs_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../res/locales/cs/nobundle-viewports.loc.json */ "./res/locales/cs/nobundle-viewports.loc.json");
var _res_locales_cs_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_2___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/cs/nobundle-viewports.loc.json */ "./res/locales/cs/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_de_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../res/locales/de/nobundle-viewports.loc.json */ "./res/locales/de/nobundle-viewports.loc.json");
var _res_locales_de_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_3___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/de/nobundle-viewports.loc.json */ "./res/locales/de/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_es_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../res/locales/es/nobundle-viewports.loc.json */ "./res/locales/es/nobundle-viewports.loc.json");
var _res_locales_es_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/es/nobundle-viewports.loc.json */ "./res/locales/es/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_fr_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../res/locales/fr/nobundle-viewports.loc.json */ "./res/locales/fr/nobundle-viewports.loc.json");
var _res_locales_fr_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/fr/nobundle-viewports.loc.json */ "./res/locales/fr/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_fr_CA_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../res/locales/fr-CA/nobundle-viewports.loc.json */ "./res/locales/fr-CA/nobundle-viewports.loc.json");
var _res_locales_fr_CA_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_6___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/fr-CA/nobundle-viewports.loc.json */ "./res/locales/fr-CA/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_it_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../res/locales/it/nobundle-viewports.loc.json */ "./res/locales/it/nobundle-viewports.loc.json");
var _res_locales_it_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_7___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/it/nobundle-viewports.loc.json */ "./res/locales/it/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_ja_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../res/locales/ja/nobundle-viewports.loc.json */ "./res/locales/ja/nobundle-viewports.loc.json");
var _res_locales_ja_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_8___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/ja/nobundle-viewports.loc.json */ "./res/locales/ja/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_ko_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../res/locales/ko/nobundle-viewports.loc.json */ "./res/locales/ko/nobundle-viewports.loc.json");
var _res_locales_ko_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_9___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/ko/nobundle-viewports.loc.json */ "./res/locales/ko/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_pl_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../res/locales/pl/nobundle-viewports.loc.json */ "./res/locales/pl/nobundle-viewports.loc.json");
var _res_locales_pl_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_10___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/pl/nobundle-viewports.loc.json */ "./res/locales/pl/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_pt_BR_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../res/locales/pt-BR/nobundle-viewports.loc.json */ "./res/locales/pt-BR/nobundle-viewports.loc.json");
var _res_locales_pt_BR_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_11___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/pt-BR/nobundle-viewports.loc.json */ "./res/locales/pt-BR/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_ru_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../res/locales/ru/nobundle-viewports.loc.json */ "./res/locales/ru/nobundle-viewports.loc.json");
var _res_locales_ru_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_12___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/ru/nobundle-viewports.loc.json */ "./res/locales/ru/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_tr_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../res/locales/tr/nobundle-viewports.loc.json */ "./res/locales/tr/nobundle-viewports.loc.json");
var _res_locales_tr_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_13___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/tr/nobundle-viewports.loc.json */ "./res/locales/tr/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_zh_HANS_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../res/locales/zh-HANS/nobundle-viewports.loc.json */ "./res/locales/zh-HANS/nobundle-viewports.loc.json");
var _res_locales_zh_HANS_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_14___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/zh-HANS/nobundle-viewports.loc.json */ "./res/locales/zh-HANS/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_zh_HANT_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../res/locales/zh-HANT/nobundle-viewports.loc.json */ "./res/locales/zh-HANT/nobundle-viewports.loc.json");
var _res_locales_zh_HANT_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_15___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/zh-HANT/nobundle-viewports.loc.json */ "./res/locales/zh-HANT/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_zh_HK_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../res/locales/zh-HK/nobundle-viewports.loc.json */ "./res/locales/zh-HK/nobundle-viewports.loc.json");
var _res_locales_zh_HK_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_16___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/zh-HK/nobundle-viewports.loc.json */ "./res/locales/zh-HK/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_nl_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../../res/locales/nl/nobundle-viewports.loc.json */ "./res/locales/nl/nobundle-viewports.loc.json");
var _res_locales_nl_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_17___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/nl/nobundle-viewports.loc.json */ "./res/locales/nl/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_sv_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../../res/locales/sv/nobundle-viewports.loc.json */ "./res/locales/sv/nobundle-viewports.loc.json");
var _res_locales_sv_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_18___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/sv/nobundle-viewports.loc.json */ "./res/locales/sv/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_da_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../../res/locales/da/nobundle-viewports.loc.json */ "./res/locales/da/nobundle-viewports.loc.json");
var _res_locales_da_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_19___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/da/nobundle-viewports.loc.json */ "./res/locales/da/nobundle-viewports.loc.json", 1);
/* harmony import */ var _res_locales_no_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../../res/locales/no/nobundle-viewports.loc.json */ "./res/locales/no/nobundle-viewports.loc.json");
var _res_locales_no_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_20___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/no/nobundle-viewports.loc.json */ "./res/locales/no/nobundle-viewports.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */
























var locales = {
  en: _res_locales_en_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_0__,
  'en-GB': _res_locales_en_GB_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_1__,
  cs: _res_locales_cs_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_2__,
  de: _res_locales_de_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_3__,
  es: _res_locales_es_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_4__,
  fr: _res_locales_fr_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_5__,
  "fr-CA": _res_locales_fr_CA_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_6__,
  it: _res_locales_it_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_7__,
  ja: _res_locales_ja_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_8__,
  ko: _res_locales_ko_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_9__,
  pl: _res_locales_pl_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_10__,
  "pt-BR": _res_locales_pt_BR_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_11__,
  ru: _res_locales_ru_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_12__,
  tr: _res_locales_tr_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_13__,
  "zh-HANS": _res_locales_zh_HANS_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_14__,
  "zh-HANT": _res_locales_zh_HANT_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_15__,
  "zh-HK": _res_locales_zh_HK_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_16__,
  nl: _res_locales_nl_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_17__,
  sv: _res_locales_sv_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_18__,
  da: _res_locales_da_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_19__,
  no: _res_locales_no_nobundle_viewports_loc_json__WEBPACK_IMPORTED_MODULE_20__ };

/***/ }),

/***/ "./extensions/AEC/common/AecModelData.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/common/AecModelData.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// Utility functions to work with AEC-specific model data. These are stored in a separate JSON file AECModelData.json. 
// Currently only available for Revit files.
//

var namespace = AutodeskNamespace('Autodesk.AEC');

var TopViewViewportTypes = ['FloorPlan', 'CeilingPlan', 'EngineeringPlan'];

// Computes a Matrix4 that maps the 'from' rectangle to the 'to' rectangle in xy.
var remapRectangle = function remapRectangle(
xMinFrom, yMinFrom, xMaxFrom, yMaxFrom,
xMinTo, yMinTo, xMaxTo, yMaxTo)
{
  var scaleX = (xMaxTo - xMinTo) / (xMaxFrom - xMinFrom);
  var scaleY = (yMaxTo - yMinTo) / (yMaxFrom - yMinFrom);

  // Note that the translation component of the matrix works on the scaled values.
  // The scaling alone would map xMinFrom to scaleX * xMinFrom. We want 
  // to map it to xMinTo instead. (analog for y)
  var offsetX = xMinTo - scaleX * xMinFrom;
  var offsetY = yMinTo - scaleY * yMinFrom;

  // Create Matrix4 that applies both
  var matrix = new THREE.Matrix4();
  matrix.elements[0] = scaleX;
  matrix.elements[5] = scaleY;
  matrix.elements[12] = offsetX;
  matrix.elements[13] = offsetY;
  return matrix;
};

var getFeetToSheetUnits = function getFeetToSheetUnits(sheetUnitScale) {
  var FeetToMeter = 0.3048;
  var MeterToSheetUnits = 1.0 / sheetUnitScale;
  return FeetToMeter * MeterToSheetUnits;
};

// Returns the 2D bbox of a viewport on a sheet.
// 
// @param {Object} vp             - Viewport data as read from AECModelData
// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().
// @returns {THREE.Box2|null}
var getViewportBounds = function getViewportBounds(vp, sheetUnitScale) {

  // viewport region in foot as array (6 floats)
  var values = vp.geometryViewportRegion;
  if (!values) {
    return null;
  }

  // Convert from foot to sheet units (usually inches)
  var scale = getFeetToSheetUnits(sheetUnitScale);

  // The viewport region returned by Revit is incorrect. It's enlarged by an offset of 0.01 ft.
  // We remove that offset before scaling. 
  // See https://thebuildingcoder.typepad.com/blog/2010/09/view-location-on-sheet.html (search for 0.01 in that page)
  var boundsCorrection = 0.01;

  var res = new THREE.Box2();
  res.min.x = (values[0] + boundsCorrection) * scale;
  res.min.y = (values[1] + boundsCorrection) * scale;
  res.max.x = (values[3] - boundsCorrection) * scale;
  res.max.y = (values[4] - boundsCorrection) * scale;
  return res;
};

// Handle available view rotation modes in Revit
// If a view was rotated in Revit, this swapped/inverted some viewport axes. We must revert this modification when transforming back to world coords.
// This function returns a Matrix4 that performs this rotation on an input vector p in normalized viewport coords (in [0,1])
//
//  @param {number} viewRotationType - as read from AECModelData. Enum value in {0,1,2}. see Revit API doc:
//                                     http://www.revitapidocs.com/2018/abd81744-b44a-e578-cb62-3cc40a334acc.htm
//  @returns {THREE.Vector2/3} Copy of vpCoords with swapped/inverted axes according to viewport rotation
var getInverseViewportRotation = function getInverseViewportRotation(viewRotationType) {

  var matrix = new THREE.Matrix4();
  switch (viewRotationType) {
    // No rotation => done
    case 0:return matrix;

    // Revit view was rotated by 90 degrees clockwise => Rotate by 90 degrees ccw
    case 1:{
        // Note that a rotation would actually mean result.x = -y. But, we just revert the effect the rotation effect on the
        // viewport axes here. I.e., input and output are in [0,1]. For this, swapping an axis means taking 1.0-value, not just the negative.
        // Therefore, the desired effect of the matrix is:
        //
        //  (x, y) => (1-y, x)
        //
        // Note the memory layout of THREE matrices is column-major.

        // out.x = (1-y)
        matrix.elements[0] = 0; //  0 * in.x
        matrix.elements[4] = -1; // -1 * in.y
        matrix.elements[12] = 1; // + 1

        // out.y = x
        matrix.elements[1] = 1; // 1 * in.x
        matrix.elements[5] = 0; // 0 * in.y

        break;
      }

    // Revit view was rotated 90 degrees counterclockwise => Rotate by 90 degrees cw
    case 2:{
        // Desired transform here is:
        //
        // (x, y) => (y, 1-x)

        // out.x = y
        matrix.elements[0] = 0; // 0 * in.x
        matrix.elements[4] = 1; // 1 * in.y

        // out.y = (1-x)
        matrix.elements[1] = -1; //    -in.x
        matrix.elements[5] = 0; // 0 * in.y
        matrix.elements[13] = 1; // + 1

        break;
      }
    default:console.warn('Unexpected enum value for view rotation: ', viewRotationType);}

  return matrix;
};

var get3DTo2DModelSheetTransform = function get3DTo2DModelSheetTransform(vp, sheetUnitScale) {
  // Only if AECModelData has been produced using latest RevitAPI changes, 
  // we get the 3DTo2D matrix directly. Otherwise return null.
  if (!vp.modelToSheetTransform) {
    return null;
  }

  var values = vp.modelToSheetTransform;
  var matrix = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(values);

  // apply post-scaling from feet to sheet-units
  // Note that using multiplyScalar() here is only similar, but not the same: E.g., it would also multiply component 15
  // which may cause weird side-effects when multiplying with other matrices.
  // The Z value of the scale is set to feetToSheetUnits as well so that getMaxScaleOnAxis
  // returns a meaningful result (used to be 1, which would skew the results)
  var feetToSheetUnits = getFeetToSheetUnits(sheetUnitScale);
  var scaleTf = new THREE.Matrix4().makeScale(feetToSheetUnits, feetToSheetUnits, feetToSheetUnits);
  matrix.multiplyMatrices(scaleTf, matrix);

  return matrix;
};

var compute2Dto3DTransform = function compute2Dto3DTransform(vp, sheetUnitScale) {
  // Viewport bbox on sheet (Box2)
  var sheetRegion = getViewportBounds(vp, sheetUnitScale);

  // SectionBox (Box3 + Matrix4): Oriented box in 3D world coords. Represents the volume
  // that is mapped to the sheet.
  var sectionBox = vp.sectionBox;
  var sectionBoxTransform = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(sectionBox.transform);

  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2
  var sheetToViewport = remapRectangle(
  sheetRegion.min.x, sheetRegion.min.y, sheetRegion.max.x, sheetRegion.max.y, // ...from viewport rectangle in sheet coordinates
  0, 0, 1, 1 // ...to [0,1] 
  );

  // Consider Revit viewport rotation. Result keeps within viewport coords ([0,1]^2)
  var vpRotationInv = getInverseViewportRotation(vp.viewportRotation);

  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2
  var viewportToSectionBox = remapRectangle(
  0, 0, 1, 1, // ...from normalized viewport coords
  sectionBox.min.x, sectionBox.min.y, sectionBox.max.x, sectionBox.max.y // ...to the xy-extent of the untransformed SectionBox
  );

  // Finally, apply the sectionBoxTransform to obtain world coords. Note that matrix products must be done in reverse order.
  return sectionBoxTransform.
  multiply(viewportToSectionBox).
  multiply(vpRotationInv).
  multiply(sheetToViewport);
};

// Compute matrix to convert 2D sheet coords within the given viewport to 3D model coordinates.
//
// @param {Object} vp             - Viewport data as read from AECModelData
// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().
//
// @returns {THREE.Matrix4}
//
// Note: Not all viewports provide A 2D/3D transform is not provided by all This feature is only available for a subset of  viewports. 
var get2DTo3DMatrix = function get2DTo3DMatrix(vp, sheetUnitScale) {
  var matrix = get3DTo2DModelSheetTransform(vp, sheetUnitScale);

  if (matrix) {
    return matrix.getInverse(matrix);
  }

  return compute2Dto3DTransform(vp, sheetUnitScale);
};

// Compute matrix to convert 3D model coords to 2D sheet coords within a given viewport. See get2Dto3DMatrix().
var get3DTo2DMatrix = function get3DTo2DMatrix(vp, sheetUnitScale) {
  var matrix = get3DTo2DModelSheetTransform(vp, sheetUnitScale);

  if (matrix) {
    return matrix;
  }

  matrix = compute2Dto3DTransform(vp, sheetUnitScale);
  return matrix.getInverse(matrix);
};

// Find Sheet BubbleNode containing the given viewport.
//
//  @params {av.BubbleNode} root - root node of a manifest in which we search for sheets
//  @params {Object}        vp   - Viewport as obtained from AecModelData.json file (aecData.viewports)
//  @returns {av.BubbleNode[]|undefined} BubbleNode of the sheet containing the viewport (if any).
var findSheetForViewport = function findSheetForViewport(root, vp) {
  var sheetNodes = root.search(Autodesk.Viewing.BubbleNode.SHEET_NODE);
  var linkedByVp = function linkedByVp(node) {return node.guid() === vp.sheetGuid;};
  return sheetNodes.find(linkedByVp);
};

// Find all viewports on a given sheet. The sheet can be specified as model or BubbleNode.
// Note that not all viewports support 2D/3D transform.
//
//  @param {av.BubbleNode|av.Model} sheet
var findViewportsOnSheet = function findViewportsOnSheet(sheet) {

  // get aecModelData from model or node
  var isNode = sheet instanceof Autodesk.Viewing.BubbleNode;
  var sheetNode = isNode ? sheet : sheet.getDocumentNode();
  var aec = sheetNode.getAecModelData();
  if (!aec || !aec.viewports) {
    return [];
  }

  // Find viewports linking the sheet guid
  return aec.viewports.filter(function (vp) {return vp.sheetGuid === sheetNode.guid();});
};

// Given a sheet and a point on that sheet, this function returns the viewport containing it.
// If multiple viewports overlap, we choose the one where (x,y) is "most inside", i.e., 
// where the distance from the viewport edges is largest.
//
//  @param {av.Model}         sheet
//  @param {Vector2}          point            - Point in sheet world-coords.
//  @param {function(Object)} [viewportFilter] - Option to exclude certain viewports
//
//  @returns {Object|undefined} 
var findViewportAtPoint = function findViewportAtPoint(sheet, point) {var viewportFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

  console.warn('Please use ViewportExtension.findViewportAtPoint instead.');

  // Find sheets linking this sheet
  var viewports = findViewportsOnSheet(sheet);

  // Apply option filter
  if (viewportFilter) {
    viewports = viewports.filter(viewportFilter);
  }

  // Couple each viewport with viewport bounds 
  viewports = viewports.map(function (vp) {
    return {
      viewport: vp,
      bounds: getViewportBounds(vp, sheet.getUnitScale()) };

  });

  // Reduce to viewports containing the given point
  var containsPoint = function containsPoint(vp) {
    return vp.bounds && vp.bounds.containsPoint(point);
  };
  viewports = viewports.filter(containsPoint);

  // Point may be outside of all viewports
  if (!viewports.length) {
    return;
  }

  // Viewports may overlap. For this case, we need a heuristic metric
  // to choose the best match. For this, we use the
  // distance to the viewport boundary edges.
  var distanceFromEdge = function distanceFromEdge(box, p) {
    return Math.min(
    Math.min(p.x - box.min.x, box.max.x - p.x),
    Math.min(p.y - box.min.y, box.max.y - p.y));

  };

  // Pick the viewport that minimizes distanceFromEdge
  var getBestMatch = function getBestMatch(vp1, vp2) {
    var d1 = distanceFromEdge(vp1.bounds, point);
    var d2 = distanceFromEdge(vp2.bounds, point);
    return d2 > d1 ? vp2 : vp1;
  };
  return viewports.reduce(getBestMatch).viewport;
};

// Get guid of the level shown by a viewport (may be null, e.g. for SectionViews)
//  @param {Object} vp - viewport object from aecModelData
//  @returns {string|undefined} levelGuid
var getLinkedLevel = function getLinkedLevel(vp) {

  // Viewports come directly from aecModelData json and do not always reference a level. 
  // So, we should not crash if anything is null here.
  var viewRange = vp.extensions && vp.extensions.viewRange;
  var cutPlane = viewRange && viewRange.cutPlane;
  return cutPlane && cutPlane.levelGuid;
};

// Find all viewports in the document that link the level indicated by levelGuid
//
// @param {Object} aecData   - as obtained from AECModelData.json
// @param {string} levelGuid
// @retuns {Object[]} Array of viewport data objects
var findViewportsForLevel = function findViewportsForLevel(aecData, levelGuid) {

  // Find viewports that links this level
  var viewports = aecData.viewports || [];

  var matchesLevel = function matchesLevel(vp) {
    var vpLevelGuid = getLinkedLevel(vp);
    return vpLevelGuid === levelGuid;
  };
  return viewports.filter(matchesLevel);
};

// Find level in aecModelData that links the given viewport.
//
// @param {Object} aecData - as obtained from AECModelData.json
// @param {Object} viewport object
// @retuns {Object|undefined} level object from aecModelData
var findLevelForViewport = function findLevelForViewport(aecData, viewport) {
  var levelGuid = getLinkedLevel(viewport);

  // Search for a level with this levelGuid
  var hasLevelGuid = function hasLevelGuid(level) {return level.guid === levelGuid;};
  return levelGuid && aecData.levels.find(hasLevelGuid);
};

// Checks if a viewport provides all required information to compute a 2D/3D transform.
//  @param {Object} vp - vieport data object as obtained from AecModelData.json
var supports2DTo3DTransform = function supports2DTo3DTransform(vp) {

  // If AECModelData contains a modelToSheetTransform (only possible for models produced using latest RevitAPI changes), we get a matrix directly
  // and don't have to care for sectionBox or isCropBoxActive anymore.
  var canUseTransform = Boolean(vp.modelToSheetTransform);

  // Check if we can use the old code path to reverse-engineer the transform from the SectionBox
  var canUseWorkaround = Boolean(vp.sectionBox && vp.isCropBoxActive);

  // If neither of the two work, we can stop here.
  if (!canUseTransform && !canUseWorkaround) {
    return false;
  }

  var supportedViewportTypes = [].concat(TopViewViewportTypes, ['Section']);

  return Boolean(supportedViewportTypes.includes(vp.viewType) &&
  vp.geometryViewportRegion && // We need the viewport outline that corresponds 1:1 with the view sectionBox (excluding labels etc.)
  !vp.hasBreaks && // A view in Revit may be split into separate parts using "View breaks". This is not supported yet.
  !vp.extensions.hasRegions); // The 2D/3D transform may actually vary within a single view. We currently don't get the required data to support this.
};

var AEC_CACHE = {};

// Returns all the fragments that belong to a specific dbId. This only takes the leaf nodes, so we can't
// just call enumNodeFragments with recurse directly.
var getLevelFragmentsIds = function getLevelFragmentsIds(instanceTree, levelDbId) {
  var leafIds = [];
  var _collectLeafNodeIds = function _collectLeafNodeIds(id) {
    var childCount = 0;
    instanceTree.enumNodeChildren(id, function (childId) {
      _collectLeafNodeIds(childId);
      childCount += 1;
    });
    if (childCount === 0) {
      leafIds.push(id);
    }
  };
  _collectLeafNodeIds(levelDbId);

  var fragIds = [];
  leafIds.forEach(function (leafId) {
    instanceTree.enumNodeFragments(leafId, function (fragId) {fragIds.push(fragId);});
  });
  return fragIds;
};

// This function holds heuristics around getting bounding boxes for levels:
// 1. Compute fuzzyBoundingBox to make sure things like pipes coming through multiple floors do not make bounding box too large
// 2. Given that levels are coming in bottom up order, we check that newly computed bounding box does not intersect with the last known level
//    and if it does, reduce the largest box among both levels. This step helps when bounding box is large by nature (e.g. due to high walls spreading over multiple levels)
var getLevelBoundingBox = function getLevelBoundingBox(dbId, model, lastLevel) {
  var instanceTree = model.getData().instanceTree;
  if (!instanceTree) {
    return;
  }

  var fragIds = getLevelFragmentsIds(instanceTree, dbId);
  var newBox = model.getFuzzyBox({ allowlist: fragIds });

  // If there is some levels in the storage already, we need to check for intersection
  if (lastLevel.min.z !== Infinity && lastLevel.max.z > newBox.min.z) {
    // there is an intersection and some box need to be cropped
    var newBoxHeight = Math.abs(newBox.max.z - newBox.min.z);
    var lastKnownBoxHeight = Math.abs(lastLevel.max.z - lastLevel.min.z);
    if (lastKnownBoxHeight > newBoxHeight) {
      lastLevel.max.z = lastLevel.min.z;
    } else {
      newBox.min.z = lastLevel.max.z;
    }
  }
  lastLevel.copy(newBox);
  return newBox;
};

var computeLevels = function computeLevels(levels, model) {
  // Need to get and apply opposite to elevation as it will be reapplied elsewhere
  var refPointTf = model.myData.placementWithOffset;
  if (!refPointTf) {
    refPointTf = new THREE.Matrix4();
  }

  var lastLevel = new THREE.Box3();
  levels.forEach(function (level, idx) {
    var levelBox = getLevelBoundingBox(level.dbId, model, lastLevel);
    if (levelBox && levelBox.min.z !== Infinity && levelBox.max.z !== Infinity) {
      level.elevation = levelBox.min.z - (refPointTf ? refPointTf.elements[14] : 0);
      if (idx === levels.length - 1) {
        level.height = model.getBoundingBox().max.z - levelBox.min.z;
      } else {
        level.height = levelBox.max.z - levelBox.min.z;
      }
    }
  });

  if (levels.some(function (l) {return !l.elevation;})) {
    console.warn('Failed to derive elevation for some levels');
    return;
  }

  var refP = [
  refPointTf.elements[0], refPointTf.elements[1], refPointTf.elements[2],
  refPointTf.elements[4], refPointTf.elements[5], refPointTf.elements[6],
  refPointTf.elements[8], refPointTf.elements[9], refPointTf.elements[10],
  refPointTf.elements[12], refPointTf.elements[13], refPointTf.elements[14]];

  var aecModelData = {
    version: '1.0.0', phases: [{ name: 'Default' }], levels: levels, scopeBoxes: [], refPointTransformation: refP };


  return aecModelData;
};

// Couple of queries used here will only work for OTG property database
// In order to make it work for SVF we need to use other property names, coming from Navisworks (Lc*)
var findLevelsOTG = function findLevelsOTG(onDone, onError, model) {
  model.search(
  'IFCBUILDING',
  function (dbIds) {
    model.getBulkProperties(
    dbIds, null,
    function (elements) {
      if (elements.length !== 1) {
        // Should find one element (if not, we consider it an edge case --maybe 2 buildings within
        // single IFC file-- for now and do nothing)
        return onDone(undefined);
      }
      var levelCandidates = elements[0].properties.
      filter(function (e) {return e.displayName === 'child';}) // get direct children
      .map(function (e) {return e.displayValue;}); // get dbId of each child

      model.getBulkProperties(
      levelCandidates, ['Name', 'Type'],
      function (levelElements) {
        // Levels are stored in Db as they are presented in IFC -> bottom up order, so we must not mess it up
        var levels = levelElements.map(function (lev) {
          var type = lev.properties.find(function (p) {return p.displayName === 'Type';});
          var name = lev.properties.find(function (p) {return p.displayName === 'Name';});
          // TODO: this might be localization dependent
          if (type && type.displayValue.includes('Level') && name) {
            return {
              guid: lev.dbId.toString(),
              name: name.displayValue,
              // NOTE: elevation and height will be populated later
              dbId: lev.dbId,
              extension: {
                buildingStory: true,
                structure: false,
                computationHeight: 0,
                groundPlane: false,
                hasAssociatedViewPlans: false } };


          }
        }).filter(Boolean);

        onDone(levels);
      },
      onError);

    },
    onError);

  }, onError, ['Type']);

};

var findLevelsSVF = function findLevelsSVF(onDone, onError, model) {
  model.search(
  'IfcBuildingStorey',
  function (dbIds) {
    model.getBulkProperties(
    dbIds,
    ['Type', 'GUID', 'NAME', 'Name', 'ELEVATION', 'Elevation', 'IfcElevation'],
    function (elements) {
      var levels = [];
      for (var i = 0; i < elements.length; i++) {
        if (elements[i].properties.length > 1) {
          var guidIdx = elements[i].properties.findIndex(function (element) {return element.displayName === 'GUID';});
          var levelIdx = elements[i].properties.findIndex(function (element) {return element.displayValue === 'Levels: Level: Level 1';});
          var nameIdx = -1;
          var elevationIdx = -1;
          if (levelIdx >= 0) {
            nameIdx = elements[i].properties.findIndex(function (element) {return (
                (element.attributeName.toLowerCase() === 'name' ||
                element.attributeName === 'LcOaNode:LcOaSceneBaseUserName') &&
                element.displayCategory === 'Item');});
          } else {
            nameIdx = elements[i].properties.findIndex(function (element) {return (
                element.displayName.toLowerCase() === 'name' && (
                element.displayCategory === 'IFC' ||
                element.attributeName === 'LcOaNode:LcOaSceneBaseUserName' &&
                element.displayCategory === 'Item' ||
                element.attributeName ===
                'LcRevitData_Element:LcRevitPropertyElementName' &&
                element.displayCategory === 'Element'));});
            elevationIdx = elements[i].properties.findIndex(function (element) {return (
                element.displayName === 'ELEVATION' &&
                element.displayCategory === 'IFC' ||
                (element.displayName === 'IfcElevation' ||
                element.displayName === 'Elevation') &&
                element.displayCategory === 'Element');});
          }
          if (nameIdx >= 0 && (elevationIdx >= 0 || levelIdx >= 0)) {
            var guid = guidIdx > -1 ? elements[i].properties[guidIdx].displayValue : elements[i].dbId;

            levels.push({
              guid: guid.toString(),
              name: elements[i].properties[nameIdx].displayValue,
              dbId: elements[i].dbId,
              extension: {
                buildingStory: true,
                structure: false,
                computationHeight: 0,
                groundPlane: false,
                hasAssociatedViewPlans: false } });


          }
        }
      }

      onDone(levels);
    },
    onError);

  },
  onError, ['Type']);

};

var computeAecModelDataForIfc = function computeAecModelDataForIfc(model) {
  if (!model) {
    return null;
  }

  var cacheKey = model.getModelKey();

  if (AEC_CACHE[cacheKey]) {// We had a heavy computation already, return result from cache
    return AEC_CACHE[cacheKey];
  }

  var promise = new Promise(function (resolve) {
    var onDone = function onDone(levels) {
      if (!levels || !levels.length) {
        return resolve(null);
      }

      var aecModelData = computeLevels(levels, model);
      if (cacheKey) {
        AEC_CACHE[cacheKey] = Object.assign({}, aecModelData);
      }
      resolve(aecModelData);
    };

    var onError = function onError(error) {
      console.error(error);
      resolve(null);
    };

    if (model.isOTG()) {
      findLevelsOTG(onDone, onError, model);
    } else {
      findLevelsSVF(onDone, onError, model);
    }
  });

  if (cacheKey) {
    // Cache the promise so if this is called multiple times it won't start the same computation in parallel
    AEC_CACHE[cacheKey] = promise;
  }

  return promise;
};

var AecModelData = {
  get2DTo3DMatrix: get2DTo3DMatrix,
  get3DTo2DMatrix: get3DTo2DMatrix,
  getViewportBounds: getViewportBounds,
  remapRectangle: remapRectangle,
  findSheetForViewport: findSheetForViewport,
  findViewportsForLevel: findViewportsForLevel,
  supports2DTo3DTransform: supports2DTo3DTransform,
  getLinkedLevel: getLinkedLevel,
  findViewportsOnSheet: findViewportsOnSheet,
  findViewportAtPoint: findViewportAtPoint,
  findLevelForViewport: findLevelForViewport,
  computeAecModelDataForIfc: computeAecModelDataForIfc,
  TopViewViewportTypes: TopViewViewportTypes };


/* harmony default export */ __webpack_exports__["default"] = (AecModelData);

namespace.AecModelData = AecModelData;

/***/ }),

/***/ "./extensions/AEC/hyperlinks/HyperlinkExtension.js":
/*!*********************************************************!*\
  !*** ./extensions/AEC/hyperlinks/HyperlinkExtension.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HyperlinkExtension; });
/* harmony import */ var _HyperlinkTracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HyperlinkTracker */ "./extensions/AEC/hyperlinks/HyperlinkTracker.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.HyperlinkExtension';


// Hyperlink extension which will display hyperlinks in 2D sheets to other sheets
//  @param {Number} options.rootBubbleNode Root bubble node of model
//  @callback options.loadViewableCb Will be called in case a hyperlink is clicked with bubble node of the sheet and
//      the total number of hyperlinks present in the sheet
//  @callback options.hyperlinksAddedCb Will be called each time hyperlinks have been added to a sheet with the id of
//      the model and the total number of hyperlinks present in the sheet
var HyperlinkExtension = /*#__PURE__*/function (_av$Extension) {_inherits(HyperlinkExtension, _av$Extension);var _super = _createSuper(HyperlinkExtension);
  function HyperlinkExtension(viewer, options) {var _this;_classCallCheck(this, HyperlinkExtension);
    _this = _super.call(this, viewer, options);

    _this.hyperlinkTracker = new _HyperlinkTracker__WEBPACK_IMPORTED_MODULE_0__["default"](_this.viewer, _this.options.rootBubbleNode,
    _this.options.loadViewableCb, _this.options.hyperlinksAddedCb);return _this;
  }_createClass(HyperlinkExtension, [{ key: "load", value: function load()

    {
      this.viewer.toolController.activateTool('hyperlink-tracker');
      return true;
    } }, { key: "unload", value: function unload()

    {
      this.viewer.toolController.deactivateTool('hyperlink-tracker');
      return true;
    } }]);return HyperlinkExtension;}(av.Extension);


namespace.HyperlinkExtension = HyperlinkExtension;
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, HyperlinkExtension);

/***/ }),

/***/ "./extensions/AEC/hyperlinks/HyperlinkTracker.js":
/*!*******************************************************!*\
  !*** ./extensions/AEC/hyperlinks/HyperlinkTracker.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HyperlinkTracker; });

//A tool that:
//Implements heuristically derived hyperlinks from text geometries in F2D drawings (and mouse hover support for hyperlinks)
//Taken from Fluent POC:
// https://git.autodesk.com/fluent/lmv-ui/blob/master/app/scripts/tools/mouse-tracker.js#L273
// https://git.autodesk.com/fluent/lmv-ui/blob/master/app/scripts/tools/mouse-tracker.js#L171


function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function (_e) {function e(_x) {return _e.apply(this, arguments);}e.toString = function () {return _e.toString();};return e;}(function (e) {throw e;}), f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function (_e2) {function e(_x2) {return _e2.apply(this, arguments);}e.toString = function () {return _e2.toString();};return e;}(function (e) {didErr = true;err = e;}), f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}

var av = Autodesk.Viewing,
avp = Autodesk.Viewing.Private;

function HyperlinkTracker(viewer, rootBubbleNode, loadViewableCb, hyperlinksAddedCb) {
  av.ToolInterface.call(this);
  this.names = ['hyperlink-tracker'];
  viewer.toolController.registerTool(this);

  var _viewer = viewer;
  var _loadViewableCb = loadViewableCb;
  var _hyperlinksAddedCb = hyperlinksAddedCb;
  var _idRead = [0, 0];
  var _linkMaps = {};
  var _dbId = 0;
  var _lastX, _lastY;
  var _mouseMoved = false;
  var _isDragging = false;

  this.update = function () {
    if (!_isDragging) {
      if (_mouseMoved) {
        var vp = _viewer.impl.clientToViewport(_lastX, _lastY);
        _dbId = _viewer.impl.renderer().idAtPixel(vp.x, vp.y, _idRead);
        _mouseMoved = false;
      }
    } else {
      _dbId = 0;
    }
    return false;
  };

  function getCurrentModel() {
    var mq = _viewer.impl.modelQueue();
    var visibleModels = mq.getModels();

    return visibleModels.length === 1 ? visibleModels[0] : undefined;
  }

  function getCurrentLinkMap() {
    var linkMap = _linkMaps[_idRead[1]];

    //Fallback for when a single model is loaded and the Model ID buffer is not working
    if (!linkMap) {
      var cm = getCurrentModel();
      if (cm) {
        linkMap = _linkMaps[cm.id];
      }
    }

    return linkMap;
  }

  function isLinkMapValid(map) {
    return map && Object.keys(map).length > 0;
  }

  this.handleSingleClick = function () {
    if (!_viewer.model || !_viewer.model.is2d())
    return;

    var vp = _viewer.impl.clientToViewport(_lastX, _lastY);
    _dbId = _viewer.impl.renderer().idAtPixel(vp.x, vp.y, _idRead);

    var linkMap = getCurrentLinkMap();

    var linkNode = isLinkMapValid(linkMap) ? linkMap[_dbId] : null;

    if (linkNode) {
      _loadViewableCb(linkNode, linkMap.numHyperlinks);
      return true;
    }

    return false;
  };

  this.handleButtonDown = function (event) {
    _isDragging = true;
    _lastX = event.canvasX;
    _lastY = event.canvasY;
    return false;
  };

  this.handleButtonUp = function () {
    _isDragging = false;
    return false;
  };

  this.handleMouseMove = function (event) {
    _lastX = event.canvasX;
    _lastY = event.canvasY;
    _mouseMoved = true;
    return false;
  };

  function addRenderBox(vbb, f2d, stringIndex, modelScale) {
    var i4 = 4 * stringIndex;

    var miny = f2d.stringBoxes[i4 + 1];
    var maxy = f2d.stringBoxes[i4 + 3];
    var border = (maxy - miny) * 0.2;
    miny = miny - border;
    maxy = maxy + border;
    var minx = f2d.stringBoxes[i4] - border;
    var maxx = f2d.stringBoxes[i4 + 2] + border;

    var dbId = f2d.stringDbIds[stringIndex];
    var vbase = vbb.vcount;

    var linkFillColor = 0x77bfbb3f;
    vbb.addVertexPolytriangle(minx, miny, linkFillColor, dbId, 0, 0);
    vbb.addVertexPolytriangle(maxx, miny, linkFillColor, dbId, 0, 0);
    vbb.addVertexPolytriangle(maxx, maxy, linkFillColor, dbId, 0, 0);
    vbb.addVertexPolytriangle(minx, maxy, linkFillColor, dbId, 0, 0);

    vbb.addIndices([0, 1, 2, 0, 2, 3], vbase);

    vbb.addSegment(minx, miny, maxx, miny, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
    vbb.addSegment(maxx, miny, maxx, maxy, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
    vbb.addSegment(maxx, maxy, minx, maxy, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
    vbb.addSegment(minx, maxy, minx, miny, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
  }

  function addLinkBoxMesh(model, vbb) {
    var fragId = model.getFragmentList().vizmeshes.length;
    var mdata = { mesh: vbb.toMesh(), is2d: true, packId: '0', meshIndex: fragId };
    avp.BufferGeometryUtils.meshToGeometry(mdata);

    var matman = _viewer.impl.matman();
    var materialId = matman.create2DMaterial(model, {});
    var m = _viewer.impl.setupMesh(model, mdata.geometry, materialId, model.getData().loadOptions.placementTransform);
    model.activateFragment(fragId, m);
    return fragId;
  }

  function removeLinkBoxMesh(model, fragId) {
    // get link box mesh
    var fragList = model.getFragmentList();
    var mesh = fragList.vizmeshes[fragId];

    // Dispose geometry. MaterialManager will take care of the material dispose on model unload. 
    // We don't dispose material here because it may be shared with other fragments of the model.
    mesh.geometry.dispose();

    delete fragList.vizmeshes[fragId];
  }

  function initializeHyperlinks(model) {
    if (!model || !model.is2d()) {
      return;
    }

    // Check if this model has been initialized already
    var linkMap = _linkMaps[model.id];
    if (linkMap) {
      return;
    }

    // find all sheets of the same document
    var node = model.getDocumentNode();
    var root = node && node.getRootNode();
    var sheets = root && root.search({ role: '2d', type: 'geometry' });
    if (!sheets || !sheets.length) {
      return;
    }

    linkMap = _linkMaps[model.id] = {};

    var currentSheetBasePath = '';
    if (model.myData) {
      currentSheetBasePath = model.myData.basePath;
    }

    var getSheetUrn = function getSheetUrn(sheet) {
      var resourceType = 'resource';
      if (sheet.children) {var _iterator = _createForOfIteratorHelper(
        sheet.children),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var child = _step.value;
            if (child.type() === resourceType) {
              var urn = child.urn();
              if (urn) {
                // We remove the primaryGraphics.f2d part from the urn
                var elements = urn.split('/');
                elements.pop();
                return elements.join('/');
              }
            }
          }} catch (err) {_iterator.e(err);} finally {_iterator.f();}
      }
      return null;
    };

    var sheetIds = sheets.map(function (s) {
      var sheetUrn = getSheetUrn(s);
      //exclude current sheet, i. e. no links to self
      if (currentSheetBasePath.indexOf(sheetUrn) === -1) {
        var split = s.name().split(' ');
        var sheetName = split[0];
        if (sheetName.length > 2) {
          return sheetName;
        }
      }
      return '';
    });

    //while finding hyperlink strings, we will also
    //create a geometry buffer containing all their bboxes
    //so we can render with their IDs.
    linkMap.numHyperlinks = 0;
    var vbb = new avp.VertexBufferBuilder();
    var modelScale = 1.0 / (model.getData().loadOptions.modelScale || 1);
    var f2d = model.getData();
    for (var i = 0; i < f2d.strings.length; i++) {

      var idx = sheetIds.indexOf(f2d.strings[i]);

      if (idx >= 0) {
        linkMap[f2d.stringDbIds[i]] = sheets[idx];

        addRenderBox(vbb, f2d, i, modelScale);
        linkMap.numHyperlinks++;
      }
    }

    linkMap.boxFragId = addLinkBoxMesh(model, vbb);

    if (_hyperlinksAddedCb) {
      _hyperlinksAddedCb(e.model.id, linkMap.numHyperlinks);
    }
  }

  function onGeomLoaded(e) {
    initializeHyperlinks(e.model);
  }

  // Execute cb for all sheets that are (completely) in memory
  function forAllSheetsInMemory(cb) {
    var allModels = _viewer.getAllModels();
    for (var i = 0; i < allModels.length; i++) {
      var model = allModels[i];
      if (model.is2d() && model.isLoadDone()) {
        cb(model);
      }
    }
  }

  function removeHyperlinks() {

    // Keep _linkMaps consistent with models: We don't want to leak dead box meshes in the models.
    // Therefore, we remove them from all models in memory
    forAllSheetsInMemory(function (model) {
      var linkMap = _linkMaps[model.id];
      if (linkMap) {
        removeLinkBoxMesh(model, linkMap.boxFragId);
      }
    });

    _linkMaps = {};

    // make sure that removed hyperlink quads are not visible anymore
    _viewer.impl.invalidate(true, true);
  }

  this.activate = function () {

    // Make sure that we don't forget to init hyperlinks if the geom-load event has already happened
    forAllSheetsInMemory(function (model) {
      initializeHyperlinks(model);
    });

    _viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, onGeomLoaded);

    // make sure that added hyperlink quads appear instantly
    _viewer.impl.invalidate(true, true);
  };

  this.deactivate = function () {
    _viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, onGeomLoaded);
    removeHyperlinks();
  };

  // Show a hand cursor, if the cursor is close to a hyperlink
  this.getCursor = function () {
    var linkMap = getCurrentLinkMap();

    if (_dbId < -1 && isLinkMapValid(linkMap) && linkMap[_dbId]) {
      return 'pointer';
    }

    return null;
  };
}

var namespace = AutodeskNamespace('Autodesk.AEC');
namespace.HyperlinkTracker = HyperlinkTracker;

/***/ }),

/***/ "./extensions/AEC/levels/FloorSelector.js":
/*!************************************************!*\
  !*** ./extensions/AEC/levels/FloorSelector.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FloorSelector; });
/* harmony import */ var _FloorSelectorFilter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FloorSelectorFilter.js */ "./extensions/AEC/levels/FloorSelectorFilter.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;
var namespace = AutodeskNamespace('Autodesk.AEC');


// FloorSelector provides graphics effects to be used by UI for floor selection.
//
// This includes:
//
//  - Setting cutplanes accordingly when a floor is selected.
//
//  - Animated transitions if the selected floor changes.
//
//  - Applying mouse-over highlighting of floors - to be used when hovering over a floor button
//
//  - "Ghost-Floors": By default, we render selected floors only. If the mouse enters the floor panel, we
//     also fade-in the other floors, but with strongly reduced opacity. (+ fade-out on mouse leave)
//
//
// How to use it:
//
//  1. Create a FloorSelector by passing the viewer to the ctor.
//
//  2. Before using the FloorSelector, you have to provide floor data that you get from the Revit metadata
//     json file. (see setFloorData comment)
//
//  3. Connect events for hovering over floor selector UI panel:
//     - Connect mouseover  to floorSelector.enterHoverMode()
//     - Connect mouseleave to floorSelector.existHoverMode()
//
//  4. Connect events for hovering over floor selection buttons: For each floor button...
//     - Connect mouseover  to floorSelector.rollOverFloor(floorIndex) - floorIndex must be the index into the floor array (see setFloorData)
//     - Connect mouseleave to floorSelector.rollOverFloor()
//
//  5. Connect floor selection button: For each floor button,
//     connect button mousedown to floorSelector.selectFloor(floorIndex, true)
//
//  6. If the set of visible models has changed
//
//  7. When discarding the FloorSelector (while keeping the Viewer alive), call FloorSelector dtor.
//
// How to enable the optional filtering of objects by dbIds per model provided by the AECModelData.json on level selection?
//
//  1. You have to provide floor filter data containing a Map of dbIds per model. The key has to be the model version URN (see setFloorFilterData).
//
//     Example on how to set the floor filter data:
//
//     const modelsDbIds = new Map();
//     modelsDbIds.set(model, [1, 2, 3, 4]);
//     var floorFilterData = {
//         modelsDbIds: modelsDbIds
//     };
//
//     floorSelector.setFloorFilterData(floorFilterData);
//
// How to control the calculated lower level boundary value by defining the levelHeightFactor factor? The factor is multiplied with the level height
// and added to the level minZ value. This newly calculated minZ value defines the lower level boundary used to filter the Floor and Ceiling elements.
//
//     Example on how to set the floor filter data with a levelHeightFactor:
//
//     const modelsDbIds = new Map();
//     modelsDbIds.set(model, [1, 2, 3, 4]);
//     var floorFilterData = {
//         modelsDbIds: modelsDbIds,
//         levelHeightFactor: 0.6 // Allowed values have to be within 0-1.
//     };
//
//     floorSelector.setFloorFilterData(floorFilterData);
//
// Technical requirements/restrictions to be aware of:
//
//  - Cross-Fading Support: FloorSelector uses LMV render target fading for some effects. For this, it activates
//    cross-fading support in LMV (if not active already). This requires 2 extra color targets, i.e.
//    consumes some additional GPU-side memory.
//
//  - Camera Movement: The camera should not be moving while using the floor selector.
//    This is because we partially use static images for the fading effects.
//    If the user moves the camera, we instantly switch off the ghost floors.
//
//  - SAO opacity: FloorSelector needs to temporarily hide SAO. For this, we have to overwrite SAO opacity
//    and recover it later. This requires that the SAO opacity is not changed in the meantime
//    while using the FloorSelector. Otherwise, it will cause a warning and may cause visual
//    artifacts.



// Time in seconds to fade in/out ghosted floors when hovering over the floor selector panel
var GhostFloorFadingTime = 0.5;

// Opacity for ghost floors when fade-in is finished.
var MaxGhostFloorOpacity = 0.2;

// These should actually be infinity and -infinity, but since the values are passed to a shader,
// we have to use large finite values instead. Setting as cutplane elevations actually corresponds to
// switching cutplanes off. But, changes the number of cutplanes triggers expesnive shader recompiles.
var MaxZLimit = 1e20;
var MinZLimit = -MaxZLimit;

// Internally used enum values for state management
var FloorRenderMode = {

  // mouse is hovering over a floor button
  Hovering: 0,

  // new floor has been selected and anim is running
  Transition: 1,

  // default rendering
  Off: 2 };


// Reserved floor-index constant to select all floors at once.
var AllFloors = -1;
var NoFloor = undefined;

// Used for setCutPlane calls to lmv. This ensures that FloorSelector controls its own cutplanes,
// which is independent of other cutplane changes like from SectionTool.
var CutPlaneSetName = 'Autodesk.AEC.FloorSelector';var

FloorSelector = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  function FloorSelector(viewer) {_classCallCheck(this, FloorSelector);

    av.EventDispatcher.prototype.apply(this);

    this._viewer = viewer;
    this._renderer = viewer.impl.renderer();

    // Make sure that ghost-floors are switched off as soon as the user starts navigating.
    // This is needed because the selected floor is just a static image when ghost-floors are shown.
    this._cameraMovedCB = this._interruptFading.bind(this);
    viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this._cameraMovedCB);

    // Stop panel-hover effect on viewer-resize: Ghost-floors use a static image overlay that becomes unusable
    // if the target size changes.
    this._viewerResizeCB = this._onViewerResized.bind(this);
    viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this._viewerResizeCB);

    // If SAO is switched off, we have to switch off roll-over highlighting too.
    this._renderOptionsChangedCB = this._onRenderOptionsChanged.bind(this);
    viewer.addEventListener(av.RENDER_OPTION_CHANGED_EVENT, this._renderOptionsChangedCB);

    // callback for the floor selection filtering
    this._floorSelectionFilterToBeUpdated = this._runFloorSelectorFilterEventHandler.bind(this);
    viewer.addEventListener(av.MODEL_ADDED_EVENT, this._floorSelectionFilterToBeUpdated);
    viewer.addEventListener(av.OBJECT_TREE_CREATED_EVENT, this._floorSelectionFilterToBeUpdated);

    // callback for the unloading of disabled models
    this._modelUnloadingCB = this._runModelUnloadingEventHandler.bind(this);
    viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this._modelUnloadingCB);

    // {Object[]} Contains the floor data. see setFloorData() comment.
    this._floors = [];

    // current state (hover/transition/off)
    this._currentMode = FloorRenderMode.Off;
    this._hovering = false; // used to track hovering state while in transition mode

    // current floor section (if cutplanes are active)
    this._floorSectionMin = undefined;
    this._floorSectionMax = undefined;

    // Determine z-range for "all-floors"
    // We determine that dynamically from the currently visible models.
    // Note that we need this value also for cutplane transitions - so we cannot
    // simply choose something arbitrarily far outside.
    this._zMinAllModels = undefined;
    this._zMaxAllModels = undefined;

    // {AnimControl} Needed to interrupt a running cutplane animation (see moveFloors)
    this._floorAnim = null;

    // {AnimControl} Needed to interrupt a runnign fade-in/out anim for ghost-floors
    this._fadeAnim = null;

    // Opacity of the render target that shows floors that are currently not selected ("ghost floors")
    // Always 0.0 if the extra target for ghost floors is not used.
    this._ghostFloorOpacity = 0.0;

    // {number|undefined} index of selected floor (or undefined if no floor is selected)
    this._currentFloor = undefined;

    // We render ghost-floors without AO, because AO cannot be smoothly faded out with them.
    // To activate AO, we need to 'backup' the current AO opacity and recover it later.
    this._aoVisible = true;
    this._aoOpacity = undefined; // if ao is blocked, we store the original ao opacity here to recover it later.

    this._floorSelectorFilter = new _FloorSelectorFilter_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._viewer);
    this._floorFilterData = undefined;

    // Indicates if we are currently using mouse-over highlighting for a floor.
    this._floorRollOverActive = false;

    // Whether to use the ghosting effect
    this._fadeEnabled = true;

    // If disabled, make sure that cutplanes keep unset. This is needed to avoid side-effects on 2D views.
    this.enabled = true;

    // Maximum time in ms that we allow for rendering offline images for fading effects.
    // By default (undefined), we use the frameBudget of regular rendering.
    this.offscreenRenderBudget = undefined;

    this.fadingTime = GhostFloorFadingTime;
  }_createClass(FloorSelector, [{ key: "dtor", value: function dtor()

    {
      if (this._viewer) {
        this._viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this._cameraMovedCB);
        this._viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this._viewerResizeCB);
        this._viewer.removeEventListener(av.RENDER_OPTION_CHANGED_EVENT, this._renderOptionsChangedCB);
        this._viewer.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, this._floorSelectionFilterToBeUpdated);
        this._viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._floorSelectionFilterToBeUpdated);
        this._viewer.removeEventListener(av.MODEL_UNLOADED_EVENT, this._modelUnloadingCB);
        this._viewer = null;
      }
    }

    // -----------------
    // --- Main API ----
    // -----------------

    // Before selecting any floors, setFloorData() must be called to provide the elevation ranges
    // of all available floors.
    //  @param {Object[]} floors - data about available floors, each item f must contain two finite floats f.zMin < f.zMax
  }, { key: "resetState",











    // sets back level isolation, selection filter and the floors.
    value: function resetState() {
      // we have to clear the settings
      this._floors = [];
      this._selectFloor(NoFloor);
      this._clearFloorSection();
      this._floorSelectorFilter.clearFilter();
    }

    // Before any objects can be filtered using the FloorSelectorFilter, setFloorFilterData() must be called to
    // provide the array of Floor and Ceiling dbIds per model.
    //  @param {Object[]} floorFilterData - A floor filter data object containing an array of dbIds per model.
  }, { key: "enterHoverMode",







    // Fades in the ghost-floors.
    // Triggered when floor selection begins, i.e., mouse is entering floor selector panel.
    value: function enterHoverMode() {

      // make sure that the ghosted floors are in a static image,
      // so that we can move the solid floor
      if (this._currentMode !== FloorRenderMode.Transition) {
        this._setMode(FloorRenderMode.Hovering);
      }

      // track hovering state - so that we can recover it after transitions
      this._hovering = true;
    }

    // Fades out the ghost floors.
    // Triggered when floor selection ends, i.e., mouse is leaving the floor selector panel.
    // @param {boolean} [force] - will exit ghosting immediately even if during transition
  }, { key: "exitHoverMode", value: function exitHoverMode(force) {

      // If a floor-transition is running, we only track the hover state and
      // set the mode when the transition has finished.
      if (this._currentMode !== FloorRenderMode.Transition || force) {
        this._setMode(FloorRenderMode.Off);
      }
      this._hovering = false;

      // make sure that no spatial filter for mouse-over highlight is set anymore, so that we don't
      // have side-effects on subsequent object selection.
      this._setSpatialFilterForRollOver();
    } }, { key: "setPanelHoverEffectEnabled", value: function setPanelHoverEffectEnabled(

    enabled) {
      this.exitHoverMode(true);
      this._skipFadeAnimations();
      this._fadeEnabled = enabled;
    } }, { key: "_getFadeExtension", value: function _getFadeExtension()

    {
      return this._fadeEnabled && this._viewer.getExtension('Autodesk.CrossFadeEffects');
    }

    // Ghosted display of inactive floors on panel hover is only supported if CrossFadeEffects extension is loaded
  }, { key: "_ghostFloorsEnabled", value: function _ghostFloorsEnabled() {
      return Boolean(this._getFadeExtension());
    }

    // Select for which floor rollOver highlighting is shown.
    //   @param {number} [floorIndex] must be either
    //                                a) a valid index into this.floors
    //                                b) a reserved constant (FloorSelector.AllFloors or FloorSelector.NoFloor)
  }, { key: "rollOverFloor", value: function rollOverFloor(floorIndex) {

      // If we don't show ghost-floors, roll-over highlighting does not make much sense if only 1 floor is visible anyway.
      // It just looks confusing, because occasionally it would only be visible for the selected floor and some parts of others
      // that overlap the z-range a bit.
      var enabled = this._ghostFloorsEnabled() || this._currentFloor === NoFloor;

      // rollOver highlight is only possible if SAO is enabled and supported.
      var supported = this._renderer.spatialFilterForRollOverSupported();
      if (floorIndex === undefined || !supported || !enabled) {

        // switch off floor highlight
        this._setSpatialFilterForRollOver();
        this._renderer.rolloverObjectId(0);
        return;
      }

      // Activate roll-over highlighting for all objects
      this._renderer.rolloverObjectId(1);

      // restrict highlighting to floor range unless all floors are selected.
      this._setSpatialFilterForRollOver(floorIndex);

      // TODO: Clarify why this call is needed. It should actually not required to re-render here.
      this._viewer.impl.invalidate(false, true, true);
    }

    // Sets the currently visible floor.
    //  @param {number}   [floorIndex]    A valid index into the floor data array (see setFloors) selects a single floor.
    //                                    FloorSelector.NoFloor discards the floor selection => all floors visible.
    //  @param {bool}     [useTransition] If true, a short animation is used to morph between previous and new floor
    //  returns false in case no selection cannot be performed
  }, { key: "selectFloor", value: function selectFloor(floorIndex, useTransition) {

      if (!this.floorSelectionValid(floorIndex)) {
        return;
      }

      if (useTransition) {
        this._moveToFloor(floorIndex);
      } else {
        this._selectFloor(floorIndex);
      }

      this._runFloorSelectorFilter();

      // If no ghosting is used, we disable rollOver highlighting if only a single floor is visible.
      if (!this._ghostFloorsEnabled()) {
        this.rollOverFloor();
      }

      this.fireEvent({ type: FloorSelector.SELECTED_FLOOR_CHANGED, levelIndex: floorIndex });
    }

    // Gets the index of the current selected floor or FloorSelector.NoFloor
  }, { key: "floorSelectionValid",



    // Returns whether a floorSelection can be performed with the specified floor
    // checks for valid value, whether floorData is available, the floor is already selected
    // and whether the floor is within the expected range.
    value: function floorSelectionValid() {var newFloor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NoFloor;
      // force boolean
      return !!((Number.isInteger(newFloor) || newFloor === NoFloor) && // not a valid value
      this.floorData && this.floorData.length !== 0 // has no floor data
      && this.currentFloor !== newFloor // newFloor floor is not selected
      && (newFloor === NoFloor ||
      newFloor >= 0 || this.floorData.length > newFloor)); // new floor is in range;
    }

    // returns true if a dbId is either hidden by FloorSelectorFilter or fully outside the cutplanes
  }, { key: "isVisible", value: function isVisible(model, dbId) {

      // reused tmp variable
      if (!this._tmpNodeBox) {
        this._tmpNodeBox = new Float32Array(6);
      }

      // Determine zMin/zMax to ceck against. We could use _floorSectionMin/Max. But this would
      // make this function depending on current animation state. Since we don't want to do permanent
      // filter-updates during animations, we use currentFloor instead, which represents the target state - independent of animations.
      var floor = this._floors[this._currentFloor];
      if (floor === NoFloor) {
        // No floor selected => Nothing hidden
        return true;
      }

      var instanceTree = model.getInstanceTree();
      if (!instanceTree) {
        // If there is not instance tree, FloorSelectorFilter would have warned already if a floor was selected.
        return true;
      }

      // get zMin/zMax for this node
      var nodeBox = this._tmpNodeBox;
      instanceTree.getNodeBox(dbId, nodeBox);
      var nodeBoxZMin = nodeBox[2];
      var nodeBoxZMax = nodeBox[5];

      // Node is hidden if...
      //  a) outside the level's cutplanes, or
      //  b) hidden by levels filter
      var outsideCutplane = nodeBoxZMin > floor.zMax || nodeBoxZMax < floor.zMin;
      return !outsideCutplane && this._floorSelectorFilter.isVisible(model, dbId);
    } }, { key: "setEnabled", value: function setEnabled(

    enabled) {
      this.enabled = enabled;
      this._applySelectedFloorSection();
    }

    // ------------------------
    // --- Internal methods ---
    // ------------------------
  }, { key: "_stopFloorAnim", value: function _stopFloorAnim()
    {
      if (this._floorAnim) {
        this._floorAnim.stop();
        this._floorAnim = null;
      }
    } }, { key: "_stopFadeAnim", value: function _stopFadeAnim()

    {
      if (this._fadeAnim) {
        this._fadeAnim.stop();
        this._fadeAnim = null;
      }
    } }, { key: "_skipFadeAnimations", value: function _skipFadeAnimations()

    {
      if (this._fadeAnim) {
        this._fadeAnim.skip();
        this._fadeAnim = null;
      }

      if (this._floorAnim) {
        this._floorAnim.skip();
        this._floorAnim = null;
      }
    } }, { key: "_leaveHoverMode", value: function _leaveHoverMode()

    {

      var fadeExt = this._getFadeExtension();
      if (!fadeExt) {
        // Nothing todo if ghosting effect is not used.
        return;
      }

      // release any baked images
      fadeExt.releaseFadingImage(0);
      fadeExt.releaseFadingImage(1);

      // make sure that model is rendered into default color target
      fadeExt.setModelTargetIndexForAll(undefined);

      // apply cutplanes according to currently selected floor
      this._applySelectedFloorSection();

      // we are now rendering real floors again,
      // so that we can switch SAO on again.
      this._setAOVisible(true);
    }

    // When rendering ghost-floors, the static part is always a static image.
    // Therefore, we have to skip the fading if the user moves the camera.
  }, { key: "_interruptFading", value: function _interruptFading() {

      // If we just left hover-mode, but the floors did not finish to fade out yet,
      // stop the anim and finish it immediately.
      if (!this._hovering && this._fadeAnim && this._fadeAnim.isRunning) {
        this._stopFadeAnim();
        this._leaveHoverMode();
      }
    } }, { key: "_onViewerResized", value: function _onViewerResized()

    {
      this.forceImageRefresh();
    } }, { key: "forceImageRefresh", value: function forceImageRefresh()

    {
      // Stop any image-based hovering effects immediately, because the baked ghost-floor image has incorrect size now.
      var isHovering = this._hovering;

      this.exitHoverMode();
      this._skipFadeAnimations();

      // Restart hovering effect if mouse is still on the panel. Now using the new render target size.
      if (isHovering) {
        this.enterHoverMode();
        this._skipFadeAnimations();
      }
    } }, { key: "_onRenderOptionsChanged", value: function _onRenderOptionsChanged()

    {
      // Make sure that we stop using roll-over-floor highlight if the depth
      // target is not available anymore.
      if (this._floorRollOverActive && !this._renderer.spatialFilterForRollOverSupported()) {
        this.rollOverFloor();
      }
    }

    // Get array of all visible models
  }, { key: "_getVisibleModels", value: function _getVisibleModels() {
      var mq = this._viewer.impl.modelQueue();
      return mq.getModels();
    }

    // Updates min/max limits for cutplane z-level, based on the bboxes of all visible models
  }, { key: "_updateZLimits", value: function _updateZLimits() {
      var models = this._getVisibleModels();

      this._zMinAllModels = MaxZLimit;
      this._zMaxAllModels = MinZLimit;
      for (var i = 0; i < models.length; i++) {
        var model = models[i];
        var box = model.getBoundingBox();

        this._zMinAllModels = Math.min(box.min.z, this._zMinAllModels);
        this._zMaxAllModels = Math.max(box.max.z, this._zMaxAllModels);
      }

      // make sure the range is valid also when no models are available
      if (this._zMinAllModels > this._zMaxAllModels) {
        this._zMinAllModels = MinZLimit;
        this._zMaxAllModels = MaxZLimit;
      }
    } }, { key: "_setAOVisible", value: function _setAOVisible(

    visible) {
      if (visible === this._aoVisible) {
        return;
      }
      this._aoVisible = visible;

      var blendPass = this._renderer.getBlendPass();

      var newOpacity = 0.0;
      if (!visible) {
        // ao switched off => backup original ao opacity
        this._aoOpacity = blendPass.uniforms['aoOpacity'].value;
      } else {

        // Opacity should be 0. Any other value indicates that it has been changed from
        // outside while ao was hidden by floor selector.
        var curOpacity = blendPass.uniforms['aoOpacity'].value;
        if (curOpacity !== 0.0) {
          console.warn('ao opacity should not be changed while FloorSelector is in use.');
        }

        // ao switched on => recover original ao opacity
        newOpacity = this._aoOpacity;
      }

      this._renderer.setAOOptions(this._renderer.getAORadius(), this._renderer.getAOIntensity(), newOpacity);
    }

    // @param {number} val - float in [0,1]
  }, { key: "_setGhostFloorOpactiy", value: function _setGhostFloorOpactiy(val) {

      // ghost-floors are always rendered into extra target 1
      var fadeExt = this._getFadeExtension();
      fadeExt && fadeExt.setCrossFadeOpacity(1, val);

      this._ghostFloorOpacity = val;

    }

    // Apply/Remove spatial filter that restricts rollOver highlighting to a single floor
    //  @param {number} If floorIndex is a valid index into this.floors, highlighting is restricted to that floor.
    //                  Otherwise, the spatial filter is switched off.
  }, { key: "_setSpatialFilterForRollOver", value: function _setSpatialFilterForRollOver(floorIndex) {

      var filter = undefined;
      var floor = this._floors[floorIndex];

      var createSpatialFilter = function createSpatialFilter(zMin, zMax) {
        // Define filter to restrict rollOver highlighting to floor elevation range
        return 'bool spatialFilter(vec3 worldPos) { return (worldPos.z >= float(' + zMin + ') && worldPos.z <= float(' + zMax + ')); }';
      };

      if (floor) {
        filter = createSpatialFilter(floor.zMin, floor.zMax);
      } else if (floorIndex === FloorSelector.AllFloors) {
        filter = createSpatialFilter(this._zMinAllModels, this._zMaxAllModels);
      }

      this._renderer.setSpatialFilterForRollOver(filter);

      // If spatial filter is defined, make sure that ghost floors are always rendered to depth target.
      // Otherwise, the spatial filter for roll-over highlighting does not work.
      var fadeExt = this._getFadeExtension();
      fadeExt && fadeExt.crossFade.setSaoHeuristicEnabled(!filter);

      this._floorRollOverActive = !!filter;
    } }, { key: "_applyFloorSection", value: function _applyFloorSection(

    zMin, zMax) {

      // Do not allow any cutplane when disabled
      if (!this.enabled) {
        this._viewer.impl.setCutPlaneSet(CutPlaneSetName, null);
        return;
      }

      // reset the defined z values to the minimum in case the value is not specified
      if (!Number.isFinite(zMin)) {
        zMin = MinZLimit;
      }
      if (!Number.isFinite(zMax)) {
        zMax = MaxZLimit;
      }


      var planes = [new THREE.Vector4(0, 0, -1, zMin), new THREE.Vector4(0, 0, 1, -zMax)];
      this._viewer.impl.setCutPlaneSet(CutPlaneSetName, planes);
    }

    // Set cut plane according to currently selected floor
  }, { key: "_applySelectedFloorSection", value: function _applySelectedFloorSection() {

      // If no floor section is active, set cutplanes to maximum range.
      // Doing this instead of clearing them avoids the repeated shader recompile
      var zMin = this._floorSectionMin !== undefined ? this._floorSectionMin : MinZLimit;
      var zMax = this._floorSectionMax !== undefined ? this._floorSectionMax : MaxZLimit;
      this._applyFloorSection(zMin, zMax);
    } }, { key: "_setFloorSection", value: function _setFloorSection(

    minElev, maxElev) {
      this._floorSectionMin = isNaN(minElev) ? undefined : minElev;
      this._floorSectionMax = isNaN(maxElev) ? undefined : maxElev;
      this._applySelectedFloorSection();
    }

    // Temporarily disable floor section cut planes. This is needed to render ghost floors.
  }, { key: "_clearFloorSection", value: function _clearFloorSection() {
      // Changing the number of cutplanes would cause a shader recompile.
      // To avoid that, we set dummy cutplanes instead.
      this._updateZLimits();
      this._applyFloorSection();
    } }, { key: "_setMode", value: function _setMode(

    mode) {var _this = this;

      if (mode === this._currentMode) {
        return;
      }
      this._currentMode = mode;

      if (mode === FloorRenderMode.Hovering) {

        var fadeExt = this._getFadeExtension();
        if (fadeExt) {

          // Take control over CrossFade effect.
          // NOTE: As long as the mouse is hovering over the LevelsPanel, we assume that no one else overtakes the crossFade effect. If the mouse leaves the LevelsPanel
          //       the ghost-floors a fading out. If the fading is needed for something else at that time, we skip the fading and drop the ghost floors immediately.
          fadeExt.acquireControl('FloorSelector', function () {return _this._interruptFading();});

          // Render snapshot of selected floors into target 0
          fadeExt.setModelTargetIndexForAll(undefined); // render to main target
          this._applySelectedFloorSection(); // set cutplanes according to selected floor
          this._renderer.rolloverObjectId(0); // keep mouse-over highlighting out of the snapshot
          this._setAOVisible(true); // Make sure that the selected floors are rendered with AO
          fadeExt.renderFadingImage(0, this.offscreenRenderBudget); // render static snapshot of selected floors into extra target 0

          // show this snapshot at full opacity
          fadeExt.setCrossFadeOpacity(0, 1.0);

          // Render remaining floors...
          this._clearFloorSection();

          // ..into target 1
          fadeExt.setModelTargetIndexForAll(1);

          // before starting to fade-in the ghost-floors,
          // hide SAO. Otherwise, SAO of the ghost
          // floors would pop in at fade start.
          this._setAOVisible(false);

          // stop any prior fade-anim
          this._stopFadeAnim();

          // fade-in ghost floors (starting at the prior opacity)
          var onTimer = this._setGhostFloorOpactiy.bind(this);
          this._fadeAnim = avp.fadeValue(this._ghostFloorOpacity, MaxGhostFloorOpacity, this.fadingTime, onTimer);
        }
      } else if (mode === FloorRenderMode.Transition) {

        // protect ghost floors from clear
        var _fadeExt = this._getFadeExtension();
        if (_fadeExt) {
          _fadeExt.setClearEnabled(1, false);

          // render into target 0 again
          _fadeExt.setClearEnabled(0, true);
          _fadeExt.setModelTargetIndexForAll(0);

          // make sure that target 0 has full opacity to make sure that floor keeps visible after moving to target 0
          _fadeExt.setCrossFadeOpacity(0, 1.0);
        }

        // reactivate AO
        this._setAOVisible(true);

        // Render selected/moving floor...
        this._applySelectedFloorSection();

      } else if (mode === FloorRenderMode.Off) {

        // stop any prior fade-anim
        this._stopFadeAnim();

        // fade-out ghost floors (starting at current opacity)
        var _onTimer = this._setGhostFloorOpactiy.bind(this);
        var onFinished = this._leaveHoverMode.bind(this);
        this._fadeAnim = avp.fadeValue(this._ghostFloorOpacity, 0.0, this.fadingTime, _onTimer, onFinished);
      }
    } }, { key: "_moveToFloor", value: function _moveToFloor(

    floorIndex) {var _this2 = this;

      this._currentFloor = floorIndex;

      this._setMode(FloorRenderMode.Transition);

      var floor = this._floors[floorIndex];

      this._updateZLimits();

      var minElevStart = this._floorSectionMin === undefined ? this._zMinAllModels : this._floorSectionMin;
      var maxElevStart = this._floorSectionMax === undefined ? this._zMaxAllModels : this._floorSectionMax;
      var minElevEnd = floor ? floor.zMin : this._zMinAllModels;
      var maxElevEnd = floor ? floor.zMax : this._zMaxAllModels;

      var updateCutPlanes = function updateCutPlanes(unitTime) {
        var t = avp.smootherStep(unitTime);
        var minElev = avp.lerp(minElevStart, minElevEnd, t);
        var maxElev = avp.lerp(maxElevStart, maxElevEnd, t);

        _this2._setFloorSection(minElev, maxElev);

        // fade-out mouse over while animating
        var blendPass = _this2._renderer.getBlendPass();
        var uniform = blendPass.uniforms['highlightIntensity'];
        uniform.value = Math.min(uniform.value, 1.0 - t);
      };

      var onAnimEnd = function onAnimEnd() {
        // leave transition mode to hovering or off
        var mode = _this2._hovering ? FloorRenderMode.Hovering : FloorRenderMode.Off;
        _this2._setMode(mode);
      };

      // If another floor anim is in running, stop it first.
      this._stopFloorAnim();

      this._floorAnim = avp.fadeValue(0.0, 1.0, this.fadingTime, updateCutPlanes, onAnimEnd);
    } }, { key: "_selectFloor", value: function _selectFloor(

    floorIndex) {

      // Make sure that a previous anim does not overwrite the cutplanes again.
      this._stopFloorAnim();

      this._currentFloor = floorIndex;

      // Note that zMin/zMax may also be undefined if no floor is selected
      var floor = this._floors[floorIndex];

      // Set min/maxElev from floor or set both to undefined (for 'no floor selected')
      var minElev = floor ? floor.zMin : undefined;
      var maxElev = floor ? floor.zMax : undefined;

      this._setFloorSection(minElev, maxElev);
    } }, { key: "_runFloorSelectorFilter", value: function _runFloorSelectorFilter()

    {
      // Make sure all previously hidden objects are set to visible again.
      this._floorSelectorFilter.clearFilter();

      if (this._floorFilterData && this._currentFloor !== undefined) {
        var floor = this._floors[this._currentFloor];
        this._floorSelectorFilter.filter(this._floorFilterData, floor);
      }
    } }, { key: "_runFloorSelectorFilterEventHandler", value: function _runFloorSelectorFilterEventHandler(

    event) {
      var model = event.model;

      if (!model.isObjectTreeLoaded()) {
        return;
      }
      if (!(this._floorFilterData && this._currentFloor !== undefined)) {
        // Handles the case when a level was deactivated while the model was not visible.
        // When activating again the model, we need to make sure that the previously
        // filtered elements are set to visible again.
        this._floorSelectorFilter.clearFilter();
        return;
      }
      this._runFloorSelectorFilter();
    } }, { key: "_runModelUnloadingEventHandler", value: function _runModelUnloadingEventHandler(

    event) {
      if (this._floorFilterData && this._currentFloor !== undefined) {
        this._floorSelectorFilter.unhideModel(event.model);
      }
    }

    // Used in order to re-render a floor section.
  }, { key: "invalidateFloorSelection", value: function invalidateFloorSelection(floorIndex) {
      // Reselect current floor.
      this._selectFloor(floorIndex);
      // This is needed in order to filter unwanted planes from the cut area.
      this._runFloorSelectorFilter();
    } }, { key: "floorData", get: function get() {return this._floors;}, set: function set(floors) {// always reset the floor selector when floors data changes to avoid inconstancy
      this.resetState();this._floors = Array.isArray(floors) ? floors : [];this.fireEvent({ type: FloorSelector.FLOOR_DATA_CHANGED, floorData: this._floors });} }, { key: "floorFilterData", get: function get() {return this._floorFilterData;}, set: function set(floorFilterData) {this._floorFilterData = floorFilterData;} }, { key: "currentFloor", get: function get() {return this._currentFloor;} }]);return FloorSelector;}();


FloorSelector.AllFloors = AllFloors;
FloorSelector.NoFloor = NoFloor;

FloorSelector.SELECTED_FLOOR_CHANGED = "selectedFloorChanged";
FloorSelector.FLOOR_DATA_CHANGED = "floorDataChanged";

namespace.FloorSelector = FloorSelector;

/***/ }),

/***/ "./extensions/AEC/levels/FloorSelectorFilter.js":
/*!******************************************************!*\
  !*** ./extensions/AEC/levels/FloorSelectorFilter.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FloorSelectorFilter; });
function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var namespace = AutodeskNamespace('Autodesk.AEC');

// The FloorSelectorFilter provides functionality to additionally apply object filtering
// by dbIds on level selection.
//
var
FloorSelectorFilter = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  function FloorSelectorFilter(viewer) {_classCallCheck(this, FloorSelectorFilter);
    this._viewer = viewer;
    // Contains all dbIds per model used to un-hide the objects whenever another level gets selected.
    this._dbIdsToUnhide = new Map();
    this._cache = {};
  }

  // Filter all elements by dbIds on level selection.
  //  @param {Object}   floorFilterData   - A floor filter data object containing all dbIds per model and an optional level height factor.
  //  @param {Object}   floor             - A floor.
  _createClass(FloorSelectorFilter, [{ key: "filter", value: function filter(floorFilterData, floor) {var _this = this;
      if (!floorFilterData) {
        throw new Error('floorFilterData cannot be undefined.');
      }
      if (!(floorFilterData.modelsDbIds instanceof Map)) {
        throw new Error('floorFilterData.modelsDbIds has to be a Map.');
      }
      if (!floor) {
        throw new Error('floor cannot be undefined.');
      }

      // Get the level height factor and also do some basic number checks.
      var levelHeightFactor = this._getLevelHeightFactor(floorFilterData.levelHeightFactor);

      // All Floor and Ceiling db ids per model to hide.
      var modelsDbIds = floorFilterData.modelsDbIds;

      // Do nothing in case no db ids are set.
      if (!this._hasModelDbIds(modelsDbIds)) {
        return;
      }

      var minZ = floor.zMin;
      var maxZ = floor.zMax;

      // Calculate the new minZ/maxZ values of the level boundary used to spatially filter the Floor and
      // Ceiling elements.
      // 1. The lower boundary value (zMin) is moved up by the factor of the level height, because the Ceiling
      //    elements we want to filter are located in the upper part of the level.
      // 2. The upper boundary value (zMax) is moved up by 10% of the level height, because in some models
      //    this helps to also remove floors which would be still shown otherwise.
      var newMinZ = minZ + (maxZ - minZ) * levelHeightFactor;
      var newMaxZ = maxZ + (maxZ - minZ) * 0.1;

      // Setup cache for each floor.
      if (!this._cache[floor.name]) {
        this._cache[floor.name] = {};
      }

      var modelQueue = this._viewer.impl.modelQueue();
      var models = modelQueue.getModels();var _loop2 = function _loop2(

      m, l) {
        var model = models[m];

        if (!model.visibilityManager) {
          console.warn("The VisibilityManager of the model with ID = ".concat(model.id, " is not yet initialized."));
          return "break";
        }

        // Try to get the db ids for a specific level and model from the cache.
        if (_this._cache[floor.name][model.id]) {
          var cachedDbIds = _this._cache[floor.name][model.id];
          if (cachedDbIds.size > 0) {
            _this.hideDbIds(model, cachedDbIds);
          }
          return "continue";
        }

        var instanceTree = model.getInstanceTree();
        if (!instanceTree) {
          console.warn("The instanceTree of the model with ID = ".concat(model.id, " is not yet initialized."));
          return "continue";
        }

        var dbIdsToHide = new Set();
        var dbIds = modelsDbIds.get(model.id);
        if (!dbIds) {
          return "continue";
        }

        dbIds.forEach(function (dbId) {
          var nodeBox = new Float32Array(6);
          instanceTree.getNodeBox(dbId, nodeBox);

          var nodeBoxMinZ = nodeBox[2];
          var nodeBoxMaxZ = nodeBox[5];

          if (nodeBoxMinZ >= newMinZ && nodeBoxMinZ <= newMaxZ ||
          nodeBoxMaxZ >= newMinZ && nodeBoxMaxZ <= newMaxZ ||
          nodeBoxMinZ <= newMinZ && nodeBoxMaxZ >= newMaxZ) {
            dbIdsToHide.add(dbId);
          }
        });

        if (dbIdsToHide.size > 0) {
          _this.hideDbIds(model, dbIdsToHide);
        }

        _this._cache[floor.name][model.id] = dbIdsToHide;};_loop: for (var m = 0, l = models.length; m < l; m++) {var _ret = _loop2(m, l);switch (_ret) {case "break":break _loop;case "continue":continue;}
      }
    } }, { key: "hideDbIds", value: function hideDbIds(

    model, dbIds) {
      if (!model.visibilityManager) {
        return;
      }

      dbIds.forEach(function (id) {
        model.visibilityManager.setNodeOff(id, true);
      });

      // Collect all dbIds per model, so we can un-hide them later on again.
      if (this._dbIdsToUnhide.has(model)) {
        var _dbIds = this._dbIdsToUnhide.get(model);var _iterator = _createForOfIteratorHelper(
        _dbIds),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var dbId = _step.value;
            _dbIds.add(dbId);
          }} catch (err) {_iterator.e(err);} finally {_iterator.f();}
      } else {
        this._dbIdsToUnhide.set(model, dbIds);
      }
    }

    // Un-hides all objects (using the dbId) per model.
  }, { key: "clearFilter", value: function clearFilter() {
      if (this._dbIdsToUnhide.size === 0) {
        return;
      }

      this._dbIdsToUnhide.forEach(function (dbIds, model) {
        // Handles the case when the model is not visible and the level isolation is deactivated.
        if (!model.visibilityManager) {
          return;
        }

        dbIds.forEach(function (id) {
          model.visibilityManager.setNodeOff(id, false);
        });

        // Only remove the model dbIds if they are successfully set to visible.
        this._dbIdsToUnhide.delete(model);
      }.bind(this));
    }

    // Un-hides only one model. It's all we can do, as the model.visibilityManager is null,
    // that is we can not call setNodeOff function again
  }, { key: "unhideModel", value: function unhideModel(model) {
      this._dbIdsToUnhide.delete(model);
    } }, { key: "_hasModelDbIds", value: function _hasModelDbIds(

    modelsDbIds) {

      if (modelsDbIds.size === 0) {
        return false;
      }var _iterator2 = _createForOfIteratorHelper(

      modelsDbIds.values()),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var dbIds = _step2.value;
          if (dbIds && dbIds.length > 0) {
            return true;
          }
        }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}

      return false;
    } }, { key: "_getLevelHeightFactor", value: function _getLevelHeightFactor(

    levelHeightFactor) {
      if (levelHeightFactor === undefined) {
        // Return default factor.
        return 0.5;
      }

      if (typeof levelHeightFactor !== 'number') {
        throw new Error('floorFilterData.levelHeightFactor has to be a number');
      }
      if (levelHeightFactor < 0 || levelHeightFactor >= 1) {
        throw new Error('floorFilterData.levelHeightFactor has to be a number between 0-1.');
      }

      return levelHeightFactor;
    }

    // Hides all dbIds in a model that are currently expected to be hidden. 
  }, { key: "reApplyFilter", value: function reApplyFilter(model) {
      var dbIds = this._dbIdsToUnhide.get(model);
      var visMan = model.visibilityManager;
      if (!dbIds || !visMan) {
        return;
      }

      dbIds.forEach(function (id) {
        visMan.setNodeOff(id, true);
      });
    } }, { key: "isVisible", value: function isVisible(

    model, dbId) {
      var dbIds = this._dbIdsToUnhide.get(model);
      return !dbIds || !dbIds.has(dbId);
    } }]);return FloorSelectorFilter;}();


namespace.FloorSelectorFilter = FloorSelectorFilter;

/***/ }),

/***/ "./extensions/AEC/levels/Level.js":
/*!****************************************!*\
  !*** ./extensions/AEC/levels/Level.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Level; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}} // A single Level.
// Usually levels are being extracted from AecModelData - but can be generated from other sources (artificially created from viewports).
var Level =
function Level(index, guid, name, zMin, zMax) {_classCallCheck(this, Level);
  this.index = index;
  this.name = name;
  this.zMin = zMin;
  this.zMax = zMax;
  this.guid = guid;
};

/***/ }),

/***/ "./extensions/AEC/levels/LevelUtils.js":
/*!*********************************************!*\
  !*** ./extensions/AEC/levels/LevelUtils.js ***!
  \*********************************************/
/*! exports provided: transformLevelsByMatrix, transformLevels, zOffsetHack, aecModelDataToLevels, chooseMainModel, modelDataOccluders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformLevelsByMatrix", function() { return transformLevelsByMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformLevels", function() { return transformLevels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zOffsetHack", function() { return zOffsetHack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "aecModelDataToLevels", function() { return aecModelDataToLevels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chooseMainModel", function() { return chooseMainModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modelDataOccluders", function() { return modelDataOccluders; });
/* harmony import */ var _Level__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Level */ "./extensions/AEC/levels/Level.js");
/* harmony import */ var _common_AecModelData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/AecModelData */ "./extensions/AEC/common/AecModelData.js");



function getProjectElevation(level) {
  var ext = level.extension;

  if (ext && ext.hasOwnProperty('projectElevation'))
  return ext.projectElevation;

  return level.elevation;
}

function transformLevelsByMatrix(levels, refPointTransformation) {

  var v = new THREE.Vector3();
  var transformByMatrix = function transformByMatrix(value) {
    v.set(0, 0, value);
    v.applyMatrix4(refPointTransformation);
    return v.z;
  };

  levels.forEach(function (currentLevel) {
    currentLevel.zMin = transformByMatrix(currentLevel.zMin);
    currentLevel.zMax = transformByMatrix(currentLevel.zMax);
  });
}


// transform is given as 12 floats
function transformLevels(levels, refPointTransformation) {
  if (!refPointTransformation)
  return;

  // get transform as THREE.Matrix4
  var matrix = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(refPointTransformation);
  transformLevelsByMatrix(levels, matrix);
}

//Explanation from design-collaboration repo:
// Hint: the idea to move the level zMin value an inch down is to make sure that the
// end-user can also see the bottom floor. Otherwise in some cases the floor would just
// be cut-away by the floor selection. This value was defined after experimenting with
// several models and maybe needs adjustment in the future.
var zOffsetHack = 1 / 12;

function aecModelDataToLevels(aecModelData, placementTf, modelTransform) {
  // levels are sorted ascending

  // we have to handle the building story flag of a Revit level
  // filter out all Revit levels which do not have building story set to true
  var filteredLevels = aecModelData.levels.filter(function (l) {
    var ext = l.extension;

    if (!ext)
    return true;

    //So.... if it has no buildingStory property, it's a building story...
    if (!ext.hasOwnProperty('buildingStory'))
    return true;

    return ext.buildingStory;
  });

  var levels = [];

  var count = filteredLevels.length;
  filteredLevels.forEach(function (currentLevel, index) {

    var nextElevation = undefined;
    if (index + 1 < count) {
      nextElevation = getProjectElevation(filteredLevels[index + 1]);
    } else
    {
      // for the topmost floor, we must use its height to determine the next boundary
      var topLevel = filteredLevels[filteredLevels.length - 1];
      var topLevelElevation = getProjectElevation(topLevel);
      nextElevation = topLevelElevation + topLevel.height;
    }

    levels.push(
    new _Level__WEBPACK_IMPORTED_MODULE_0__["default"](
    levels.length,
    currentLevel.guid,
    currentLevel.name,
    getProjectElevation(currentLevel) - zOffsetHack, // zMin
    nextElevation // zMax
    ));

  });

  if (modelTransform) {
    transformLevelsByMatrix(levels, modelTransform);
  }

  // If the model is known, use its attached transform. This variant works with any loadOptions. 
  if (placementTf) {
    transformLevelsByMatrix(levels, placementTf);
  } else {
    // If the model is not known, we assume that no zOffset is applied. This is only
    // true when using applyRefPoint=true and a gobalOffset with z=0.
    transformLevels(levels, aecModelData.refPointTransformation);
  }

  return levels;
}

function chooseMainModel(viewer, ignoreAecModelData) {

  var models = viewer.impl.modelQueue().getModels();
  var mainModel = null;
  var mainModelSize = -1;
  models.forEach(function (model) {

    if (model.is2d())
    return;

    var bubbleNode = model.getDocumentNode();

    if (!bubbleNode)
    return;

    if (!ignoreAecModelData) {
      var aecModelData = bubbleNode.getAecModelData();

      if (!aecModelData)
      return;
    }

    if (bubbleNode.data.size > mainModelSize) {
      mainModel = model;
      mainModelSize = bubbleNode.data.size;
    } else if (!bubbleNode.data.size && mainModelSize === -1) {
      mainModel = model;
      mainModelSize = 0;
    }
  });
  return mainModel;
}

function modelDataOccluders(viewer) {

  var models = viewer.impl.modelQueue().getModels();

  var occludersPerModel = new Map();

  models.forEach(function (model) {

    if (model.is2d())
    return;

    var bubbleNode = model.getDocumentNode();
    if (!bubbleNode)
    return;
    var aecModelData = bubbleNode.getAecModelData();
    if (!aecModelData)
    return;

    occludersPerModel.set(model.id, aecModelData.levelOccluderIds);
  });

  return { modelsDbIds: occludersPerModel };
}

/***/ }),

/***/ "./extensions/AEC/levels/LevelsExtension.js":
/*!**************************************************!*\
  !*** ./extensions/AEC/levels/LevelsExtension.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LevelsExtension; });
/* harmony import */ var _FloorSelector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FloorSelector */ "./extensions/AEC/levels/FloorSelector.js");
/* harmony import */ var _LevelUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LevelUtils */ "./extensions/AEC/levels/LevelUtils.js");
/* harmony import */ var _ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/ListPanel */ "./extensions/AEC/ui/ListPanel.js");
/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var av = Autodesk.Viewing,avu = av.UI;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.LevelsExtension';






// Options:
//   @param {bool} [autoDetectAecModelData = true]
//         Level selection requires data about existing floors. By default (true), these are extracted automatically:
//          - For a single model, we get them by calling getAecModelData() on the document node.
//          - If multiple models with aecModelData are visible, we choose the largest one to define the levels.
//
//         If set to false, an application can (and has to) call setAecModelData() explicitly instead.
//  @param {bool} [ifcLevelsEnabled = false] - If enabled will try to extract levels for IFC models using heuristics.
var LevelsExtension = /*#__PURE__*/function (_av$Extension) {_inherits(LevelsExtension, _av$Extension);var _super = _createSuper(LevelsExtension);
  function LevelsExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, LevelsExtension);
    _this = _super.call(this, viewer, options);

    _this.container = _this.options.panelUIContainers && _this.options.panelUIContainers.levelsPanel;

    _this._onCameraMoved = _this._onCameraMoved.bind(_assertThisInitialized(_this));
    _this.onItemMouseEnter = _this.onItemMouseEnter.bind(_assertThisInitialized(_this));
    _this.onItemMouseLeave = _this.onItemMouseLeave.bind(_assertThisInitialized(_this));
    _this.onItemSelected = _this.onItemSelected.bind(_assertThisInitialized(_this));
    _this.updateFloorsData = _this.updateFloorsData.bind(_assertThisInitialized(_this));

    _this.doNotCreateUI = options.doNotCreateUI;
    _this._currentLevel = undefined;return _this;
  }_createClass(LevelsExtension, [{ key: "_onCameraMoved", value: function _onCameraMoved()

    {
      var currentLevel = this._mapCameraToLevel();

      if (!currentLevel)
      return;

      if (!this._currentLevel || currentLevel.guid !== this._currentLevel.guid) {
        this._currentLevel = currentLevel;
        this.viewer.dispatchEvent({ type: LevelsExtension.LEVEL_CHANGED, level: currentLevel });
      }
    } }, { key: "_mapCameraToLevel", value: function _mapCameraToLevel()

    {
      var floors = this.floorSelector.floorData;
      if (!floors.length) {
        return;
      }

      var currentElevation = this.viewer.impl.camera.position.z;

      if (currentElevation < floors[0].zMin) {
        return floors[0];
      } else
      if (currentElevation > floors[floors.length - 1].zMax) {
        return floors[floors.length - 1];
      } else
      {
        return floors.find(function (f) {return f.zMin <= currentElevation && f.zMax >= currentElevation;});
      }
    } }, { key: "onToolbarCreated", value: function onToolbarCreated()

    {

      if (this.container) {
        //Add our button to the toolbar if host app did not ask to render UI in some other place
        return;
      }

      // Add levelsButton to modelTools. 
      // We can safely assume toolbar to exis, because onToolbarCreated() is only called if 
      // 1. GuiViewer is used and 2. the toolbar is ready.
      var toolbar = this.viewer.getToolbar();
      var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);
      if (modelTools && this.levelsButton) {
        modelTools.addControl(this.levelsButton);
      }
    } }, { key: "onItemMouseEnter", value: function onItemMouseEnter(_ref)

    {var item = _ref.item;
      var levelIndex = item.index;

      // Selecting an already selected level again will unselect => i.e. all Floors will be shown.
      // Correspondingly, we trigger rollover highlighting for all floors when hovering over the selected level.
      if (levelIndex === this.floorSelector.currentFloor) {
        levelIndex = _FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].AllFloors;
      }

      this.floorSelector.rollOverFloor(levelIndex);
      this.hoveredFloor = levelIndex;
    } }, { key: "onItemMouseLeave", value: function onItemMouseLeave(_ref2)

    {var item = _ref2.item;
      if (this.hoveredFloor === item.index) {
        this.hoveredFloor = undefined;
        this.floorSelector.rollOverFloor(_FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].NoFloor);
      }
    } }, { key: "onItemSelected", value: function onItemSelected(_ref3)

    {var item = _ref3.item;
      // on item selected
      var levelIndex = item.index !== this.floorSelector.currentFloor ? item.index : undefined;
      this.floorSelector.selectFloor(levelIndex, true);
    } }, { key: "_createUI", value: function _createUI()

    {var _this2 = this;
      if (this.doNotCreateUI) return;

      this.levelsButton = new avu.Button("toolbar-levelsTool");
      this.levelsButton.setToolTip('Levels');
      this.levelsButton.icon.innerHTML = createLevelsIcon();

      var panelOptions = {
        enableCheckmark: true // show checkmark at the end of selected items
      };

      this.levelsPanel = new _ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanel"](this.container || this.viewer.container, 'LevelsPanel-' + this.viewer.id, 'Levels', panelOptions);
      this.levelsPanel.setGlobalManager(this.globalManager);

      if (!this.container) {
        // This ensures that the Panel keeps visible within the viewer canvas on resize.
        this.viewer.addPanel && this.viewer.addPanel(this.levelsPanel);
      }


      // Keep button-state consistent when pressing panel close
      this.levelsPanel.addVisibilityListener(function (visible) {
        _this2.levelsButton.setState(visible ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);
      });

      // allow client app to be notified on panel close
      this.levelsPanel.closer.addEventListener('click', function () {
        if (_this2.onPanelVisibilityToggled) {
          _this2.onPanelVisibilityToggled(false);
        }
      });

      this.levelsPanel.addEventListener(_ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanelEvents"].ITEM_MOUSE_ENTER, this.onItemMouseEnter);

      this.levelsPanel.addEventListener(_ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanelEvents"].ITEM_MOUSE_LEAVE, this.onItemMouseLeave);

      this.levelsPanel.addEventListener(_ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanelEvents"].ITEM_SELECT, this.onItemSelected);

      // Handle hovering over panel
      this.levelsPanel.container.addEventListener("mouseenter", function () {return _this2.floorSelector.enterHoverMode();});
      this.levelsPanel.container.addEventListener("mouseleave", function () {return _this2.floorSelector.exitHoverMode();});

      // Keep selected item in-sync with selected Floor
      this.floorSelector.addEventListener(
      _FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].SELECTED_FLOOR_CHANGED,
      function () {return _this2.levelsPanel.updateItemStates();});


      this.levelsPanel.setItemHandlers(
      function (item) {return item.index === _this2.floorSelector.currentFloor;},
      function (item) {return item.text;});


      // Connect levelsButton
      this.levelsButton.onClick = function () {
        var visible = !_this2.levelsPanel.isVisible();
        _this2.levelsPanel.setVisible(visible);

        // allow client app to be notified
        if (_this2.onPanelVisibilityToggled) {
          _this2.onPanelVisibilityToggled(visible);
        }
      };
    } }, { key: "setAecModelData", value: function setAecModelData(

    aecModelData, model, isDataInWorldCoords) {

      if (aecModelData !== this.aecModelData) {

        this.aecModelData = aecModelData;
        this.isDataInWorldCoords = isDataInWorldCoords;
        this.currentModel = model;

        this.updateFloorsData();

        var levels = this.floorSelector.floorData;
        var items = [];
        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          items.push({
            text: level.name,
            index: i });

        }

        // list items in reverse order, because aecModelData levels are sorted by increasing z
        items.reverse();
        if (this.levelsPanel) {
          this.levelsPanel.setItems(items);
        }

        this._updateOccluderData();
      }
    } }, { key: "updateFloorsData", value: function updateFloorsData()

    {
      // Backup currentFloor before changing floorData inner values.
      // It's important to backup it here, because whenever we set floorData, it immediately calls `resetState`.
      var currentFloor = this.floorSelector.currentFloor;

      if (this.aecModelData) {
        // If data is already in world coordinates, just use it as is.
        if (this.isDataInWorldCoords) {
          this.floorSelector.floorData = this.aecModelData;
        } else {var _this$currentModel, _this$currentModel2;
          // Otherwise, we need to apply model transform on the levels first.
          //
          // If placementTf is undefined, we use the refPointTransform of aecModelData.
          // Note that this is correct when using applyRefPoint=true and a globalOffset with z=0
          // for the model load options.
          var placementTf = (_this$currentModel = this.currentModel) === null || _this$currentModel === void 0 ? void 0 : _this$currentModel.getData().placementWithOffset;
          var modelTransform = (_this$currentModel2 = this.currentModel) === null || _this$currentModel2 === void 0 ? void 0 : _this$currentModel2.getModelTransform();

          this.floorSelector.floorData = Object(_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["aecModelDataToLevels"])(this.aecModelData, placementTf, modelTransform);
        }

        // Invalidate section.
        this.floorSelector.invalidateFloorSelection(currentFloor);
      } else {
        this.floorSelector.floorData = [];
      }

      // Since changing model z offset can cause the camera position (aka "player") to be outside / inside of a level,
      // It's important to call _onCameraMoved here, so if a level has changed according to the new transform - it will trigger a LEVEL_CHANGED event.
      this._onCameraMoved();
    } }, { key: "_updateOccluderData", value: function _updateOccluderData()

    {
      // Make sure that occluder data is known if a main model is specified
      var occludersPerModel = this.aecModelData ? Object(_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["modelDataOccluders"])(this.viewer) : undefined;
      this.floorSelector.floorFilterData = occludersPerModel;
    } }, { key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var _this3 = this;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (


                  this.viewer.loadExtension('Autodesk.AEC.ViewportsExtension'));case 2:this.viewportsExtension = _context2.sent;

                this.floorSelector = new _FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer);

                this.updateFloorSelector = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var autoDetect, isDataInWorldCoords, model, bubbleNode, aecModelData, generatedLevels, is3d;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:if (
                          _this3.floorSelector) {_context.next = 2;break;}return _context.abrupt("return");case 2:



                          // auto-detect main model if not disabled
                          autoDetect = _this3.options.autoDetectAecModelData !== false;if (!
                          autoDetect) {_context.next = 19;break;}
                          isDataInWorldCoords = false;

                          model = Object(_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["chooseMainModel"])(_this3.viewer, true); // Returns null when no model
                          bubbleNode = model && model.getDocumentNode();
                          aecModelData = bubbleNode && bubbleNode.getAecModelData(); // Returns null when no aec model data
                          if (!(
                          !aecModelData && model && model.getData().loadOptions.fileExt === 'ifc' && _this3.options.ifcLevelsEnabled)) {_context.next = 13;break;}
                          // Set momentarily to undefined until async computation is finished. Helps differentiate when it's
                          // still loading (undefined), from having no levels information (null)
                          _this3.setAecModelData(undefined, model);_context.next = 12;return (
                            _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_3__["default"].computeAecModelDataForIfc(model));case 12:aecModelData = _context.sent;case 13:if (!(


                          !aecModelData && model)) {_context.next = 18;break;}_context.next = 16;return (
                            _this3.viewportsExtension.generateLevelsFromViewports(model.getDocumentNode()));case 16:generatedLevels = _context.sent;

                          if (generatedLevels.length) {
                            aecModelData = generatedLevels;

                            isDataInWorldCoords = true;
                          }case 18:


                          _this3.setAecModelData(aecModelData, model, isDataInWorldCoords);case 19:


                          _this3._updateOccluderData();

                          // Make sure that cutplanes are disabled when in 2d views and reactivated in 3d
                          // Todo: Check if we can move the MODEL_ADDED event at the end of addModel, so that we could simply use viewer.is2d here.
                          is3d = _this3.viewer.getVisibleModels().some(function (model) {return model.is3d();});
                          _this3.floorSelector.setEnabled(is3d);case 22:case "end":return _context.stop();}}}, _callee);}));


                this.viewer.addEventListener(av.MODEL_ROOT_LOADED_EVENT, this.updateFloorSelector);
                this.viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this.updateFloorSelector);
                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.updateFloorSelector);
                this.viewer.addEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, this.updateFloorsData);
                this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this._onCameraMoved);
                this.viewportsExtension.addEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this.updateFloorSelector);

                this._createUI();
                this.updateFloorSelector();return _context2.abrupt("return",

                true);case 14:case "end":return _context2.stop();}}}, _callee2, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      if (!this.container) {
        this.viewer.removePanel && this.viewer.removePanel(this.levelsPanel);
      }
      this.floorSelector.selectFloor(undefined, false);
      this.levelsPanel = null;

      if (this.updateFloorSelector) {
        this.viewer.removeEventListener(av.MODEL_ROOT_LOADED_EVENT, this.updateFloorSelector);
        this.viewer.removeEventListener(av.MODEL_UNLOADED_EVENT, this.updateFloorSelector);
        this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.updateFloorSelector);
        this.viewer.removeEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, this.updateFloorsData);
        this.viewportsExtension.removeEventListener(Autodesk.AEC.ViewportsExtension.Events.VIEWPORT_DATA_FETCHED_EVENT, this.updateFloorSelector);
        this.updateFloorSelector = null;
      }

      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this._onCameraMoved);
      this._currentLevel = null;

      this.floorSelector = null;

      this.aecModelData = null;
      this.currentModel = null;

      return true;
    }

    /**
       * Gets the extension state as a plain object. Invoked automatically by viewer.getState()
       * @param {object} viewerState - Object to inject extension values.
       */ }, { key: "getState", value: function getState(
    viewerState) {
      if (!this.viewer.model || this.viewer.model.is2d()) {
        return;
      }

      var floor = this.floorSelector.currentFloor;
      viewerState.floorGuid = floor ? this.floorSelector.floorData[floor].guid : null;
    } }, { key: "restoreState",

    /**
                                 * Restores the extension state from a given object. Invoked automatically by viewer.restoreState()
                                 * @param {object} viewerState - Viewer state.
                                 * @param {boolean} immediate - Whether the new view is applied with (true) or without transition (false).
                                 * @returns {boolean} True if restore operation was successful.
                                 */value: function restoreState(
    viewerState, immediate) {
      // If floorGuid is undefined we should keep the extension as it is. (unlike null which means 'no levels') 
      if (viewerState.floorGuid === undefined) {
        return;
      }
      if (viewerState.floorGuid) {
        var floor = this.floorSelector.floorData.find(function (data) {return data.guid === viewerState.floorGuid;});

        if (floor) {
          this.floorSelector.selectFloor(floor.index, false);
        }
      } else {
        this.floorSelector.selectFloor(_FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].NoFloor, false);
      }

      return true;
    } }, { key: "getCurrentLevel",

    // Returns a floor object {index, name}
    value: function getCurrentLevel() {
      // If a level is selected, use that one and ignore camera z
      var fs = this.floorSelector;
      var level = fs.floorData[fs.currentFloor];
      if (level) {
        return level;
      }

      // No floor selected => determine based on camera z
      return this._mapCameraToLevel();
    }

    // index must be a valid FloorIndex
  }, { key: "getZRange", value: function getZRange(index) {
      var floor = this.floorSelector && this.floorSelector.floorData[index];

      // Cut everything above zMid of current floor
      var zMax = floor.zMin + 0.5 * (floor.zMax - floor.zMin);

      // Cut everything below zMid of the floor below
      // (Cutting below zMin keeps stairs to lower floors visible)
      var floorBelow = this.floorSelector.floorData[index - 1];
      var zMin = floorBelow ? 0.5 * (floorBelow.zMin + floorBelow.zMax) : floor.zMin;

      return { zMin: zMin, zMax: zMax };
    } }]);return LevelsExtension;}(av.Extension);


var createLevelsIcon = function createLevelsIcon() {
  return [
  '<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">',
  '<g stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">',
  '<path d="M4 8 L12 3 L 20 8 L12 13Z"/>',
  '<path d="M4 12 L12 17 L 20 12"/>',
  '<path d="M4 16 L12 21 L 20 16"/>Ä',
  '</g>',
  '</svg>'].
  join('');
};

namespace.LevelsExtension = LevelsExtension; // Makes it easier to get e.g. the version

LevelsExtension.LEVEL_CHANGED = "levelChanged";

// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, LevelsExtension);

/***/ }),

/***/ "./extensions/AEC/ui/ListPanel.css":
/*!*****************************************!*\
  !*** ./extensions/AEC/ui/ListPanel.css ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./ListPanel.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/ui/ListPanel.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/ui/ListPanel.js":
/*!****************************************!*\
  !*** ./extensions/AEC/ui/ListPanel.js ***!
  \****************************************/
/*! exports provided: ListPanelEvents, ListPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListPanelEvents", function() { return ListPanelEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListPanel", function() { return ListPanel; });

var av = Autodesk.Viewing;
var avu = Autodesk.Viewing.UI;


var ListPanelEvents = {

  /**
                                * Fired when clicking on an item. (not fired when setting current item per code)
                                *  @property {Object} item  - data item being selected.
                                */
  ITEM_SELECT: 'itemSelect',

  /*
                              * Fired when toggling item visibility
                              *  @property {Object} item    - data item
                              *  @property {bool}   visible - whether item was toggled on or off
                              */
  ITEM_VISIBILITY_CHANGED: 'itemVisibibilityChanged',

  /**
                                                       * @property {Object} item - data item being selected.
                                                       */
  ITEM_MOUSE_ENTER: 'itemMouseEnter',
  ITEM_MOUSE_LEAVE: 'itemMouseLeave' };


function ListPanel(parentContainer, id, title, options) {

  avu.DockingPanel.call(this, parentContainer, id, title, options);

  av.EventDispatcher.prototype.apply(this);

  this.container.classList.add('list-panel');
  this.container.dockRight = true;
  this.createScrollContainer({ left: false, heightAdjustment: 65, marginTop: 0 });
}

ListPanel.prototype = Object.create(avu.DockingPanel.prototype);

// @param {Object[]} items - Array order defines display order top-down.
ListPanel.prototype.setItems = function (items) {

  this.buttons = [];
  this.items = items;

  // remove old list
  if (this.listDiv) {
    this.scrollContainer.removeChild(this.listDiv);
  }
  var _document = this.getDocument();
  this.listDiv = _document.createElement('div');
  this.listDiv.classList.add('itemList');

  this.scrollContainer.appendChild(this.listDiv);

  var scope = this;

  var createButton = function createButton(item) {

    var itemText = scope._getItemText ? scope._getItemText(item) : '<no item text>';

    var button = _document.createElement('div');
    button.classList.add('listItem');
    button.item = item;
    button.setAttribute('title', itemText);

    button.addEventListener('click', function () {
      scope.fireEvent({
        type: ListPanelEvents.ITEM_SELECT,
        item: item });

    });
    button.addEventListener('mouseenter', function () {
      scope.fireEvent({
        type: ListPanelEvents.ITEM_MOUSE_ENTER,
        item: item });

      button.classList.add('hover');
    });
    button.addEventListener('mouseleave', function () {
      scope.fireEvent({
        type: ListPanelEvents.ITEM_MOUSE_LEAVE,
        item: item });

      button.classList.remove('hover');
    });

    var textSpan = _document.createElement('span');
    textSpan.innerHTML = itemText;
    textSpan.classList.add("text");

    // This container DIV is required to enable proper text fade-out for long texts.
    var textContainerDiv = _document.createElement('div');
    textContainerDiv.classList.add("textContainer");
    textContainerDiv.appendChild(textSpan);
    button.appendChild(textContainerDiv);

    // Optional: Enable warning symbol per item
    if (scope.options.enableWarningSymbol) {
      var warnSpan = _document.createElement('span');
      warnSpan.classList.add("list-panel-item-warning");
      button.appendChild(warnSpan);
      button.warnSpan = warnSpan;
    }

    // Optional: Show checkmark for selected items
    if (scope.options.enableCheckmark) {
      var checkSpan = _document.createElement('span');
      checkSpan.classList.add("icon");
      button.appendChild(checkSpan);
    }

    // Optional: Show eye-symbol
    if (scope.options.enableVisibilityToggle) {
      var eyeSymbol = _document.createElement('div');
      eyeSymbol.classList.add("visibility");
      button.appendChild(eyeSymbol);

      eyeSymbol.addEventListener('click', function () {
        var wasVisible = scope._isVisible ? scope._isVisible(button.item) : true;
        scope.fireEvent({
          type: ListPanelEvents.ITEM_VISIBILITY_CHANGED,
          item: button.item,
          visible: !wasVisible });

        scope.updateItemStates();
      });
    }

    return button;
  };

  for (var index = 0; index < items.length; index++) {

    var item = items[index];
    var button = createButton(item);

    this.listDiv.appendChild(button);
    this.buttons.push(button);
  }

  this.updateItemStates();
};

// Trigger mouse-over highlighting on item. 
//  @param {function} filter - gets an item
ListPanel.prototype.rollOverItem = function (filter) {
  for (var i = 0; i < this.buttons.length; i++) {
    var button = this.buttons[i];
    if (filter(button.item)) {
      button.classList.add('hover');
    } else {
      button.classList.remove('hover');
    }
  }
};

ListPanel.prototype.updateItemStates = function () {

  if (!this.buttons) {
    return;
  }
  for (var i = 0; i < this.buttons.length; i++) {

    // set/unset blue color for selected items and show optional checkmark
    var button = this.buttons[i];
    button.classList.remove("selected");
    if (this._isSelected && this._isSelected(button.item)) {
      button.classList.add("selected");
    }

    // set/unset warning symbol
    if (this.options.enableWarningSymbol) {
      var warnText = this._getWarningText && this._getWarningText(button.item);
      button.warnSpan.style.visibility = warnText ? 'visible' : 'hidden';
      button.warnSpan.setAttribute('title', warnText || '');
    }

    // set state of visibility toggle (eye symbol)
    if (this.options.enableVisibilityToggle) {
      button.classList.remove("dim");
      var isVisible = this._isVisible ? this._isVisible(button.item) : true;
      if (!isVisible) {
        button.classList.add('dim');
      }
    }
  }
};

// Set functions to define how to handle each item
//  @param {function(item)} isSelected       - takes a list item (see setItems) and returns true for 'selected state'
//  @param {function(item)} getItemText      - returns the text to be displayed
//  @param {function(item)} [getWarningText] - Optional: Display a warning symbol. Function defines tooltip text.
//  @param {function(item)} [isVisible]      - Optional: State of visibility toggle. If set, an additional eye-symbol is shown to toggle visibility per item. 
ListPanel.prototype.setItemHandlers = function (isSelected, getItemText, getWarningText, isVisible) {
  this._isSelected = isSelected;
  this._getItemText = getItemText;
  this._getWarningText = getWarningText;
  this._isVisible = isVisible;
  this.updateItemStates();
};

avu.ListPanelEvents = ListPanelEvents;
avu.ListPanel = ListPanel;

/***/ }),

/***/ "./extensions/CompGeom/bezier.js":
/*!***************************************!*\
  !*** ./extensions/CompGeom/bezier.js ***!
  \***************************************/
/*! exports provided: DefaultTessParams, SetTesselationParams, TesselateCubic, TesselateQuad, getCubeBezierPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultTessParams", function() { return DefaultTessParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetTesselationParams", function() { return SetTesselationParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TesselateCubic", function() { return TesselateCubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TesselateQuad", function() { return TesselateQuad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCubeBezierPoint", function() { return getCubeBezierPoint; });


var DefaultTessParams = {
  //How many forward iterations to use when approximating Bezier curves
  //More iterations are needed in case the min_seg_len setting below is smaller
  //relative to mesh size. However, the two numbers need to be tuned together
  //so that NUM_ITERATIONS is enough to result in segment lengths desired.

  //Note that those values are tuned for PDF rendering, where text characters
  //are drawn one by one. If a long piece of text is drawn all at once, then
  //its bounding box will be quite large, so the relative min_seg_len will also
  //be too large and the characters will look coarse. In such cases, we will need
  //to better estimate this by using e.g. the font height only.
  numIterations: 100,

  //What fraction of the bounding sbox should be the minimum length of
  //a segment
  minSegLenFraction: 0.05 };


function SetTesselationParams(num_iterations, min_seg_len_fraction) {
  if (num_iterations)
  DefaultTessParams.numIterations = num_iterations;

  if (min_seg_len_fraction)
  DefaultTessParams.minSegLenFraction = min_seg_len_fraction;
}

function distance(x1, y1, x2, y2) {
  return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

function adjustMaxdim(maxdim, segLength) {
  if (maxdim > 4 * segLength && segLength > 0) {
    var time = Math.sqrt(maxdim / segLength);
    time = Math.min(4, time);
    maxdim = segLength * time;
  }
  return maxdim;
}

function TesselateCubic(ctx, px1, py1, px2, py2, px3, py3, px4, py4, maxdim, tessParams, isFont)
{
  tessParams = tessParams || DefaultTessParams;

  var aproximateLength = distance(px1, py1, px2, py2) + distance(px2, py2, px3, py3) + distance(px3, py3, px4, py4);

  // maxdim is the size of the bounds of the path
  // but for individual path, we need to use aproximateLength
  // we need to balance both performance and visual effect
  // so we leverage both value and try to balance it.
  if (!isFont) {
    maxdim = adjustMaxdim(maxdim, aproximateLength);
  }

  //we will base the max number of segments to use for approximation
  //on the bounds of the full line buffer contents
  //TODO: as an improvement we could take the bounds of this particular curve
  //with respect to the full bounds of the line buffer data.
  maxdim = maxdim || 1 / tessParams.minSegLenFraction;

  //minimum length of tesselation segment
  //set to 1/100 of the bounds
  var minSegLen = maxdim * tessParams.minSegLenFraction;

  //but for now we will iterate 100 times
  var dt = 1.0 / tessParams.numIterations;

  //double dt2 = dt*dt;
  var dt3 = dt * dt * dt;

  var pre1 = 3.0 * dt;
  var pre2 = pre1 * dt;
  var pre3 = pre2 + pre2;
  var pre4 = 6.0 * dt3;

  var temp1x = px1 - 2.0 * px2 + px3;
  var temp1y = py1 - 2.0 * py2 + py3;
  var temp2x = 3.0 * (px2 - px3) - px1 + px4;
  var temp2y = 3.0 * (py2 - py3) - py1 + py4;

  var fx = px1;
  var fy = py1;
  var dfx = (px2 - px1) * pre1 + temp1x * pre2 + temp2x * dt3;
  var dfy = (py2 - py1) * pre1 + temp1y * pre2 + temp2y * dt3;
  var ddfx = temp1x * pre3 + temp2x * pre4;
  var ddfy = temp1y * pre3 + temp2y * pre4;
  var dddfx = temp2x * pre4;
  var dddfy = temp2y * pre4;

  var error = 0.0;

  // forward differencing loop
  var tMax = 0 | 1.0 / dt - 0.5;
  for (var t = 0; t < tMax; t++)
  {
    fx += dfx;
    fy += dfy;
    dfx += ddfx;
    dfy += ddfy;
    ddfy += dddfy;
    ddfx += dddfx;

    error += Math.sqrt(dfx * dfx + dfy * dfy);

    if (error >= minSegLen) //add segment only if we have reached treshold length
      {
        // line to current
        ctx.lineTo(fx, fy);
        error = 0.0;
      }
  }

  ctx.lineTo(px4, py4);
}

function TesselateQuad(ctx, px1, py1, px2, py2, px3, py3, maxdim, tessParams, isFont)
{
  tessParams = tessParams || DefaultTessParams;

  var aproximateLength = distance(px1, py1, px2, py2) + distance(px2, py2, px3, py3);

  // maxdim is the size of the bounds of the path
  // but for individual path, we need to use aproximateLength
  // we need to balance both performance and visual effect
  // so we leverage both value and try to balance it.
  if (!isFont) {
    maxdim = adjustMaxdim(maxdim, aproximateLength);
  }

  //we will base the max number of segments to use for approximation
  //on the bounds of the full line buffer contents
  //TODO: as an improvement we could take the bounds of this particular curve
  //with respect to the full bounds of the line buffer data.
  maxdim = maxdim || 1 / tessParams.minSegLenFraction;

  //minimum length of tesselation segment
  //set to a fraction of the bbox of the entire path (value chosen to work well for text at reasonable font size)
  var minSegLen = maxdim * tessParams.minSegLenFraction;

  //but for now we will iterate 100 times
  var dt = 1.0 / tessParams.numIterations;

  var dt2 = dt * dt;

  var ax = px1 - 2.0 * px2 + px3; //replace 2* by addition?
  var ay = py1 - 2.0 * py2 + py3; //replace 2* by addition?

  var bx = 2.0 * (px2 - px1);
  var by = 2.0 * (py2 - py1);

  var fx = px1;
  var fy = py1;
  var dfx = bx * dt + ax * dt2;
  var dfy = by * dt + ay * dt2;
  var ddfx = 2.0 * ax * dt2;
  var ddfy = 2.0 * ay * dt2;

  var error = 0.0;

  //forward differencing loop
  var tMax = 0 | 1.0 / dt - 0.5;
  for (var t = 0; t < tMax; t++)
  {
    fx += dfx;
    fy += dfy;
    dfx += ddfx;
    dfy += ddfy;

    error += Math.sqrt(dfx * dfx + dfy * dfy);

    if (error >= minSegLen) // how many pixels should each line be?)
      {
        ctx.lineTo(fx, fy);
        error = 0.0;
      }
  }

  ctx.lineTo(px3, py3);
}

// Cubic Bezier for single points. Note that TesselateCubic is faster by using deltas.
// Result is returned as a new {x,y} or written to optionalTarget.
function getCubeBezierPoint(t, px1, py1, px2, py2, px3, py3, px4, py4, optionalTarget) {

  var result = optionalTarget || { x: x, y: y };

  var k = 1 - t;

  // Bernstein coefficients
  var bp1 = k * k * k;
  var bp2 = 3 * k * k * t;
  var bp3 = 3 * k * t * t;
  var bp4 = t * t * t;

  result.x = bp1 * px1 + bp2 * px2 + bp3 * px3 + bp4 * px4;
  result.y = bp1 * py1 + bp2 * py2 + bp3 * py3 + bp4 * py4;

  return result;
}

/***/ }),

/***/ "./extensions/Edit2D/EditShapes.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/EditShapes.js ***!
  \*****************************************/
/*! exports provided: Style, Shape, LoopType, PolyBase, PolyIndex, Polygon, Polyline, EdgeType, runPath, EllipseArcParams, Path, PolygonPath, PolylinePath, Circle, ShapeWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Style", function() { return Style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopType", function() { return LoopType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyBase", function() { return PolyBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyIndex", function() { return PolyIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polyline", function() { return Polyline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeType", function() { return EdgeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runPath", function() { return runPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseArcParams", function() { return EllipseArcParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonPath", function() { return PolygonPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolylinePath", function() { return PolylinePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeWrapper", function() { return ShapeWrapper; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Svg.js */ "./extensions/Edit2D/Svg.js");
/* harmony import */ var _LoopContainment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LoopContainment.js */ "./extensions/Edit2D/LoopContainment.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var nextShapeId = 1;

var av = Autodesk.Viewing;

var toColor = function toColor(r, g, b) {
  return "rgb(" + r + "," + g + "," + b + ")";
};

var cloneVectorArray = function cloneVectorArray(src) {
  return src.map(function (p) {return { x: p.x, y: p.y };});
};

// Default arc tessellation params that we use for area computations. (see Bezier.js)
// We use smaller min segment length than for drawing, because the DefaultTessParams would cause too inaccurate measurements.
// TODO: Replace by more accurate and faster analytic computation to replace brute-force tesselation completely.
var AreaTessParam = {
  numIterations: 100,
  minSegLenFraction: 0.01 };


var tmpVec3 = new THREE.Vector3();
var tmpVec3_2 = new THREE.Vector3();
var tmpBox2 = new THREE.Box2();
var tmpVec2 = new THREE.Vector2();

var Style = /*#__PURE__*/function () {

  /**
                                              * Creates a new Style for the Edit 2D tools.
                                              * @param {object} [params]           - various style values to overwrite the default style.
                                              * @param {string} [params.color]     - sets the color for the line and fill area
                                              * @param {number} [params.alpha]     - sets the alpha value for the line and fill area
                                              * @param {string} [params.lineColor] - sets the color for the line
                                              * @param {number} [params.lineAlpha] - sets the alpha value for the line
                                              * @param {number} [params.lineWidth] - sets the line width for the line.
                                              * @param {number} [params.lineStyle] - sets the style of the line
                                              * @param {string} [params.fillColor] - sets the color for the fill area
                                              * @param {number} [params.fillAlpha] - sets the alpha value for the fill area
                                              */
  function Style() {var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, Style);
    this.lineColor = params.lineColor || params.color || "rgb(0,0,128)";
    this.lineAlpha = params.lineAlpha !== undefined ? params.lineAlpha : params.alpha !== undefined ? params.alpha : 1.0;
    this.lineWidth = params.lineWidth !== undefined ? params.lineWidth : 3.0;

    this.fillColor = params.fillColor || params.color || "rgb(0,0,128)";
    this.fillAlpha = params.fillAlpha !== undefined ? params.fillAlpha : params.alpha !== undefined ? params.alpha : 0.2;

    // lineStyle is an index into a list of dash/dot patterns defined in See LineStyleDef.js.
    // Examples:
    //   0:  Solid line:    ______________
    //   10: Dashes long:   __ __ __ __ __
    //   11: Dashes short:  _ _ _ _ _ _ _
    //   12: Dashes longer: ___ ___ ___ ___
    //   16: Dots:          . . . . . . .
    //   17: Dots dense:    ..............
    //   18: Dots sparse:   .  .  .  .  .
    this.lineStyle = params.lineStyle || 0;

    // By default, we interpret line widths in screen-space
    this.isScreenSpace = params.isScreenSpace !== undefined ? params.isScreenSpace : true;
    this.compositeOperation = 'source-over';
  }

  // Components r,b,g are in [0,255]
  _createClass(Style, [{ key: "setFillColor", value: function setFillColor(r, g, b) {
      this.fillColor = toColor(r, g, b);
    } }, { key: "setLineColor", value: function setLineColor(

    r, g, b) {
      this.lineColor = toColor(r, g, b);
    } }, { key: "clone", value: function clone()

    {
      return new Style().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.lineColor = from.lineColor;
      this.lineAlpha = from.lineAlpha;
      this.lineWidth = from.lineWidth;
      this.fillColor = from.fillColor;
      this.fillAlpha = from.fillAlpha;
      this.lineStyle = from.lineStyle;
      this.isScreenSpace = from.isScreenSpace;
      this.compositeOperation = from.compositeOperation;
      return this;
    } }]);return Style;}();


Style.toColor = toColor;

var DefaultStyle = new Style();

// Add all points to given bbox.
var addPointsToBBox = function addPointsToBBox(points, dstBox) {
  for (var i = 0; i < points.length; i++) {
    dstBox.expandByPoint(points[i]);
  }
};

var Shape = /*#__PURE__*/function (_av$EventDispatcher) {_inherits(Shape, _av$EventDispatcher);var _super = _createSuper(Shape);
  function Shape() {var _this;var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultStyle.clone();_classCallCheck(this, Shape);
    _this = _super.call(this);

    _this.style = style;

    // assign unique id
    _this.id = nextShapeId++;

    _this.bbox = new THREE.Box2();
    _this.bboxDirty = true;

    // If false, it is skipped by EditLayer traversals
    _this.visible = true;

    // whether users can move this shape by clicking and dragging.
    _this.movable = true;

    // whether users can select this shape. If false, clicks on this shape will not select it, and by consequence it
    // won't be editable either.
    _this.selectable = true;

    // Should be set by creator by something more descriptive.
    _this.name = _this.id.toString();return _this;
  }

  // Must be provided by derivaties
  _createClass(Shape, [{ key: "draw", value: function draw() /*ctx, overrideStyle*/{} }, { key: "hitTest", value: function hitTest()
    /*x, y, hitRadius*/{} // hitRadius is a distance in layer-coords used for line feature hit-tests.
  }, { key: "move", value: function move()
    /*dx, dy*/{return this;}

    // Apply a transform to each point. (assuming z=0)
    // @param {Matrix4}
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {return this;} }, { key: "clone", value: function clone()

    {
      return new Shape().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.style = from.style.clone();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      console.error("Must be implemented by derived class.");
    } }, { key: "modified", value: function modified()

    {
      this.bboxDirty = true;
      this.fireEvent({ type: Shape.Events.MODIFIED });
    } }, { key: "updateBBox", value: function updateBBox()

    {
      if (this.bboxDirty) {
        this.computeBBox();
        this.bboxDirty = false;
      }
    }

    // Return bbox while making sure that it's up-to-date.
  }, { key: "getBBox", value: function getBBox() {
      this.updateBBox();
      return this.bbox;
    }

    // @param {string}  svg - e.g. '<path d="M 13,4 L 14,4"/>'
  }, { key: "toSVG",



    // Convert to SVG style string, e.g., '<path d="M 13,4 L 14,4"/>'
    // See Svg.toSvg() comment for options.
    //
    // Note: The digits param is deprecated and only exists for legacy reasons. 
    //       Set digits via options.digits instead.
    value: function toSVG(options, digits) {
      return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].toSvg(this, options, digits);
    }

    // Converts shape into a DOM element (usually a <path>).
    //  @param {Object} 
    //  @param {bool}   [options.exportStyle=true]
  }, { key: "createSvgShape", value: function createSvgShape(options) {
      return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].toSvgElement(this, options);
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      this.visible = visible;
    } }], [{ key: "fromSVG", value: function fromSVG(svg) {return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].fromSvg(svg);} }]);return Shape;}(av.EventDispatcher);


Shape.Events = {
  MODIFIED: 'modified' };


av.GlobalManagerMixin.call(Shape.prototype);

var LoopType = {
  Empty: 0, // Loop is empty or does not exist
  Inner: 1,
  Outer: 2,
  Overlapping: 3 // Loop is intersecting itself or other loops
};

// Common base class for Polygons and Polylines
var PolyBase = /*#__PURE__*/function (_Shape) {_inherits(PolyBase, _Shape);var _super2 = _createSuper(PolyBase);

  function PolyBase() {var _this2;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, PolyBase);
    _this2 = _super2.call(this, style);

    // Array of Array of points, each represented as an object {x, y}
    // By default, we start with a single loop/chain
    _this2._loops = points ? [points] : [];

    // Set by derived classes
    _this2.isClosed = undefined;

    // Computed on-demand: Provides extra information about how loops are nested.
    _this2._loopInfos = null;return _this2;
  }

  // For backward compatibility
  _createClass(PolyBase, [{ key: "allocPoints",








    // acquire a number of additional points in the given loop. Each has initial coords (0,0)
    value: function allocPoints(numPoints) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = 0; i < numPoints; ++i) {
        this.addPoint(0, 0, loopIndex);
      }
      return this;
    } }, { key: "isPolygon", value: function isPolygon()

    {return this.isClosed;} }, { key: "isPolyline", value: function isPolyline()
    {return !this.isClosed;} }, { key: "isPath", value: function isPath()

    {
      return this instanceof Path;
    } }, { key: "addPoint", value: function addPoint(

    x, y) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      // get or create loop
      var loop = this._loops[loopIndex] || (this._loops[loopIndex] = []);

      // add point to loop
      var point = { x: x, y: y };
      loop.push(point);
      this.modified();
      return point;
    } }, { key: "getPoint", value: function getPoint(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();

      // Legacy fallback (deprecated): This can be removed as soon as no code
      // is passing a target vector without a loop index
      if (_typeof(loopIndex) === 'object') {
        target = loopIndex;
        loopIndex = 0;
      }

      return target.copy(this._loops[loopIndex][index]);
    } }, { key: "removePoint", value: function removePoint(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this._loops[loopIndex].splice(index, 1);
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var p = this._loops[loopIndex][index];
      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "insertPoint", value: function insertPoint(

    index, p) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this._loops[loopIndex].splice(index, 0, p);
    } }, { key: "getVertexCount",











    // Returns 0 if a loop is empty or does not exist.
    value: function getVertexCount() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // Array may not exist yet if no vertices were added to the loop yet.
      var loop = this._loops[loopIndex];
      return loop ? loop.length : 0;
    }

    // Reset back to a single empty loop
  }, { key: "clear", value: function clear() {
      this._loops = [];
      this.modified();
    }

    // Enumerate all edges (a,b).
    //  @param {function(a, b, ai, bi)} cb - For each edge, we trigger cb(a, b, ai, bi), where (a,b) are the points and (ai, bi) the indices of the edge.
    //                                       If cb() returns true, the traversal stops.
  }, { key: "enumEdges", value: function enumEdges(cb) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      // get edge count
      var edgeCount = this.getEdgeCount(loopIndex);

      // check for each edge whether p is close to it.
      for (var i = 0; i < edgeCount; i++) {
        // get indices
        var ai = i;
        var bi = this.nextIndex(i, loopIndex);

        // get points
        var a = this.getPoint(ai, loopIndex);
        var b = this.getPoint(bi, loopIndex);

        // pass all to cb
        var stop = cb(a, b, ai, bi);

        // allow early out
        if (stop) {
          return;
        }
      }
    }

    // Given a polyline or polygon, it checks if the position is close to any edge of the shape.
    // If so, it returns the index of that edge, otherwise -1.
    // All values are in layer coords.
  }, { key: "findEdgeIndex", value: function findEdgeIndex(p, precision) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var edgeIndex = -1;

      // Callback to find edge containing p
      var findEdgeCb = function findEdgeCb(a, b, ai) {

        // If edge contains p, store its edge index
        var containsP = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].isPointOnEdge(p, a, b, precision);
        if (containsP) {
          edgeIndex = ai;
        }

        // Stop on success
        return containsP;
      };
      this.enumEdges(findEdgeCb, loopIndex);
      return edgeIndex;
    } }, { key: "moveLoop", value: function moveLoop(

    dx, dy, loopIndex) {
      var points = this._loops[loopIndex];
      for (var i = 0; i < points.length; i++) {
        points[i].x += dx;
        points[i].y += dy;
      }
      this.modified();
    } }, { key: "move", value: function move(

    dx, dy) {
      for (var l = 0; l < this.loopCount; l++) {
        this.moveLoop(dx, dy, l);
      }
      return this;
    }

    // Note: Ellipse arcs only support simple transforms (translation, rotation, uniform scaling)
    // @param {THREE.Matrix4}
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {

      for (var l = 0; l < this.loopCount; l++) {
        var points = this._loops[l];

        for (var i = 0; i < points.length; i++) {
          var p = points[i];

          // set target to (x,y) * matrix
          var transformPoint = function transformPoint(x, y, target) {
            // convert to vec3, transform, and write back to target
            var vec3 = tmpVec3.set(x, y, 0).applyMatrix4(matrix);
            target.x = vec3.x;
            target.y = vec3.y;
            return target;
          };

          transformPoint(p.x, p.y, p);

          // transform Bezier control points
          if (this.isBezierArc(i, l)) {
            var cp = transformPoint(p.cp1x, p.cp1y, tmpVec3);
            p.cp1x = cp.x;
            p.cp1y = cp.y;

            cp = transformPoint(p.cp2x, p.cp2y, tmpVec3);
            p.cp2x = cp.x;
            p.cp2y = cp.y;
          }

          // Transform ellipse arcs
          // Note: Currently, this only works for simple transforms (translate, rotate, uniform scale)
          if (this.isEllipseArc(i, l)) {
            p.ellipseArcParams.applyMatrix4(matrix);
          }
        }
      }
      this.modified();
      return this;
    }

    // Copy a single loop from src poly and adds it to this one
    //  @param {PolyBase} srcPoly
    //  @param {number}   srcLoopIndex - must be a valid loopIndex of src
    //  @param {number} [dstLoopIndex] Optional: index where to insert the new loop. By default, we use the first free loopIndex.
  }, { key: "addLoop", value: function addLoop(srcPoly) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var dstLoopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      // copy loop points
      var srcLoop = srcPoly._loops[srcLoopIndex];
      var newLoop = cloneVectorArray(srcLoop);

      // insert new loop
      var newIndex;
      if (dstLoopIndex === -1) {
        // find a free loop index to store the new loop
        newIndex = this.nextFreeLoop();
        this._loops[newIndex] = newLoop;
      } else {
        // insert new loop at given index
        newIndex = dstLoopIndex;
        this._loops.splice(newIndex, 0, newLoop);
      }
      this.modified();

      return newIndex;
    }

    // Removes any empty loops, so that any loop i for 0<i<this.loopCount contains points.
  }, { key: "cleanupLoops", value: function cleanupLoops() {
      this._loops = this._loops.filter(function (l) {return l && l.length > 0;});
      this.modified();
    } }, { key: "copyGeometry", value: function copyGeometry(

    srcPoly) {
      this.isClosed = srcPoly.isClosed;

      // copy loops
      this._loops = [];
      for (var i = 0; i < srcPoly.loopCount; i++) {
        this.addLoop(srcPoly, i);
      }
      return this;
    } }, { key: "copy", value: function copy(

    srcPoly) {
      _get(_getPrototypeOf(PolyBase.prototype), "copy", this).call(this, srcPoly);
      return this.copyGeometry(srcPoly);
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.makeEmpty();
      for (var i = 0; i < this.loopCount; i++) {
        var loop = this._loops[i];
        if (loop) {
          addPointsToBBox(loop, this.bbox);
        }
      }
      return this.bbox;
    } }, { key: "indexValid", value: function indexValid(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return index >= 0 && index < this.getVertexCount(loopIndex);
    }

    // Returns -1 if there is no next Index    
  }, { key: "nextIndex", value: function nextIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Return -1 for invalid input
      if (!this.indexValid(index, loopIndex)) {
        return -1;
      }

      // Handle last vertex
      var isLast = index === this.getVertexCount(loopIndex) - 1;
      if (isLast) {
        // If closed, restart. Otherwise, there is no next index.
        return this.isClosed ? 0 : -1;
      }

      return index + 1;
    }

    // Returns -1 if there is no previous vertex index
  }, { key: "prevIndex", value: function prevIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Return -1 for invalid input
      if (!this.indexValid(index, loopIndex)) {
        return -1;
      }

      // Handle first vertex
      if (index === 0) {
        // if closed, continue at end. Otherwise, there is no previous index.
        var vertexCount = this.getVertexCount(loopIndex);
        return this.isClosed ? vertexCount - 1 : -1;
      }

      return index - 1;
    }

    // Returns index of the edge ending at the given vertex or -1 if it does not exist.
  }, { key: "edgeBeforeVertex", value: function edgeBeforeVertex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.prevIndex(index, loopIndex);
    }

    // Returns index of the edge starting at the given vertex.
    // Returns -1 if index is the end vertex of a polyline.
  }, { key: "edgeAfterVertex", value: function edgeAfterVertex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(index, loopIndex) ? index : -1;
    }

    // Returns -1 if there is no previous edge.
  }, { key: "nextEdgeIndex", value: function nextEdgeIndex(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Check edgeIndex validity
      if (!this.edgeIndexValid(edgeIndex, loopIndex)) {
        return -1;
      }

      // Return -1 for last polyline edge
      if (!this.isClosed && edgeIndex === this.getEdgeCount(loopIndex) - 1) {
        return -1;
      }

      return this.nextIndex(edgeIndex, loopIndex);
    } }, { key: "prevEdgeIndex", value: function prevEdgeIndex(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Check edgeindex validity
      if (!this.edgeIndexValid(edgeIndex, loopIndex)) {
        return -1;
      }

      // Return -1 for first polyline edge
      if (!this.isClosed && edgeIndex === 0) {
        return -1;
      }

      return this.prevIndex(edgeIndex, loopIndex);
    } }, { key: "edgeIndexValid", value: function edgeIndexValid(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var edgeCount = this.getEdgeCount(loopIndex);
      return edgeIndex >= 0 && edgeIndex < edgeCount;
    } }, { key: "prevEdgeExists", value: function prevEdgeExists(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      return this.edgeIndexValid(edgeIndex, loopIndex) && vertexCount > 2 && (edgeIndex > 0 || this.isClosed);
    } }, { key: "nextEdgeExists", value: function nextEdgeExists(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      var isLastEdge = edgeIndex === vertexCount - 2;
      return this.edgeIndexValid(edgeIndex, loopIndex) && vertexCount > 2 && (!isLastEdge || this.isClosed);
    }

    // Copy start/end of an edge into outA, outB out params (Vector2).
    // edgeIndex must be valid.
  }, { key: "getEdge", value: function getEdge(edgeIndex, outA, outB) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex, loopIndex);
      this.getPoint(ia, loopIndex, outA);
      this.getPoint(ib, loopIndex, outB);
    } }, { key: "getEdgeDirection", value: function getEdgeDirection(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex, loopIndex);
      var loop = this._loops[loopIndex];
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(loop[ia], loop[ib], target);
    } }, { key: "getEdgeLength", value: function getEdgeLength(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex, loopIndex);
      var loop = this._loops[loopIndex];
      var a = loop[ia];
      var b = loop[ib];
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeLength(a, b);
    } }, { key: "getEdgeCount", value: function getEdgeCount()

    {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      return this.isClosed ? vertexCount : vertexCount - 1;
    }

    // Return the summed edge length for Polygons and Polylines.
    //
    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getLength", value: function getLength(measureTransform) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      var sum = 0.0;
      for (var i = 0; i < this.getEdgeCount(loopIndex); i++) {
        this.getEdge(i, a, b, loopIndex);

        // apply optional measure transform
        if (measureTransform) {
          measureTransform.apply(a);
          measureTransform.apply(b);
        }

        sum += a.distanceTo(b);
      }
      return sum;
    }

    // Set vertices from THREE.Box2
  }, { key: "fromBox2", value: function fromBox2(box) {
      this.addPoint(box.min.x, box.min.y);
      this.addPoint(box.max.x, box.min.y);
      this.addPoint(box.max.x, box.max.y);
      this.addPoint(box.min.x, box.max.y);
      return this;
    }

    // Returns a point along an edge. Note that the edge may be an arc for Paths.
    //  @param {number} edgeIndex   - A valid edgeIndex
    //  @param {number} t           - in [0,1]. t=0: startPoint, t=1: endPoint
    //  @param {number} [loopIndex]
    //  @param {Vector2} [target]  
  }, { key: "getPointOnEdge", value: function getPointOnEdge(edgeIndex, t) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();

      var loop = this._loops[loopIndex];
      var p0 = loop[edgeIndex];
      var p1 = loop[this.nextIndex(edgeIndex, loopIndex)];
      return target.lerpVectors(p0, p1, t);
    }

    // Checks if outer loop is counterclockwise. For polylines that doesn't form a loop, 
    // we assume an additional edge from end to start.
    // @returns {bool}
  }, { key: "isCCW", value: function isCCW() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return Autodesk.Extensions.CompGeom.polygonArea(this._loops[loopIndex]) > 0;
    }

    // Return 2D edge normal
  }, { key: "getLeftEdgeNormal", value: function getLeftEdgeNormal(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();

      var points = this._loops[loopIndex];

      // get start/end point of the edge
      var vi1 = edgeIndex;
      var vi2 = (edgeIndex + 1) % points.length;
      var v1 = points[vi1];
      var v2 = points[vi2];

      // get edge direction
      target.subVectors(v2, v1).normalize();

      // rotate by 90 degrees
      var tmp = target.x;
      target.x = -target.y;
      target.y = tmp;

      return target;
    }

    // Get edge normal facing outside wrt. to the loop containing the edge. If the contour is not closed, we
    // assume an additional connection between endpoint and startpoint to defined "outside".
  }, { key: "getOuterNormal", value: function getOuterNormal(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();
      var normal = this.getLeftEdgeNormal(edgeIndex, loopIndex, target);
      return this.isCCW(loopIndex) ? normal.multiplyScalar(-1) : normal;
    }

    // Returns the first loopIndex >=0 that doesn't contain any points yet.
    //  @param {number}
  }, { key: "nextFreeLoop", value: function nextFreeLoop() {
      var isFree = function isFree(l) {return !l || !l.length;};
      var index = this._loops.findIndex(isFree);
      return index >= 0 ? index : this.loopCount;
    }

    // Seaches all loops to find a vertex for which cb(vertexIndex, loopIndex) returns true.    
    //  @{function(vertexIndex, loopIndex)=>bool} searchFilter   
    //  @returns {Object|null}                    A {vertexIndex, loopIndex} pair on success. Otherwise null.
  }, { key: "findVertex", value: function findVertex(searchFilter) {
      for (var l = 0; l < this.loopCount; l++) {
        var len = this.getVertexCount(l);
        for (var i = 0; i < len; i++) {
          if (searchFilter(i, l)) {
            return {
              vertexIndex: i,
              loopIndex: l };

          }
        }
      }
      return null;
    }

    // Returns true if poly does not contain any (non-empty loops)
  }, { key: "empty", value: function empty() {
      return !this._loops.some(function (loop) {return loop && loop.length > 0;});
    } }, { key: "modified", value: function modified()

    {
      _get(_getPrototypeOf(PolyBase.prototype), "modified", this).call(this);

      // Loop containment may have changed
      this._loopInfos = null;
    }

    // Returns true if the shape has overlapping loops
  }, { key: "isSelfIntersecting", value: function isSelfIntersecting() {

      // Todo: Currently, we only detect overlaps between different loops. We also
      //       have to track self-intersections within a single loop.


      // Check if we have multiple overlapping loops
      var loopInfos = this._getLoopInfos();
      return loopInfos && loopInfos.some(function (l) {return l.error;});
    } }, { key: "_getLoopInfos", value: function _getLoopInfos()

    {
      // Loop infos are only needed for closed paths with 2 or more loops
      if (!this.isClosed || this.loopCount < 1) {
        return undefined;
      }

      // Reuse if already available
      if (!this._loopInfos) {
        this._loopInfos = Object(_LoopContainment_js__WEBPACK_IMPORTED_MODULE_2__["computeLoopContainment"])(this);
      }
      return this._loopInfos;
    }

    // Only works for closed loops.
  }, { key: "getLoopType", value: function getLoopType(loopIndex) {

      if (!this.isClosed) {
        return undefined;
      }

      if (!this.getVertexCount(loopIndex)) {
        return LoopType.Empty;
      }

      // LoopInfo should always exist for closed non-empty loops
      var infos = this._getLoopInfos();
      var info = infos[loopIndex];

      if (info.error) {
        return LoopType.Overlapping;
      }

      // Even-odd-rule: Loops with even rank are outer ones.
      return info.rank & 1 ? LoopType.Inner : LoopType.Outer;
    }

    // Get all loops (directly or indirectly) enclosed by the given one
  }, { key: "getChildLoops", value: function getChildLoops(loopIndex) {
      var infos = this._getLoopInfos();
      var info = infos && infos[loopIndex];
      return info ? info.containedLoops.slice() : [];
    }

    // Eliminiate all empty loops, so that loopCount matches the number of non-empty loops
  }, { key: "cleanupLoops", value: function cleanupLoops() {
      this._loops = this._loops.filter(function (l) {return l && l.length >= 0;});
    }

    // Returns all loops that are not enclosed by any other one. Only for closed shapes.
  }, { key: "getMainLoops", value: function getMainLoops() {
      var infos = this._getLoopInfos();
      if (!infos) {
        return [];
      }

      // Collect all rank-0 loops
      var loops = [];
      for (var i = 0; i < infos.length; i++) {
        var info = infos[i];

        // Skip empty or invalid loops
        var type = this.getLoopType(i);
        if (type !== LoopType.Outer) {
          continue;
        }

        if (info.rank === 0) {
          loops.push(i);
        }
      }
      return loops;
    }

    // Remove loop. Remaining loop indices are shifted back by one 
  }, { key: "removeLoop", value: function removeLoop(loopIndex) {
      this._loops.splice(loopIndex, 1);
      this.modified();
      return this;
    }

    // Remove multiple loop indices
    // @param {number[]}  
  }, { key: "removeLoops", value: function removeLoops(loops) {
      this._loops = this._loops.filter(function (l, i) {return !loops.includes(i);});
    }

    // Returns true if a point contains valid (i.e. finite) numbers.
  }, { key: "isPointFinite", value: function isPointFinite(vertex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (!this.indexValid(vertex, loopIndex)) {
        return false;
      }

      var points = this._loops[loopIndex];
      var p = points[vertex];
      return isFinite(p.x) && isFinite(p.y);
    } }, { key: "isLoopFinite", value: function isLoopFinite(

    loopIndex) {
      var points = this._loops[loopIndex];
      var count = points ? points.length : 0;
      for (var i = 0; i < count; i++) {
        if (!this.isPointFinite(i, loopIndex)) {
          return false;
        }
      }
      return true;
    } }, { key: "points", get: function get() {// Create empty loop 0 if needed
      return this._loops[0] || (this._loops[0] = []);} }, { key: "loopCount", get: function get() {return this._loops.length;} }, { key: "length", get: function get() {console.warn('poly.length is deprecated and will be removed. Please use poly.vertexCount property instead.');return this.points.length;} // for backwards compatibility
  }, { key: "vertexCount", get: function get() {return this.points.length;} }]);return PolyBase;}(Shape);
// Helper class to address a single vertex within a loop of a PolyBase.
// Can also be used to address edges (by indexing its start vertex).
var PolyIndex = /*#__PURE__*/function () {
  function PolyIndex(_ref) {var _ref$vertex = _ref.vertex,vertex = _ref$vertex === void 0 ? 0 : _ref$vertex,_ref$loop = _ref.loop,loop = _ref$loop === void 0 ? 0 : _ref$loop;_classCallCheck(this, PolyIndex);
    this.vertex = vertex;
    this.loop = loop;
  }_createClass(PolyIndex, [{ key: "equals", value: function equals(
    v) {
      return v && this.vertex === v.vertex && this.loop === v.loop;
    } }]);return PolyIndex;}();


var Polygon = /*#__PURE__*/function (_PolyBase) {_inherits(Polygon, _PolyBase);var _super3 = _createSuper(Polygon);

  function Polygon() {var _this3;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polygon);
    _this3 = _super3.call(this, points, style);
    _this3.isClosed = true;return _this3;
  }

  // Draw Polygon into LmvCanvasContext
  _createClass(Polygon, [{ key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    }

    // We use even-odd rule if a polygon has multiple loops: A point is considered inside if it
    // is enclosed by an odd number of loops.
  }, { key: "hitTest", value: function hitTest(x, y) {
      if (!this.vertexCount) {
        return false;
      }

      // Compute number of loops that enclose (x,y)
      var rank = 0;
      for (var l = 0; l < this.loopCount; l++) {
        var loop = this._loops[l];
        if (!loop) {
          continue;
        }

        // set current loop as points
        var cp = new Autodesk.Extensions.CompGeom.ComplexPolygon(loop);

        // create dummy contour
        // TODO: Consider generalizing pointInCountour() to make it usable for non-indexed polygons
        var contour = [];
        for (var i = 0; i < loop.length; i++) {
          contour.push(i);
        }

        if (cp.pointInContour(x, y, contour)) {
          rank++;
        }
      }

      // Apply even-odd-rule
      return Boolean(rank & 1);
    } }, { key: "clone", value: function clone()

    {
      return new Polygon().copy(this);
    }

    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getArea", value: function getArea(measureTransform) {

      if (!this.isClosed) {
        return undefined;
      }

      // If there are multiple loops, we need loopInfos to distinguish inner and outer loops
      var loopInfos = this._getLoopInfos();

      var sumArea = 0;
      for (var loopIndex = 0; loopIndex < this.loopCount; loopIndex++) {

        // Skip degenerate loops
        if (this.points.length < 3) {
          continue;
        }

        // determine loop rank (number of other loops containing it)
        // Note that loopInfos are null for single loops where we don't need them.
        var loopInfo = loopInfos ? loopInfos[loopIndex] : null;
        var rank = loopInfo ? loopInfo.rank : 0;

        // Even-odd rule: Loops with odd rank are holes and contribute negatively
        var sign = rank & 1 ? -1 : 1;

        var loopArea = 0.0;
        this.enumEdges(function (a, b) {
          // apply optional transform
          measureTransform && measureTransform.apply(a);
          measureTransform && measureTransform.apply(b);

          // sum up signed areas
          loopArea += a.x * b.y - b.x * a.y;
        }, loopIndex);
        sumArea += sign * Math.abs(0.5 * loopArea);
      }
      return sumArea;
    } }]);return Polygon;}(PolyBase);


var Polyline = /*#__PURE__*/function (_PolyBase2) {_inherits(Polyline, _PolyBase2);var _super4 = _createSuper(Polyline);

  function Polyline() {var _this4;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polyline);
    _this4 = _super4.call(this, points, style);
    _this4.isClosed = false;return _this4;
  }_createClass(Polyline, [{ key: "makeLine", value: function makeLine()

    {var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var x1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var y1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      if (this.vertexCount !== 2) {
        this.clear();
        this.addPoint(x0, y0);
        this.addPoint(x1, y1);
      } else {
        this.updatePoint(0, x0, y0);
        this.updatePoint(1, x1, y1);
      }
      return this;
    }

    // Draw Polyline into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    } }, { key: "clone", value: function clone()

    {
      return new Polyline().copy(this);
    }

    // hitRadius is in layer-coords
  }, { key: "hitTest", value: function hitTest(x, y, hitRadius) {
      var edgeIndex = this.findEdgeIndex({ x: x, y: y }, hitRadius);
      return edgeIndex !== -1;
    } }]);return Polyline;}(PolyBase);


var EdgeType = {
  Line: 0, // Simple line segment
  Bezier: 1, // Cubic Bezier Arc
  Ellipse: 2 // Ellipse Arc
};


// Tmp objct for Ellipse Arcs. We need delayed initialization, 
// because Autodesk.Extensions.CompGeom might not be available yet at compile time.
var _tmpArc = null;
var getTmpArc = function getTmpArc() {
  _tmpArc = _tmpArc || new Autodesk.Extensions.CompGeom.EllipseArc();
  return _tmpArc;
};

var tmpVec = new THREE.Vector2();

// Helper function to run moveTo/lineTo/arcTo/closePath calls for a single loop of a path on a given context object.
//  @param {Path2d|LmvCanvasContext|Object} ctx       - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
//  @param {Polyline|Polygon|Path}          path
//  @param {number}                         loopIndex - must be a valid loop index in path
var runLoop = function runLoop(ctx, path, loopIndex) {

  var points = path._loops[loopIndex];
  if (!points || !points.length) {
    return;
  }

  // Trying to fill paths with NaN or infinite numbers may cause hangs in clipper. So, we prevent those here.
  if (!path.isLoopFinite(loopIndex)) {
    console.warn("Skipped loop, because it contains Inf or NaN values. Shape ID: ".concat(path.id, ". LoopIndex: ").concat(loopIndex));
    return;
  }

  ctx.moveTo(points[0].x, points[0].y);

  var processSegment = function processSegment(pStart, pEnd, edgeIndex) {
    switch (pStart.arcType) {
      case EdgeType.Line:break;

      case EdgeType.Bezier:{
          ctx.bezierCurveTo(pStart.cp1x, pStart.cp1y, pStart.cp2x, pStart.cp2y, pEnd.x, pEnd.y);
          return;
        }

      case EdgeType.Ellipse:{
          var params = pStart.ellipseArcParams;
          var arc = path.exportEllipseArc(edgeIndex, loopIndex, getTmpArc());

          // ignore arcs with NaN values
          if (!arc.isValid()) {
            break;
          }

          if (ctx.ellipseArcTo) {
            // Support SolidDef Path2D
            ctx.ellipseArcTo(params.rx, params.ry, THREE.Math.degToRad(params.rotation), params.largeArcFlag, params.sweepFlag, pEnd.x, pEnd.y);
          } else {
            // For Autodesk.CompGeom (Path2D and LmvCanvasContext). Also compatible to CanvasContext and Path2D in HTML5.
            ctx.ellipse(arc.cx, arc.cy, arc.rx, arc.ry, arc.rotation, arc.startAngle, arc.endAngle, arc.ccw);
          }

          return;
        }}

    ctx.lineTo(pEnd.x, pEnd.y);
  };

  for (var i = 1; i < points.length; i += 1) {
    // The segment start point defines the type (line or arc)
    var prev = points[i - 1];
    var p = points[i];

    processSegment(prev, p, i - 1);
  }

  if (path.isClosed) {
    // add closing segment
    var pLast = points[points.length - 1];
    var pFirst = points[0];
    processSegment(pLast, pFirst, points.length - 1);

    ctx.closePath();
  }
};

// Helper function to run moveTo/lineTo/arcTo/closePath calls on a given context object.
//  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
//  @param {Polyline|Polygon|Path}          path
var runPath = function runPath(ctx, path) {
  for (var i = 0; i < path.loopCount; i++) {
    runLoop(ctx, path, i);
  }
};

// Draw Path to CanvasContext. Unified implementation for Path, Polyline, and Polygon
//  @param {LmvCanvasContext}      ctx
//  @param {Polyline|Polygon|Path} path
//  @param {Style}                 [overrideStyle]
var drawPath = function drawPath(ctx, path, overrideStyle) {

  if (!path.vertexCount) {
    return;
  }

  var style = overrideStyle || path.style;
  var c = ctx.canvasContext;
  ctx.dbId = path.id;
  ctx.lineStyle = style.lineStyle;
  ctx.isScreenSpace = style.isScreenSpace;

  var currentGlobalCompositeOp = c.globalCompositeOperation;
  if (style.compositeOperation) {
    c.globalCompositeOperation = style.compositeOperation;
    // Make sure any previous shapes with a different blending are flushed first
    ctx.flushBuffer(0, true);
  }

  ctx.beginPath();

  // Run moveTo/lineTo/... commands on context
  runPath(ctx, path);

  // Draw fill for closed paths
  if (path.isClosed) {
    c.fillStyle = style.fillColor;
    // Creates a gradient fill style.
    if (style.fillColor.hasOwnProperty('colorStops')) {
      var gradientData = ctx.createGradientData(style.fillColor);
      var fillStyle = gradientData.getFillStyle(c);
      c.fillStyle = fillStyle;
    }
    c.globalAlpha = style.fillAlpha;

    ctx.fill();
  }

  // draw lines
  c.strokeStyle = style.lineColor;
  c.globalAlpha = style.lineAlpha;
  c.lineWidth = style.lineWidth;

  // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.
  // For human eyes the line width is then the same width.
  if (style.isScreenSpace) c.lineWidth *= window.devicePixelRatio;

  ctx.stroke();

  // restore default values
  ctx.dbId = -1;
  ctx.lineStyle = 0;
  ctx.isScreenSpace = false;
  c.globalCompositeOperation = currentGlobalCompositeOp;
};

// Extra params for cubic Bezier arc edges.
var BezierArcParams = /*#__PURE__*/function () {
  function BezierArcParams() {_classCallCheck(this, BezierArcParams);
    // control point 1 that defines start tangent
    this.cp1x = 0;
    this.cp1y = 0;

    // control point 2 that defines end tangent
    this.cp2x = 0;
    this.cp2y = 0;
  }_createClass(BezierArcParams, [{ key: "copy", value: function copy(

    src) {
      this.cp1x = src.cp1x;
      this.cp1y = src.cp1y;
      this.cp2x = src.cp2x;
      this.cp2y = src.cp2y;
      return this;
    } }, { key: "clone", value: function clone()

    {
      return new BezierArcParams().copy(this);
    } }]);return BezierArcParams;}();


// SVG compatible ellipse arc params
// see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands
var EllipseArcParams = /*#__PURE__*/function () {

  function EllipseArcParams() {_classCallCheck(this, EllipseArcParams);
    // {number} Radius along x-axis
    this.rx = 0;

    // {number} Radius along y-axis
    this.ry = 0;

    // {number} ccw rotation of x/y-axes in degrees
    this.rotation = 0;

    // {bool} whether to use shorter or longer path around ellipse.
    this.largeArcFlag = false;

    // {bool} Whether to go ccw (true) or cw (false) from startAngle. See SVG docs link above for details.
    this.sweepFlag = false;
  }_createClass(EllipseArcParams, [{ key: "copy", value: function copy(

    src) {
      this.rx = src.rx;
      this.ry = src.ry;
      this.rotation = src.rotation;
      this.largeArcFlag = src.largeArcFlag;
      this.sweepFlag = src.sweepFlag;
      return this;
    } }, { key: "clone", value: function clone()
    {
      return new EllipseArcParams().copy(this);
    }

    // @param {number} angle - counterclockwise in degrees
  }, { key: "rotate", value: function rotate(angle) {

      this.rotation += angle;

      // Normalize angle to keep within [0,360]
      this.rotation -= Math.trunc(this.rotation / 360) * 360;
    } }, { key: "scale", value: function scale(

    factor) {
      this.rx *= factor;
      this.ry *= factor;
    }

    // updates arc params according to a given transform.
    // Note: Transforming ellipse arcs is currently only supported for 
    //       simple transforms like translation, rotation, and uniform scaling.
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {

      // apply transform to x-axis direction
      tmpVec3.set(1, 0, 0).applyMatrix4(matrix);
      tmpVec3_2.set(0, 0, 0).applyMatrix4(matrix);
      var axis = tmpVec3.sub(tmpVec3_2);

      // obtain rotation angle and scale (assuming uniform scaling)
      var rotAngle = THREE.Math.radToDeg(Math.atan2(axis.y, axis.x));
      var scale = axis.length();

      // update ellipse params
      this.rotate(rotAngle);
      this.scale(scale);

      // If a transform changes the orientation, we have to invert sweepFlag and rotation param
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].changesOrientation(matrix)) {
        this.sweepFlag = !this.sweepFlag;
        this.rotation = 360.0 - this.rotation;
      }
    } }]);return EllipseArcParams;}();


var Path = /*#__PURE__*/function (_PolyBase3) {_inherits(Path, _PolyBase3);var _super5 = _createSuper(Path);

  function Path(points) {var _this5;var isClosed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultStyle.clone();_classCallCheck(this, Path);
    _this5 = _super5.call(this, points, style);

    // If true, the path is automatically closed and can be filled.
    _this5.isClosed = isClosed;return _this5;
  }

  // Updates ellipse arc of an edge if vertices of the edges are going to be modified   
  // @param {number} edgeIndex   - must be valid. Edge vertices must be in state _before_ modification.
  // @param {number} loopIndex   - must be valid. 
  // @param {Vector2} newA, newB - edge vertices after modification
  _createClass(Path, [{ key: "_updateEllipseArcParams", value: function _updateEllipseArcParams(edgeIndex, loopIndex, newA, newB) {

      var params = this._loops[loopIndex][edgeIndex].ellipseArcParams;

      // compute angle by which the edge was rotated
      var oldDir = this.getEdgeDirection(edgeIndex, loopIndex);
      var newDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(newA, newB);
      var dAngle = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].angleBetweenDirections(newDir, oldDir);

      params.rotate(THREE.Math.radToDeg(dAngle));

      // get scale factor applied to the edge
      var oldLength = this.getEdgeLength(edgeIndex, loopIndex);
      var newLength = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].distance2D(newA, newB); // also works for simple {x,y} pairs
      var scale = newLength / oldLength;

      // scale ellipse radii (if scaling is valid)
      var scaleValid = isFinite(scale) && scale > 0; // zero-radii do not work
      if (scaleValid) {
        params.scale(scale);
      }
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var points = this._loops[loopIndex];
      var p = points[index];

      var pNew = tmpVec.set(x, y);

      // If p is adjacent to a BezierArc segment, the tangent should keep the same after changing the position
      // Therefore, we change the corresponding control points as well
      var dx = x - p.x;
      var dy = y - p.y;

      // Control point for the start tangent of the arc segment starting at p
      if (this.isBezierArc(index, loopIndex)) {
        p.cp1x += dx;
        p.cp1y += dy;
      }

      // Update ellipse arc starting at p
      if (this.isEllipseArc(index, loopIndex)) {
        // next point must exist if index is a valid ellipse-arc edge.
        var nextIndex = this.nextIndex(index, loopIndex);
        var pNext = points[nextIndex];
        this._updateEllipseArcParams(index, loopIndex, pNew, pNext);
      }

      // Update arc params of segment ending at p
      // Note: For polylines, this edge does not exist for index==0
      var prevEdge = this.edgeBeforeVertex(index, loopIndex);
      if (this.edgeIndexValid(prevEdge, loopIndex)) {

        // get previous vertex
        var pPrev = points[prevEdge];

        // Update bezier control point
        if (this.isBezierArc(prevEdge, loopIndex)) {
          pPrev.cp2x += dx;
          pPrev.cp2y += dy;
        }

        // Update ellipse arc
        if (this.isEllipseArc(prevEdge, loopIndex)) {
          this._updateEllipseArcParams(prevEdge, loopIndex, pPrev, pNew);
        }
      }

      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "getEdgeType", value: function getEdgeType(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var type = this._loops[loopIndex][segmentIndex].arcType;
      return type ? type : EdgeType.Line;
    }

    // Change segment into a cubic Bezier arc.
    // First and last control point are already given by the vertex positions.    
    //        
    //  @param {number}             segmentIndex - must be in [0, this.getEdgeCount(loopIndex)]
    //  @param {BezierArcParams}    params
    //  @param {number} [loopIndex]
  }, { key: "setBezierArc", value: function setBezierArc(segmentIndex, params) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      // Legacy support:
      // If cp1x, cp2x etc. are enlisted individually, reshape params to expected form.
      // It's a pain that JS doesn't have function overloads.
      var isParamObj = _typeof(params) === 'object';
      if (!isParamObj) {
        params = {
          cp1x: params,
          cp1y: loopIndex,
          cp2x: arguments.length <= 3 ? undefined : arguments[3],
          cp2y: arguments.length <= 4 ? undefined : arguments[4] };

        loopIndex = (arguments.length <= 5 ? undefined : arguments[5]) || 0;
      }

      var p = this._loops[loopIndex][segmentIndex];
      p.arcType = EdgeType.Bezier;
      BezierArcParams.prototype.copy.call(p, params);

      this.modified();
    } }, { key: "getBezierArcParams", value: function getBezierArcParams(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BezierArcParams();
      // Find params
      var p = this._loops[loopIndex][segmentIndex];
      var srcParams = p && p.arcType === EdgeType.Bezier && p;

      // return a copy if found, otherwise undefined
      return srcParams && target.copy(srcParams);
    }

    // Set ellipse arc segment. Parameters are the same as for SVG ellipse arcs.
    // see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands
    //
    //  @param {number}   segmentIndex - must be in [0, this.getEdgeCount()]
    //  @param {EllipseArcParams} arcParams 
  }, { key: "setEllipseArc", value: function setEllipseArc(segmentIndex, arcParams) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var p = this._loops[loopIndex][segmentIndex];

      p.arcType = EdgeType.Ellipse;
      p.ellipseArcParams = arcParams.clone();

      this.modified();
    }

    // @param {number}           segmentIndex - must be a valid ellipse-arc edge
    // @param {EllipseArcParams} target
    // @returns {EllipseArcParams}
  }, { key: "getEllipseArcParams", value: function getEllipseArcParams(segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new EllipseArcParams();

      // Find params
      var p = this._loops[loopIndex][segmentIndex];
      var srcParams = p && p.arcType === EdgeType.Ellipse && p.ellipseArcParams;

      // Return a copy if found, otherwise undefined.
      return srcParams && target.copy(srcParams);
    }

    // Configures an EllipseArc curve to match with an ellipse-arc edge. This allows for sampling the arc.
    //  @param {number}     edgeIndex     - must be an ellipse arc
    //  @param {number}     [loopIndex=0] - loopIndex
    //  @param {EllipseArc} [target]      - optional
    //  @returns {EllipseArc}
  }, { key: "exportEllipseArc", value: function exportEllipseArc(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new EllipseArc();

      var points = this._loops[loopIndex];

      // get start/end points
      var nextIndex = this.nextIndex(edgeIndex, loopIndex);
      var pStart = points[edgeIndex];
      var pEnd = points[nextIndex];
      var params = pStart.ellipseArcParams;

      target.setFromSvgArc(
      params.rx,
      params.ry,
      params.rotation,
      params.largeArcFlag,
      params.sweepFlag,
      pStart,
      pEnd);

      return target;
    } }, { key: "isBezierArc", value: function isBezierArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(segmentIndex, loopIndex) && this._loops[loopIndex][segmentIndex].arcType === EdgeType.Bezier;
    } }, { key: "isEllipseArc", value: function isEllipseArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(segmentIndex, loopIndex) && this._loops[loopIndex][segmentIndex].arcType === EdgeType.Ellipse;
    } }, { key: "isArc", value: function isArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.isBezierArc(segmentIndex, loopIndex) || this.isEllipseArc(segmentIndex, loopIndex);
    }

    // Get tangent vector pointing from start vertex to control point 1 of an arc segment.
    // Only allowed for Bezier arcs. Result is not normalized.
    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @returns {Vector2}
  }, { key: "getStartTangent", value: function getStartTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var target = outTarget || new THREE.Vector2();
      var p = this.points[segmentIndex];
      target.x = p.cp1x - p.x;
      target.y = p.cp1y - p.y;
      return target;
    }

    // Get tangent vector pointing from end vertex to control point 2 of an arc segment.
    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @returns {Vector2}
  }, { key: "getEndTangent", value: function getEndTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var target = outTarget || new THREE.Vector2();
      var endVertex = this.nextIndex(segmentIndex);

      // get start/end point of the segment
      var pStart = this.points[segmentIndex];
      var pEnd = this.points[endVertex];
      target.x = pStart.cp2x - pEnd.x;
      target.y = pStart.cp2y - pEnd.y;
      return target;
    }

    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @param {Vector2} tangent
  }, { key: "setStartTangent", value: function setStartTangent(segmentIndex, tangent) {
      var p = this.points[segmentIndex];
      p.cp1x = p.x + tangent.x;
      p.cp1y = p.y + tangent.y;
      this.modified();
    }

    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @param {Vector2} tangent
  }, { key: "setEndTangent", value: function setEndTangent(segmentIndex, tangent) {
      var p = this.points[segmentIndex];
      var pEnd = this.points[this.nextIndex(segmentIndex)];
      p.cp2x = pEnd.x + tangent.x;
      p.cp2y = pEnd.y + tangent.y;
      this.modified();
    }

    // Change Bezier or Ellipse arc back to simple line segment
  }, { key: "removeArc", value: function removeArc(segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var p = this._loops[loopIndex][segmentIndex];

      if (p.arcType === EdgeType.Bezier) {
        p.cp1x = undefined;
        p.cp1y = undefined;
        p.cp2x = undefined;
        p.cp2y = undefined;
      }

      if (p.ellipseArcParams) p.ellipseArcParams = undefined;

      // reset type
      p.arcType = EdgeType.Line;

      this.modified();
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by
    //                                  current vertex position
    // @param {Vector2} [target]
    // @param {number}  [loopIndex]
  }, { key: "getControlPoint", value: function getControlPoint(segmentIndex, ctrlPointIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();
      var p = this._loops[loopIndex][segmentIndex];

      if (ctrlPointIndex === 1) {
        target.x = p.cp1x;
        target.y = p.cp1y;
      } else {
        target.x = p.cp2x;
        target.y = p.cp2y;
      }
      return target;
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by
    //                                  current vertex position
  }, { key: "updateControlPoint", value: function updateControlPoint(segmentIndex, ctrlPoint, x, y) {var loopIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var p = this._loops[loopIndex][segmentIndex];
      if (ctrlPoint === 1) {
        p.cp1x = x;
        p.cp1y = y;
      } else {
        p.cp2x = x;
        p.cp2y = y;
      }
      this.modified();
    }

    // Draw Polygon into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    }

    // Sample path into a Polygon or Polyline.
    //  @returns {Polygon|Polyline}
  }, { key: "toPoly", value: function toPoly() {var _this6 = this;var tessParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Autodesk.Extensions.CompGeom.DefaultTessParams;

      var poly = this.isClosed ? new Polygon() : new Polyline();var _loop = function _loop(
      l) {

        // Build up a polygon from path commands
        var ctx = {
          moveTo: function moveTo(x, y) {return poly.addPoint(x, y, l);},
          lineTo: function lineTo(x, y) {return poly.addPoint(x, y, l);},
          bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {

            // get last added point. Note that it always exists, because runLoop() always starts with moveTo.
            // so we know for sure that >=1 points were already added to this polygon loop.
            var points = poly._loops[l];
            var last = points[points.length - 1];

            // compute bbox of the arc - which we use as an estimate for required accuracy
            var arcBox = tmpBox2.makeEmpty();
            arcBox.expandByPoint(last);
            arcBox.expandByPoint(tmpVec2.set(x, y));
            arcBox.expandByPoint(tmpVec2.set(cp1x, cp1y));
            arcBox.expandByPoint(tmpVec2.set(cp2x, cp2y));
            var sz = arcBox.size(tmpVec).length();

            // sample arc into lineTo() segments
            Autodesk.Extensions.CompGeom.TesselateCubic(ctx, last.x, last.y, cp1x, cp1y, cp2x, cp2y, x, y, sz, tessParams);
          },
          ellipse: function ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {

            // use ellipse maxRadius a reference for required accuracy
            var sz = Math.max(rx, ry);

            // determine tesselation params                    
            var maxSegments = tessParams.numIterations;
            var minSegmentLength = tessParams.minSegLenFraction * sz;

            // tesselate arc
            var arc = getTmpArc().set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw);
            arc.tesselate(ctx, maxSegments, minSegmentLength);
          },
          closePath: function closePath() {} // Polygon is closed anyway.
        };
        runLoop(ctx, _this6, l);};for (var l = 0; l < this.loopCount; l++) {_loop(l);
      }
      return poly;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      // Compute bbox of all vertices
      _get(_getPrototypeOf(Path.prototype), "computeBBox", this).call(this);

      // Consider Bezier arcs: By definition, Bezier curves are always bounded by the convex hull of their control
      // points. Therefore, we can simply add the control points to the bbox.
      //
      // Note: The bboxes obtained by this simple approach are only guaranteed to contain the curve. But, they are not guaranteed to be minimal.
      //       This is not a big issue for most uses (hitTest, drawing etc.). In case it becomes a problem anywhere, we need a better solution here, e.g.
      //       https://stackoverflow.com/questions/24809978/calculating-the-bounding-box-of-cubic-bezier-curve
      var cp = new THREE.Vector2();
      for (var l = 0; l < this.loopCount; l++) {
        for (var i = 0; i < this.getVertexCount(l); i++) {

          if (this.isBezierArc(i, l)) {
            // add control point 1
            this.getControlPoint(i, 1, l, cp);
            this.bbox.expandByPoint(cp);

            // add control point 2
            this.getControlPoint(i, 2, l, cp);
            this.bbox.expandByPoint(cp);
          } else
          if (this.isEllipseArc(i, l)) {
            var arc = this.exportEllipseArc(i, l, getTmpArc());
            this.bbox.union(arc.computeBBox(tmpBox2));
          }
        }
      }
    } }, { key: "hitTest", value: function hitTest(

    x, y, hitRadius) {
      var poly = this.toPoly();
      return poly.hitTest(x, y, hitRadius);
    } }, { key: "clone", value: function clone()

    {
      return new Path().copy(this);
    }

    // @param {Path} srcPath
    // @param {number} srcLoopIndex loop in srcPath to copy
    // @param {number} [dstLoopIndex] Optional: index where to insert the new loop. By default, we use the first free loopIndex.
  }, { key: "addLoop", value: function addLoop(srcPath) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var dstLoopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

      // If dstLoop is not set, it will be chosen by the super.addLoop().
      dstLoopIndex = _get(_getPrototypeOf(Path.prototype), "addLoop", this).call(this, srcPath, srcLoopIndex, dstLoopIndex);

      var srcPoints = srcPath._loops[srcLoopIndex];
      var dstPoints = this._loops[dstLoopIndex];

      // Copy extra information for arcs
      for (var i = 0; i < srcPoints.length; i++) {
        var type = srcPath.getEdgeType(i, srcLoopIndex);

        // Line segments are fully handled by the base class already
        if (type === EdgeType.Line) {
          continue;
        }

        var src = srcPoints[i];
        var dst = dstPoints[i];

        dst.arcType = src.arcType;

        switch (type) {
          case EdgeType.Bezier:{
              // copy control points
              dst.cp1x = src.cp1x;
              dst.cp1y = src.cp1y;
              dst.cp2x = src.cp2x;
              dst.cp2y = src.cp2y;
              break;
            }
          case EdgeType.Ellipse:{
              // copy arc params
              dst.ellipseArcParams = src.ellipseArcParams && src.ellipseArcParams.clone();
              break;
            }}

      }

      this.modified();
      return this;
    } }, { key: "moveLoop", value: function moveLoop(

    dx, dy, loopIndex) {
      _get(_getPrototypeOf(Path.prototype), "moveLoop", this).call(this, dx, dy, loopIndex);

      // Move affected control points as well
      var points = this._loops[loopIndex];
      for (var i = 0; i < points.length; i++) {
        if (!this.isBezierArc(i, loopIndex)) {
          continue;
        }

        var p = points[i];
        p.cp1x += dx;
        p.cp1y += dy;
        p.cp2x += dx;
        p.cp2y += dy;
      }

      // Note that for Ellipse arcs, it is sufficient to move start/end like for line segments.
    } }, { key: "getArea", value: function getArea(

    measureTransform) {
      if (!this.isClosed) {
        return undefined;
      }

      // Todo: If performance becomes an issue, this can be optimized by a less brute-force way.
      var poly = this.toPoly(AreaTessParam);

      // Since poly is just temporary, we can just share the loop infos to prevent poly.getArea()
      // from computing them again.
      poly._loopInfos = this._getLoopInfos();

      return poly.getArea(measureTransform);
    } }, { key: "getLength", value: function getLength(

    measureTransform) {
      var poly = this.toPoly();
      return poly.getLength(measureTransform);
    }

    // Get point on segment. This refines the implementation 
    // of PolyBase by supporting arc segments.
  }, { key: "getPointOnEdge", value: function getPointOnEdge(segmentIndex, t) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();

      var points = this._loops[loopIndex];
      var type = this.getEdgeType(segmentIndex, loopIndex);
      switch (type) {
        case EdgeType.Line:break;
        case EdgeType.Bezier:{
            // get segment start/end
            var a = points[segmentIndex];
            var b = points[this.nextIndex(segmentIndex)];

            return Autodesk.Extensions.CompGeom.getCubeBezierPoint(t, a.x, a.y, a.cp1x, a.cp1y, a.cp2x, a.cp2y, b.x, b.y, target);
          }
        case EdgeType.Ellipse:{
            var arc = this.exportEllipseArc(segmentIndex, loopIndex, getTmpArc());

            // ignore arcs with NaN values
            if (!arc.isValid()) {
              break;
            }
            return arc.getPoint(t, target);
          }
        default:avp.logger.error('unexpected edge type');}


      return _get(_getPrototypeOf(Path.prototype), "getPointOnEdge", this).call(this, segmentIndex, t, loopIndex, target);
    }

    // Run moveTo/lineTo/arcTo/closePath calls on a given context object.    
    //  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
  }, { key: "runPathCommands", value: function runPathCommands(ctx) {
      runPath(ctx, this);
    }

    // Returns false if all edges of all loops are line segments.
  }, { key: "hasArcs", value: function hasArcs() {var _this7 = this;
      var filter = function filter(vertexIndex, loopIndex) {return _this7.isArc(vertexIndex, loopIndex);};
      return Boolean(this.findVertex(filter));
    } }]);return Path;}(PolyBase);


// Alias that can be used for Polyline/Polygon paths. Use only if you don't intend to change the isClosed prop during lifetime.
var PolygonPath = /*#__PURE__*/function (_Path) {_inherits(PolygonPath, _Path);var _super6 = _createSuper(PolygonPath);
  function PolygonPath(points, style) {_classCallCheck(this, PolygonPath);return _super6.call(this,
    points, true, style);
  }return PolygonPath;}(Path);
;

var PolylinePath = /*#__PURE__*/function (_Path2) {_inherits(PolylinePath, _Path2);var _super7 = _createSuper(PolylinePath);
  function PolylinePath(points, style) {_classCallCheck(this, PolylinePath);return _super7.call(this,
    points, false, style);
  }return PolylinePath;}(Path);
;

var Circle = /*#__PURE__*/function (_Shape2) {_inherits(Circle, _Shape2);var _super8 = _createSuper(Circle);

  // Note: The tessSegments parameter will be removed later when the implementation uses arcs from LineShader directly.
  function Circle() {var _this8;var centerX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;var centerY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultStyle.clone();var tessSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;_classCallCheck(this, Circle);
    _this8 = _super8.call(this, style);

    _this8.polygon = new Polygon([], style);

    // Force polygon.id to be the same, so that its geometry is associated with this Circle.
    // This is a bit hacky, but can be removed as soon as we use native arcs for circle rendering.
    _this8.polygon.id = _this8.id;

    _this8.centerX = centerX;
    _this8.centerY = centerY;
    _this8.radius = radius;
    _this8.tessSegments = tessSegments;

    _this8.needsUpdate = true;return _this8;
  }_createClass(Circle, [{ key: "draw", value: function draw(

    ctx, overrideStyle) {

      this.polygon.points.length = 0;

      // angle delta in degrees
      var stepSize = 360 / this.tessSegments;
      for (var angle = 0; angle < 360; angle += stepSize) {

        var a = angle * Math.PI / 180;
        var x = this.radius * Math.cos(a);
        var y = this.radius * Math.sin(a);

        this.polygon.addPoint(this.centerX + x, this.centerY + y);
      }

      this.needsUpdate = false;

      this.polygon.draw(ctx, overrideStyle);
    } }, { key: "setCenter", value: function setCenter(

    x, y) {
      this.centerX = x;
      this.centerY = y;
      this.modified();
    } }, { key: "move", value: function move(

    dx, dy) {
      this.centerX += dx;
      this.centerY += dy;
      this.modified();
      return this;
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      var dx = x - this.centerX;
      var dy = y - this.centerY;
      return dx * dx + dy * dy < this.radius * this.radius;
    } }, { key: "clone", value: function clone()

    {
      return new Circle().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(Circle.prototype), "copy", this).call(this, from);
      this.polygon = from.polygon.clone();
      this.centerX = from.centerX;
      this.centerY = from.centerY;
      this.radius = from.radius;
      this.tessSegments = from.tessSegments;
      this.modified();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.min.set(this.centerX - this.radius, this.centerY - this.radius);
      this.bbox.max.set(this.centerX + this.radius, this.centerY + this.radius);
    } }]);return Circle;}(Shape);


var ShapeWrapper = /*#__PURE__*/function (_Shape3) {_inherits(ShapeWrapper, _Shape3);var _super9 = _createSuper(ShapeWrapper);

  // @param {Shape} shape - must not be null
  function ShapeWrapper(shape) {var _this9;_classCallCheck(this, ShapeWrapper);
    _this9 = _super9.call(this);
    _this9.shape = shape;

    Object.defineProperty(_assertThisInitialized(_this9), 'bbox', {
      get: function get() {return _this9.shape.bbox;},
      set: function set(bbox) {_this9.shape.bbox = bbox;} });


    Object.defineProperty(_assertThisInitialized(_this9), 'id', {
      get: function get() {return _this9.shape.id;},
      set: function set(id) {_this9.shape.id = id;} });


    Object.defineProperty(_assertThisInitialized(_this9), 'bboxDirty', {
      get: function get() {return _this9.shape.bboxDirty;},
      set: function set(dirty) {_this9.shape.bboxDirty = dirty;} });


    Object.defineProperty(_assertThisInitialized(_this9), 'name', {
      get: function get() {return _this9.shape.name;},
      set: function set(name) {_this9.shape.name = name;} });return _this9;

  }_createClass(ShapeWrapper, [{ key: "draw", value: function draw()

    {var _this$shape;return (_this$shape = this.shape).draw.apply(_this$shape, arguments);} }, { key: "hitTest", value: function hitTest()
    {var _this$shape2;return (_this$shape2 = this.shape).hitTest.apply(_this$shape2, arguments);} }, { key: "move", value: function move()
    {var _this$shape3;return (_this$shape3 = this.shape).move.apply(_this$shape3, arguments);} }, { key: "modified", value: function modified()
    {var _this$shape4;return (_this$shape4 = this.shape).modified.apply(_this$shape4, arguments);} }, { key: "computeBBox", value: function computeBBox()
    {var _this$shape5;return (_this$shape5 = this.shape).computeBBox.apply(_this$shape5, arguments);} }, { key: "updateBBox", value: function updateBBox()
    {var _this$shape6;return (_this$shape6 = this.shape).updateBBox.apply(_this$shape6, arguments);} }, { key: "clone", value: function clone()

    {
      return new ShapeWrapper(this.shape.clone());
    } }, { key: "copy", value: function copy(

    from) {
      this.shape.copy(from.shape);
    } }]);return ShapeWrapper;}(Shape);

/***/ }),

/***/ "./extensions/Edit2D/LoopContainment.js":
/*!**********************************************!*\
  !*** ./extensions/Edit2D/LoopContainment.js ***!
  \**********************************************/
/*! exports provided: getFacesInsideLoop, computeLoopContainment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFacesInsideLoop", function() { return getFacesInsideLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeLoopContainment", function() { return computeLoopContainment; });
/* harmony import */ var _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SolidDefConvert.js */ "./extensions/Edit2D/SolidDefConvert.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adsk/solid-definition */ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__);
function _readOnlyError(name) {throw new Error("\"" + name + "\" is read-only");}function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}



// Result values of classifySets
var SetContainment = {
  Contains: 0, // A contains B (not vice versa)
  IsContainedIn: 1, // B contains A (not vice versa)
  Disjoint: 2, // No common elements
  Overlapping: 3, // Intersecting, but not equal
  Equal: 4 // Sets are identical
};

// @param {SketchRegionSolver} solver       - initialized with all edges of subject and cutLoop
// @param {Edges[]}            loopEdges    - edges of the loop that we test against.
// @returns {Face[]} subset of solver.getFaces(). All faces encludes by the loopEdges.
var getFacesInsideLoop = function getFacesInsideLoop(solver, loopEdges) {

  // Get all faces that we obtained by intersecting all edges against each other
  var regionFaces = solver.getFaces();

  // Get ordered array of loop edges within solver that correspond to the cutLoop
  var cutRegionEdges = Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["getRegionEdges"])(solver, loopEdges);

  // Find all faces that are 
  return Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["getBoundedRegionFaces"])(regionFaces, cutRegionEdges);
};

// Tolerance for self-intersection tests: If intersections are very close to a shared vertex, we ignore them.
// Note that the tolerance is not in units but a fraction of an edge.
var Precision = 1.e-5;

// Check whether a single loop has self-intersections
// TODO: There is one edge case that we would not detect here: If a loop passes the same vertex multiple times.
var hasSelfIntersections = function hasSelfIntersections(loopEdges) {
  for (var _i = 0; _i < loopEdges.length; _i++) {
    var edge1 = loopEdges[_i];

    // Check all subsequent edges.
    for (var j = _i + 1; j < loopEdges.length; j++) {

      // Check intersections of both edges
      var edge2 = loopEdges[j];
      var cuts = Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["computeCurveCurveIntersections"])(edge1, edge2, false, true);

      // Check if there are any intersections (except for shared vertices)
      for (var _i2 = 0; _i2 < cuts.length; _i2++) {
        var cut = cuts[_i2];

        // Ignore intersections at a shared vertex
        // Due to accuracy issues, the cut may also be just close to a vertex
        var param1 = cut.cutInfo.param;
        var param2 = cut.cutByInfo.param;

        var range1 = edge1.getRange();
        var range2 = edge2.getRange();

        // Check if both parameters are very close to range start/end of an edge
        var dist1 = Math.min(Math.abs(param1 - range1[0]), Math.abs(param1 - range1[1]));
        var dist2 = Math.min(Math.abs(param2 - range2[0]), Math.abs(param2 - range2[1]));
        var d = Math.max(dist1, dist2);

        // If cut was not approximately equal to a shared vertex,
        // consider it as a self-intersection.
        if (d > Precision) {
          return true;
        }
      }
    }
  }
  return false;
};

// Given two sets of values, faces, each indexed by integer faceIds, this function checks how the sets are related.
var classifySets = function classifySets(A, B) {

  // Track which kind of indices we found
  var foundCommon = false; // >=0 elems are in both
  var foundAOnly = false; // >=0 elems are only in set A
  var foundBOnly = false; // >=0 elems are only in set B

  var checkElems = function checkElems(elemIndex) {
    var isInA = A.has(elemIndex);
    var isInB = B.has(elemIndex);

    if (isInA && isInB) foundCommon = true;else
    if (isInA) foundAOnly = true;else
    if (isInB) foundBOnly = true;
  };var _iterator = _createForOfIteratorHelper(

  A),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var elem = _step.value;
      checkElems(elem);
    }} catch (err) {_iterator.e(err);} finally {_iterator.f();}var _iterator2 = _createForOfIteratorHelper(

  B),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var _elem = _step2.value;
      checkElems(_elem);
    }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}

  if (!foundCommon) {
    return SetContainment.Disjoint;
  }

  if (foundAOnly && !foundBOnly) {
    return SetContainment.Contains;
  }

  if (foundBOnly && !foundAOnly) {
    return SetContainment.IsContainedIn;
  }

  if (!foundAOnly && !foundBOnly) {
    return SetContainment.Equal;
  }

  return SetContainment.Overlapping;
};

// Contains loop containment for a path
var computeLoopContainment = function computeLoopContainment(path) {

  // Convert to SolidDef Path
  var pathSd = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(path);

  // get path as wires
  var wireBody = pathSd.getWireBody();
  var wires = wireBody.getWires();

  // get path as edge array
  var edges = wireBody.getEdges();

  // Init empty loop infos
  var loopInfos = [];
  for (var l = 0; l < wires.length; l++) {

    // Get loop edges
    var w = wires[l];
    var loopEdges = w.getEdges();

    loopInfos[l] = {
      containedLoops: [],
      rank: 0,

      // Indicates if loop containment could not properly computed. 
      // This happens if 
      //   a) The loop has self-intersections
      //   b) The loop is overlapping with another one
      //   c) The loop is exactly matching with another one
      error: hasSelfIntersections(loopEdges) // Initially, we detect only a)
    };
  }

  // For only a single loop or less, we are done here.
  if (wires.length < 2) {
    return loopInfos;
  }

  // Feed them into solver to intersect them against each other and extract the resulting region faces.
  var solver = new _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["SketchRegionSolver"]();
  solver.compute(edges);

  // check which of the faces are within path and cutPath
  var faces = solver.getFaces();

  // attach arrayIndex to each face
  faces.forEach(function (f, index) {return f.arrayIndex = index;});

  // for each loop l, collect a set facesPerLoop[l] that contains the array indices of all enclosed faces.     
  var facesPerLoop = [];var _loop = function _loop(
  _l) {

    // get edges of loop i
    var w = wires[_l];
    var loopEdges = w.getEdges();

    // If a loop has self-intersections, just mark it as invalid and skip it
    if (hasSelfIntersections(loopEdges)) {
      loopInfos[_l].error = true;
      facesPerLoop[_l] = new Set();
      return "continue";
    }

    // get all faces within this loop
    var enclosedFaceIds = new Set();
    var faces = getFacesInsideLoop(solver, loopEdges);
    faces.forEach(function (f) {
      enclosedFaceIds.add(f.arrayIndex);
    });

    facesPerLoop[_l] = enclosedFaceIds;};for (var _l = 0; _l < wires.length; _l++) {var _ret = _loop(_l);if (_ret === "continue") continue;
  }

  // Use the faceId sets to derive which loop is contained in which other    
  for (var a = 0; a < facesPerLoop.length; a++) {

    // indices of all faces enclosed by loop a
    var A = facesPerLoop[a];

    for (var b = a + 1; b < facesPerLoop.length; b++) {
      // indices of all faces enclosed by loop i
      var B = facesPerLoop[b];

      // Check set relation between A and B
      var cont = classifySets(A, B);
      switch (cont) {
        case SetContainment.Disjoint:
          // No common faces at all. E.g., for two holes.
          continue;
        case SetContainment.Contains:
          loopInfos[a].containedLoops.push(b);
          loopInfos[b].rank++;
          break;
        case SetContainment.IsContainedIn:
          loopInfos[b].containedLoops.push(b);
          loopInfos[a].rank++;
          break;
        default:
          loopInfos[a].error = true;
          loopInfos[b].error = true;}

    }
  }

  // If the original paths contained empty loops, we may have to reindex the loopInfos,
  // because empty loops will not produce a corresponding wire in the SolidDef representation.
  if (wires.length !== path.loopCount) {
    var reindexed = [];
    var srcIndex = 0;
    for (var _l2 = 0; _l2 < path.loopCount; _l2++) {
      // Only non-empty loops get loopInfos
      if (path.getVertexCount(_l2)) {
        reindexed[i] = loopInfos[(_readOnlyError("srcIndex"), srcIndex++)];
      }
    }
    loopInfos = (_readOnlyError("loopInfos"), reindexed);
  }

  return loopInfos;
};

/***/ }),

/***/ "./extensions/Edit2D/Math2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Math2D.js ***!
  \*************************************/
/*! exports provided: Math2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math2D", function() { return Math2D; });
var tmpVec2d = new THREE.Vector2();
var tmpVec2d2 = new THREE.Vector2();

// Collection of simple helper functions for 2D math functions.

// Return normalized edge direction vector (b-a).normalized
var getEdgeDirection = function getEdgeDirection(a, b, target) {
  target = target || new THREE.Vector2();

  return target.copy(b).sub(a).normalize();
};

var getEdgeCenter = function getEdgeCenter(a, b, target) {
  target = target || new THREE.Vector2();

  return target.set(0.5 * (a.x + b.x), 0.5 * (a.y + b.y));
};

// Get edge length. (a, b) can just be {x, y} pairs, i.e., not required to be THREE.Vector2
var getEdgeLength = function getEdgeLength(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Rotates direction vector p 90 degrees to the left. (in-place)
var turnLeft = function turnLeft(p) {
  var tmp = p.x;
  p.x = -p.y;
  p.y = tmp;
  return p;
};

// Projects a point p to a line. Works in-place
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var projectToLine = function projectToLine(p, linePoint, lineDir) {

  // dp = dot(p-linePoint, lineDir)
  var dp = (p.x - linePoint.x) * lineDir.x + (p.y - linePoint.y) * lineDir.y;

  // return linePoint + lineDir * dp
  p.set(
  linePoint.x + dp * lineDir.x,
  linePoint.y + dp * lineDir.y);

};

// Get distance between the point p and a line given by point and direction.
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var pointLineDistance = function () {
  var pProj = new THREE.Vector2();
  return function (p, linePoint, lineDir) {
    projectToLine(pProj.copy(p), linePoint, lineDir);
    return p.distanceTo(pProj);
  };
}();

// Calculates the intersection point of both given lines
// assumes that the lines are not parallel
// see: http://www.paulbourke.net/geometry/pointlineplane/
var intersectLines = function intersectLines(linePoint1, lineDir1, linePoint2, lineDir2, outPoint) {

  var denom = lineDir2.y * lineDir1.x - lineDir2.x * lineDir1.y;
  if (Math.abs(denom) < 1.0e-8) {return false;}

  // diff = linePoint1 - linePoint2
  var diffX = linePoint1.x - linePoint2.x;
  var diffY = linePoint1.y - linePoint2.y;

  var u = lineDir2.x * diffY - lineDir2.y * diffX;

  if (outPoint) {
    outPoint.x = linePoint1.x + u / denom * lineDir1.x;
    outPoint.y = linePoint1.y + u / denom * lineDir1.y;
  }
  return true;
};

// Rotate a vector p around origin or a given center. Works in-place.
//  @param {Vector2} p
//  @param {number}  angle in radians
//  @param [Vector2] center 
var rotateAround = function rotateAround(p, angle, center) {

  var c = Math.cos(angle);
  var s = Math.sin(angle);

  if (center) {
    p.sub(center);
  }

  var x = p.x;
  var y = p.y;

  p.x = x * c - y * s;
  p.y = x * s + y * c;

  if (center) {
    p.add(center);
  }
  return p;
};

//  @param {Vector2} dir1, dir2           - No normalization required.
//  @returns {number} result in [0, 2*Pi] - clockwise angle in radians that you have to apply to rotate dir2 into dir1.
var angleBetweenDirections = function angleBetweenDirections(dir1, dir2) {

  // get angle formed with positive x-axis. 
  // angle1/2 are in [-Pi, Pi]
  var angle1 = Math.atan2(dir1.y, dir1.x);
  var angle2 = Math.atan2(dir2.y, dir2.x);

  // Difference is in [-2*Pi, 2*Pi]
  var angle = angle1 - angle2;

  // Map result to [0, 2*Pi] range
  if (angle < 0) angle += 2 * Math.PI;

  return angle;
};

// see isPointOnEdge
var isPointOnLine = function isPointOnLine(p, a, b, precision) {
  return isPointOnEdge(p, a, b, precision, false);
};

// Returns true if p lies close to the edge (p1, p2). 
var isPointOnEdge = function isPointOnEdge(p, a, b, precision) {var checkInsideSegment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

  // Compute edge length
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  var length = Math.sqrt(dx * dx + dy * dy);

  var e = {
    v1: a,
    dx: dx,
    dy: dy,
    length: length,
    length2: length * length };

  return Autodesk.Extensions.CompGeom.pointOnLine(p.x, p.y, e, checkInsideSegment, precision);
};

var pointDelta = function pointDelta(a, b) {var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var delta = { x: b.x - a.x, y: b.y - a.y };
  if (digits)
  {
    var exp = Math.pow(10, digits);
    delta.x = Math.round(delta.x * exp) / exp;
    delta.y = Math.round(delta.y * exp) / exp;
  }
  if (!delta.x && !delta.y) {
    return;
  }
  return delta;
};

var edgeIsDegenerated = function edgeIsDegenerated(a, b) {var eps2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0e-10;
  return a.distanceToSquared(b) < eps2;
};

// Compute target point resulting from mirroring point p
// on the given center point c.
var mirrorPointOnPoint = function mirrorPointOnPoint(p, c) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  target = target || new THREE.Vector2();
  target.x = c.x - (p.x - c.x);
  target.y = c.y - (p.y - c.y);
  return target;
};

var fuzzyEqual = function fuzzyEqual(a, b, precision) {
  return Math.abs(a - b) < precision;
};

// Checks if two lines are collinear.
//  @param {Vector2} p1, dir1 - First line, given as point and normalized direction.
//  @param {Vector2} p2, dir2 - Second line
//  @param {number}  precision
//  @returns {bool}
var collinear = function collinear(p1, dir1, p2, dir2, precision) {

  // Directions must be either equal or opposite
  var dirEqual = fuzzyEqual(dir1.x, dir2.x, precision) && fuzzyEqual(dir1.y, dir2.y, precision);
  var dirOpposite = fuzzyEqual(dir1.x, -dir2.x, precision) && fuzzyEqual(dir1.y, -dir2.y, precision);
  if (!dirEqual && !dirOpposite) {
    return false;
  }

  // Directions are equal or opposite => Lines are collinear if and only if p2 is on line (p1, dir1).
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  var dot = dx * dir1.x + dy * dir1.y;
  return Math.abs(dot) < precision;
};

// same as p1.distanceTo(p2), but working for any {x,y} object.
var distance2D = function distance2D(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Checks if a matrix changes the orientation.
//  @param {Matrix4} matrix
var changesOrientation = function changesOrientation(matrix) {
  return matrix.determinant() < 0;
};

// Compute a matrix that transforms fromBox into toBox.
//
//  @param {Box2}    fromBox
//  @param {Box2}    toBox
//  @param {Object}  [options]
//  @param {bool}    [options.flipY]           - include y-axis flip
//  @param {bool}    [options.preserveAspect]  - force uniform scaling (m * fromBox might be smaller than toBox in one axis)
//  @param {Matrix4} [target]
var getFitToBoxTransform = function getFitToBoxTransform(fromBox, toBox) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Matrix4();
  var fromSize = fromBox.size(tmpVec2d);
  var toSize = toBox.size(tmpVec2d2);

  // compute scale   
  var sx = toSize.x / fromSize.x;
  var sy = toSize.y / fromSize.y;

  // preserveAspect
  if (options.preserveAspect) {
    sx = Math.min(sx, sy);
    sy = sx;
  }

  // anchor is the point of fromBox that will be mapped to toBox.min
  var anchorX = fromBox.min.x;
  var anchorY = fromBox.min.y;

  // apply optional y-flip
  if (options.flipY) {
    sy *= -1;
    anchorY = fromBox.max.y;
  }

  // compute translation: after scaling, anchor should move to toBox.min
  var tx = -sx * anchorX + toBox.min.x;
  var ty = -sy * anchorY + toBox.min.y;

  // Create (scale + translate)-matrix.
  var matrix = target.makeScale(sx, sy, 1.0);
  matrix.elements[12] = tx;
  matrix.elements[13] = ty;

  return matrix;
};

var Math2D = {
  getEdgeDirection: getEdgeDirection,
  projectToLine: projectToLine,
  pointLineDistance: pointLineDistance,
  intersectLines: intersectLines,
  rotateAround: rotateAround,
  angleBetweenDirections: angleBetweenDirections,
  getEdgeCenter: getEdgeCenter,
  getEdgeLength: getEdgeLength,
  turnLeft: turnLeft,
  isPointOnEdge: isPointOnEdge,
  isPointOnLine: isPointOnLine,
  pointDelta: pointDelta,
  edgeIsDegenerated: edgeIsDegenerated,
  mirrorPointOnPoint: mirrorPointOnPoint,
  fuzzyEqual: fuzzyEqual,
  collinear: collinear,
  distance2D: distance2D,
  changesOrientation: changesOrientation,
  getFitToBoxTransform: getFitToBoxTransform };

/***/ }),

/***/ "./extensions/Edit2D/SolidDefConvert.js":
/*!**********************************************!*\
  !*** ./extensions/Edit2D/SolidDefConvert.js ***!
  \**********************************************/
/*! exports provided: SolidDefConvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SolidDefConvert", function() { return SolidDefConvert; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adsk/solid-definition */ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__);





var tmpVec1 = new THREE.Vector3();
var tmpVec2 = new THREE.Vector3();

// Convert SolidDef float-array to THREE-Vector3
var toVec3 = function toVec3(ar) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();
  return target.set(ar[0], ar[1], ar[2]);
};

// Add (directed) edge segment to an Edit2D path. If path is non-empty, it is
// assumed that it already ends at the start point of the new edge
//  @param {Path}                     path         - Edit2D path
//  @param {SolidDef.Coedge|SolidDef} ce           - Directed edge from SolidDef 
//  @param {number}                   loopIndex    - index of the loop in target path where we add the edge to
//  @param {bool}                     lastLoopEdge - For the last edge in a loop, we only copy the arc params, but don't add the end vertex.
//                                                   This is because Edit2D shapes do not repeat the start vertex at the end.
var addCoedge = function addCoedge(path, ce, loopIndex) {var lastLoopEdge = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var vertexCount = path.getVertexCount(loopIndex);

  // Add start vertex on first call
  if (vertexCount == 0) {
    var pStart = ce.getStartVertex().getPosition();
    path.addPoint(pStart[0], pStart[1], loopIndex);
  }

  // Add end point - unless this is the last edge of a loop.
  if (!lastLoopEdge) {
    var pEnd = ce.getEndVertex().getPosition();
    path.addPoint(pEnd[0], pEnd[1], loopIndex);
  }

  // This function works for Coedges as well as edges. If ce is already an edge, we just set e=ce.
  var isCoedge = ce instanceof _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["Coedge"];
  var e = isCoedge ? ce.getEdge() : ce;

  // Determine whether the curve direction is flipped. For coedges, this may happen up to twice, because
  // cedge as well as edge have their own isReversed flag.
  var ceReversed = isCoedge ? ce.isReversed() : false;
  var edgeReversed = e.isReversed();
  var isReversed = ceReversed !== edgeReversed; // logical XOR (true if exactly one of both is reversed)

  var type = e.getCurveType();

  // For line segments, we are done
  if (type === _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPES"].LINE) {
    return;
  }

  // convert curve parameters for new edge
  var edgeIndex = Math.max(vertexCount - 1, 0);
  var curve = e.getCurve();

  // Bezier case
  if (type === _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPES"].BCURVE) {

    // Note that we cannot simply copy the control points of the SolidDef bcurve. Reasons:
    //  1. Coedge or edge may be reversed (which may invert the order of the control points)
    //  2. The edge may not cover the whole curve, but only a part of it.
    //
    // Due to 2. we have to construct a new cubic Bezier here based start/end tangent of the edge.

    // get params at edge start/end
    var t0 = ce.t0();
    var t1 = ce.t1();

    // get start/end point
    var _pStart = ce.evaluatePosition(t0);
    var _pEnd = ce.evaluatePosition(t1);

    // get start/end tangent
    var tStart = ce.evaluateDt(t0);
    var tEnd = ce.evaluateDt(t1);

    // We are searching for a cubic Bezier B with the following properties:
    //  - Its parameter domain is [0,1], i.e. B(0)=start vertex, B(1) is end vertex
    //  - Tangents at start/end positions are the same as for the given edge.

    // Note that changing from [t0, t1] to a larger parameter domain [0,1] scales down the tangent vectors accordingly.
    var rangeScale = Math.abs(t1 - t0);
    tStart[0] *= rangeScale;
    tStart[1] *= rangeScale;
    tEnd[0] *= rangeScale;
    tEnd[1] *= rangeScale;

    // The start tangent of a cubic bezier is 3 * (cp1-cp0). So, we can obtain cp1 from the start tangent.
    // Same principle applies to cp2.
    var cp1x = _pStart[0] + tStart[0] / 3;
    var cp1y = _pStart[1] + tStart[1] / 3;
    var cp2x = _pEnd[0] - tEnd[0] / 3;
    var cp2y = _pEnd[1] - tEnd[1] / 3;

    path.setBezierArc(edgeIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);
    return;
  }

  // Ellipse arcs
  if (type === _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPES"].ELLIPSE) {

    var params = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
    params.rx = curve.getMajorRadius();
    params.ry = curve.getMinorRadius();

    // compute axis rotation
    var xAxis = curve.getMajorAxis();
    var angle = Math.atan2(xAxis[1], xAxis[0]);
    params.rotation = THREE.Math.radToDeg(angle);

    // determine largeArc flag
    // Note that the edge may only use a subset of the curve. 
    // So, it's essential to get the range from the directed edge.
    var range = ce.getRange();
    var startAngle = range[0];
    var endAngle = range[1];
    params.largeArcFlag = endAngle - startAngle > Math.PI; // Note that endAngle is always >startAngle

    // determine sweep flag: Ellipse curves in SolidDef always run ccw (sweepFlag = true).
    // But it may be inverted if the edge direction is flipped.
    params.sweepFlag = !isReversed;

    // Note: In Edit2D, the unrotated y-axis always points up. I.e. rotation=0 means xAxis = (1,0) and yAxis = (-1,0).
    //       In SolidDef, the axes are more flexible. As long as we don't transform the curves arbitrarily, the ellipse
    //       axes still form a 90 degree angle. However, the ellipse coordinate system may have opposite orientation.
    //       If this happens, we have to invert the ellipse orientation.
    var yAxis = curve.getMinorAxis();
    var xDir = toVec3(xAxis, tmpVec1);
    var yDir = toVec3(yAxis, tmpVec2);
    var needsExtraFlip = xDir.cross(yDir).z < 0;
    if (needsExtraFlip) {
      params.sweepFlag = !params.sweepFlag;
    }

    path.setEllipseArc(edgeIndex, params, loopIndex);
    return;
  }

  console.error("Unexpected curve type");
};

// Creates an Edit2D Path loop from a given SoliDef loop. The loop is added to the target path.
//  @param {SolidDef.Loop} loop
//  @param {Path}          [target]
//  @returns {Path}
var loopToShape = function loopToShape(loop) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  // start new loop in target path
  var loopIndex = target.nextFreeLoop();

  // traverse coedges of the loop
  var coedges = loop.getCoedges();
  for (var i = 0; i < coedges.length; i++) {
    var ce = coedges[i];

    // for the last loopEdge, we only copy the arc param, but don't repeat the start vertex
    var lastLoopEdge = i == coedges.length - 1;

    // add next edge to target
    addCoedge(target, ce, loopIndex, lastLoopEdge);
  }

  return target;
};

// Convert SolidDef face into one or more Edit2D Paths.
// Todo: If we support multiple loops per Path, result will be a single Path
//  @param {SolidDef.Face} face
//  @param {Path}          [target]
//  @returns {Path}
var faceToShape = function faceToShape(face) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  // convert loops and collect them into target path
  face.getLoops().forEach(function (l) {
    target = loopToShape(l, target);
  });
  return target;
};

// Convert array of faces to array of shapes
var facesToShape = function facesToShape(faces) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  faces.forEach(function (f) {
    target = faceToShape(f, target);
  });
  return target;
};

// Convert SolidDef wire to an Edit2D Path.
//
// Note: This function only works for wires that don't branch and have already ordered edges.
//       This is true for wires that we get from SolidDef.Path.
//  @param {SolidDef.Wire} wire
var wireToShape = function wireToShape(wire) {

  // create empty path
  var path = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();
  path.isClosed = wire.isClosed();

  // add edges    
  var edges = wire.getOrderedEdges().edges;
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var lastLoopEdge = wire.isClosed() && i == edges.length - 1;
    addCoedge(path, edge, 0, lastLoopEdge);
  }
  return path;
};

// Convert SolidDef path to an array of shapes
var pathToShape = function pathToShape(path) {
  var body = path.getWireBody();
  var wires = body.getWires();

  if (wires.length == 0) {
    return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();
  }

  var result = wireToShape(wires[0]);

  // convert additional loops (if any)
  for (var i = 1; i < wires.length; i++) {
    var wire = wires[i];
    var tmp = wireToShape(wire);
    result.addLoop(tmp, 0);
  }

  return result;
};

// Convert Edit2D Path to SolidDef Path2D
var toSolidDefPath = function toSolidDefPath(path) {
  var path2D = new _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["Path2D"]();
  Object(_EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["runPath"])(path2D, path);
  return path2D;
};

var SolidDefConvert = {
  addCoedge: addCoedge,
  loopToShape: loopToShape,
  faceToShape: faceToShape,
  facesToShape: facesToShape,
  wireToShape: wireToShape,
  pathToShape: pathToShape,
  toSolidDefPath: toSolidDefPath };

/***/ }),

/***/ "./extensions/Edit2D/Svg.js":
/*!**********************************!*\
  !*** ./extensions/Edit2D/Svg.js ***!
  \**********************************/
/*! exports provided: Svg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Svg", function() { return Svg; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _CompGeom_bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CompGeom/bezier.js */ "./extensions/CompGeom/bezier.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}



var domParser = null;

// SVG (de)serialization for EditShapes

// Url of XML-Namespace for SVG
var SvgNs = "http://www.w3.org/2000/svg";

var exp4 = Math.pow(10, 4);
var limitDigits = function limitDigits(value) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!value || digits === null) {
    return value;
  }
  // like value.toFixed(), but removing trailing zeros
  var exp = digits === 4 ? exp4 : Math.pow(10, digits);
  return Math.round(value * exp) / exp;
};

var domToCircle = function domToCircle(circleNode) {

  if (!circleNode.hasAttributes || !circleNode.hasAttributes()) {
    throw 'No attributes available on the <circle/> node';
  }
  var circle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"]();
  for (var i = circleNode.attributes.length - 1; i >= 0; i--) {
    var attr = circleNode.attributes[i];
    switch (attr.name) {
      case 'cx':
        circle.centerX = parseFloat(attr.value);
        break;
      case 'cy':
        circle.centerY = parseFloat(attr.value);
        break;
      case 'r':
        circle.radius = parseFloat(attr.value);
        break;}

  }
  return circle;
};

var circleToSvg = function circleToSvg(circle) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;var stylePostFix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return "<circle cx=\"".concat(limitDigits(circle.centerX, digits), "\" cy=\"").concat(limitDigits(circle.centerY, digits), "\" r=\"").concat(limitDigits(circle.radius, digits)).concat(stylePostFix, "\"/>");
};

var domToPath = function domToPath(pathNode) {

  var d = pathNode.getAttribute('d');
  if (!d) {
    return;
  }

  return parsePath(d);
};

// For closed paths, remove last point of each loop if it is just a repetition of the start vertex.
var removeDuplicateLoopEndPoints = function removeDuplicateLoopEndPoints(path) {

  // Bezier applied to the last point will create an additional point which is equal to the endpoint to close the path
  // see Path.toSVGPath(). Path is always closed, therefore we can remove the duplicate end point.
  if (path.isClosed) {
    var pStart = new THREE.Vector2();
    var pEnd = new THREE.Vector2();
    var loopCount = path.loopCount;
    for (var l = 0; l < loopCount; l++) {

      // skip invalid loops
      var lastIndex = path.getVertexCount(l) - 1;
      if (lastIndex < 1) {
        continue;
      }

      // get start/end
      pStart = path.getPoint(0, l, pStart);
      pEnd = path.getPoint(lastIndex, l, pEnd);

      var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(pStart, pEnd, 0);
      if (!delta) {
        path.removePoint(lastIndex, l);
      }

    }
  }
};

var parsePath = function parsePath(svgPath) {
  // split at all chars but keep the char using positive look ahead
  // sample payload for path d = M 13.882,4.8592 L 14.6757,4.738 L 13.9668,4.4896 L 14.005,4.4896 C 15.3211,5.4567,14.79,3.1599,14.6624,4.155 L 13.9189,3.8945 L 13.9189,3.8 L 14.6234,3.7516 Z
  // results into list with glyph with position array:
  // ['M 13.882,4.8592', 'L 14.6757,4.738', 'L 13.9668,4.4896', 'L 14.005,4.4896', 'C 15.3211,5.4567,14.79,3.1599,14.6624,4.155', 'L 13.9189,3.8945', 'L 13.9189,3.8', 'L 14.6234,3.7516', 'Z']
  var pointStrings = svgPath.split(/ (?=[a-zA-Z])/gi);
  var validChars = "MLHVCZA";

  // Reused per cycle
  var ellipseParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
  var nextPoint = new THREE.Vector2();

  // the current loop that we are adding edges to
  var loopIndex = 0;

  var path = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();

  for (var i = 0; i < pointStrings.length; i++) {

    // Check for unexpected characters
    var pointString = pointStrings[i];
    if (validChars.indexOf(pointString[0]) === -1) {
      throw "\"".concat(pointString[0], "\" is not a supported or invalid glyph: ").concat(pointString);
    }

    var segmentIndex = path.getVertexCount(loopIndex) - 1;

    // Determine edge type, position, and extra params for arcs
    var value = pointString.substring(1);
    switch (pointString[0]) {
      case 'M':
        // start new loop
        loopIndex = path.nextFreeLoop();
      case 'L':
        var coords = value.split(',');
        nextPoint.x = parseFloat(coords[0]);
        nextPoint.y = parseFloat(coords[1]);
        break;
      case 'H':
        nextPoint.x = parseFloat(value);
        break;
      case 'V':
        nextPoint.y = parseFloat(value);
        break;
      case 'C':

        // tokenize params
        var bezierCoords = value.split(',');

        // get position
        nextPoint.x = parseFloat(bezierCoords[4]);
        nextPoint.y = parseFloat(bezierCoords[5]);

        // get bezier params                
        var cp1x = parseFloat(bezierCoords[0]);
        var cp1y = parseFloat(bezierCoords[1]);
        var cp2x = parseFloat(bezierCoords[2]);
        var cp2y = parseFloat(bezierCoords[3]);

        if (segmentIndex >= 0) {
          path.setBezierArc(segmentIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);
        } else {
          console.error('SVG Parse error: Path is not expected to start with "C" command');
        }
        break;

      case 'A':
        // tokenize params
        var src = value.split(',');

        // get position
        nextPoint.x = parseFloat(src[5]);
        nextPoint.y = parseFloat(src[6]);

        // read ellipse params.                
        ellipseParams.rx = parseFloat(src[0]);
        ellipseParams.ry = parseFloat(src[1]);
        ellipseParams.rotation = parseFloat(src[2]);
        ellipseParams.largeArcFlag = Boolean(parseFloat(src[3]));
        ellipseParams.sweepFlag = Boolean(parseFloat(src[4]));

        if (segmentIndex >= 0) {
          path.setEllipseArc(segmentIndex, ellipseParams, loopIndex);
        } else {
          console.error('SVG Parse error: Path is not expected to start with "A" command');
        }
        break;
      case 'Z':
        // we are done
        path.isClosed = true;
        continue;}


    // add next point
    path.addPoint(nextPoint.x, nextPoint.y, loopIndex);
  }

  removeDuplicateLoopEndPoints(path);

  return path;
};

var pathToSvgPath = function pathToSvgPath(path) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!path.vertexCount) {
    return [];
  }

  // Shortcut for restricting number of digits
  var ld = function ld(num) {return limitDigits(num, digits);};

  var svgPath = [];

  // reused per loop cycle
  var p = new THREE.Vector2();
  var pPrev = new THREE.Vector2();
  var params = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
  var cp1 = new THREE.Vector2();
  var cp2 = new THREE.Vector2();

  var loopCount = path.loopCount;
  for (var l = 0; l < loopCount; l++) {

    // Add M command for first vertex
    var edgeCount = path.getEdgeCount(l);
    if (edgeCount > 0) {
      p = path.getPoint(0, l, p);
      svgPath.push("M ".concat(ld(p.x), ",").concat(ld(p.y)));
    }

    for (var i = 0; i < edgeCount; i++) {

      // Vertex i is the end point of segment i-1, which defines edge type and arc params
      var segmentIndex = i;
      var edgeType = path.isPath() ? path.getEdgeType(segmentIndex, l) : _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line;

      // get next point. Note: If the path is closed, p will be the start vertex of the loop again.
      var edgeEndVertex = path.nextIndex(segmentIndex, l);
      p = path.getPoint(edgeEndVertex, l, p);

      var value = '';
      switch (edgeType) {

        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:
          params = path.getEllipseArcParams(segmentIndex, l, params);

          // Convert boolean flags to 1/0
          var largeArc = params.largeArcFlag ? 1 : 0;
          var sweep = params.sweepFlag ? 1 : 0;

          value = "A ".concat(params.rx, ",").concat(params.ry, ",").concat(params.rotation, ",").concat(largeArc, ",").concat(sweep, ",").concat(p.x, ",").concat(p.y);
          break;

        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:
          cp1 = path.getControlPoint(segmentIndex, 1, l, cp1);
          cp2 = path.getControlPoint(segmentIndex, 2, l, cp2);
          value = "C ".concat(ld(cp1.x, digits), ",").concat(ld(cp1.y, digits), ",").concat(ld(cp2.x, digits), ",").concat(ld(cp2.y, digits), ",").concat(ld(p.x, digits), ",").concat(ld(p.y, digits));
          break;

        default:
          {
            // skip empty/duplicate points
            pPrev = path.getPoint(i, l, pPrev);
            var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(pPrev, p, digits);
            if (!delta) {
              continue;
            }

            if (Math.abs(delta.x) <= precision) {
              value = "V ".concat(ld(p.y));
            } else if (Math.abs(delta.y) <= precision) {
              value = "H ".concat(ld(p.x));
            } else {
              value = "L ".concat(ld(p.x), ",").concat(ld(p.y));
            }
          }}


      // For closed paths, the edge end vertex will be 0. Repeating the start vertex is only necessary if the
      // last segment is an arc: Without repeating the start vertex at the loop end, we could not store the arc parameters in SVG.
      var isRepeatedStartVertex = edgeEndVertex === 0;
      if (isRepeatedStartVertex && edgeType === _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line) {
        // Last segment of the loop is a line. We don't need to repeat the start vertex in this case.
        continue;
      }

      svgPath.push(value);
    }

    // For a closed path, repeat the end vertex. This is necessary to preserve arc params
    if (path.isClosed) {
      // close loop
      svgPath.push('Z');
    }
  }

  return svgPath;
};

// Extract dictionary of SVG style attributes from Edit2D style
//  @param {Style} style
//  @returns {Object}
var getSvgStyleAttributes = function getSvgStyleAttributes(style) {

  var target = {};
  target["stroke"] = style.lineColor;
  target["fill"] = style.fillColor;
  target["stroke-width"] = style.lineWidth;

  // omit opacities if they are 1 (default)
  if (style.lineAlpha != 1) target["stroke-opacity"] = style.lineAlpha;
  if (style.fillAlpha != 1) target["fill-opacity"] = style.fillAlpha;

  return target;
};

// Converts the result of getSvgStyleAttributes to a string postfix. Since we append it
// to other attributes, it contains a preceding space. 
// Example: ' stroke="rgb(0,0,0)" fill="rgb(0,0,255)" ... '
var getAttributePostFix = function getAttributePostFix(attribs) {
  var str = '';
  for (var key in attribs) {
    str += " ".concat(key, "=\"").concat(attribs[key], "\"");
  }
  return str;
};

// Apply all given attributes to a Dom Element
var applyAttributes = function applyAttributes(domElement, attribs) {
  for (var key in attribs) {
    domElement.setAttribute(key, attribs[key]);
  }
};

// Converts a shape into a string describing an SVG path. Note that (for legacy reasons),
// style attributes are only exported if specified in options.
//
// @param {Shape} shape
// @param {Object} [options]
// @param {number} [options.precision=0]       - accuracy for unifying duplicate points 
// @param {number} [options.digis=0]           - number of digits for number strings 
// @param {bool}   [options.exportStyle=false] - If true, we also export style attributes
//
// Note: We currently have to use function syntax, otherwise we cannot use 'arguments' for the legacy fallback below.
var toSvg = function toSvg(shape, options) {

  var precision = options && options.precision || 0;
  var digits = options && options.digits || null; // means no limitation of digits
  var exportStyle = options && options.exportStyle || false;

  // add style params if wanted
  var stylePostfix = '';
  if (exportStyle) {
    var attribs = getSvgStyleAttributes(shape.style);
    stylePostfix = getAttributePostFix(attribs);
  }

  // Legacy: Keep old code using that still passes precision/digits separately
  // Todo: Remove this when checked with clients.
  if (_typeof(options) !== 'object') {
    if (typeof arguments[1] == 'number') precision = arguments[1];
    if (typeof arguments[2] == 'number') digits = arguments[2];
  }

  if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"]) {
    return circleToSvg(shape, digits, stylePostfix);
  }

  if (!(shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"])) {
    console.error('SVG serialization not supported for this shape: ', shape);
    return;
  }

  // PolyBase and Path are translated to SVG Path
  var path = pathToSvgPath(shape, precision, digits);

  return "<path d=\"".concat(path.join(' '), "\"").concat(stylePostfix, "/>");
};

// see toSvg for options.
var createSvgShape = function createSvgShape(shape, options) {
  var precision = options && options.precision || 0;
  var digits = options && options.digits || 0;
  var exportStyle = options && options.exportStyle || true;

  // Todo: support circles and other shapes if anyone needs it.
  if (!(shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"])) {
    console.error('SVG serialization not supported for this shape: ', shape);
    return;
  }

  var path = document.createElementNS(SvgNs, 'path');
  path.setAttribute('d', pathToSvgPath(shape, precision, digits));

  if (exportStyle) {
    var attribs = getSvgStyleAttributes(shape.style);
    applyAttributes(path, attribs);
  }

  return path;
};

// @param {string}  svg - e.g. '<path d="M 13.882,4.8592 L 14.6757,4.738"/>'
var fromSvg = function fromSvg(svg) {
  if (!svg) {
    return;
  }

  // init on first use
  domParser = domParser || new DOMParser();

  var dom = domParser.parseFromString(svg, 'application/xml');

  if (dom.childNodes.length !== 1) {
    throw 'Function does only support svg with a single element: path, circle';
  }
  var node = dom.firstChild;
  if (node.nodeName === 'circle') {
    return domToCircle(node);
  } else
  if (node.nodeName === 'path') {
    return domToPath(node);
  }

  throw "Unsupported svg node type: ".concat(node.nodeName);
};

// Converts several shapes to an SVG element.
//  @param {Object} [options]
//  @param {Box2} [dstBox] - If specified, shapes can be rescaled to fit into a destination box for the given SVG.
//  @param {Box2} [srcBox] - By default, srcBox is the union of all shapeBoxes. Shapes are uniformly rescaled from srcBox into dstBox.
// see toSvg() for other options
var createSvgElement = function createSvgElement(shapes) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // get summed box of all shapes
  var sumBox = new THREE.Box2();
  shapes.forEach(function (shape) {return sumBox.union(shape.getBBox());});

  var srcBox = options.srcBox || sumBox;
  var dstBox = options.dstBox || sumBox;

  // Note that we always have to swap y-axis, because the y-axis direction is flipped when 
  // converting 2D world coords in LMV to SVG.
  var scaleOptions = {
    preserveAspect: true,
    flipY: true };

  var tf = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getFitToBoxTransform(srcBox, dstBox, scaleOptions);

  // get required size of svg
  var width = dstBox.max.x - dstBox.min.x;
  var height = dstBox.max.y - dstBox.min.y;

  // create svg root element      
  var svg = document.createElementNS(SvgNs, 'svg');
  svg.setAttribute('height', width);
  svg.setAttribute('width', height);

  // rescale & convert each shape
  shapes.forEach(function (shape) {
    var scaledShape = shape.clone().applyMatrix4(tf);
    var path = createSvgShape(scaledShape, options);
    svg.appendChild(path);
  });

  return svg;
};

var Svg = {
  toSvg: toSvg,
  fromSvg: fromSvg,
  createSvgShape: createSvgShape,
  createSvgElement: createSvgElement };

/***/ }),

/***/ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@adsk/solid-definition/dist/solid-definition.min.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);} /*!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Copyright 2017 Autodesk, Inc. All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * This computer source code and related instructions and comments are the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * unpublished confidential and proprietary information of Autodesk, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * and are protected under applicable copyright and trade secret law. They
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * may not be disclosed to, copied or used by any third party without the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * prior written consent of Autodesk, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */
!function (e, t) {"object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports["solid-definition"] = t() : e.SolidDefinition = t();}("undefined" != typeof self ? self : this, function () {return function (e) {var t = {};function r(n) {if (t[n]) return t[n].exports;var o = t[n] = { i: n, l: !1, exports: {} };return e[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports;}return r.m = e, r.c = t, r.d = function (e, t, n) {r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n });}, r.r = function (e) {"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });}, r.t = function (e, t) {if (1 & t && (e = r(e)), 8 & t) return e;if (4 & t && "object" == _typeof(e) && e && e.__esModule) return e;var n = Object.create(null);if (r.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var o in e) {r.d(n, o, function (t) {return e[t];}.bind(null, o));}return n;}, r.n = function (e) {var t = e && e.__esModule ? function () {return e.default;} : function () {return e;};return r.d(t, "a", t), t;}, r.o = function (e, t) {return Object.prototype.hasOwnProperty.call(e, t);}, r.p = "", r(r.s = 86);}([function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = !1;"undefined" != typeof window && window.isJaguar && (t.isSceneComposerEnv = n = !0);var o = !1;n && (t.USE_LEGACY_LEIDS = o = window.isJaguar && window.isJaguar() || !!JSON.parse(localStorage.getItem("USE_LEGACY_LEIDS"))), t.KERNEL_TOLERANCE = 1e-6, t.KERNEL_ANGULAR_TOLERANCE = 1e-10, t.PARAMETER_SPACE_TOLERANCE = 1e-10, t.SPLINE_TANGENT_HANDLE_SCALE = 1, t.SPLINE_DISTANCE_TOLERANCE = 1e-4, t.DEFAULT_CURVE_RESOLUTION = 64, t.isSceneComposerEnv = n, t.NO_ID = "", t.USE_LEGACY_LEIDS = o, t.TESSELLATION = { LINEAR_PRECISION: 1e-4, ANGULAR_PRECISION: 1e-5 }, t.GEOMETRY_TYPES = { POINT: 1, BCURVE: 2, CIRCLE: 3, ELLIPSE: 4, HAPCURVE: 5, LINE: 6, BSURFACE: 7, CONE: 8, CYLINDER: 9, ELLIPTICAL_CONE: 10, ELLIPTICAL_CYLINDER: 11, PLANE: 12, SPHERE: 13, TORUS: 14, toString: function toString(e) {switch (e) {case this.POINT:return "Point";case this.BCURVE:return "BCurve";case this.CIRCLE:return "Circle";case this.ELLIPSE:return "Ellipse";case this.HAPCURVE:return "HapCurve";case this.LINE:return "Line";case this.BSURFACE:return "BSurface";case this.CONE:return "Cone";case this.CYLINDER:return "Cylinder";case this.ELLIPTICAL_CONE:return "EllipticalCone";case this.ELLIPTICAL_CYLINDER:return "EllipticalCylinder";case this.PLANE:return "Plane";case this.SPHERE:return "Sphere";case this.TORUS:return "Torus";default:return "unknown";}} }, t.TOPOLOGY_TYPES = { VERTEX: 1, EDGE: 2, COEDGE: 3, LOOP: 4, FACE: 5, SHELL: 6, LUMP: 7, BODY: 8, WIRE: 9, WIREBODY: 10, toString: function toString(e) {switch (e) {case this.VERTEX:return "Vertex";case this.EDGE:return "Edge";case this.COEDGE:return "Coedge";case this.LOOP:return "Loop";case this.FACE:return "Face";case this.SHELL:return "Shell";case this.LUMP:return "Lump";case this.BODY:return "Body";case this.WIRE:return "Wire";case this.WIREBODY:return "WireBody";default:return "unknown";}} };}, function (e, t, r) {"use strict";r.r(t), r.d(t, "Vector2", function () {return s;}), r.d(t, "Vector3", function () {return c;}), r.d(t, "Vector4", function () {return l;}), r.d(t, "Matrix22", function () {return d;}), r.d(t, "Matrix33", function () {return p;}), r.d(t, "Matrix44", function () {return v;}), r.d(t, "Quat", function () {return y;}), r.d(t, "ProjectionUtils", function () {return m;}), r.d(t, "FLOAT64_TOLERANCE", function () {return n;}), r.d(t, "FLOAT32_TOLERANCE", function () {return o;});var n = 1e-12,o = 1e-6;var i = { createFloat32: function createFloat32() {var e = new Float32Array(2);return e[0] = 0, e[1] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(2);return e[0] = 0, e[1] = 0, e;}, createNumber: function createNumber() {return [0, 0];}, clone: function clone(e) {var t = new e.constructor(2);return t[0] = e[0], t[1] = e[1], t;}, createFloat32FromValues: function createFloat32FromValues(e, t) {var r = new Float32Array(2);return r[0] = e, r[1] = t, r;} };i.asFloat32 = i.createFloat32FromValues, i.createFloat64FromValues = function (e, t) {var r = new Float64Array(2);return r[0] = e, r[1] = t, r;}, i.asFloat64 = i.createFloat64FromValues, i.createNumberFromValues = function (e, t) {return [e, t];}, i.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e;}, i.set = function (e, t, r) {return e[0] = t, e[1] = r, e;}, i.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e;}, i.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e;}, i.sub = i.subtract, i.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e;}, i.mul = i.multiply, i.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e;}, i.div = i.divide, i.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e;}, i.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e;}, i.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e;}, i.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e;}, i.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e;}, i.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e;}, i.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e;}, i.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1];return Math.sqrt(r * r + n * n);}, i.dist = i.distance, i.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1];return r * r + n * n;}, i.sqrDist = i.squaredDistance, i.length = function (e) {var t = e[0],r = e[1];return Math.sqrt(t * t + r * r);}, i.len = i.length, i.squaredLength = function (e) {var t = e[0],r = e[1];return t * t + r * r;}, i.sqrLen = i.squaredLength, i.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e;}, i.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e;}, i.normalize = function (e, t) {var r = t[0],n = t[1],o = r * r + n * n;return o > 0 && (o = 1 / Math.sqrt(o), e[0] = t[0] * o, e[1] = t[1] * o), e;}, i.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1];}, i.cross = function (e, t, r) {var n = t[0] * r[1] - t[1] * r[0];return e[0] = e[1] = 0, e[2] = n, e;}, i.lerp = function (e, t, r, n) {var o = t[0],i = t[1];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e;}, i.random = function (e, t) {t = t || 1;var r = 2 * Math.random() * Math.PI;return e[0] = Math.cos(r) * t, e[1] = Math.sin(r) * t, e;}, i.transformMatrix22 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[2] * o, e[1] = r[1] * n + r[3] * o, e;}, i.transformMatrix33 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[3] * o + r[6], e[1] = r[1] * n + r[4] * o + r[7], e;}, i.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[4] * o + r[12], e[1] = r[1] * n + r[5] * o + r[13], e;}, i.angle = function (e, t) {var r = i.clone(e),n = i.clone(t);i.normalize(r, r), i.normalize(n, n);var o = i.dot(r, n),s = Math.abs(r[0] * n[1] - r[1] * n[0]);return Math.atan2(s, o);}, i.isParallel = function (e, t, r, o) {o = o || n, r = r || 0;var s = e[0] * t[1] - e[1] * t[0];return !(s * s > o * o * i.squaredLength(e) * i.squaredLength(t)) && (r > 0 ? i.dot(e, t) > 0 : !(r < 0) || i.dot(e, t) < 0);}, i.isOrthogonal = function (e, t, r) {r = r || n;var o = i.dot(e, t);return o * o <= r * r * i.squaredLength(e) * i.squaredLength(t);}, i.toString = function (e) {return "[" + e[0] + ", " + e[1] + "]";}, i.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1];}, i.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r;};var s = i,a = { createFloat32: function createFloat32() {var e = new Float32Array(3);return e[0] = 0, e[1] = 0, e[2] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(3);return e[0] = 0, e[1] = 0, e[2] = 0, e;}, createNumber: function createNumber() {return [0, 0, 0];}, clone: function clone(e) {var t = new e.constructor(3);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;}, createFloat32FromValues: function createFloat32FromValues(e, t, r) {var n = new Float32Array(3);return n[0] = e, n[1] = t, n[2] = r, n;} };a.asFloat32 = a.createFloat32FromValues, a.createFloat64FromValues = function (e, t, r) {var n = new Float64Array(3);return n[0] = e, n[1] = t, n[2] = r, n;}, a.asFloat64 = a.createFloat64FromValues, a.createNumberFromValues = function (e, t, r) {return [e, t, r];}, a.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;}, a.set = function (e, t, r, n) {return e[0] = t, e[1] = r, e[2] = n, e;}, a.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e;}, a.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e;}, a.sub = a.subtract, a.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e;}, a.mul = a.multiply, a.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e;}, a.div = a.divide, a.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e;}, a.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e;}, a.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e;}, a.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e;}, a.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e;}, a.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e;}, a.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e;}, a.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2];return Math.sqrt(r * r + n * n + o * o);}, a.dist = a.distance, a.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2];return r * r + n * n + o * o;}, a.sqrDist = a.squaredDistance, a.length = function (e) {var t = e[0],r = e[1],n = e[2];return Math.sqrt(t * t + r * r + n * n);}, a.len = a.length, a.squaredLength = function (e) {var t = e[0],r = e[1],n = e[2];return t * t + r * r + n * n;}, a.sqrLen = a.squaredLength, a.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e;}, a.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e;}, a.normalize = function (e, t) {var r = t[0],n = t[1],o = t[2],i = r * r + n * n + o * o;return i > 0 && (i = 1 / Math.sqrt(i), e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i), e;}, a.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];}, a.cross = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2];return e[0] = o * c - i * a, e[1] = i * s - n * c, e[2] = n * a - o * s, e;}, a.lerp = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e[2] = s + n * (r[2] - s), e;}, a.hermite = function (e, t, r, n, o, i) {var s = i * i,a = s * (2 * i - 3) + 1,c = s * (i - 2) + i,u = s * (i - 1),l = s * (3 - 2 * i);return e[0] = t[0] * a + r[0] * c + n[0] * u + o[0] * l, e[1] = t[1] * a + r[1] * c + n[1] * u + o[1] * l, e[2] = t[2] * a + r[2] * c + n[2] * u + o[2] * l, e;}, a.bezier = function (e, t, r, n, o, i) {var s = 1 - i,a = s * s,c = i * i,u = a * s,l = 3 * i * a,h = 3 * c * s,d = c * i;return e[0] = t[0] * u + r[0] * l + n[0] * h + o[0] * d, e[1] = t[1] * u + r[1] * l + n[1] * h + o[1] * d, e[2] = t[2] * u + r[2] * l + n[2] * h + o[2] * d, e;}, a.random = function (e, t) {t = t || 1;var r = 2 * Math.random() * Math.PI,n = 2 * Math.random() - 1,o = Math.sqrt(1 - n * n) * t;return e[0] = Math.cos(r) * o, e[1] = Math.sin(r) * o, e[2] = n * t, e;}, a.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = r[0] * n + r[4] * o + r[8] * i + r[12], e[1] = r[1] * n + r[5] * o + r[9] * i + r[13], e[2] = r[2] * n + r[6] * o + r[10] * i + r[14], e;}, a.transformAsDirectionMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = r[0] * n + r[4] * o + r[8] * i, e[1] = r[1] * n + r[5] * o + r[9] * i, e[2] = r[2] * n + r[6] * o + r[10] * i, e;}, a.transformMatrix33 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = n * r[0] + o * r[3] + i * r[6], e[1] = n * r[1] + o * r[4] + i * r[7], e[2] = n * r[2] + o * r[5] + i * r[8], e;}, a.transformQuat = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2],u = r[3],l = u * n + a * i - c * o,h = u * o + c * n - s * i,d = u * i + s * o - a * n,g = -s * n - a * o - c * i;return e[0] = l * u + g * -s + h * -c - d * -a, e[1] = h * u + g * -a + d * -s - l * -c, e[2] = d * u + g * -c + l * -a - h * -s, e;}, a.setFromMatrixScale = function (e, t) {var r = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),n = Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),o = Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);return e[0] = r, e[1] = n, e[2] = o, e;}, a.rotateX = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[0], i[1] = o[1] * Math.cos(n) - o[2] * Math.sin(n), i[2] = o[1] * Math.sin(n) + o[2] * Math.cos(n), e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.rotateY = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[2] * Math.sin(n) + o[0] * Math.cos(n), i[1] = o[1], i[2] = o[2] * Math.cos(n) - o[0] * Math.sin(n), e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.rotateZ = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[0] * Math.cos(n) - o[1] * Math.sin(n), i[1] = o[0] * Math.sin(n) + o[1] * Math.cos(n), i[2] = o[2], e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.angle = function (e, t) {var r = a.clone(e),n = a.clone(t);a.normalize(r, r), a.normalize(n, n);var o = a.dot(r, n),i = a.length(a.cross(r, r, n));return Math.atan2(i, o);}, a.isParallel = function (e, t, r, o) {o = o || n, r = r || 0;var i = a.createFloat64();return a.cross(i, e, t), !(a.squaredLength(i) > o * o * a.squaredLength(e) * a.squaredLength(t)) && (r > 0 ? a.dot(e, t) > 0 : !(r < 0) || a.dot(e, t) < 0);}, a.isOrthogonal = function (e, t, r) {r = r || n;var o = a.dot(e, t);return o * o <= r * r * a.squaredLength(e) * a.squaredLength(t);}, a.computeOrthogonal = function (e, t) {return t[0] * t[0] > t[2] * t[2] ? a.set(e, t[1], -t[0], 0) : a.set(e, 0, t[2], -t[1]), e;}, a.setEulerFromRotationMatrix = function (e, t, r) {var o = 1 - n;function i(e) {return Math.min(Math.max(e, -1), 1);}var s = t[0],a = t[4],c = t[8],u = t[1],l = t[5],h = t[9],d = t[2],g = t[6],p = t[10];return void 0 === r || "XYZ" === r ? (e[1] = Math.asin(i(c)), Math.abs(c) < o ? (e[0] = Math.atan2(-h, p), e[2] = Math.atan2(-a, s)) : (e[0] = Math.atan2(g, l), e[2] = 0)) : "YXZ" === r ? (e[0] = Math.asin(-i(h)), Math.abs(h) < o ? (e[1] = Math.atan2(c, p), e[2] = Math.atan2(u, l)) : (e[1] = Math.atan2(-d, s), e[2] = 0)) : "ZXY" === r ? (e[0] = Math.asin(i(g)), Math.abs(g) < o ? (e[1] = Math.atan2(-d, p), e[2] = Math.atan2(-a, l)) : (e[1] = 0, e[2] = Math.atan2(u, s))) : "ZYX" === r ? (e[1] = Math.asin(-i(d)), Math.abs(d) < o ? (e[0] = Math.atan2(g, p), e[2] = Math.atan2(u, s)) : (e[0] = 0, e[2] = Math.atan2(-a, l))) : "YZX" === r ? (e[2] = Math.asin(i(u)), Math.abs(u) < o ? (e[0] = Math.atan2(-h, l), e[1] = Math.atan2(-d, s)) : (e[0] = 0, e[1] = Math.atan2(c, p))) : "XZY" === r && (e[2] = Math.asin(-i(a)), Math.abs(a) < o ? (e[0] = Math.atan2(g, l), e[1] = Math.atan2(c, s)) : (e[0] = Math.atan2(-h, p), e[1] = 0)), e;}, a.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + "]";}, a.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];}, a.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r;};var c = a,u = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;}, createNumber: function createNumber() {return [0, 0, 0, 0];}, clone: function clone(e) {var t = new e.constructor(4);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n) {var o = new Float32Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;} };u.asFloat32 = u.createFloat32FromValues, u.createFloat64FromValues = function (e, t, r, n) {var o = new Float64Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;}, u.asFloat64 = u.createFloat64FromValues, u.createNumberFromValues = function (e, t, r, n) {return [e, t, r, n];}, u.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;}, u.set = function (e, t, r, n, o) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e;}, u.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;}, u.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;}, u.sub = u.subtract, u.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e;}, u.mul = u.multiply, u.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e[3] = t[3] / r[3], e;}, u.div = u.divide, u.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e;}, u.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e;}, u.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e[3] = Math.min(t[3], r[3]), e;}, u.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e[3] = Math.max(t[3], r[3]), e;}, u.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e[3] = Math.round(t[3]), e;}, u.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;}, u.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;}, u.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2],i = t[3] - e[3];return Math.sqrt(r * r + n * n + o * o + i * i);}, u.dist = u.distance, u.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2],i = t[3] - e[3];return r * r + n * n + o * o + i * i;}, u.sqrDist = u.squaredDistance, u.length = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3];return Math.sqrt(t * t + r * r + n * n + o * o);}, u.len = u.length, u.squaredLength = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3];return t * t + r * r + n * n + o * o;}, u.sqrLen = u.squaredLength, u.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e;}, u.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e;}, u.normalize = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * r + n * n + o * o + i * i;return s > 0 && (s = 1 / Math.sqrt(s), e[0] = r * s, e[1] = n * s, e[2] = o * s, e[3] = i * s), e;}, u.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];}, u.lerp = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2],a = t[3];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e[2] = s + n * (r[2] - s), e[3] = a + n * (r[3] - a), e;}, u.random = function (e, t) {return t = t || 1, e[0] = Math.random(), e[1] = Math.random(), e[2] = Math.random(), e[3] = Math.random(), u.normalize(e, e), u.scale(e, e, t), e;}, u.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3];return e[0] = r[0] * n + r[4] * o + r[8] * i + r[12] * s, e[1] = r[1] * n + r[5] * o + r[9] * i + r[13] * s, e[2] = r[2] * n + r[6] * o + r[10] * i + r[14] * s, e[3] = r[3] * n + r[7] * o + r[11] * i + r[15] * s, e;}, u.transformQuat = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2],u = r[3],l = u * n + a * i - c * o,h = u * o + c * n - s * i,d = u * i + s * o - a * n,g = -s * n - a * o - c * i;return e[0] = l * u + g * -s + h * -c - d * -a, e[1] = h * u + g * -a + d * -s - l * -c, e[2] = d * u + g * -c + l * -a - h * -s, e[3] = t[3], e;}, u.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + "]";}, u.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];}, u.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[2] - t[2]) <= r;};var l = u,h = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 1];}, clone: function clone(e) {var t = new e.constructor(9);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n) {var o = new Float32Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;} };h.asFloat32 = h.createFloat32FromValues, h.createFloat64FromValues = function (e, t, r, n) {var o = new Float64Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;}, h.asFloat64 = h.createFloat64FromValues, h.createNumberFromValues = function (e, t, r, n) {return [e, t, r, n];}, h.set = function (e, t, r, n, o) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e;}, h.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, h.transpose = function (e, t) {if (e === t) {var r = t[1];e[1] = t[2], e[2] = r;} else e[0] = t[0], e[1] = t[2], e[2] = t[1], e[3] = t[3];return e;}, h.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * i - o * n;return s ? (s = 1 / s, e[0] = i * s, e[1] = -n * s, e[2] = -o * s, e[3] = r * s, e) : null;}, h.determinant = function (e) {return e[0] * e[3] - e[2] * e[1];}, h.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1],u = r[2],l = r[3];return e[0] = n * a + i * c, e[1] = o * a + s * c, e[2] = n * u + i * l, e[3] = o * u + s * l, e;}, h.mul = h.multiply, h.scale = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1];return e[0] = n * a, e[1] = o * a, e[2] = i * c, e[3] = s * c, e;}, h.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + "]";}, h.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;}, h.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;}, h.sub = h.subtract, h.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;}, h.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;}, h.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];}, h.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r;};var d = h,g = { createFloat32: function createFloat32() {var e = new Float32Array(9);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(9);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 0, 1, 0, 0, 0, 1];}, fromMatrix44: function fromMatrix44(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e;}, clone: function clone(e) {var t = new e.constructor(9);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n, o, i, s, a, c) {var u = new Float32Array(9);return u[0] = e, u[1] = t, u[2] = r, u[3] = n, u[4] = o, u[5] = i, u[6] = s, u[7] = a, u[8] = c, u;} };g.asFloat32 = g.createFloat32FromValues, g.createFloat64FromValues = function (e, t, r, n, o, i, s, a, c) {var u = new Float64Array(9);return u[0] = e, u[1] = t, u[2] = r, u[3] = n, u[4] = o, u[5] = i, u[6] = s, u[7] = a, u[8] = c, u;}, g.asFloat64 = g.createFloat64FromValues, g.createNumberFromValues = function (e, t, r, n, o, i, s, a, c) {return [e, t, r, n, o, i, s, a, c];}, g.set = function (e, t, r, n, o, i, s, a, c, u) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e[4] = i, e[5] = s, e[6] = a, e[7] = c, e[8] = u, e;}, g.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.transpose = function (e, t) {if (e === t) {var r = t[1],n = t[2],o = t[5];e[1] = t[3], e[2] = t[6], e[3] = r, e[5] = t[7], e[6] = n, e[7] = o;} else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];return e;}, g.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = l * s - a * u,d = -l * i + a * c,g = u * i - s * c,p = r * h + n * d + o * g;return p ? (p = 1 / p, e[0] = h * p, e[1] = (-l * n + o * u) * p, e[2] = (a * n - o * s) * p, e[3] = d * p, e[4] = (l * r - o * c) * p, e[5] = (-a * r + o * i) * p, e[6] = g * p, e[7] = (-u * r + n * c) * p, e[8] = (s * r - n * i) * p, e) : null;}, g.determinant = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3],i = e[4],s = e[5],a = e[6],c = e[7],u = e[8];return t * (u * i - s * c) + r * (-u * o + s * a) + n * (c * o - i * a);}, g.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = t[4],c = t[5],u = t[6],l = t[7],h = t[8],d = r[0],g = r[1],p = r[2],f = r[3],v = r[4],_ = r[5],y = r[6],m = r[7],E = r[8];return e[0] = d * n + g * s + p * u, e[1] = d * o + g * a + p * l, e[2] = d * i + g * c + p * h, e[3] = f * n + v * s + _ * u, e[4] = f * o + v * a + _ * l, e[5] = f * i + v * c + _ * h, e[6] = y * n + m * s + E * u, e[7] = y * o + m * a + E * l, e[8] = y * i + m * c + E * h, e;}, g.mul = g.multiply, g.fromTranslation = function (e, t) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e;}, g.fromRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = r, e[2] = 0, e[3] = -r, e[4] = n, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.fromScaling = function (e, t) {return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = t[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.fromQuat = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r + r,a = n + n,c = o + o,u = r * s,l = n * s,h = n * a,d = o * s,g = o * a,p = o * c,f = i * s,v = i * a,_ = i * c;return e[0] = 1 - h - p, e[3] = l - _, e[6] = d + v, e[1] = l + _, e[4] = 1 - u - p, e[7] = g - f, e[2] = d - v, e[5] = g + f, e[8] = 1 - u - h, e;}, g.normalFromMatrix44 = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = t[9],d = t[10],g = t[11],p = t[12],f = t[13],v = t[14],_ = t[15],y = r * a - n * s,m = r * c - o * s,E = r * u - i * s,x = n * c - o * a,R = n * u - i * a,A = o * u - i * c,P = l * f - h * p,V = l * v - d * p,T = l * _ - g * p,C = h * v - d * f,b = h * _ - g * f,L = d * _ - g * v,O = y * L - m * b + E * C + x * T - R * V + A * P;return O ? (O = 1 / O, e[0] = (a * L - c * b + u * C) * O, e[1] = (c * T - s * L - u * V) * O, e[2] = (s * b - a * T + u * P) * O, e[3] = (o * b - n * L - i * C) * O, e[4] = (r * L - o * T + i * V) * O, e[5] = (n * T - r * b - i * P) * O, e[6] = (f * A - v * R + _ * x) * O, e[7] = (v * E - p * A - _ * m) * O, e[8] = (p * R - f * E + _ * y) * O, e) : null;}, g.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + "]";}, g.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e;}, g.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e;}, g.sub = g.subtract, g.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e;}, g.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e;}, g.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8];}, g.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r && Math.abs(e[4] - t[4]) <= r && Math.abs(e[5] - t[5]) <= r && Math.abs(e[6] - t[6]) <= r && Math.abs(e[7] - t[7]) <= r && Math.abs(e[8] - t[8]) <= r;};var p = g,f = { createFloat32: function createFloat32() {var e = new Float32Array(16);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(16);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];}, clone: function clone(e) {var t = new e.constructor(16);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {var v = new Float32Array(16);return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = o, v[5] = i, v[6] = s, v[7] = a, v[8] = c, v[9] = u, v[10] = l, v[11] = h, v[12] = d, v[13] = g, v[14] = p, v[15] = f, v;} };f.asFloat32 = f.createFloat32FromValues, f.createFloat64FromValues = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {var v = new Float64Array(16);return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = o, v[5] = i, v[6] = s, v[7] = a, v[8] = c, v[9] = u, v[10] = l, v[11] = h, v[12] = d, v[13] = g, v[14] = p, v[15] = f, v;}, f.asFloat64 = f.createFloat64FromValues, f.createNumberFromValues = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {return [e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f];}, f.set = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f, v) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e[4] = i, e[5] = s, e[6] = a, e[7] = c, e[8] = u, e[9] = l, e[10] = h, e[11] = d, e[12] = g, e[13] = p, e[14] = f, e[15] = v, e;}, f.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.transpose = function (e, t) {if (e === t) {var r = t[1],n = t[2],o = t[3],i = t[6],s = t[7],a = t[11];e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = r, e[6] = t[9], e[7] = t[13], e[8] = n, e[9] = i, e[11] = t[14], e[12] = o, e[13] = s, e[14] = a;} else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];return e;}, f.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = t[9],d = t[10],g = t[11],p = t[12],f = t[13],v = t[14],_ = t[15],y = r * a - n * s,m = r * c - o * s,E = r * u - i * s,x = n * c - o * a,R = n * u - i * a,A = o * u - i * c,P = l * f - h * p,V = l * v - d * p,T = l * _ - g * p,C = h * v - d * f,b = h * _ - g * f,L = d * _ - g * v,O = y * L - m * b + E * C + x * T - R * V + A * P;return O ? (O = 1 / O, e[0] = (a * L - c * b + u * C) * O, e[1] = (o * b - n * L - i * C) * O, e[2] = (f * A - v * R + _ * x) * O, e[3] = (d * R - h * A - g * x) * O, e[4] = (c * T - s * L - u * V) * O, e[5] = (r * L - o * T + i * V) * O, e[6] = (v * E - p * A - _ * m) * O, e[7] = (l * A - d * E + g * m) * O, e[8] = (s * b - a * T + u * P) * O, e[9] = (n * T - r * b - i * P) * O, e[10] = (p * R - f * E + _ * y) * O, e[11] = (h * E - l * R - g * y) * O, e[12] = (a * V - s * C - c * P) * O, e[13] = (r * C - n * V + o * P) * O, e[14] = (f * m - p * x - v * y) * O, e[15] = (l * x - h * m + d * y) * O, e) : null;}, f.determinant = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3],i = e[4],s = e[5],a = e[6],c = e[7],u = e[8],l = e[9],h = e[10],d = e[11],g = e[12],p = e[13],f = e[14],v = e[15];return (t * s - r * i) * (h * v - d * f) - (t * a - n * i) * (l * v - d * p) + (t * c - o * i) * (l * f - h * p) + (r * a - n * s) * (u * v - d * g) - (r * c - o * s) * (u * f - h * g) + (n * c - o * a) * (u * p - l * g);}, f.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = t[4],c = t[5],u = t[6],l = t[7],h = t[8],d = t[9],g = t[10],p = t[11],f = t[12],v = t[13],_ = t[14],y = t[15],m = r[0],E = r[1],x = r[2],R = r[3];return e[0] = m * n + E * a + x * h + R * f, e[1] = m * o + E * c + x * d + R * v, e[2] = m * i + E * u + x * g + R * _, e[3] = m * s + E * l + x * p + R * y, m = r[4], E = r[5], x = r[6], R = r[7], e[4] = m * n + E * a + x * h + R * f, e[5] = m * o + E * c + x * d + R * v, e[6] = m * i + E * u + x * g + R * _, e[7] = m * s + E * l + x * p + R * y, m = r[8], E = r[9], x = r[10], R = r[11], e[8] = m * n + E * a + x * h + R * f, e[9] = m * o + E * c + x * d + R * v, e[10] = m * i + E * u + x * g + R * _, e[11] = m * s + E * l + x * p + R * y, m = r[12], E = r[13], x = r[14], R = r[15], e[12] = m * n + E * a + x * h + R * f, e[13] = m * o + E * c + x * d + R * v, e[14] = m * i + E * u + x * g + R * _, e[15] = m * s + E * l + x * p + R * y, e;}, f.mul = f.multiply, f.fromTranslation = function (e, t) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e;}, f.fromScaling = function (e, t) {return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromRotation = function (e, t, r) {var o,i,s,a = r[0],c = r[1],u = r[2],l = Math.sqrt(a * a + c * c + u * u);return Math.abs(l) < n ? null : (a *= l = 1 / l, c *= l, u *= l, o = Math.sin(t), s = 1 - (i = Math.cos(t)), e[0] = a * a * s + i, e[1] = c * a * s + u * o, e[2] = u * a * s - c * o, e[3] = 0, e[4] = a * c * s - u * o, e[5] = c * c * s + i, e[6] = u * c * s + a * o, e[7] = 0, e[8] = a * u * s + c * o, e[9] = c * u * s - a * o, e[10] = u * u * s + i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e);}, f.fromXRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = r, e[7] = 0, e[8] = 0, e[9] = -r, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromYRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = 0, e[2] = -r, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = r, e[9] = 0, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromZRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = r, e[2] = 0, e[3] = 0, e[4] = -r, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromRotationTranslation = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = n + n,c = o + o,u = i + i,l = n * a,h = n * c,d = n * u,g = o * c,p = o * u,f = i * u,v = s * a,_ = s * c,y = s * u;return e[0] = 1 - (g + f), e[1] = h + y, e[2] = d - _, e[3] = 0, e[4] = h - y, e[5] = 1 - (l + f), e[6] = p + v, e[7] = 0, e[8] = d + _, e[9] = p - v, e[10] = 1 - (l + g), e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;}, f.getTranslation = function (e, t) {return e[0] = t[12], e[1] = t[13], e[2] = t[14], e;}, f.extractRotation = function (e, t) {var r = 1 / Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),n = 1 / Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),o = 1 / Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = 0, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = 0, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;}, f.getRotation = function (e, t) {var r = t[0] + t[5] + t[10],n = 0;return r > 0 ? (n = 2 * Math.sqrt(r + 1), e[3] = .25 * n, e[0] = (t[6] - t[9]) / n, e[1] = (t[8] - t[2]) / n, e[2] = (t[1] - t[4]) / n) : t[0] > t[5] && t[0] > t[10] ? (n = 2 * Math.sqrt(1 + t[0] - t[5] - t[10]), e[3] = (t[6] - t[9]) / n, e[0] = .25 * n, e[1] = (t[1] + t[4]) / n, e[2] = (t[8] + t[2]) / n) : t[5] > t[10] ? (n = 2 * Math.sqrt(1 + t[5] - t[0] - t[10]), e[3] = (t[8] - t[2]) / n, e[0] = (t[1] + t[4]) / n, e[1] = .25 * n, e[2] = (t[6] + t[9]) / n) : (n = 2 * Math.sqrt(1 + t[10] - t[0] - t[5]), e[3] = (t[1] - t[4]) / n, e[0] = (t[8] + t[2]) / n, e[1] = (t[6] + t[9]) / n, e[2] = .25 * n), e;}, f.fromRotationTranslationScale = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2],a = t[3],c = o + o,u = i + i,l = s + s,h = o * c,d = o * u,g = o * l,p = i * u,f = i * l,v = s * l,_ = a * c,y = a * u,m = a * l,E = n[0],x = n[1],R = n[2];return e[0] = (1 - (p + v)) * E, e[1] = (d + m) * E, e[2] = (g - y) * E, e[3] = 0, e[4] = (d - m) * x, e[5] = (1 - (h + v)) * x, e[6] = (f + _) * x, e[7] = 0, e[8] = (g + y) * R, e[9] = (f - _) * R, e[10] = (1 - (h + p)) * R, e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;}, f.fromRotationTranslationScaleOrigin = function (e, t, r, n, o) {var i = t[0],s = t[1],a = t[2],c = t[3],u = i + i,l = s + s,h = a + a,d = i * u,g = i * l,p = i * h,f = s * l,v = s * h,_ = a * h,y = c * u,m = c * l,E = c * h,x = n[0],R = n[1],A = n[2],P = o[0],V = o[1],T = o[2];return e[0] = (1 - (f + _)) * x, e[1] = (g + E) * x, e[2] = (p - m) * x, e[3] = 0, e[4] = (g - E) * R, e[5] = (1 - (d + _)) * R, e[6] = (v + y) * R, e[7] = 0, e[8] = (p + m) * A, e[9] = (v - y) * A, e[10] = (1 - (d + f)) * A, e[11] = 0, e[12] = r[0] + P - (e[0] * P + e[4] * V + e[8] * T), e[13] = r[1] + V - (e[1] * P + e[5] * V + e[9] * T), e[14] = r[2] + T - (e[2] * P + e[6] * V + e[10] * T), e[15] = 1, e;}, f.fromQuat = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r + r,a = n + n,c = o + o,u = r * s,l = n * s,h = n * a,d = o * s,g = o * a,p = o * c,f = i * s,v = i * a,_ = i * c;return e[0] = 1 - h - p, e[1] = l + _, e[2] = d - v, e[3] = 0, e[4] = l - _, e[5] = 1 - u - p, e[6] = g + f, e[7] = 0, e[8] = d + v, e[9] = g - f, e[10] = 1 - u - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.setRotationFromEuler = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = Math.cos(n),a = Math.sin(n),c = Math.cos(o),u = Math.sin(o),l = Math.cos(i),h = Math.sin(i);if (void 0 === r || "XYZ" === r) {var d = s * l,g = s * h,p = a * l,f = a * h;e[0] = c * l, e[4] = -c * h, e[8] = u, e[1] = g + p * u, e[5] = d - f * u, e[9] = -a * c, e[2] = f - d * u, e[6] = p + g * u, e[10] = s * c;} else if ("YXZ" === r) {var v = c * l,_ = c * h,y = u * l,m = u * h;e[0] = v + m * a, e[4] = y * a - _, e[8] = s * u, e[1] = s * h, e[5] = s * l, e[9] = -a, e[2] = _ * a - y, e[6] = m + v * a, e[10] = s * c;} else if ("ZXY" === r) v = c * l, _ = c * h, y = u * l, m = u * h, e[0] = v - m * a, e[4] = -s * h, e[8] = y + _ * a, e[1] = _ + y * a, e[5] = s * l, e[9] = m - v * a, e[2] = -s * u, e[6] = a, e[10] = s * c;else if ("ZYX" === r) d = s * l, g = s * h, p = a * l, f = a * h, e[0] = c * l, e[4] = p * u - g, e[8] = d * u + f, e[1] = c * h, e[5] = f * u + d, e[9] = g * u - p, e[2] = -u, e[6] = a * c, e[10] = s * c;else if ("YZX" === r) {var E = s * c,x = s * u,R = a * c,A = a * u;e[0] = c * l, e[4] = A - E * h, e[8] = R * h + x, e[1] = h, e[5] = s * l, e[9] = -a * l, e[2] = -u * l, e[6] = x * h + R, e[10] = E - A * h;} else "XZY" === r && (E = s * c, x = s * u, R = a * c, A = a * u, e[0] = c * l, e[4] = -h, e[8] = u * l, e[1] = E * h + A, e[5] = s * l, e[9] = x * h - R, e[2] = R * h - x, e[6] = a * l, e[10] = A * h + E);return e;}, f.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ", " + e[9] + ", " + e[10] + ", " + e[11] + ", " + e[12] + ", " + e[13] + ", " + e[14] + ", " + e[15] + "]";}, f.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e[9] = t[9] + r[9], e[10] = t[10] + r[10], e[11] = t[11] + r[11], e[12] = t[12] + r[12], e[13] = t[13] + r[13], e[14] = t[14] + r[14], e[15] = t[15] + r[15], e;}, f.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e[9] = t[9] - r[9], e[10] = t[10] - r[10], e[11] = t[11] - r[11], e[12] = t[12] - r[12], e[13] = t[13] - r[13], e[14] = t[14] - r[14], e[15] = t[15] - r[15], e;}, f.sub = f.subtract, f.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12] * r, e[13] = t[13] * r, e[14] = t[14] * r, e[15] = t[15] * r, e;}, f.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e[9] = t[9] + r[9] * n, e[10] = t[10] + r[10] * n, e[11] = t[11] + r[11] * n, e[12] = t[12] + r[12] * n, e[13] = t[13] + r[13] * n, e[14] = t[14] + r[14] * n, e[15] = t[15] + r[15] * n, e;}, f.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];}, f.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r && Math.abs(e[4] - t[4]) <= r && Math.abs(e[5] - t[5]) <= r && Math.abs(e[6] - t[6]) <= r && Math.abs(e[7] - t[7]) <= r && Math.abs(e[8] - t[8]) <= r && Math.abs(e[9] - t[9]) <= r && Math.abs(e[10] - t[10]) <= r && Math.abs(e[11] - t[11]) <= r && Math.abs(e[12] - t[12]) <= r && Math.abs(e[13] - t[13]) <= r && Math.abs(e[14] - t[14]) <= r && Math.abs(e[15] - t[15]) <= r;};var v = f,_ = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createNumber: function createNumber() {return [0, 0, 0, 1];} };_.rotationTo = function () {var e = c.createFloat64(),t = c.createFloat64FromValues(1, 0, 0),r = c.createFloat64FromValues(0, 1, 0);return function (o, i, s) {var a = c.dot(i, s);return a < -1 + n ? (c.cross(e, t, i), c.length(e) < n && c.cross(e, r, i), c.normalize(e, e), _.setAxisAngle(o, e, Math.PI), o) : a > 1 - n ? (o[0] = 0, o[1] = 0, o[2] = 0, o[3] = 1, o) : (c.cross(e, i, s), o[0] = e[0], o[1] = e[1], o[2] = e[2], o[3] = 1 + a, _.normalize(o, o));};}(), _.setAxes = function () {var e = p.createFloat64();return function (t, r, n, o) {return e[0] = n[0], e[3] = n[1], e[6] = n[2], e[1] = o[0], e[4] = o[1], e[7] = o[2], e[2] = -r[0], e[5] = -r[1], e[8] = -r[2], _.normalize(t, _.fromMatrix33(t, e));};}(), _.clone = l.clone, _.createFloat32FromValues = l.createFloat32FromValues, _.createFloat64FromValues = l.createFloat64FromValues, _.createNumberFromValues = l.createNumberFromValues, _.asFloat32 = l.createFloat32FromValues, _.asFloat64 = l.createFloat64FromValues, _.copy = l.copy, _.set = l.set, _.identity = function (e) {return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, _.setAxisAngle = function (e, t, r) {r *= .5;var n = Math.sin(r);return e[0] = n * t[0], e[1] = n * t[1], e[2] = n * t[2], e[3] = Math.cos(r), e;}, _.getAxisAngle = function (e, t) {var r = 2 * Math.acos(t[3]),n = Math.sin(r / 2);return 0 !== n ? (e[0] = t[0] / n, e[1] = t[1] / n, e[2] = t[2] / n) : (e[0] = 1, e[1] = 0, e[2] = 0), r;}, _.add = l.add, _.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1],u = r[2],l = r[3];return e[0] = n * l + s * a + o * u - i * c, e[1] = o * l + s * c + i * a - n * u, e[2] = i * l + s * u + n * c - o * a, e[3] = s * l - n * a - o * c - i * u, e;}, _.mul = _.multiply, _.scale = l.scale, _.rotateX = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c + s * a, e[1] = o * c + i * a, e[2] = i * c - o * a, e[3] = s * c - n * a, e;}, _.rotateY = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c - i * a, e[1] = o * c + s * a, e[2] = i * c + n * a, e[3] = s * c - o * a, e;}, _.rotateZ = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c + o * a, e[1] = o * c - n * a, e[2] = i * c + s * a, e[3] = s * c - i * a, e;}, _.calculateW = function (e, t) {var r = t[0],n = t[1],o = t[2];return e[0] = r, e[1] = n, e[2] = o, e[3] = Math.sqrt(Math.abs(1 - r * r - n * n - o * o)), e;}, _.dot = l.dot, _.lerp = l.lerp, _.slerp = function (e, t, r, o) {var i,s,a,c,u,l = t[0],h = t[1],d = t[2],g = t[3],p = r[0],f = r[1],v = r[2],_ = r[3];return (s = l * p + h * f + d * v + g * _) < 0 && (s = -s, p = -p, f = -f, v = -v, _ = -_), 1 - s > n ? (i = Math.acos(s), a = Math.sin(i), c = Math.sin((1 - o) * i) / a, u = Math.sin(o * i) / a) : (c = 1 - o, u = o), e[0] = c * l + u * p, e[1] = c * h + u * f, e[2] = c * d + u * v, e[3] = c * g + u * _, e;}, _.sqlerp = function () {var e = _.createFloat64(),t = _.createFloat64();return function (r, n, o, i, s, a) {return _.slerp(e, n, s, a), _.slerp(t, o, i, a), _.slerp(r, e, t, 2 * a * (1 - a)), r;};}(), _.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * r + n * n + o * o + i * i,a = s ? 1 / s : 0;return e[0] = -r * a, e[1] = -n * a, e[2] = -o * a, e[3] = i * a, e;}, _.conjugate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e;}, _.length = l.length, _.len = _.length, _.squaredLength = l.squaredLength, _.sqrLen = _.squaredLength, _.normalize = l.normalize, _.fromMatrix33 = function (e, t) {var r,n = t[0] + t[4] + t[8];if (n > 0) r = Math.sqrt(n + 1), e[3] = .5 * r, r = .5 / r, e[0] = (t[5] - t[7]) * r, e[1] = (t[6] - t[2]) * r, e[2] = (t[1] - t[3]) * r;else {var o = 0;t[4] > t[0] && (o = 1), t[8] > t[3 * o + o] && (o = 2);var i = (o + 1) % 3,s = (o + 2) % 3;r = Math.sqrt(t[3 * o + o] - t[3 * i + i] - t[3 * s + s] + 1), e[o] = .5 * r, r = .5 / r, e[3] = (t[3 * i + s] - t[3 * s + i]) * r, e[i] = (t[3 * i + o] + t[3 * o + i]) * r, e[s] = (t[3 * s + o] + t[3 * o + s]) * r;}return e;}, _.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + "]";}, _.exactEquals = l.exactEquals, _.equals = l.equals;var y = _,m = { frustum: function frustum(e, t, r, n, o, i, s) {var a = 1 / (r - t),c = 1 / (o - n),u = 1 / (i - s);return e[0] = 2 * i * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 2 * i * c, e[6] = 0, e[7] = 0, e[8] = (r + t) * a, e[9] = (o + n) * c, e[10] = (s + i) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = s * i * 2 * u, e[15] = 0, e;}, perspective: function perspective(e, t, r, n, o) {var i = 1 / Math.tan(t / 2),s = 1 / (n - o);return e[0] = i / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (o + n) * s, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = 2 * o * n * s, e[15] = 0, e;}, ortho: function ortho(e, t, r, n, o, i, s) {var a = 1 / (t - r),c = 1 / (n - o),u = 1 / (i - s);return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + r) * a, e[13] = (o + n) * c, e[14] = (s + i) * u, e[15] = 1, e;}, lookAt: function lookAt(e, t, r, o) {var i,s,a,c,u,l,h,d,g,p,f = t[0],_ = t[1],y = t[2],m = o[0],E = o[1],x = o[2],R = r[0],A = r[1],P = r[2];return Math.abs(f - R) < n && Math.abs(_ - A) < n && Math.abs(y - P) < n ? v.identity(e) : (h = f - R, d = _ - A, g = y - P, i = E * (g *= p = 1 / Math.sqrt(h * h + d * d + g * g)) - x * (d *= p), s = x * (h *= p) - m * g, a = m * d - E * h, (p = Math.sqrt(i * i + s * s + a * a)) ? (i *= p = 1 / p, s *= p, a *= p) : (i = 0, s = 0, a = 0), c = d * a - g * s, u = g * i - h * a, l = h * s - d * i, (p = Math.sqrt(c * c + u * u + l * l)) ? (c *= p = 1 / p, u *= p, l *= p) : (c = 0, u = 0, l = 0), e[0] = i, e[1] = c, e[2] = h, e[3] = 0, e[4] = s, e[5] = u, e[6] = d, e[7] = 0, e[8] = a, e[9] = l, e[10] = g, e[11] = 0, e[12] = -(i * f + s * _ + a * y), e[13] = -(c * f + u * _ + l * y), e[14] = -(h * f + d * _ + g * y), e[15] = 1, e);}, transformProjectionMatrix: function transformProjectionMatrix(e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[3] * n + r[7] * o + r[11] * i + r[15];return s = s || 1, e[0] = (r[0] * n + r[4] * o + r[8] * i + r[12]) / s, e[1] = (r[1] * n + r[5] * o + r[9] * i + r[13]) / s, e[2] = (r[2] * n + r[6] * o + r[10] * i + r[14]) / s, e;} };t.default = { Vector2: s, Vector3: c, Vector4: l, Matrix22: d, Matrix33: p, Matrix44: v, Quat: y, ProjectionUtils: m, FLOAT64_TOLERANCE: n, FLOAT32_TOLERANCE: o };}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = { assert: function assert(e, t) {if (!e) throw new Error(t);} };t.ConsoleUtils = n;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.definePlaneThroughPoints = t.getPlaneTransforms = t.limitRange = t.PI2 = t.sortedIndex = t.clamp = t.orient2D = t.signedDistanceTo2DLine = t.intersectIntervals = t.solveTwoEquationsTwoVariables = t.closestPointToTriangle = t.closestPointToPolyline = t.distancePointToLineSegment = t.projectPointToLineSegment = t.angleDifference = t.periodicDifference = t.minMaxCosSinFunc = t.convertToOtherPeriodicRange = t.adjustParameterToPeriodicRange = t.getShortestParametricRange = t.isParameterWithinPeriodicRange = t.normalizeSegmentsToPeriodicRange = t.normalizeParametricRange = t.normalizeParametricRangeToShiftedRange = t.normalizeParameterToShiftedRange = t.adjustAngleToRange = t.normalizeAngleRange = t.normalizeAngle = t.normalizeParameter = t.foldNearTo = t.foldAbove = t.fold = t.modulus = t.getSignedAngle = t.isPointInsidePolygon2D = t.binomialCoefficients = void 0;var n = r(1),o = r(0),i = r(2),s = 2 * Math.PI,a = [];!function () {for (var e = 0; e < 8; ++e) {a[e] = [1];for (var t = 1; t < e; ++t) {a[e][t] = a[e - 1][t - 1] + a[e - 1][t];}a[e][e] = 1;}}();var c = function c(e, t, r) {return Math.min(Math.max(t, e), r);},u = function u(e, t) {return e - t * Math.floor(e / t);},l = function l(e, t) {var r = e % t;return r < 0 ? r + t : r;},h = function h(e, t, r) {return l(e - t, r) + t;},d = function d(e, t) {return e < 0 ? t + e % t : e % t;},g = function g(e, t) {return d(e - t[0], t[1] - t[0]) + t[0];},p = function p(e, t) {i.ConsoleUtils.assert(e[1] >= e[0], "normalizeParametricRange: in_range ends not in order.");var r = e[1] - e[0],n = d(e[0], t);return [n, n + r];},f = function f(e, t, r, n, o) {if (!isFinite(r)) return e;var i = p(t, r),s = d(e, r),a = s + r;if (n = !!n, s >= i[0] && s <= i[1]) return t[0] + (s - i[0]);if (a >= i[0] && a <= i[1]) return t[0] + (a - i[0]);var c = Math.abs(i[0] - s),u = Math.abs(s - i[1]),l = Math.abs(i[0] - a),h = Math.abs(a - i[1]);return o ? Math.min(c, l) < Math.min(u, h) ? t[0] : t[1] : Math.min(c, u) > Math.min(l, h) && !n ? t[0] + (a - i[0]) : t[0] + (s - i[0]);},v = function v(e, t, r) {var n = Math.abs(e - t);return isFinite(r) && (n %= r) > r / 2 ? r - n : n;},_ = function _(e, t, r) {var i = n.Vector3.sub(n.Vector3.createFloat64(), t, e),s = n.Vector3.dot(i, i);if (s < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return 0;var a = n.Vector3.sub(n.Vector3.createFloat64(), r, e);return n.Vector3.dot(a, i) / s;};t.binomialCoefficients = a, t.isPointInsidePolygon2D = function (e, t) {for (var r = !1, n = t.length, o = 0, i = n - 2; o < n; o += 2) {t[o + 1] > e[1] != t[i + 1] > e[1] && e[0] < (t[i] - t[o]) * (e[1] - t[o + 1]) / (t[i + 1] - t[o + 1]) + t[o] && (r = !r), i = o;}return r;}, t.getSignedAngle = function (e, t) {var r = c(n.Vector2.dot(e, t), -1, 1),o = t[0] * e[1] - t[1] * e[0];return 0 === o ? .5 * Math.PI * (r - 1) : o < 0 ? -Math.acos(r) : Math.acos(r);}, t.modulus = u, t.fold = l, t.foldAbove = h, t.foldNearTo = function (e, t, r) {return h(e, t - r / 2, r);}, t.normalizeParameter = d, t.normalizeAngle = function (e) {return d(e, s);}, t.normalizeAngleRange = function (e) {return p(e, 2 * Math.PI);}, t.adjustAngleToRange = function (e, t) {return f(e, t, 2 * Math.PI);}, t.normalizeParameterToShiftedRange = g, t.normalizeParametricRangeToShiftedRange = function (e, t) {i.ConsoleUtils.assert(e[1] >= e[0], "normalizeParametricRangeToShiftedRange: in_range ends not in order.");var r = e[1] - e[0],n = g(e[0], t);return [n, n + r];}, t.normalizeParametricRange = p, t.normalizeSegmentsToPeriodicRange = function (e, t, r, n, i) {for (var s = void 0 !== n ? n : o.KERNEL_TOLERANCE, a = void 0 !== i ? i : t[1] - t[0], c = [], u = 0; u < e.length; u++) {var l = g(e[u][0], t),h = e[u][1] - e[u][0];if (h >= a) return [[t[0], t[1]]];var d = l + h;d < t[1] ? c.push([l, d]) : (c.push([l, t[1]]), c.push([t[0], d - t[1] + t[0]]));}var p = [];for (c.sort(function (e, t) {return e[0] - t[0];}), u = 0; u < c.length; u++) {for (var f = c[u]; u + 1 < c.length && c[u + 1][0] < f[1];) {f[1] = Math.max(f[1], c[u + 1][1]), u++;}(Math.abs(f[1] - f[0]) > s || !r) && p.push(f);}return p;}, t.isParameterWithinPeriodicRange = function (e, t, r, n) {var o = f(e, t, r);return n = n || 0, o > t[0] - n && o < t[1] + n;}, t.getShortestParametricRange = function (e, t, r) {if ((e = d(e, r)) > (t = d(t, r))) {var n = e;e = t, t = n;}return e - t + r < t - e ? [t, e + r] : [e, t];}, t.adjustParameterToPeriodicRange = f, t.convertToOtherPeriodicRange = function (e, t, r, n) {if (!isFinite(r)) return i.ConsoleUtils.assert(e[0] >= t[0] - n, "The start of the input range doesn't lie in the target range."), i.ConsoleUtils.assert(e[1] <= t[1] + n, "The input range doesn't lie within the target range."), e;if (n = n || 0, e[1] - e[0] >= r - n) return t[1] - t[0] < r - n && console.error("The input range is larger than the target range."), t;var o = f(e[0], t, r);i.ConsoleUtils.assert(o >= t[0] - n, "The start of the input range doesn't lie in the target range.");var s = o + e[1] - e[0];return i.ConsoleUtils.assert(s <= t[1] + n, "The input range doesn't lie within the target range."), [o, s];}, t.minMaxCosSinFunc = function (e, t, r, n) {if (0 === e && 0 === t) return [r, r];var o,i = p(n, 2 * Math.PI),s = f(Math.atan(t / e), i, Math.PI, !0),a = [];for (o = 0; o < 3; ++o) {i[0] <= s && i[1] >= s && a.push(e * Math.cos(s) + t * Math.sin(s)), s += Math.PI;}if (n[1] - n[0] < 2 * Math.PI) for (o = 0; o < 2; o++) {a.push(e * Math.cos(n[o]) + t * Math.sin(n[o]));}return [Math.min.apply(null, a) + r, Math.max.apply(null, a) + r];}, t.periodicDifference = v, t.angleDifference = function (e, t) {return v(e, t, 2 * Math.PI);}, t.projectPointToLineSegment = _, t.distancePointToLineSegment = function (e, t, r, o) {var i = _(e, t, r);i = c(i, 0, 1);var s = o || n.Vector3.createFloat64();return n.Vector3.lerp(s, e, t, i), n.Vector3.distance(s, r);}, t.closestPointToPolyline = function (e, t, r, o, i) {for (var s = "number" == typeof t[0], a = s ? t.length / 3 : t.length, u = void 0, l = Number.POSITIVE_INFINITY, h = n.Vector3.createFloat64(), d = 0; d < a - 1; ++d) {var g = r ? r[d] : d,p = r ? r[d + 1] : d + 1,f = 0,v = 1;if (!(o && (o[0] > g && (f = (o[0] - g) / (p - g)), o[1] < p && (v = (o[1] - g) / (p - g)), v < f))) {var y, m;s ? (y = [t[3 * d], t[3 * d + 1], t[3 * d + 2]], m = [t[3 * d + 3], t[3 * d + 4], t[3 * d + 5]]) : (y = t[d], m = t[d + 1]);var E = _(y, m, e);E = c(E, f, v), n.Vector3.lerp(h, y, m, E);var x = n.Vector3.squaredDistance(h, e);x < l && (u = (1 - E) * g + E * p, l = x, i && n.Vector3.copy(i, h));}}return u;}, t.closestPointToTriangle = function (e, t, r, i, s) {var a,u,l = n.Vector3.sub(n.Vector3.createFloat64(), r, t),h = n.Vector3.sub(n.Vector3.createFloat64(), i, t),d = n.Vector3.sub(n.Vector3.createFloat64(), e, t),g = n.Vector3.squaredLength(l),p = n.Vector3.squaredLength(h),f = n.Vector3.dot(l, h),v = n.Vector3.dot(d, l),y = n.Vector3.dot(d, h);if (g < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && p < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = u = 0;else if (g < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = 0, u = c(y / p, 0, 1);else if (p < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = c(v / g, 0, 1), u = 0;else {var m = n.Matrix22.createFloat64FromValues(g, f, f, p);if (Math.abs(n.Matrix22.determinant(m)) > n.FLOAT64_TOLERANCE) {n.Matrix22.invert(m, m);var E = [v, y];n.Vector2.transformMatrix22(E, E, m), a = E[0], u = E[1];} else u = y / p, (a = v / g) <= 0 || u <= 0 ? (a = c(a, 0, 1), u = c(u, 0, 1)) : a < u ? (a = c(a, 0, 1), u = 0) : (a = 0, u = c(u, 0, 1));}if (a < 0 && y >= 0 && y <= p && (a = 0, u = y / p), u < 0 && v >= 0 && v <= g && (a = v / g, u = 0), a + u > 1) {var x = _(r, i, e);x >= 0 && x <= 1 && (a = 1 - x, u = x);}if (a < 0 || u < 0 || a + u > 1) {var R = n.Vector3.squaredLength(d),A = n.Vector3.squaredDistance(e, r),P = n.Vector3.squaredDistance(e, i);A <= R && A <= P ? (a = 1, u = 0) : P <= R && P <= A ? (a = 0, u = 1) : a = u = 0;}return s && (n.Vector3.scaleAndAdd(s, t, l, a), n.Vector3.scaleAndAdd(s, s, h, u)), { coordA: a, coordB: u };}, t.solveTwoEquationsTwoVariables = function (e) {var t = e[0][0],r = e[0][1],n = e[1][0],o = e[1][1],i = t * o - r * n;if (0 !== i) {var s = o * e[0][2] - r * e[1][2],a = -n * e[0][2] + t * e[1][2];return [s /= i, a /= i];}}, t.intersectIntervals = function (e, t, r) {r = r || 0;for (var n = [], o = 0; o < e.length; o++) {for (var i = 0; i < t.length; i++) {var s = Math.max(e[o][0], t[i][0]),a = Math.min(e[o][1], t[i][1]);a - r > s && (a > s ? n.push([s, a]) : n.push([a, a]));}}return n;}, t.signedDistanceTo2DLine = function (e, t, r) {var n = r[0] - e[0],o = r[1] - e[1];return t[1] * n - t[0] * o;}, t.orient2D = function (e, t, r) {var n = e[0] - r[0],o = t[0] - r[0],i = e[1] - r[1];return n * (t[1] - r[1]) - i * o;}, t.clamp = c, t.sortedIndex = function (e, t) {for (var r = 0, n = e.length; n > r;) {var o = Math.floor((r + n) / 2);t > e[o] ? r = o + 1 : n = o;}return n;}, t.PI2 = s, t.limitRange = function (e, t, r, o) {if (i.ConsoleUtils.assert(2 === t.length), i.ConsoleUtils.assert(t[0] <= t[1]), r) return t[1] - t[0] < o + n.FLOAT64_TOLERANCE ? [t[0], t[1]] : (console.warn("limitRange : in_limitRange length cannot be greater than in_period"), [t[0], t[0] + o]);var s = Math.max(e[0], t[0]),a = Math.min(e[1], t[1]);return s > a && (s > a + n.FLOAT64_TOLERANCE && console.warn("limitRange : requested range must overlap in_oldRange"), s = a = t[0] > e[1] ? e[1] : e[0]), [s, a];}, t.getPlaneTransforms = function (e) {var t,r,o = e.evaluateDu(0, 0),i = e.evaluateDv(0, 0),s = e.getOrigin();if (!n.Vector3.isParallel(o, [1, 0, 0], 1) || !n.Vector3.isParallel(i, [0, 1, 0], 1) || Math.abs(s[2]) > n.FLOAT64_TOLERANCE) {var a = e.evaluateNormal(0, 0);t = n.Matrix44.createFloat64FromValues(o[0], o[1], o[2], 0, i[0], i[1], i[2], 0, a[0], a[1], a[2], 0, s[0], s[1], s[2], 1), r = n.Matrix44.createFloat64(), n.Matrix44.invert(r, t);}return { uvToThreeSpace: t, threeSpaceToUV: r };}, t.definePlaneThroughPoints = function (e) {var t,r,i,s = [0, 0, 0],a = [0, 0, 0];if (!(e.length < 3)) {var c = [0, 0, 0];for (t = 0; t < e.length; ++t) {n.Vector3.add(c, c, e[t]);}n.Vector3.scale(c, c, 1 / e.length);var l = [0, 0, 0];r = 0;var h = 0,d = 0;for (t = 0; t < e.length; ++t) {(i = n.Vector3.squaredDistance(c, e[t])) > d && (d = i, h = t), (i /= 100) > r && (r = i, n.Vector3.sub(l, e[t], c));var g = (t + 1) % e.length;(i = n.Vector3.squaredDistance(e[t], e[g])) > r && (r = i, n.Vector3.sub(l, e[g], e[t]));}if (!(d < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE)) {n.Vector3.normalize(l, l);var p = [0, 0, 0];for (r = 0, t = 0; t < e.length; ++t) {n.Vector3.sub(s, e[t], c), n.Vector3.cross(s, s, l), (i = n.Vector3.squaredLength(s)) > r && (r = i, n.Vector3.copy(p, s));}if (!(r < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE)) {n.Vector3.normalize(p, p);var f = e[h],v = e[u(h - 1, e.length)],_ = e[u(h + 1, e.length)];n.Vector3.sub(s, v, f), n.Vector3.sub(a, _, f), n.Vector3.dot(n.Vector3.cross(a, a, s), p) < 0 && n.Vector3.negate(p, p);var y = [0, 0, 0];n.Vector3.cross(y, p, l), n.Vector3.normalize(y, y);var m = Number.POSITIVE_INFINITY,E = Number.NEGATIVE_INFINITY,x = Number.POSITIVE_INFINITY,R = Number.NEGATIVE_INFINITY;for (t = 0; t < e.length; ++t) {n.Vector3.sub(s, e[t], c);var A = n.Vector3.dot(s, l),P = n.Vector3.dot(s, y);m = Math.min(m, A), E = Math.max(E, A), x = Math.min(x, P), R = Math.max(R, P);}return { origin: c, normal: p, uAxis: l, vAxis: y, uRange: [m, E], vRange: [x, R] };}}}};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BoundingBox = void 0;var n = r(1),o = r(0),i = function i(e, t) {this.min = e ? n.Vector3.createFloat64FromValues(e[0], e[1], e[2]) : n.Vector3.createFloat64FromValues(1 / 0, 1 / 0, 1 / 0), this.max = t ? n.Vector3.createFloat64FromValues(t[0], t[1], t[2]) : n.Vector3.createFloat64FromValues(-1 / 0, -1 / 0, -1 / 0);};i.prototype.toString = function () {return "(x:" + this.min[0] + ", y:" + this.min[1] + ", z:" + this.min[2] + ") -> (x:" + this.max[0] + ", y:" + this.max[1] + ", z:" + this.max[2] + ")";}, i.prototype.copy = function (e) {return n.Vector3.copy(this.min, e.min), n.Vector3.copy(this.max, e.max), this;}, i.prototype.clone = function () {return new i(this.min, this.max);}, i.prototype.getWidth = function (e) {var t = 0;return 0 <= e && e <= 2 ? (t = this.max[e] - this.min[e], isFinite(t) ? t : 0) : (console.error("wrong axis argument supplied to BoundingBox.getWidth(): " + e), 0);}, i.prototype.getMaxMinAligned = function (e, t, r) {for (var o, s, a, c = this.getCorners(), u = [], l = [], h = [], d = 0; d < c.length; ++d) {o = n.Vector3.dot(c[d], e), s = n.Vector3.dot(c[d], t), a = n.Vector3.dot(c[d], r), u.push(o), l.push(s), h.push(a);}var g = Math.min.apply(void 0, u),p = Math.min.apply(void 0, l),f = Math.min.apply(void 0, h),v = Math.max.apply(void 0, u),_ = Math.max.apply(void 0, l),y = Math.max.apply(void 0, h);return new i([g, p, f], [v, _, y]);}, i.prototype.include = function (e) {return this.includeX(e.min[0], e.max[0]), this.includeY(e.min[1], e.max[1]), this.includeZ(e.min[2], e.max[2]), this;}, i.prototype.includeX = function (e, t) {return this.min[0] = Math.min(this.min[0], e), this.max[0] = Math.max(this.max[0], t), this;}, i.prototype.includeY = function (e, t) {return this.min[1] = Math.min(this.min[1], e), this.max[1] = Math.max(this.max[1], t), this;}, i.prototype.includeZ = function (e, t) {return this.min[2] = Math.min(this.min[2], e), this.max[2] = Math.max(this.max[2], t), this;}, i.prototype.includeSphere = function (e) {var t = e.getCenter(),r = e.getRadius();return this.includeX(t[0] - r, t[0] + r), this.includeY(t[1] - r, t[1] + r), this.includeZ(t[2] - r, t[2] + r), this;}, i.prototype.translate = function (e) {return n.Vector3.add(this.min, this.min, e), n.Vector3.add(this.max, this.max, e), this;}, i.prototype.getCorners = function () {var e = this.getDiagonal();return [n.Vector3.clone(this.min), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1] + e[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1], this.min[2] + e[2]), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1] + e[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1], this.min[2] + e[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1] + e[1], this.min[2] + e[2]), n.Vector3.clone(this.max)];}, i.prototype.transform = function (e) {if (!this.isEmpty()) {var t = this.getCorners();this.max[0] = -1 / 0, this.max[1] = -1 / 0, this.max[2] = -1 / 0, this.min[0] = 1 / 0, this.min[1] = 1 / 0, this.min[2] = 1 / 0;for (var r = 0; r < t.length; ++r) {n.Vector3.transformMatrix44(t[r], t[r], e), n.Vector3.max(this.max, this.max, t[r]), n.Vector3.min(this.min, this.min, t[r]);}}return this;}, i.prototype.includePointXYZ = function (e) {return this.includeX(e.x, e.x), this.includeY(e.y, e.y), this.includeZ(e.z, e.z), this;}, i.prototype.includePoint = function (e) {return this.includeX(e[0], e[0]), this.includeY(e[1], e[1]), this.includeZ(e[2], e[2]), this;}, i.prototype.getCenter = function () {var e = n.Vector3.createFloat64();return n.Vector3.add(e, this.min, this.max), n.Vector3.scale(e, e, .5), e;}, i.prototype.getDiagonal = function () {var e = n.Vector3.createFloat64();return n.Vector3.sub(e, this.max, this.min), e;}, i.prototype.isPointInside = function (e) {return !(e[0] < this.min[0] || e[0] > this.max[0] || e[1] < this.min[1] || e[1] > this.max[1] || e[2] < this.min[2] || e[2] > this.max[2]);}, i.prototype.isPointInsideWithTolerance = function (e, t) {return t || (t = o.KERNEL_TOLERANCE), !(e[0] < this.min[0] - t || e[0] > this.max[0] + t || e[1] < this.min[1] - t || e[1] > this.max[1] + t || e[2] < this.min[2] - t || e[2] > this.max[2] + t);}, i.prototype.intersects = function (e) {return !(e.min[0] > this.max[0] || e.max[0] < this.min[0] || e.min[1] > this.max[1] || e.max[1] < this.min[1] || e.min[2] > this.max[2] || e.max[2] < this.min[2]);}, i.prototype.intersectsWithTolerance = function (e, t) {return t || (t = o.KERNEL_TOLERANCE), !(e.min[0] > this.max[0] + t || e.max[0] < this.min[0] - t || e.min[1] > this.max[1] + t || e.max[1] < this.min[1] - t || e.min[2] > this.max[2] + t || e.max[2] < this.min[2] - t);}, i.prototype.isEmpty = function () {return this.max[0] < this.min[0] || this.max[1] < this.min[1] || this.max[2] < this.min[2];}, i.prototype.setEmpty = function () {return this.max[0] = -1 / 0, this.min[0] = 1 / 0, this.max[1] = -1 / 0, this.min[1] = 1 / 0, this.max[2] = -1 / 0, this.min[2] = 1 / 0, this;}, i.prototype.isBounded = function () {return isFinite(this.max[0]) && isFinite(this.max[1]) && isFinite(this.max[2]) && isFinite(this.min[0]) && isFinite(this.min[1]) && isFinite(this.min[2]);}, t.BoundingBox = i;}, function (e, t, r) {"use strict";var n,o,i = e.exports = r(10),s = r(61);i.codegen = r(99), i.fetch = r(100), i.path = r(101), i.fs = i.inquire("fs"), i.toArray = function (e) {if (e) {for (var t = Object.keys(e), r = new Array(t.length), n = 0; n < t.length;) {r[n] = e[t[n++]];}return r;}return [];}, i.toObject = function (e) {for (var t = {}, r = 0; r < e.length;) {var n = e[r++],o = e[r++];void 0 !== o && (t[n] = o);}return t;};var a = /\\/g,c = /"/g;i.isReserved = function (e) {return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(e);}, i.safeProp = function (e) {return !/^[$\w_]+$/.test(e) || i.isReserved(e) ? '["' + e.replace(a, "\\\\").replace(c, '\\"') + '"]' : "." + e;}, i.ucFirst = function (e) {return e.charAt(0).toUpperCase() + e.substring(1);};var u = /_([a-z])/g;i.camelCase = function (e) {return e.substring(0, 1) + e.substring(1).replace(u, function (e, t) {return t.toUpperCase();});}, i.compareFieldsById = function (e, t) {return e.id - t.id;}, i.decorateType = function (e, t) {if (e.$type) return t && e.$type.name !== t && (i.decorateRoot.remove(e.$type), e.$type.name = t, i.decorateRoot.add(e.$type)), e.$type;n || (n = r(63));var o = new n(t || e.name);return i.decorateRoot.add(o), o.ctor = e, Object.defineProperty(e, "$type", { value: o, enumerable: !1 }), Object.defineProperty(e.prototype, "$type", { value: o, enumerable: !1 }), o;};var l = 0;i.decorateEnum = function (e) {if (e.$type) return e.$type;o || (o = r(11));var t = new o("Enum" + l++, e);return i.decorateRoot.add(t), Object.defineProperty(e, "$type", { value: t, enumerable: !1 }), t;}, Object.defineProperty(i, "decorateRoot", { get: function get() {return s.decorated || (s.decorated = new (r(71))());} });}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Point = void 0;var n = r(1),o = r(43),i = r(4),s = r(0),a = function a(e) {o.BaseGeometry.call(this), this._position = n.Vector3.createFloat64(), e && n.Vector3.copy(this._position, e);};(a.prototype = Object.create(o.BaseGeometry.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.POINT;}, a.prototype.clone = function () {var e = new a();return e.copy(this), e;}, a.prototype.copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this.copyPosition(e.getPosition());}, a.prototype.getPosition = function () {return this._position;}, a.prototype.copyPosition = function (e) {n.Vector3.copy(this._position, e);}, a.prototype.setPosition = function (e, t, r) {n.Vector3.set(this._position, e, t, r);}, a.prototype.getBoundingBox = function () {var e = new i.BoundingBox();return e.includePoint(this.getPosition()), e;}, a.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._position, this._position, e);}, a.prototype.toObject = function () {return { position: this.vectorToObject(this._position) };}, t.Point = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Line = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(2),l = function l() {a.Curve.call(this), this._position = n.Vector3.createFloat64FromValues(0, 0, 0), this._direction = n.Vector3.createFloat64FromValues(1, 0, 0);};(l.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.LINE;}, l.prototype.set = function (e, t) {u.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.copy(this._position, e), n.Vector3.copy(this._direction, t);}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.tessellate = function (e, t) {var r = { positions: [], offsets: [], tolerance: 0 };r.offsets.push(0);var n = e[0];r.positions.push(this.evaluatePosition(n));for (var o = 1; o < e.length; ++o) {var i = e[o];r.positions.push(this.evaluatePosition(i)), r.offsets.push(r.positions.length - 1), n = i;}return r;}, l.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._position, e._position), n.Vector3.copy(this._direction, e._direction);}, l.prototype.getRangeUnlimited = function () {return [-1 / 0, 1 / 0];}, l.prototype.isPeriodicUnlimited = function () {return !1;}, l.prototype.isClosedUnlimited = function () {return !1;}, l.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(t, this._position, this._direction, e);}, l.prototype.evaluateDt = function (e) {return n.Vector3.clone(this._direction);}, l.prototype.tangentLength = function (e) {return n.Vector3.length(this._direction);}, l.prototype.getTangentCone = function (e) {var t = n.Vector3.createFloat64();return new i.TangentCone(n.Vector3.normalize(t, this.evaluateDt(0)), 0);}, l.prototype.getArcLength = function (e) {return void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited()), isFinite(e[0]) && isFinite(e[1]) ? (e[1] - e[0]) * n.Vector3.length(this._direction) : 1 / 0;}, l.prototype.getParameterFromArcLength = function (e, t) {if (void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited()), isFinite(t[0]) && isFinite(t[1])) {var r = t[0] + e / n.Vector3.length(this._direction);return (0, c.clamp)(r, t[0], t[1]);}return NaN;}, l.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = new o.BoundingBox();return isFinite(e[0]) && isFinite(e[1]) ? (t.includePoint(this.evaluatePosition(e[0])), t.includePoint(this.evaluatePosition(e[1]))) : (t.includePoint([1 / 0, 1 / 0, 1 / 0]), t.includePoint([-1 / 0, -1 / 0, -1 / 0])), t;}, l.prototype.closestToRayParam = function (e, t, r, o) {var i = n.Vector3.createFloat64();n.Vector3.sub(i, this._position, e);var s = n.Vector3.squaredLength(this._direction),a = n.Vector3.squaredLength(t),c = n.Vector3.dot(this._direction, t),u = n.Vector3.dot(i, this._direction),l = n.Vector3.dot(i, t),h = s * a - c * c,d = (c * l - a * u) / h,g = (c * u - s * l) / h;if (isFinite(d) && isFinite(g)) {if (r) if (d < r[0]) {if (d = r[0], void 0 !== o) {var p = this.evaluatePosition(r[0]),f = n.Vector3.createFloat64();n.Vector3.sub(f, p, e), g = n.Vector3.dot(f, t) / a;}} else if (d > r[1] && (d = r[1], void 0 !== o)) {var v = this.evaluatePosition(r[1]);f = n.Vector3.createFloat64(), n.Vector3.sub(f, v, e), g = n.Vector3.dot(f, t) / a;}if (void 0 !== o) {var _ = this.evaluatePosition(d),y = n.Vector3.createFloat64();if (n.Vector3.scaleAndAdd(y, e, t, g), n.Vector3.squaredDistance(_, y) > o * o) return;}return d;}}, l.prototype.setFromEndpoints = function (e, t) {u.ConsoleUtils.assert(n.Vector3.squaredDistance(e, t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._position = n.Vector3.clone(e), n.Vector3.normalize(this._direction, n.Vector3.sub(this._direction, t, e)), this.unlimitRange();}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._position, this._position, e), n.Vector3.transformAsDirectionMatrix44(this._direction, this._direction, e);}, l.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._position);var o = this._direction,i = n.Vector3.dot(r, o) / n.Vector3.squaredLength(o);return isFinite(t[0]) && isFinite(t[1]) ? (0, c.clamp)(i, t[0], t[1]) : i;}, l.prototype.suggestSplittingParam = function (e) {}, l.prototype.toObject = function () {return { position: this.vectorToObject(this._position), direction: this.vectorToObject(this._direction), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Line = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = !1,o = !1,i = {},s = { init3D: function init3D(e) {for (var t in n = !0, e) {"function" == typeof e[t] && (s[t] = e[t].bind(e));}}, setLevel: function setLevel(e, t) {var r = i[e];return i[e] = t, console.log("Debug of " + e + " set to level " + t), r;}, level: function level(e) {if (!n) return 0;var t = i[e];return void 0 === t ? 0 : t;}, setConsoleWarnings: function setConsoleWarnings(e) {o = e;}, warn: function warn(e) {o && console.warn(e);} };t.DebugUtils = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseTopology = void 0;var n = r(44),o = r(0),i = function i() {n.Base.call(this), this._attributes = [];};(i.prototype = Object.create(n.Base.prototype)).getTopologyType = function () {console.warn("BaseTopology.getTopologyType : abstract method invoked!");}, i.prototype.getBoundingBox = function () {console.warn("BaseTopology.getBoundingBox : abstract method invoked!");}, i.prototype.getBody = function () {console.warn("BaseTopology.getBody : abstract method invoked!");}, i.prototype.collectFaces = function (e) {return console.warn("BaseTopology.collectFaces : abstract method invoked!"), e || new Set();}, i.prototype.collectEdges = function (e) {return console.warn("BaseTopology.collectEdges : abstract method invoked!"), e || new Set();}, i.prototype.collectVertices = function (e) {return console.warn("BaseTopology.collectVertices : abstract method invoked!"), e || new Set();}, i.prototype.getAttributes = function () {return this._attributes;}, i.prototype.addAttribute = function (e) {this._attributes ? this._attributes.push(e) : this._attributes = [e], e.addTopology(this);}, i.prototype.removeAttribute = function (e) {var t = this._attributes.indexOf(e);return t > -1 && (this._attributes.splice(t, 1), e.removeTopology(this), !0);}, i.prototype.removeAllAttributes = function () {if (this._attributes) for (var _e2 = 0; _e2 < this._attributes.length; _e2++) {this.removeAttribute(this._attributes[_e2]);}}, i.prototype.isVertex = function () {return this.getTopologyType() === o.TOPOLOGY_TYPES.VERTEX;}, i.prototype.getFaces = function () {return Array.from(this.collectFaces());}, i.prototype.getEdges = function () {return Array.from(this.collectEdges());}, i.prototype.getVertices = function () {return Array.from(this.collectVertices());}, i.prototype.addAllToModelObject = function (e, t) {if (!e.topologies[this.getGuid()]) {var _t2 = {};_t2[o.TOPOLOGY_TYPES.toString(this.getTopologyType()).toLowerCase()] = this.toObject(), e.topologies[this.getGuid()] = _t2;}t.forEach(function (t) {null != t && (Array.isArray(t) ? t.forEach(function (t) {t.addToModelObject(e);}) : t.addToModelObject(e));});}, t.BaseTopology = i;}, function (e, t, r) {"use strict";(function (e) {var n = t;function o(e, t, r) {for (var n = Object.keys(t), o = 0; o < n.length; ++o) {void 0 !== e[n[o]] && r || (e[n[o]] = t[n[o]]);}return e;}function i(e) {function t(e, r) {if (!(this instanceof t)) return new t(e, r);Object.defineProperty(this, "message", { get: function get() {return e;} }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), r && o(this, r);}return (t.prototype = Object.create(Error.prototype)).constructor = t, Object.defineProperty(t.prototype, "name", { get: function get() {return e;} }), t.prototype.toString = function () {return this.name + ": " + this.message;}, t;}n.asPromise = r(58), n.base64 = r(90), n.EventEmitter = r(91), n.float = r(92), n.inquire = r(59), n.utf8 = r(93), n.pool = r(94), n.LongBits = r(95), n.global = "undefined" != typeof window && window || void 0 !== e && e || "undefined" != typeof self && self || this, n.emptyArray = Object.freeze ? Object.freeze([]) : [], n.emptyObject = Object.freeze ? Object.freeze({}) : {}, n.isNode = Boolean(n.global.process && n.global.process.versions && n.global.process.versions.node), n.isInteger = Number.isInteger || function (e) {return "number" == typeof e && isFinite(e) && Math.floor(e) === e;}, n.isString = function (e) {return "string" == typeof e || e instanceof String;}, n.isObject = function (e) {return e && "object" == _typeof(e);}, n.isset = n.isSet = function (e, t) {var r = e[t];return !(null == r || !e.hasOwnProperty(t)) && ("object" != _typeof(r) || (Array.isArray(r) ? r.length : Object.keys(r).length) > 0);}, n.Buffer = function () {try {var e = n.inquire("buffer").Buffer;return e.prototype.utf8Write ? e : null;} catch (e) {return null;}}(), n._Buffer_from = null, n._Buffer_allocUnsafe = null, n.newBuffer = function (e) {return "number" == typeof e ? n.Buffer ? n._Buffer_allocUnsafe(e) : new n.Array(e) : n.Buffer ? n._Buffer_from(e) : "undefined" == typeof Uint8Array ? e : new Uint8Array(e);}, n.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, n.Long = n.global.dcodeIO && n.global.dcodeIO.Long || n.global.Long || n.inquire("long"), n.key2Re = /^true|false|0|1$/, n.key32Re = /^-?(?:0|[1-9][0-9]*)$/, n.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, n.longToHash = function (e) {return e ? n.LongBits.from(e).toHash() : n.LongBits.zeroHash;}, n.longFromHash = function (e, t) {var r = n.LongBits.fromHash(e);return n.Long ? n.Long.fromBits(r.lo, r.hi, t) : r.toNumber(Boolean(t));}, n.merge = o, n.lcFirst = function (e) {return e.charAt(0).toLowerCase() + e.substring(1);}, n.newError = i, n.ProtocolError = i("ProtocolError"), n.oneOfGetter = function (e) {for (var t = {}, r = 0; r < e.length; ++r) {t[e[r]] = 1;}return function () {for (var e = Object.keys(this), r = e.length - 1; r > -1; --r) {if (1 === t[e[r]] && void 0 !== this[e[r]] && null !== this[e[r]]) return e[r];}};}, n.oneOfSetter = function (e) {return function (t) {for (var r = 0; r < e.length; ++r) {e[r] !== t && delete this[e[r]];}};}, n.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }, n._configure = function () {var e = n.Buffer;e ? (n._Buffer_from = e.from !== Uint8Array.from && e.from || function (t, r) {return new e(t, r);}, n._Buffer_allocUnsafe = e.allocUnsafe || function (t) {return new e(t);}) : n._Buffer_from = n._Buffer_allocUnsafe = null;};}).call(this, r(57));}, function (e, t, r) {"use strict";e.exports = s;var n = r(21);((s.prototype = Object.create(n.prototype)).constructor = s).className = "Enum";var o = r(30),i = r(5);function s(e, t, r, o, i) {if (n.call(this, e, r), t && "object" != _typeof(t)) throw TypeError("values must be an object");if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = o, this.comments = i || {}, this.reserved = void 0, t) for (var s = Object.keys(t), a = 0; a < s.length; ++a) {"number" == typeof t[s[a]] && (this.valuesById[this.values[s[a]] = t[s[a]]] = s[a]);}}s.fromJSON = function (e, t) {var r = new s(e, t.values, t.options, t.comment, t.comments);return r.reserved = t.reserved, r;}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject(["options", this.options, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "comment", t ? this.comment : void 0, "comments", t ? this.comments : void 0]);}, s.prototype.add = function (e, t, r) {if (!i.isString(e)) throw TypeError("name must be a string");if (!i.isInteger(t)) throw TypeError("id must be an integer");if (void 0 !== this.values[e]) throw Error("duplicate name '" + e + "' in " + this);if (this.isReservedId(t)) throw Error("id " + t + " is reserved in " + this);if (this.isReservedName(e)) throw Error("name '" + e + "' is reserved in " + this);if (void 0 !== this.valuesById[t]) {if (!this.options || !this.options.allow_alias) throw Error("duplicate id " + t + " in " + this);this.values[e] = t;} else this.valuesById[this.values[e] = t] = e;return this.comments[e] = r || null, this;}, s.prototype.remove = function (e) {if (!i.isString(e)) throw TypeError("name must be a string");var t = this.values[e];if (null == t) throw Error("name '" + e + "' does not exist in " + this);return delete this.valuesById[t], delete this.values[e], delete this.comments[e], this;}, s.prototype.isReservedId = function (e) {return o.isReservedId(this.reserved, e);}, s.prototype.isReservedName = function (e) {return o.isReservedName(this.reserved, e);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Surface = void 0;var n = r(1),o = r(43),i = r(0),s = r(3),a = function a() {o.BaseGeometry.call(this), this._subrangeU = [], this._subrangeV = [];};(a.prototype = Object.create(o.BaseGeometry.prototype)).copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this._subrangeU = e.isLimitedU() ? [e._subrangeU[0], e._subrangeU[1]] : [], this._subrangeV = e.isLimitedV() ? [e._subrangeV[0], e._subrangeV[1]] : [];}, a.prototype.isLimitedU = function () {return this._subrangeU.length > 0;}, a.prototype.isLimitedV = function () {return this._subrangeV.length > 0;}, a.prototype.getRangeU = function () {return this.isLimitedU() ? this._subrangeU : this.getRangeUnlimitedU();}, a.prototype.getRangeV = function () {return this.isLimitedV() ? this._subrangeV : this.getRangeUnlimitedV();}, a.prototype.getRangeUnlimitedU = function () {console.warn("Surface.getRangeUnlimitedU : abstract method invoked!");}, a.prototype.getRangeUnlimitedV = function () {console.warn("Surface.getRangeUnlimitedV : abstract method invoked!");}, a.prototype.limitRangeU = function (e) {var t = this.getRangeU();this._subrangeU = (0, s.limitRange)(t, e, this.isPeriodicU(), this.getPeriodU());}, a.prototype.limitRangeV = function (e) {var t = this.getRangeV();this._subrangeV = (0, s.limitRange)(t, e, this.isPeriodicV(), this.getPeriodV());}, a.prototype.unlimitRangeU = function () {this._subrangeU = [];}, a.prototype.unlimitRangeV = function () {this._subrangeV = [];}, a.prototype.isPeriodicU = function () {return this.isPeriodicUnlimitedU() && !this.isLimitedU();}, a.prototype.isPeriodicV = function () {return this.isPeriodicUnlimitedV() && !this.isLimitedV();}, a.prototype.isPeriodicUnlimitedU = function () {console.warn("Surface.isPeriodicUnlimitedU : abstract method invoked!");}, a.prototype.isPeriodicUnlimitedV = function () {console.warn("Surface.isPeriodicUnlimitedV : abstract method invoked!");}, a.prototype.getPeriodU = function () {return this.isLimitedU() ? void 0 : this.getPeriodUnlimitedU();}, a.prototype.getPeriodV = function () {return this.isLimitedV() ? void 0 : this.getPeriodUnlimitedV();}, a.prototype.getPeriodUnlimitedU = function () {if (this.isPeriodicUnlimitedU()) {var e = this.getRangeUnlimitedU();return e[1] - e[0];}}, a.prototype.getPeriodUnlimitedV = function () {if (this.isPeriodicUnlimitedV()) {var e = this.getRangeUnlimitedV();return e[1] - e[0];}}, a.prototype.isClosedU = function () {if (this.isClosedUnlimitedU()) {if (this.isLimitedU()) {var e = this.getRangeUnlimitedU(),t = e[1] - e[0];return this._subrangeU[1] - this._subrangeU[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, a.prototype.isClosedV = function () {if (this.isClosedUnlimitedV()) {if (this.isLimitedV()) {var e = this.getRangeUnlimitedV(),t = e[1] - e[0];return this._subrangeV[1] - this._subrangeV[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, a.prototype.isClosedUnlimitedU = function () {console.warn("Surface.isClosedUnlimitedU : abstract method invoked!");}, a.prototype.isClosedUnlimitedV = function () {console.warn("Surface.isClosedUnlimitedV : abstract method invoked!");}, a.prototype.evaluatePosition = function (e, t) {console.warn("Surface.evaluatePosition : abstract method invoked");}, a.prototype.evaluateDu = function (e, t) {console.warn("Surface.evaluateDu : abstract method invoked");}, a.prototype.evaluateDv = function (e, t) {console.warn("Surface.evaluateDv : abstract method invoked");}, a.prototype.evaluateNormal = function (e, t) {var r = this.evaluateDu(e, t);return n.Vector3.cross(r, r, this.evaluateDv(e, t)), n.Vector3.normalize(r, r), r;}, a.prototype.closestParam = function (e) {console.warn("Surface.closestParam : abstract method invoked");}, a.prototype.vParamLine = function (e) {console.warn("Surface.vParamLine : abstract method invoked, returning undefined");}, a.prototype.uParamLine = function (e) {console.warn("Surface.uParamLine : abstract method invoked, returning undefined");}, a.prototype.getBoundingBox = function (e, t) {console.warn("Surface.getBoundingBox : abstract method invoked, returning undefined");}, a.prototype.transform = function (e) {console.warn("Surface.transform : abstract method invoked");}, t.Surface = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Loop = void 0;var n = r(9),o = r(0),i = function i() {n.BaseTopology.call(this), this._coedges = [], this._face = void 0;};(i.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.LOOP;}, i.prototype.getFace = function () {return this._face;}, i.prototype.setFace = function (e) {this._face = e;}, i.prototype.getCoedges = function () {return this._coedges;}, i.prototype.setCoedges = function (e) {this._coedges = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._coedges[t] = e[t];}}, i.prototype.addCoedge = function (e) {this._coedges ? this._coedges.push(e) : this._coedges = [e], e.setLoop(this);}, i.prototype.addCoedges = function (e) {this._coedges || (this._coedges = []);for (var t = 0; t < e.length; ++t) {e[t].setLoop(this);}this._coedges = this._coedges.concat(e);}, i.prototype.removeCoedge = function (e) {var t = this._coedges.indexOf(e);return t > -1 && (this._coedges.splice(t, 1), e.getLoop() === this && e.setLoop(void 0), !0);}, i.prototype.getBody = function () {return this._face ? this._face.getBody() : void 0;}, i.prototype.collectFaces = function (e) {return e = e || new Set(), this._face && e.add(this._face), e;}, i.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._coedges.length; ++t) {this._coedges[t].collectEdges(e);}return e;}, i.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._coedges.length; ++t) {this._coedges[t].collectVertices(e);}return e;}, i.prototype.toString = function () {return "Loop";}, i.prototype.toObject = function () {return { coedges: this.refsToStrings(this._coedges), attributes: this.refsToStrings(this._attributes) };}, i.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._coedges, this._attributes]);}, t.Loop = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Circle = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(2),l = r(50),h = function h() {a.Curve.call(this), this._center = n.Vector3.createFloat64FromValues(0, 0, 0), this._normal = n.Vector3.createFloat64FromValues(0, 0, 1), this._xAxis = n.Vector3.createFloat64FromValues(1, 0, 0), this._yAxis = n.Vector3.createFloat64FromValues(0, 1, 0), this._radius = 1;};(h.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.CIRCLE;}, h.prototype.set = function (e, t, r) {u.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.squaredLength(r) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(t, r, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.copy(this._center, e), n.Vector3.normalize(this._normal, t), n.Vector3.normalize(this._xAxis, r), this._radius = n.Vector3.length(r), this._computeYAxis();}, h.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._normal, this._xAxis);}, h.prototype.clone = function () {var e = new h();return e.copy(this), e;}, h.prototype.getCenter = function () {return this._center;}, h.prototype.getNormal = function () {return this._normal;}, h.prototype.setNormal = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._normal !== e && (n.Vector3.normalize(this._normal, e), n.Vector3.isOrthogonal(this._xAxis, this._normal) || (n.Vector3.computeOrthogonal(this._xAxis, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis());}, h.prototype.getRadius = function () {return this._radius;}, h.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._radius = e;}, h.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, h.prototype.setOrigin = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(e, this._normal, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, h.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), this._radius = e._radius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._normal, e._normal);}, h.prototype.getRangeUnlimited = function () {return [-Math.PI, Math.PI];}, h.prototype.isPeriodicUnlimited = function () {return !0;}, h.prototype.isClosedUnlimited = function () {return !0;}, h.prototype._computeRadiusVector = function () {return n.Vector3.scale(n.Vector3.createFloat64(), this._xAxis, this._radius);}, h.prototype.tessellate = function (e, t) {t = t || s.TESSELLATION.LINEAR_PRECISION;var r = { positions: [], offsets: [], tolerance: 0 };r.offsets.push(0);for (var n = e[0], o = 1; o < e.length; ++o) {var i = e[o],a = l.CurveTessellator.getCircularArcRenderPoints(this, [n, i], t, 1 === o, r.positions);r.offsets.push(r.positions.length - 1), n = i, r.tolerance = Math.max(r.tolerance, a);}return r;}, h.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, Math.cos(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.sin(e) * this._radius), n.Vector3.add(t, t, this._center), t;}, h.prototype.evaluateDt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.sin(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.cos(e) * this._radius), t;}, h.prototype.evaluateDtt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.cos(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, -Math.sin(e) * this._radius), t;}, h.prototype.tangentLength = function (e) {return this.getRadius();}, h.prototype.getArcLength = function (e) {return void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited()), this.getRadius() * (e[1] - e[0]);}, h.prototype.getParameterFromArcLength = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = t[0] + e / this.getRadius();return (0, c.clamp)(r, t[0], t[1]);}, h.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = (0, c.minMaxCosSinFunc)(this._xAxis[0] * this._radius, this._yAxis[0] * this._radius, this._center[0], e),r = (0, c.minMaxCosSinFunc)(this._xAxis[1] * this._radius, this._yAxis[1] * this._radius, this._center[1], e),n = (0, c.minMaxCosSinFunc)(this._xAxis[2] * this._radius, this._yAxis[2] * this._radius, this._center[2], e),i = new o.BoundingBox();return i.min[0] = t[0], i.max[0] = t[1], i.min[1] = r[0], i.max[1] = r[1], i.min[2] = n[0], i.max[2] = n[1], i;}, h.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = .5 * (e[0] + e[1]),r = n.Vector3.createFloat64FromValues(0, 0, 0);n.Vector3.scaleAndAdd(r, r, this._xAxis, -Math.sin(t)), n.Vector3.scaleAndAdd(r, r, this._yAxis, Math.cos(t));var o = Math.min(Math.PI, .5 * (e[1] - e[0]));return new i.TangentCone(r, o);}, h.prototype.closestToRayParam = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, this._center, e);var i = n.Vector3.dot(o, this._normal) / n.Vector3.dot(t, this._normal);if (isFinite(i)) {var s = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(s, e, t, i), this.closestToPointParam(s, r);}}, h.prototype.getRadiusAndRangeFromEndpoints = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center);var i = n.Vector3.createFloat64();n.Vector3.sub(i, t, this._center);var a,u = .5 * (n.Vector3.length(o) + n.Vector3.length(i)),l = n.Vector3.dot(o, this._xAxis),h = n.Vector3.dot(o, this._yAxis),d = (0, c.normalizeAngle)(Math.atan2(h, l));if (e === t || n.Vector3.squaredDistance(e, t) < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) a = d + c.PI2;else {var g = n.Vector3.dot(i, this._xAxis),p = n.Vector3.dot(i, this._yAxis);if ((a = (0, c.normalizeAngle)(Math.atan2(p, g))) < d && (a += c.PI2), r) {var f = a;a = d, d = f - c.PI2;}}return { radius: u, range: [d, a] };}, h.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._center);var o,i = n.Vector3.dot(r, this._xAxis),a = n.Vector3.dot(r, this._yAxis);return o = i * i + a * a < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE ? .5 * Math.PI : Math.atan2(a, i), o = (0, c.foldNearTo)(o, .5 * (t[0] + t[1]), 2 * Math.PI), (0, c.clamp)(o, t[0], t[1]);}, h.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.scale(this._xAxis, this._xAxis, this._radius), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), this._radius = n.Vector3.length(this._xAxis), n.Vector3.normalize(this._normal, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis), this._computeYAxis();}, h.prototype.suggestSplittingParam = function (e) {}, h.prototype.toObject = function () {var e = this.evaluatePosition(0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), normal: this.vectorToObject(this._normal), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Circle = h;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Face = void 0;var n = r(1),o = r(9),i = r(0),s = r(8),a = function a(e) {o.BaseTopology.call(this), this._surface = e, this._reversed = !1, this._loops = [], this._shell = void 0;};(a.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.FACE;}, a.prototype.getSurfaceType = function () {return this._surface ? this._surface.getGeometryType() : void 0;}, a.prototype.clone = function () {var e = new a();return e._surface = this._surface ? this._surface.clone() : void 0, e._reversed = this._reversed, e.setLoops(this._loops), e._shell = this._shell, e._vertexUvData = void 0, e;}, a.prototype.getSurface = function () {return this._surface;}, a.prototype.setSurface = function (e) {this._surface = e;}, a.prototype.getShell = function () {return this._shell;}, a.prototype.setShell = function (e) {this._shell = e;}, a.prototype.getLoops = function () {return this._loops;}, a.prototype.setLoops = function (e) {this._loops = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._loops[t] = e[t];}}, a.prototype.addLoop = function (e) {this._loops ? this._loops.push(e) : this._loops = [e], e.setFace(this);}, a.prototype.addLoops = function (e) {this._loops || (this._loops = []);for (var t = 0; t < e.length; ++t) {e[t].setFace(this);}this._loops = this._loops.concat(e);}, a.prototype.removeLoop = function (e) {var t = this._loops.indexOf(e);return t > -1 && (this._loops.splice(t, 1), e.getFace() === this && e.setFace(void 0), !0);}, a.prototype.isReversed = function () {return this._reversed;}, a.prototype.setReversed = function (e) {this._reversed = e;}, a.prototype.getVertices = function () {return Array.from(this.collectVertices());}, a.prototype.evaluatePosition = function (e, t) {return this._surface.evaluatePosition(e, t);}, a.prototype.evaluateNormal = function (e, t) {var r = this._surface.evaluateNormal(e, t);return !0 === this.isReversed() && n.Vector3.negate(r, r), r;}, a.prototype.getBody = function () {return this._shell ? this._shell.getBody() : void 0;}, a.prototype.collectFaces = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._loops.length; ++t) {this._loops[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._loops.length; ++t) {this._loops[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {var e = this._surface.getRangeU(),t = this._surface.getRangeV();return isFinite(e[0]) && isFinite(e[1]) || (s.DebugUtils.warn("Face.getBoundingBox: Surface is unbounded in u."), e = [0, 1]), isFinite(t[0]) && isFinite(t[1]) || (s.DebugUtils.warn("Face.getBoundingBox: Surface is unbounded in v."), t = [0, 1]), this._surface.getBoundingBox(e, t);}, a.prototype.closestParam = function (e) {return this._surface.closestParam(e);}, a.prototype.isPlanarFace = function () {return this.getSurfaceType() === i.GEOMETRY_TYPES.PLANE;}, a.prototype.toObject = function () {return { loops: this.refsToStrings(this._loops), reversed: this._reversed, geometry: this.refToString(this._surface), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._loops, this._surface, this._attributes]);}, t.Face = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Vertex = void 0;var n = r(9),o = r(0),i = r(2),s = r(78),a = function a(e) {n.BaseTopology.call(this), this._point = e, this._precision = 0, this._edges = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.VERTEX;}, a.prototype.getPoint = function () {return this._point;}, a.prototype.setPoint = function (e) {this._point = e;}, a.prototype.getPrecision = function () {return this._precision;}, a.prototype.setPrecision = function (e) {i.ConsoleUtils.assert(e >= 0), this._precision = e;}, a.prototype.getEdges = function () {return this._edges;}, a.prototype.isAdjacentEdge = function (e) {return -1 !== this._edges.indexOf(e);}, a.prototype.getOtherEdge = function (e) {for (var t = 0; t < this._edges.length; t++) {var r = this._edges[t];if (r !== e) return r;}return null;}, a.prototype.getOtherEdges = function (e) {for (var t = [], r = 0; r < this._edges.length; r++) {var n = this._edges[r];n !== e && t.push(n);}return t;}, a.prototype.getAdjacentVertices = function () {for (var e = [], t = 0; t < this._edges.length; t++) {var r = this._edges[t].getOtherVertex(this);r !== this && e.indexOf(r) < 0 && e.push(r);}return e;}, a.prototype.getCommonEdges = function (e) {for (var t = [], r = 0; r < this._edges.length; r++) {var n = this._edges[r],o = n.getStartVertex(),i = n.getEndVertex();(o === this && i === e || i === this && o === e) && t.push(n);}return t;}, a.prototype.addEdge = function (e) {-1 === this._edges.indexOf(e) && this._edges.push(e);}, a.prototype.removeEdge = function (e) {var t = this._edges.indexOf(e);return t >= 0 && (this._edges.splice(t, 1), !0);}, a.prototype.getPosition = function () {return this._point.getPosition();}, a.prototype.getBody = function () {return this._edges.length > 0 ? this._edges[0].getBody() : void 0;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {this._edges[t].collectFaces(e);}return e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {e.add(this._edges[t]);}return e;}, a.prototype.collectVertices = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.getBoundingBox = function () {return this._point.getBoundingBox();}, a.prototype.toString = function () {return String(this._point.getPosition());}, a.prototype.getOrderedFaces = function () {var e = [],t = (0, s.getOrderedFacesOnVertex)(this);for (var _r = 0; _r < t.length; _r++) {t[_r].faces.forEach(function (t) {e.push(t);});}return e;}, a.prototype.toObject = function () {return { geometry: this.refToString(this._point), precision: this.getPrecision(), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._point, this._attributes]);}, t.Vertex = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.controlPointsFromHomogeneous = t.controlPointsToHomogeneous = t.getUniqueKnots = t.findKnotSpanAndMultiplicity = t.findKnotSpan = void 0;var n = r(0),o = r(2),i = function i(e, t) {var r = 0,n = t.length - 1;if (e <= t[r]) {for (; t[r] === t[r + 1] && r < n - 1;) {r += 1;}return r;}if (e >= t[n]) {for (; t[n] === t[n - 1] && n > r + 1;) {n -= 1;}return n - 1;}for (var o = Math.floor((r + n) / 2); e < t[o] || e >= t[o + 1];) {e < t[o] ? n = o : r = o, o = Math.floor((r + n) / 2);}return o;};t.findKnotSpan = i, t.findKnotSpanAndMultiplicity = function (e, t) {var r = n.PARAMETER_SPACE_TOLERANCE,o = i(e, t),s = 0,a = e,c = o;if (e < t[c] + r) for (a = t[c]; c >= 0 && Math.abs(t[c] - a) < r;) {--c, ++s;} else if (e > t[c + 1] - r) {for (a = t[++c]; c < t.length && Math.abs(t[c] - a) < r;) {++c, ++s;}a = c < t.length ? t[o = c - 1] : t[t.length - 1];}return { span: o, multiplicity: s, knot: a };}, t.getUniqueKnots = function (e) {for (var t = [e[0]], r = 1; r < e.length; ++r) {e[r] !== e[r - 1] && t.push(e[r]);}return t;}, t.controlPointsToHomogeneous = function (e, t) {o.ConsoleUtils.assert(e.length > 0 && e.length === 3 * t.length);for (var r = t.length, n = new Array(4 * r), i = 0; i < r; ++i) {var s = t[i];n[4 * i] = e[3 * i] * s, n[4 * i + 1] = e[3 * i + 1] * s, n[4 * i + 2] = e[3 * i + 2] * s, n[4 * i + 3] = s;}return n;}, t.controlPointsFromHomogeneous = function (e) {o.ConsoleUtils.assert(e.length > 0 && e.length % 4 == 0);for (var t = e.length / 4, r = new Array(3 * t), n = new Array(t), i = 0; i < t; ++i) {var s = e[4 * i + 3];r[3 * i] = e[4 * i] / s, r[3 * i + 1] = e[4 * i + 1] / s, r[3 * i + 2] = e[4 * i + 2] / s, n[i] = s;}return { P: r, w: n };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Plane = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(2),u = function u() {s.Surface.call(this), this._origin = n.Vector3.createFloat64(), this._normal = n.Vector3.createFloat64(), this._uAxis = n.Vector3.createFloat64(), this._vAxis = n.Vector3.createFloat64();};(u.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.PLANE;}, u.prototype.clone = function () {var e = new u();return e.copy(this), e;}, u.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), n.Vector3.copy(this._origin, e._origin), n.Vector3.copy(this._normal, e._normal), n.Vector3.copy(this._uAxis, e._uAxis), n.Vector3.copy(this._vAxis, e._vAxis);}, u.prototype._computeVAxis = function () {n.Vector3.cross(this._vAxis, this._normal, this._uAxis);}, u.prototype.set = function (e, t, r) {n.Vector3.copy(this._origin, e), c.ConsoleUtils.assert(n.Vector3.squaredLength(t) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._normal, t), void 0 === r || n.Vector3.squaredLength(r) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (n.Vector3.computeOrthogonal(this._uAxis, this._normal), n.Vector3.normalize(this._uAxis, this._uAxis)) : (c.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, t, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.copy(this._uAxis, r)), this._computeVAxis();}, u.prototype.getOrigin = function () {return this._origin;}, u.prototype.setOrigin = function (e) {n.Vector3.copy(this._origin, e);}, u.prototype.getNormal = function () {return this._normal;}, u.prototype.setNormal = function (e) {c.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._normal, e), (n.Vector3.squaredLength(this._uAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._uAxis, this._normal, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._uAxis, this._normal), n.Vector3.normalize(this._uAxis, this._uAxis)), this._computeVAxis();}, u.prototype.getUAxis = function () {return this._uAxis;}, u.prototype.setUAxis = function (e) {c.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.copy(this._uAxis, e), this._computeVAxis();}, u.prototype.evaluatePosition = function (e, t) {var r = n.Vector3.clone(this._origin);return n.Vector3.scaleAndAdd(r, r, this._uAxis, e), n.Vector3.scaleAndAdd(r, r, this._vAxis, t), r;}, u.prototype.evaluateNormal = function (e, t) {return n.Vector3.clone(this._normal);}, u.prototype.evaluateDu = function (e, t) {return n.Vector3.clone(this._uAxis);}, u.prototype.evaluateDv = function (e, t) {return n.Vector3.clone(this._vAxis);}, u.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();return n.Vector3.sub(t, e, this._origin), { u: n.Vector3.dot(t, this._uAxis) / n.Vector3.squaredLength(this._uAxis), v: n.Vector3.dot(t, this._vAxis) / n.Vector3.squaredLength(this._vAxis) };}, u.prototype.vParamLine = function (e) {var t = new a.Line();return t.set(this.evaluatePosition(e, 0), this._vAxis), t;}, u.prototype.uParamLine = function (e) {var t = new a.Line();return t.set(this.evaluatePosition(0, e), this._uAxis), t;}, u.prototype.getBoundingBox = function (e, t) {var r = new o.BoundingBox();return e && t ? (r.includePoint(this.evaluatePosition(e[0], t[0])), r.includePoint(this.evaluatePosition(e[0], t[1])), r.includePoint(this.evaluatePosition(e[1], t[1])), r.includePoint(this.evaluatePosition(e[1], t[0]))) : (r.includePoint([-1 / 0, -1 / 0, -1 / 0]), r.includePoint([1 / 0, 1 / 0, 1 / 0])), r;}, u.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._origin, this._origin, e), n.Vector3.transformAsDirectionMatrix44(this._uAxis, this._uAxis, e), n.Vector3.transformAsDirectionMatrix44(this._vAxis, this._vAxis, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.normalize(this._normal, this._normal);}, u.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, u.prototype.getRangeUnlimitedV = function () {return [-1 / 0, 1 / 0];}, u.prototype.isPeriodicUnlimitedU = function () {return !1;}, u.prototype.isPeriodicUnlimitedV = function () {return !1;}, u.prototype.isClosedUnlimitedU = function () {return !1;}, u.prototype.isClosedUnlimitedV = function () {return !1;}, u.prototype.toObject = function () {return { origin: this.vectorToObject(this._origin), normal: this.vectorToObject(this._normal), uAxis: this.vectorToObject(this._uAxis), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Plane = u;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.mergeConnectedFaces = t.mergeFaces = t.findConnectedFaces = t.findConnectedEdges = t.mergeCoincidentVertices = t.transformTopology = t.reverseFace = void 0;var n = r(1),o = r(0),i = r(13),s = r(2),a = function a(e) {e.setReversed(!e.isReversed());},c = function c(e, t) {var r = !1,n = !0,o = new Set();t && (void 0 !== t.inputFacesOnly && (r = t.inputFacesOnly), void 0 !== t.allowVertexConnections && (n = t.allowVertexConnections), void 0 !== t.barrierEdges && (o = new Set(t.barrierEdges)));var i = new Set(),s = new Set(e);function a(t) {s.delete(t), i.add(t), i.forEach(function (t) {var a = new Set();n ? t.collectVertices().forEach(function (e) {e.collectEdges(a);}) : (t.collectEdges(a), o.forEach(function (e) {a.delete(e);})), a.forEach(function (t) {for (var n = t.getCoedge(), o = n; o;) {if (o.getLoop()) {var a = o.getLoop().getFace();i.has(a) || r && !(e.indexOf(a) >= 0) || (i.add(a), s.delete(a));}(o = o.getPartner()) === n && (o = void 0);}});});}for (var c = []; s.size > 0;) {i.clear(), a(s.values().next().value), c.push(Array.from(i));}return c;},u = function u(e) {if (1 !== e.length) {var t = new Set();e.forEach(function (e) {e.collectEdges(t);});var r = new Set(),n = [];t.forEach(function (t) {var o = t.getCoedges(),i = o.map(function (t) {return e.indexOf(t.getFace()) >= 0;});if (2 === o.length && i[0] && i[1]) n.push(t);else for (var s = 0; s < o.length; s++) {i[s] && (r.add(o[s]), o[s].resetUVCurve());}});for (var o = []; r.size > 0;) {for (var a = [], c = r.values().next().value; c;) {a.push(c), r.delete(c);var u = c,l = void 0,h = 2 * c.getEndVertex().getEdges().length;do {if (u = u.getNext(), r.has(u)) {l = u;break;}u = u.getPartner();} while (u && u !== c && --h > 0);c = l;}s.ConsoleUtils.assert(a[0].getStartVertex() === a[a.length - 1].getEndVertex()), o.push(a);}n.forEach(function (e) {e.setStartVertex(null), e.setEndVertex(null);});var d = e[0];d.setLoops([]), o.forEach(function (e) {var t = new i.Loop();t.addCoedges(e), d.addLoop(t);});for (var g = 1; g < e.length; g++) {e[g].getShell() && e[g].getShell().removeFace(e[g]);}var p = d.getSurface();p.unlimitRangeU(), p.unlimitRangeV();}};t.reverseFace = function (e) {e.setReversed(!e.isReversed());for (var t = e.getLoops(), r = 0; r < t.length; ++r) {for (var n = t[r].getCoedges(), o = 0; o < n.length; ++o) {a(n[o]);}n.reverse();}}, t.transformTopology = function (e, t) {Array.isArray(e) || (e = [e]);for (var r = new Set(), n = new Set(), i = new Set(), s = 0; s < e.length; ++s) {var a = e[s],c = a.getTopologyType();a.collectVertices(r), c !== o.TOPOLOGY_TYPES.VERTEX && a.collectEdges(n), c !== o.TOPOLOGY_TYPES.VERTEX && c !== o.TOPOLOGY_TYPES.EDGE && c !== o.TOPOLOGY_TYPES.COEDGE && c !== o.TOPOLOGY_TYPES.LOOP && a.collectFaces(i);}r.forEach(function (e) {e.getPoint() && e.getPoint().transform(t);}), n.forEach(function (e) {e.getCurve() && e.getCurve().transform(t);}), i.forEach(function (e) {e.getSurface() && e.getSurface().transform(t);});}, t.mergeCoincidentVertices = function (e) {for (var t = o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE, r = [], i = 0; i < e.length; ++i) {var s,a = e[i],c = a.getStartVertex(),u = a.getEndVertex();for (s = 0; s < r.length && !(n.Vector3.squaredDistance(c.getPosition(), r[s].getPosition()) < t); ++s) {;}if (s === r.length ? r.push(c) : (r[s].setPrecision(Math.max(r[s].getPrecision(), c.getPrecision())), a.setStartVertex(r[s])), c !== u) for (s = 0; s < r.length && !(n.Vector3.squaredDistance(u.getPosition(), r[s].getPosition()) < t); ++s) {;}s === r.length ? r.push(u) : (r[s].setPrecision(Math.max(r[s].getPrecision(), u.getPrecision())), a.setEndVertex(r[s]));}}, t.findConnectedEdges = function (e, t) {for (var r = t || !1, n = [], o = new Set(), i = 0; i < e.length; ++i) {var s = e[i];if (!o.has(s)) {for (var a = [], c = [s], u = 0; u < c.length; ++u) {var l = c[u];o.has(l) || r && !(e.indexOf(l) >= 0) || (o.add(l), a.push(l), c = c.concat(l.getStartVertex().getEdges(), l.getEndVertex().getEdges()));}n.push(a);}}return n;}, t.findConnectedFaces = c, t.mergeFaces = u, t.mergeConnectedFaces = function (e) {var t = [];return c(e, { inputFacesOnly: !0, allowVertexConnections: !1 }).forEach(function (e) {u(e), t.push(e[0]);}), t;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Edge = void 0;var n = r(1),o = r(9),i = r(0),s = r(2),a = function a(e) {o.BaseTopology.call(this), this._curve = e, this._reversed = !1, this._vertices = [null, null], this._range = [0, 0], this._precision = 0, this._coedge = void 0, this._wire = void 0, this._tessellationPoints = [];};(a.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.EDGE;}, a.prototype.getCurveType = function () {return this._curve ? this._curve.getGeometryType() : void 0;}, a.prototype.clone = function () {var e = new a();return e._curve = this._curve ? this._curve.clone() : void 0, e._reversed = this._reversed, e._vertices[0] = this._vertices[0], e._vertices[1] = this._vertices[1], e._range[0] = this._range[0], e._range[1] = this._range[1], e._precision = this._precision, e._coedge = this._coedge, e._wire = this._wire, e._tessellationPoints = [], e;}, a.prototype.getCurve = function () {return this._curve;}, a.prototype.setCurve = function (e) {this._curve = e;}, a.prototype.getArcLength = function () {var e = this.getRange();return this.isReversed() && (e = [-e[1], -e[0]]), this._curve.getArcLength(e);}, a.prototype.getVertices = function () {return this._vertices;}, a.prototype.getVertex = function (e) {return s.ConsoleUtils.assert(0 === e || 1 === e), this._vertices[e];}, a.prototype.getStartVertex = function () {return this._vertices[0];}, a.prototype.getEndVertex = function () {return this._vertices[1];}, a.prototype.setCoedge = function (e) {this._coedge = e;}, a.prototype.getCoedge = function () {return this._coedge;}, a.prototype.getCoedges = function () {for (var e = [], t = this._coedge; t;) {e.push(t), (t = t.getPartner()) === this._coedge && (t = void 0);}return e;}, a.prototype.setWire = function (e) {this._wire = e;}, a.prototype.getWire = function () {return this._wire;}, a.prototype.getRange = function () {return this._range;}, a.prototype.setRange = function (e) {s.ConsoleUtils.assert(2 === e.length), this._range[0] = e[0], this._range[1] = e[1];}, a.prototype.t0 = function () {return this._range[0];}, a.prototype.sett0 = function (e) {this._range[0] = e;}, a.prototype.t1 = function () {return this._range[1];}, a.prototype.sett1 = function (e) {this._range[1] = e;}, a.prototype.isClosed = function () {return this._curve && this._vertices[0] && this._vertices[0] === this._vertices[1];}, a.prototype.getOtherVertex = function (e) {return s.ConsoleUtils.assert(this._vertices[0] === e || this._vertices[1] === e), this._vertices[0] === e ? this._vertices[1] : this._vertices[0];}, a.prototype.getCommonVertex = function (e) {var t = this.getStartVertex(),r = this.getEndVertex(),n = e.getStartVertex(),o = e.getEndVertex();return t === n || t === o ? t : r === n || r === o ? r : null;}, a.prototype.setVertex = function (e, t) {s.ConsoleUtils.assert(0 === e || 1 === e), t !== this._vertices[e] && (this._vertices[e] && this._vertices[0] !== this._vertices[1] && this._vertices[e].removeEdge(this), this._vertices[e] = t, t && this._vertices[e].addEdge(this));}, a.prototype.setStartVertex = function (e) {this.setVertex(0, e);}, a.prototype.setEndVertex = function (e) {this.setVertex(1, e);}, a.prototype.getCoedgeForFace = function (e) {for (var t = this._coedge; t;) {if (t.getFace() === e) return t;if ((t = t.getPartner()) === this._coedge) break;}}, a.prototype.getOtherFace = function (e) {var t = this.getCoedgeForFace(e);s.ConsoleUtils.assert(t);var r = t.getPartner();if (r && r !== t) return r.getFace();}, a.prototype.isReversed = function () {return this._reversed;}, a.prototype.setReversed = function (e) {this._reversed = e;}, a.prototype.getPrecision = function () {return this._precision;}, a.prototype.setPrecision = function (e) {s.ConsoleUtils.assert(e >= 0), this._precision = e;}, a.prototype.evaluatePosition = function (e) {return this.isReversed() && (e = -e), this._curve.evaluatePosition(e);}, a.prototype.evaluateDt = function (e) {this.isReversed() && (e = -e);var t = this._curve.evaluateDt(e);return this.isReversed() && n.Vector3.negate(t, t), t;}, a.prototype.evaluateCurvature = function (e, t) {return this.isReversed() && (e = -e), this._curve.evaluateCurvature(e, t);}, a.prototype.closestToPointParam = function (e, t) {if (this._curve) {var r = t || this.getRange();this.isReversed() && (r = [-r[1], -r[0]]);var n = this._curve.closestToPointParam(e, r);return this.isReversed() ? -n : n;}}, a.prototype.includesPoint = function (e) {var t = Math.max(this.getPrecision(), i.KERNEL_TOLERANCE),r = this.closestToPointParam(e),o = this.evaluatePosition(r);return n.Vector3.squaredDistance(o, e) < t * t;}, a.prototype.distanceToPoint = function (e) {var t = this.closestToPointParam(e),r = this.evaluatePosition(t);return n.Vector3.distance(r, e);}, a.prototype.tessellate = function (e, t) {var r, o;if (!1 === this.isReversed()) r = e || [this._range[0], this._range[1]];else if (e) {r = new Array(e.length);for (var i = 0; i < e.length; ++i) {r[i] = -e[e.length - 1 - i];}} else r = [-this._range[1], -this._range[0]];var s,a = this._curve.tessellate(r, t);if (this._tessellationPoints.length !== a.positions.length) for (this._tessellationPoints = new Array(a.positions.length), i = 0; i < a.positions.length; i++) {this._tessellationPoints[i] = n.Vector3.createFloat64();}if (!1 === this.isReversed()) for (s = a.offsets, o = 0; o < a.positions.length; ++o) {n.Vector3.copy(this._tessellationPoints[o], a.positions[o]);} else {for (o = 0; o < a.positions.length; ++o) {n.Vector3.copy(this._tessellationPoints[o], a.positions[a.positions.length - 1 - o]);}for (s = new Array(a.offsets.length), o = 0; o < a.offsets.length; ++o) {s[o] = a.positions.length - 1 - a.offsets[a.offsets.length - 1 - o];}}return { positions: this._tessellationPoints, offsets: s, tolerance: a.tolerance };}, a.prototype.getBody = function () {return s.ConsoleUtils.assert(void 0 === this._coedge || void 0 === this._wire), this._coedge ? this._coedge.getBody() : this._wire ? this._wire.getBody() : void 0;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = this._coedge; t;) {t.collectFaces(e), (t = t.getPartner()) === this._coedge && (t = void 0);}return e;}, a.prototype.collectEdges = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._vertices.length; ++t) {this._vertices[t] && e.add(this._vertices[t]);}return e;}, a.prototype.getBoundingBox = function () {var e = this.getRange();return !0 === this.isReversed() && (e = [-e[1], -e[0]]), this._curve.getBoundingBox(e);}, a.prototype.closestToRayParam = function (e, t, r) {var n = this.getRange();!0 === this.isReversed() && (n = [-n[1], -n[0]]);var o = this._curve.closestToRayParam(e, t, n, r);return !0 === this.isReversed() ? -o : o;}, a.prototype.toString = function () {return i.GEOMETRY_TYPES.toString(this.getCurveType()) + " " + String(this.getStartVertex()) + " -> " + String(this.getEndVertex());}, a.prototype.getLoops = function () {var e = this.getCoedges(),t = new Set();for (var _r2 = 0; _r2 < e.length; _r2++) {t.add(e[_r2].getLoop());}return Array.from(t);}, a.prototype.toObject = function () {return { vertex0: this.refToString(this._vertices[0]), vertex1: this.refToString(this._vertices[1]), precision: this._precision, range: this.rangeToObject(this._range, !0), reversed: this._reversed, geometry: this.refToString(this._curve), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._vertices[0], this._vertices[1], this._curve, this._attributes]);}, t.Edge = a;}, function (e, t, r) {"use strict";e.exports = i, i.className = "ReflectionObject";var n,o = r(5);function i(e, t) {if (!o.isString(e)) throw TypeError("name must be a string");if (t && !o.isObject(t)) throw TypeError("options must be an object");this.options = t, this.name = e, this.parent = null, this.resolved = !1, this.comment = null, this.filename = null;}Object.defineProperties(i.prototype, { root: { get: function get() {for (var e = this; null !== e.parent;) {e = e.parent;}return e;} }, fullName: { get: function get() {for (var e = [this.name], t = this.parent; t;) {e.unshift(t.name), t = t.parent;}return e.join(".");} } }), i.prototype.toJSON = function () {throw Error();}, i.prototype.onAdd = function (e) {this.parent && this.parent !== e && this.parent.remove(this), this.parent = e, this.resolved = !1;var t = e.root;t instanceof n && t._handleAdd(this);}, i.prototype.onRemove = function (e) {var t = e.root;t instanceof n && t._handleRemove(this), this.parent = null, this.resolved = !1;}, i.prototype.resolve = function () {return this.resolved || this.root instanceof n && (this.resolved = !0), this;}, i.prototype.getOption = function (e) {if (this.options) return this.options[e];}, i.prototype.setOption = function (e, t, r) {return r && this.options && void 0 !== this.options[e] || ((this.options || (this.options = {}))[e] = t), this;}, i.prototype.setOptions = function (e, t) {if (e) for (var r = Object.keys(e), n = 0; n < r.length; ++n) {this.setOption(r[n], e[r[n]], t);}return this;}, i.prototype.toString = function () {var e = this.constructor.className,t = this.fullName;return t.length ? e + " " + t : e;}, i._configure = function (e) {n = e;};}, function (e, t, r) {"use strict";e.exports = u;var n = r(21);((u.prototype = Object.create(n.prototype)).constructor = u).className = "Field";var o,i = r(11),s = r(31),a = r(5),c = /^required|optional|repeated$/;function u(e, t, r, o, i, u, l) {if (a.isObject(o) ? (l = i, u = o, o = i = void 0) : a.isObject(i) && (l = u, u = i, i = void 0), n.call(this, e, u), !a.isInteger(t) || t < 0) throw TypeError("id must be a non-negative integer");if (!a.isString(r)) throw TypeError("type must be a string");if (void 0 !== o && !c.test(o = o.toString().toLowerCase())) throw TypeError("rule must be a string rule");if (void 0 !== i && !a.isString(i)) throw TypeError("extend must be a string");this.rule = o && "optional" !== o ? o : void 0, this.type = r, this.id = t, this.extend = i || void 0, this.required = "required" === o, this.optional = !this.required, this.repeated = "repeated" === o, this.map = !1, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = !!a.Long && void 0 !== s.long[r], this.bytes = "bytes" === r, this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this.comment = l;}u.fromJSON = function (e, t) {return new u(e, t.id, t.type, t.rule, t.extend, t.options, t.comment);}, Object.defineProperty(u.prototype, "packed", { get: function get() {return null === this._packed && (this._packed = !1 !== this.getOption("packed")), this._packed;} }), u.prototype.setOption = function (e, t, r) {return "packed" === e && (this._packed = null), n.prototype.setOption.call(this, e, t, r);}, u.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return a.toObject(["rule", "optional" !== this.rule && this.rule || void 0, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t ? this.comment : void 0]);}, u.prototype.resolve = function () {if (this.resolved) return this;if (void 0 === (this.typeDefault = s.defaults[this.type]) && (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof o ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]), this.options && null != this.options.default && (this.typeDefault = this.options.default, this.resolvedType instanceof i && "string" == typeof this.typeDefault && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (!0 !== this.options.packed && (void 0 === this.options.packed || !this.resolvedType || this.resolvedType instanceof i) || delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long) this.typeDefault = a.Long.fromNumber(this.typeDefault, "u" === this.type.charAt(0)), Object.freeze && Object.freeze(this.typeDefault);else if (this.bytes && "string" == typeof this.typeDefault) {var e;a.base64.test(this.typeDefault) ? a.base64.decode(this.typeDefault, e = a.newBuffer(a.base64.length(this.typeDefault)), 0) : a.utf8.write(this.typeDefault, e = a.newBuffer(a.utf8.length(this.typeDefault)), 0), this.typeDefault = e;}return this.map ? this.defaultValue = a.emptyObject : this.repeated ? this.defaultValue = a.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof o && (this.parent.ctor.prototype[this.name] = this.defaultValue), n.prototype.resolve.call(this);}, u.d = function (e, t, r, n) {return "function" == typeof t ? t = a.decorateType(t).name : t && "object" == _typeof(t) && (t = a.decorateEnum(t).name), function (o, i) {a.decorateType(o.constructor).add(new u(i, e, t, r, { default: n }));};}, u._configure = function (e) {o = e;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Ellipse = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(35),l = r(2),h = r(50),d = function d() {a.Curve.call(this), this._center = n.Vector3.createFloat64FromValues(0, 0, 0), this._normal = n.Vector3.createFloat64FromValues(0, 0, 1), this._xAxis = n.Vector3.createFloat64FromValues(1, 0, 0), this._yAxis = n.Vector3.createFloat64FromValues(0, 1, 0), this._majorRadius = 0, this._minorRadius = 0, this._tessellationCache = new h.TessellationCache();};(d.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.ELLIPSE;}, d.prototype.set = function (e, t, r, o) {l.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.squaredLength(r) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.isOrthogonal(t, r, s.KERNEL_ANGULAR_TOLERANCE)), l.ConsoleUtils.assert(o > n.FLOAT64_TOLERANCE && o <= 1, "Invalid radius ratio"), n.Vector3.copy(this._center, e), n.Vector3.normalize(this._normal, t), n.Vector3.normalize(this._xAxis, r), this._majorRadius = n.Vector3.length(r), this._minorRadius = this._majorRadius * o, this._computeYAxis(), this._dirtyTessellation();}, d.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._normal, this._xAxis);}, d.prototype.getCenter = function () {return this._center;}, d.prototype.getNormal = function () {return this._normal;}, d.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e), this._dirtyTessellation();}, d.prototype.setNormal = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._normal !== e && (n.Vector3.normalize(this._normal, e), n.Vector3.isOrthogonal(this._xAxis, this._normal) || (n.Vector3.computeOrthogonal(this._xAxis, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis(), this._dirtyTessellation());}, d.prototype.setMajorAxis = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.isOrthogonal(e, this._normal, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, e), this._computeYAxis(), this._dirtyTessellation();}, d.prototype.getMajorAxis = function () {return this._xAxis;}, d.prototype.getMinorAxis = function () {return this._yAxis;}, d.prototype.clone = function () {var e = new d();return e.copy(this), e;}, d.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._normal, e._normal);}, d.prototype.getMajorRadius = function () {return this._majorRadius;}, d.prototype.getMinorRadius = function () {return this._minorRadius;}, d.prototype.setMajorRadius = function (e) {l.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._majorRadius = e, this._dirtyTessellation();}, d.prototype.setMinorRadius = function (e) {l.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._minorRadius = e, this._dirtyTessellation();}, d.prototype.getRangeUnlimited = function () {return [-Math.PI, Math.PI];}, d.prototype.isPeriodicUnlimited = function () {return !0;}, d.prototype.isClosedUnlimited = function () {return !0;}, d.prototype._dirtyTessellation = function () {this._tessellationCache.setDirty(!0);}, d.prototype._evaluateArcLengthIntegrand = function (e) {var t = this._majorRadius * Math.sin(e),r = this._minorRadius * Math.cos(e);return Math.sqrt(t * t + r * r);}, d.prototype.getArcLength = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());for (var t = e[0], r = 0; t < e[1] + s.PARAMETER_SPACE_TOLERANCE;) {for (var n = t, o = [this._evaluateArcLengthIntegrand(t)]; o.length < 5 && t < e[1] + s.PARAMETER_SPACE_TOLERANCE;) {t += .01, o.push(this._evaluateArcLengthIntegrand(t));}switch (n = t - n, o.length) {case 1:break;case 2:r += (o[0] + o[1]) * n / 2;break;case 3:r += (o[0] + 4 * o[1] + o[2]) * n / 6;break;case 4:r += (o[0] + 3 * o[1] + 3 * o[2] + o[3]) * n / 8;break;default:r += (7 * o[0] + 32 * o[1] + 12 * o[2] + 32 * o[3] + 7 * o[4]) * n / 90;}(n = t - e[1]) > s.PARAMETER_SPACE_TOLERANCE && (r -= this._evaluateArcLengthIntegrand(e[1]) * n);}return r;}, d.prototype.getParameterFromArcLength = function (e, t) {return void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited()), (0, u.invertIntegral1D)(this._evaluateArcLengthIntegrand.bind(this), e, t);}, d.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, Math.cos(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.sin(e) * this._minorRadius), n.Vector3.add(t, t, this._center), t;}, d.prototype.evaluateDt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.sin(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.cos(e) * this._minorRadius), t;}, d.prototype.evaluateDtt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.cos(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, -Math.sin(e) * this._minorRadius), t;}, d.prototype._getFullTessellation = function (e) {var t = [-Math.PI, -Math.PI / 2, 0, Math.PI / 2, Math.PI],r = h.CurveTessellator.getAdaptiveRenderPoints(this, e, [-Math.PI, Math.PI], t);return r.didRetessellate = !0, r;}, d.prototype.tessellate = function (e, t) {return t = t || s.TESSELLATION.LINEAR_PRECISION, this._tessellationCache.getTessellation(e, this, t, this._getFullTessellation.bind(this));}, d.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = (0, c.minMaxCosSinFunc)(this._xAxis[0] * this._majorRadius, this._yAxis[0] * this._minorRadius, this._center[0], e),r = (0, c.minMaxCosSinFunc)(this._xAxis[1] * this._majorRadius, this._yAxis[1] * this._minorRadius, this._center[1], e),n = (0, c.minMaxCosSinFunc)(this._xAxis[2] * this._majorRadius, this._yAxis[2] * this._minorRadius, this._center[2], e),i = new o.BoundingBox();return i.min[0] = t[0], i.max[0] = t[1], i.min[1] = r[0], i.max[1] = r[1], i.min[2] = n[0], i.max[2] = n[1], i;}, d.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this.evaluateDt(e[0]);n.Vector3.normalize(t, t);var r = this.evaluateDt(e[1]);n.Vector3.normalize(r, r);var o = n.Vector3.createFloat64(),a = n.Vector3.dot(t, r),u = n.Vector3.dot(n.Vector3.cross(o, t, r), this._normal),l = Math.atan2(u, a);l < 0 ? l += c.PI2 : e[1] - e[0] > c.PI2 - s.PARAMETER_SPACE_TOLERANCE && (l = c.PI2), l *= .5, a = Math.cos(l), u = Math.sin(l);var h = n.Vector3.clone(t);return n.Vector3.scale(h, h, a), n.Vector3.cross(o, this._normal, t), n.Vector3.scaleAndAdd(h, h, o, u), new i.TangentCone(h, l);}, d.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.scale(this._xAxis, this._xAxis, this._majorRadius), n.Vector3.scale(this._yAxis, this._yAxis, this._minorRadius), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), this._majorRadius = n.Vector3.length(this._xAxis), this._minorRadius = n.Vector3.length(this._yAxis), n.Vector3.normalize(this._normal, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis), this._computeYAxis(), this._dirtyTessellation();}, d.prototype.closestToRayParam = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, this._center, e);var i = n.Vector3.dot(o, this._normal) / n.Vector3.dot(t, this._normal);if (isFinite(i)) {var s = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(s, e, t, i), this.closestToPointParam(s, r);}}, d.prototype.isCircular = function () {return Math.abs(this._majorRadius - this._minorRadius) < s.KERNEL_TOLERANCE;}, d.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._center);var o = n.Vector3.dot(r, this._xAxis),i = n.Vector3.dot(r, this._yAxis);if (o * o + i * i < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) {var a = .5 * Math.PI;if (((a = (0, c.adjustParameterToPeriodicRange)(a, t, c.PI2)) < t[0] || a > t[1]) && (a = (0, c.adjustParameterToPeriodicRange)(.5 * -Math.PI, t, c.PI2)), a < t[0] || a > t[1]) {var l = this.evaluatePosition(t[0]),h = this.evaluatePosition(t[1]);a = n.Vector3.squaredDistance(this._center, l) < n.Vector3.squaredDistance(this._center, h) ? t[0] : t[1];}return a;}var d = this._majorRadius,g = this._minorRadius,p = Math.atan2(d * i, g * o),f = this.evaluatePosition(p);n.Vector3.sub(f, f, this._center), o * o + i * i < n.Vector3.squaredLength(f) && (p = (i < s.KERNEL_TOLERANCE ? -1 : 1) * Math.acos(o / d));var v,_ = n.FLOAT64_TOLERANCE,y = function y(t) {var r = this.evaluatePosition(t),n = this.evaluateDt(t),o = this.evaluateDtt(t),i = [r[0] - e[0], r[1] - e[1], r[2] - e[2]];return { val: 2 * (i[0] * n[0] + i[1] * n[1] + i[2] * n[2]), deriv: 2 * (i[0] * o[0] + i[1] * o[1] + i[2] * o[2] + (n[0] * n[0] + n[1] * n[1] + n[2] * n[2])) };},m = (0, u.newtonRaphson1D)(y.bind(this), void 0, p, _, 32);(m = (0, c.adjustParameterToPeriodicRange)(m, t, c.PI2)) < t[0] || m > t[1] ? (m = (0, u.newtonRaphson1D)(y.bind(this), void 0, -m, _, 32), v = (m = (0, c.adjustParameterToPeriodicRange)(m, t, c.PI2)) < t[0] || m > t[1] ? 1 / 0 : n.Vector3.squaredDistance(e, this.evaluatePosition(m))) : v = n.Vector3.squaredDistance(e, this.evaluatePosition(m));var E = n.Vector3.squaredDistance(e, this.evaluatePosition(t[0])),x = n.Vector3.squaredDistance(e, this.evaluatePosition(t[1]));return E < v && (v = E, m = t[0]), x < v && (m = t[1]), m;}, d.prototype.suggestSplittingParam = function (e) {}, d.prototype.toObject = function () {var e = this.evaluatePosition(0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), normal: this.vectorToObject(this._normal), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Ellipse = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Body = void 0;var n = r(9),o = r(0),i = r(4),s = r(19),a = function a() {n.BaseTopology.call(this), this._lumps = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.BODY;}, a.prototype.getLumps = function () {return this._lumps;}, a.prototype.setLumps = function (e) {this._lumps = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._lumps[t] = e[t];}}, a.prototype.addLump = function (e) {this._lumps ? this._lumps.push(e) : this._lumps = [e], e.setBody(this);}, a.prototype.addLumps = function (e) {this._lumps || (this._lumps = []);for (var t = 0; t < e.length; ++t) {e[t].setBody(this);}this._lumps = this._lumps.concat(e);}, a.prototype.removeLump = function (e) {var t = this._lumps.indexOf(e);return t > -1 && (this._lumps.splice(t, 1), e.getBody() === this && e.setBody(void 0), !0);}, a.prototype.getBody = function () {return this;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectFaces(e);}return e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._lumps.length; ++t) {e.include(this._lumps[t].getBoundingBox());}return e;}, a.prototype.transform = function (e) {(0, s.transformTopology)(this, e);}, a.prototype.toObject = function () {return { lumps: this.refsToStrings(this._lumps), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._lumps, this._attributes]);}, t.Body = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Lump = void 0;var n = r(9),o = r(0),i = r(4),s = function s() {n.BaseTopology.call(this), this._shells = [], this._body = void 0;};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.LUMP;}, s.prototype.getBody = function () {return this._body;}, s.prototype.setBody = function (e) {this._body = e;}, s.prototype.getShells = function () {return this._shells;}, s.prototype.setShells = function (e) {this._shells = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._shells[t] = e[t];}}, s.prototype.addShell = function (e) {this._shells ? this._shells.push(e) : this._shells = [e], e.setLump(this);}, s.prototype.addShells = function (e) {this._shells || (this._shells = []);for (var t = 0; t < e.length; ++t) {e[t].setLump(this);}this._shells = this._shells.concat(e);}, s.prototype.removeShell = function (e) {var t = this._shells.indexOf(e);return t > -1 && (this._shells.splice(t, 1), e.getLump() === this && e.setLump(void 0), !0);}, s.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectFaces(e);}return e;}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectEdges(e);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectVertices(e);}return e;}, s.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._shells.length; ++t) {e.include(this._shells[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return "Lump";}, s.prototype.toObject = function () {return { shells: this.refsToStrings(this._shells), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._shells, this._attributes]);}, t.Lump = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Shell = void 0;var n = r(9),o = r(0),i = r(4),s = function s() {n.BaseTopology.call(this), this._faces = [], this._lump = void 0;};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.SHELL;}, s.prototype.getLump = function () {return this._lump;}, s.prototype.setLump = function (e) {this._lump = e;}, s.prototype.getFaces = function () {return this._faces;}, s.prototype.setFaces = function (e) {this._faces = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._faces[t] = e[t];}}, s.prototype.addFace = function (e) {this._faces ? this._faces.push(e) : this._faces = [e], e.setShell(this);}, s.prototype.addFaces = function (e) {this._faces || (this._faces = []);for (var t = 0; t < e.length; ++t) {e[t].setShell(this);}this._faces = this._faces.concat(e);}, s.prototype.removeFace = function (e) {var t = this._faces.indexOf(e);return t > -1 && (this._faces.splice(t, 1), e.getShell() === this && e.setShell(void 0), !0);}, s.prototype.getBody = function () {return this._lump ? this._lump.getBody() : void 0;}, s.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {e.add(this._faces[t]);}return e;}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {this._faces[t].collectEdges(e);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {this._faces[t].collectVertices(e);}return e;}, s.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._faces.length; ++t) {e.include(this._faces[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return "Shell";}, s.prototype.toObject = function () {return { faces: this.refsToStrings(this._faces), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._faces, this._attributes]);}, t.Shell = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Coedge = void 0;var n = r(1),o = r(9),i = r(0),s = r(2),a = r(3),c = r(36),u = function u(e) {o.BaseTopology.call(this), this._reversed = !1, this._edge = e, this._loop = void 0, this._partner = void 0, this._uvCurve = void 0;};(u.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.COEDGE;}, u.prototype.getEdge = function () {return this._edge;}, u.prototype.getLoop = function () {return this._loop;}, u.prototype.getPartner = function () {return this._partner;}, u.prototype.setEdge = function (e) {this._edge = e;}, u.prototype.setLoop = function (e) {this._loop = e;}, u.prototype.setPartner = function (e) {this._partner = e;}, u.prototype.getStartVertex = function () {return this._reversed ? this._edge.getEndVertex() : this._edge.getStartVertex();}, u.prototype.getEndVertex = function () {return this._reversed ? this._edge.getStartVertex() : this._edge.getEndVertex();}, u.prototype.getFace = function () {return this._loop ? this._loop.getFace() : void 0;}, u.prototype.getNext = function () {if (this._loop) {var e = this._loop.getCoedges(),t = e.indexOf(this);return s.ConsoleUtils.assert(t >= 0), e[(t + 1) % e.length];}}, u.prototype.getPrevious = function () {if (this._loop) {var e = this._loop.getCoedges(),t = e.indexOf(this);return s.ConsoleUtils.assert(t >= 0), e[(0, a.modulus)(t - 1, e.length)];}}, u.prototype.isReversed = function () {return this._reversed;}, u.prototype.setReversed = function (e) {this._reversed = e;}, u.prototype.getRange = function () {if (this._edge) return this._reversed ? [-this._edge.t1(), -this._edge.t0()] : [this._edge.t0(), this._edge.t1()];}, u.prototype.t0 = function () {if (this._edge) return this._reversed ? -this._edge.t1() : this._edge.t0();}, u.prototype.t1 = function () {if (this._edge) return this._reversed ? -this._edge.t0() : this._edge.t1();}, u.prototype.evaluatePosition = function (e) {if (this._edge) return this.isReversed() && (e = -e), this._edge.evaluatePosition(e);}, u.prototype.evaluateDt = function (e) {if (this._edge) {this.isReversed() && (e = -e);var t = this._edge.evaluateDt(e);return this.isReversed() && n.Vector3.negate(t, t), t;}}, u.prototype.evaluateCurvature = function (e, t) {if (this._edge) return this.isReversed() && (e = -e), this._edge.evaluateCurvature(e, t);}, u.prototype.evaluateFaceUV = function (e) {var t = this.getFace();if (t) {var r = this.evaluatePosition(e);return t.closestParam(r);}}, u.prototype.evaluateInwardDirection = function (e) {var t = this.getFace();if (t) {var r = this.evaluateDt(e),o = this.evaluateFaceUV(e),i = t.evaluateNormal(o.u, o.v),s = [0, 0, 0];return n.Vector3.cross(s, i, r), n.Vector3.normalize(s, s), s;}}, u.prototype.getBoundingBox = function () {if (this._edge) return this._edge.getBoundingBox();}, u.prototype.generateUVCurve = function (e) {if (!this._uvCurve && this._edge) {var t = this._edge.getCurve();if (t && this._loop && this._loop.getFace()) {var r = this._loop.getFace().getSurface();r && r.getGeometryType() === i.GEOMETRY_TYPES.PLANE && (e || (e = (0, a.getPlaneTransforms)(r).threeSpaceToUV), e ? (this._uvCurve = t.clone(), this._uvCurve.transform(e)) : this._uvCurve = t);}}}, u.prototype.resetUVCurve = function () {this._uvCurve = void 0;}, u.prototype.uvAngleSubtended = function (e) {var t = this._loop.getFace().getSurface().closestParam(e),r = [t.u, t.v, 0];this.generateUVCurve(), s.ConsoleUtils.assert(this._uvCurve);var o = this.getRange(),u = 1;this.isReversed() !== this._edge.isReversed() && (o = [-o[1], -o[0]], u = -1), this._loop && this._loop.getFace() && this._loop.getFace().isReversed() && (u *= -1);var l = !1,h = this._uvCurve.getRange();this._uvCurve.isClosed() && o[1] - o[0] >= h[1] - h[0] - 2 * i.PARAMETER_SPACE_TOLERANCE && (l = !0);var d = this._uvCurve.evaluatePosition(o[0]),g = this._uvCurve.evaluatePosition(o[1]),p = n.Vector3.createFloat64();n.Vector3.sub(p, d, r), n.Vector3.normalize(p, p);var f = n.Vector3.createFloat64();n.Vector3.sub(f, g, r), n.Vector3.normalize(f, f);var v = (0, a.getSignedAngle)(p, f),_ = v < 0,y = !1,m = !1;switch (this._edge.getCurveType()) {case i.GEOMETRY_TYPES.LINE:break;case i.GEOMETRY_TYPES.CIRCLE:m = this._uvCurve.getNormal()[2] > 0, y = n.Vector3.distance(r, this._uvCurve.getCenter()) < this._uvCurve.getRadius(), l || (y = y && _ !== m);break;case i.GEOMETRY_TYPES.ELLIPSE:m = this._uvCurve.getNormal()[2] > 0;var E = n.Vector3.sub([0, 0, 0], r, this._uvCurve.getCenter()),x = n.Vector3.dot(E, this._uvCurve.getMajorAxis()) / this._uvCurve.getMajorRadius(),R = n.Vector3.dot(E, this._uvCurve.getMinorAxis()) / this._uvCurve.getMinorRadius();y = x * x + R * R <= 1, l || (y = y && _ !== m);break;case i.GEOMETRY_TYPES.BCURVE:this._uvCurve.isPlanarXY() || console.warn("Unsupported non-planar curve for uvAngleSubtended");var A = [r[0], r[1]];y = c.SplineCurveHelper.isPointInsideSplineRegionXYPlanar3D(A, this._uvCurve, o), m = !0;break;default:throw new Error("Unsupported curve type for uvAngleSubtended");}return l ? v = y ? 2 * Math.PI * (m ? -1 : 1) : 0 : y && (v < 0 ? v = 2 * Math.PI + v : v -= 2 * Math.PI), v * u;}, u.prototype.getBody = function () {return this._loop ? this._loop.getBody() : void 0;}, u.prototype.collectFaces = function (e) {return e = e || new Set(), this._loop && this._loop.collectFaces(e), e;}, u.prototype.collectEdges = function (e) {return e = e || new Set(), this._edge && e.add(this._edge), e;}, u.prototype.collectVertices = function (e) {return e = e || new Set(), this._edge && this._edge.collectVertices(e), e;}, u.prototype.toString = function () {return "Coedge";}, u.prototype.toObject = function () {return { edge: this.refToString(this._edge), partner: this.refToString(this._partner), reversed: this._reversed, attributes: this.refsToStrings(this._attributes) };}, u.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._edge, this._attributes]);}, t.Coedge = u;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createShellsFromFaces = t.createWiresFromEdges = t.createEdgesFromCurves = t.createEdgeFromCurve = t.createLoopFromPolyline = t.createFaceFromPolyline = t.makeConeOrCylinderVParamLoop = t.createCoedgeOnEdge = t.createLineEdge = t.createLineEdgeBetweenVertices = void 0;var n = r(1),o = r(0),i = r(2),s = r(6),a = r(7),c = r(18),u = r(27),l = r(16),h = r(26),d = r(20),g = r(13),p = r(15),f = r(40),v = r(3),_ = r(19),y = function y(e, t) {var r = e.getPosition(),o = t.getPosition(),i = new a.Line();i.setFromEndpoints(r, o);var s = new d.Edge(i);return s.setRange([0, n.Vector3.distance(r, o)]), s.setStartVertex(e), s.setEndVertex(t), s;},m = function m(e) {var t = new u.Coedge();t.setEdge(e);var r = e.getCoedge();return r ? (i.ConsoleUtils.assert(!r.getPartner()), r.setPartner(t), t.setPartner(r), t.setReversed(!r.isReversed())) : e.setCoedge(t), t;},E = function E(e) {for (var t = e.length, r = new Array(t), n = 0; n < t; ++n) {r[n] = new l.Vertex(new s.Point(e[n]));}var o = new Array(t);for (n = 0; n < t; ++n) {var i = (n + 1) % t,a = y(r[n], r[i]);o[n] = m(a);}var c = new g.Loop();return c.addCoedges(o), c;},x = function x(e) {var t = new d.Edge(e),r = e.getRange();r[0] !== -1 / 0 && r[1] !== 1 / 0 ? (t.sett0(r[0]), t.sett1(r[1])) : (t.sett0(0), t.sett1(1));var n = t.evaluatePosition(t.t0());if (t.setStartVertex(new l.Vertex(new s.Point(n))), e.isClosed()) t.setEndVertex(t.getStartVertex());else {var o = t.evaluatePosition(t.t1());t.setEndVertex(new l.Vertex(new s.Point(o)));}return t;};t.createLineEdgeBetweenVertices = y, t.createLineEdge = function (e, t) {var r = new l.Vertex(new s.Point(e)),n = new l.Vertex(new s.Point(t));return y(r, n);}, t.createCoedgeOnEdge = m, t.makeConeOrCylinderVParamLoop = function (e, t) {i.ConsoleUtils.assert(e.getGeometryType() === o.GEOMETRY_TYPES.CYLINDER || e.getGeometryType() === o.GEOMETRY_TYPES.CONE || e.getGeometryType() === o.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER || e.getGeometryType() === o.GEOMETRY_TYPES.ELLIPTICAL_CONE), i.ConsoleUtils.assert(e.isPeriodicV());var r,n = new d.Edge(),a = e.vParamLine(t);a.getGeometryType() === o.GEOMETRY_TYPES.POINT ? r = a : (r = new s.Point(a.evaluatePosition(a.getRange()[0])), n.setCurve(a), n.setRange(a.getRange()));var c = new l.Vertex(r);n.setStartVertex(c), n.setEndVertex(c);var u = new g.Loop();return u.addCoedge(m(n)), u;}, t.createFaceFromPolyline = function (e) {var t = E(e),r = (0, v.definePlaneThroughPoints)(e),n = new c.Plane();n.set(r.origin, r.normal, r.uAxis), n.limitRangeU(r.uRange), n.limitRangeV(r.vRange);var o = new p.Face(n);return o.addLoop(t), o;}, t.createLoopFromPolyline = E, t.createEdgeFromCurve = x, t.createEdgesFromCurves = function (e) {for (var t = [], r = 0; r < e.length; ++r) {t.push(x(e[r]));}return (0, _.mergeCoincidentVertices)(t), t;}, t.createWiresFromEdges = function (e) {for (var t = (0, _.findConnectedEdges)(e), r = [], n = 0; n < t.length; ++n) {var o = new f.Wire();o.addEdges(t[n]), r.push(o);}return r;}, t.createShellsFromFaces = function (e) {for (var t = (0, _.findConnectedFaces)(e), r = new Array(t.length), n = 0; n < t.length; ++n) {var o = new h.Shell();o.addFaces(t[n]), r[n] = o;}return r;};}, function (e, t, r) {"use strict";r.r(t), function (e) {r.d(t, "default", function () {return _;}), r.d(t, "VERSION", function () {return y;}), r.d(t, "iteratee", function () {return x;}), r.d(t, "restArguments", function () {return A;}), r.d(t, "each", function () {return S;}), r.d(t, "forEach", function () {return S;}), r.d(t, "map", function () {return M;}), r.d(t, "collect", function () {return M;}), r.d(t, "reduce", function () {return N;}), r.d(t, "foldl", function () {return N;}), r.d(t, "inject", function () {return N;}), r.d(t, "reduceRight", function () {return F;}), r.d(t, "foldr", function () {return F;}), r.d(t, "find", function () {return I;}), r.d(t, "detect", function () {return I;}), r.d(t, "filter", function () {return D;}), r.d(t, "select", function () {return D;}), r.d(t, "reject", function () {return j;}), r.d(t, "every", function () {return B;}), r.d(t, "all", function () {return B;}), r.d(t, "some", function () {return U;}), r.d(t, "any", function () {return U;}), r.d(t, "contains", function () {return k;}), r.d(t, "includes", function () {return k;}), r.d(t, "include", function () {return k;}), r.d(t, "invoke", function () {return G;}), r.d(t, "pluck", function () {return z;}), r.d(t, "where", function () {return Y;}), r.d(t, "findWhere", function () {return K;}), r.d(t, "max", function () {return q;}), r.d(t, "min", function () {return W;}), r.d(t, "shuffle", function () {return H;}), r.d(t, "sample", function () {return X;}), r.d(t, "sortBy", function () {return J;}), r.d(t, "groupBy", function () {return Z;}), r.d(t, "indexBy", function () {return Q;}), r.d(t, "countBy", function () {return ee;}), r.d(t, "toArray", function () {return re;}), r.d(t, "size", function () {return ne;}), r.d(t, "partition", function () {return oe;}), r.d(t, "first", function () {return ie;}), r.d(t, "head", function () {return ie;}), r.d(t, "take", function () {return ie;}), r.d(t, "initial", function () {return se;}), r.d(t, "last", function () {return ae;}), r.d(t, "rest", function () {return ce;}), r.d(t, "tail", function () {return ce;}), r.d(t, "drop", function () {return ce;}), r.d(t, "compact", function () {return ue;}), r.d(t, "flatten", function () {return he;}), r.d(t, "without", function () {return de;}), r.d(t, "uniq", function () {return ge;}), r.d(t, "unique", function () {return ge;}), r.d(t, "union", function () {return pe;}), r.d(t, "intersection", function () {return fe;}), r.d(t, "difference", function () {return ve;}), r.d(t, "unzip", function () {return _e;}), r.d(t, "zip", function () {return ye;}), r.d(t, "object", function () {return me;}), r.d(t, "findIndex", function () {return xe;}), r.d(t, "findLastIndex", function () {return Re;}), r.d(t, "sortedIndex", function () {return Ae;}), r.d(t, "indexOf", function () {return Ve;}), r.d(t, "lastIndexOf", function () {return Te;}), r.d(t, "range", function () {return Ce;}), r.d(t, "chunk", function () {return be;}), r.d(t, "bind", function () {return Oe;}), r.d(t, "partial", function () {return Se;}), r.d(t, "bindAll", function () {return Me;}), r.d(t, "memoize", function () {return we;}), r.d(t, "delay", function () {return Ne;}), r.d(t, "defer", function () {return Fe;}), r.d(t, "throttle", function () {return Ie;}), r.d(t, "debounce", function () {return De;}), r.d(t, "wrap", function () {return je;}), r.d(t, "negate", function () {return Be;}), r.d(t, "compose", function () {return Ue;}), r.d(t, "after", function () {return ke;}), r.d(t, "before", function () {return Ge;}), r.d(t, "once", function () {return ze;}), r.d(t, "keys", function () {return We;}), r.d(t, "allKeys", function () {return He;}), r.d(t, "values", function () {return Xe;}), r.d(t, "mapObject", function () {return Je;}), r.d(t, "pairs", function () {return $e;}), r.d(t, "invert", function () {return Ze;}), r.d(t, "functions", function () {return Qe;}), r.d(t, "methods", function () {return Qe;}), r.d(t, "extend", function () {return tt;}), r.d(t, "extendOwn", function () {return rt;}), r.d(t, "assign", function () {return rt;}), r.d(t, "findKey", function () {return nt;}), r.d(t, "pick", function () {return it;}), r.d(t, "omit", function () {return st;}), r.d(t, "defaults", function () {return at;}), r.d(t, "create", function () {return ct;}), r.d(t, "clone", function () {return ut;}), r.d(t, "tap", function () {return lt;}), r.d(t, "isMatch", function () {return ht;}), r.d(t, "isEqual", function () {return dt;}), r.d(t, "isEmpty", function () {return gt;}), r.d(t, "isElement", function () {return pt;}), r.d(t, "isArray", function () {return vt;}), r.d(t, "isObject", function () {return _t;}), r.d(t, "isArguments", function () {return yt;}), r.d(t, "isFunction", function () {return mt;}), r.d(t, "isString", function () {return Et;}), r.d(t, "isNumber", function () {return xt;}), r.d(t, "isDate", function () {return Rt;}), r.d(t, "isRegExp", function () {return At;}), r.d(t, "isError", function () {return Pt;}), r.d(t, "isSymbol", function () {return Vt;}), r.d(t, "isMap", function () {return Tt;}), r.d(t, "isWeakMap", function () {return Ct;}), r.d(t, "isSet", function () {return bt;}), r.d(t, "isWeakSet", function () {return Lt;}), r.d(t, "isFinite", function () {return St;}), r.d(t, "isNaN", function () {return Mt;}), r.d(t, "isBoolean", function () {return wt;}), r.d(t, "isNull", function () {return Nt;}), r.d(t, "isUndefined", function () {return Ft;}), r.d(t, "has", function () {return It;}), r.d(t, "identity", function () {return Dt;}), r.d(t, "constant", function () {return jt;}), r.d(t, "noop", function () {return Bt;}), r.d(t, "property", function () {return Ut;}), r.d(t, "propertyOf", function () {return kt;}), r.d(t, "matcher", function () {return Gt;}), r.d(t, "matches", function () {return Gt;}), r.d(t, "times", function () {return zt;}), r.d(t, "random", function () {return Yt;}), r.d(t, "now", function () {return Kt;}), r.d(t, "escape", function () {return Xt;}), r.d(t, "unescape", function () {return Jt;}), r.d(t, "result", function () {return $t;}), r.d(t, "uniqueId", function () {return Qt;}), r.d(t, "templateSettings", function () {return er;}), r.d(t, "template", function () {return ir;}), r.d(t, "chain", function () {return sr;}), r.d(t, "mixin", function () {return cr;});var n = "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self.self === self && self || "object" == _typeof(e) && e.global === e && e || Function("return this")() || {},o = Array.prototype,i = Object.prototype,s = "undefined" != typeof Symbol ? Symbol.prototype : null,a = o.push,c = o.slice,u = i.toString,l = i.hasOwnProperty,h = Array.isArray,d = Object.keys,g = Object.create,p = n.isNaN,f = n.isFinite,v = function v() {};function _(e) {return e instanceof _ ? e : this instanceof _ ? void (this._wrapped = e) : new _(e);}var y = _.VERSION = "1.10.2";function m(e, t, r) {if (void 0 === t) return e;switch (null == r ? 3 : r) {case 1:return function (r) {return e.call(t, r);};case 3:return function (r, n, o) {return e.call(t, r, n, o);};case 4:return function (r, n, o, i) {return e.call(t, r, n, o, i);};}return function () {return e.apply(t, arguments);};}function E(e, t, r) {return null == e ? Dt : mt(e) ? m(e, t, r) : _t(e) && !vt(e) ? Gt(e) : Ut(e);}function x(e, t) {return E(e, t, 1 / 0);}function R(e, t, r) {return _.iteratee !== x ? _.iteratee(e, t) : E(e, t, r);}function A(e, t) {return t = null == t ? e.length - 1 : +t, function () {for (var r = Math.max(arguments.length - t, 0), n = Array(r), o = 0; o < r; o++) {n[o] = arguments[o + t];}switch (t) {case 0:return e.call(this, n);case 1:return e.call(this, arguments[0], n);case 2:return e.call(this, arguments[0], arguments[1], n);}var i = Array(t + 1);for (o = 0; o < t; o++) {i[o] = arguments[o];}return i[t] = n, e.apply(this, i);};}function P(e) {if (!_t(e)) return {};if (g) return g(e);v.prototype = e;var t = new v();return v.prototype = null, t;}function V(e) {return function (t) {return null == t ? void 0 : t[e];};}function T(e, t) {return null != e && l.call(e, t);}function C(e, t) {for (var r = t.length, n = 0; n < r; n++) {if (null == e) return;e = e[t[n]];}return r ? e : void 0;}_.iteratee = x;var b = Math.pow(2, 53) - 1,L = V("length");function O(e) {var t = L(e);return "number" == typeof t && t >= 0 && t <= b;}function S(e, t, r) {var n, o;if (t = m(t, r), O(e)) for (n = 0, o = e.length; n < o; n++) {t(e[n], n, e);} else {var i = We(e);for (n = 0, o = i.length; n < o; n++) {t(e[i[n]], i[n], e);}}return e;}function M(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = Array(o), s = 0; s < o; s++) {var a = n ? n[s] : s;i[s] = t(e[a], a, e);}return i;}function w(e) {return function (t, r, n, o) {var i = arguments.length >= 3;return function (t, r, n, o) {var i = !O(t) && We(t),s = (i || t).length,a = e > 0 ? 0 : s - 1;for (o || (n = t[i ? i[a] : a], a += e); a >= 0 && a < s; a += e) {var c = i ? i[a] : a;n = r(n, t[c], c, t);}return n;}(t, m(r, o, 4), n, i);};}var N = w(1),F = w(-1);function I(e, t, r) {var n = (O(e) ? xe : nt)(e, t, r);if (void 0 !== n && -1 !== n) return e[n];}function D(e, t, r) {var n = [];return t = R(t, r), S(e, function (e, r, o) {t(e, r, o) && n.push(e);}), n;}function j(e, t, r) {return D(e, Be(R(t)), r);}function B(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = 0; i < o; i++) {var s = n ? n[i] : i;if (!t(e[s], s, e)) return !1;}return !0;}function U(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = 0; i < o; i++) {var s = n ? n[i] : i;if (t(e[s], s, e)) return !0;}return !1;}function k(e, t, r, n) {return O(e) || (e = Xe(e)), ("number" != typeof r || n) && (r = 0), Ve(e, t, r) >= 0;}var G = A(function (e, t, r) {var n, o;return mt(t) ? o = t : vt(t) && (n = t.slice(0, -1), t = t[t.length - 1]), M(e, function (e) {var i = o;if (!i) {if (n && n.length && (e = C(e, n)), null == e) return;i = e[t];}return null == i ? i : i.apply(e, r);});});function z(e, t) {return M(e, Ut(t));}function Y(e, t) {return D(e, Gt(t));}function K(e, t) {return I(e, Gt(t));}function q(e, t, r) {var n,o,i = -1 / 0,s = -1 / 0;if (null == t || "number" == typeof t && "object" != _typeof(e[0]) && null != e) for (var a = 0, c = (e = O(e) ? e : Xe(e)).length; a < c; a++) {null != (n = e[a]) && n > i && (i = n);} else t = R(t, r), S(e, function (e, r, n) {((o = t(e, r, n)) > s || o === -1 / 0 && i === -1 / 0) && (i = e, s = o);});return i;}function W(e, t, r) {var n,o,i = 1 / 0,s = 1 / 0;if (null == t || "number" == typeof t && "object" != _typeof(e[0]) && null != e) for (var a = 0, c = (e = O(e) ? e : Xe(e)).length; a < c; a++) {null != (n = e[a]) && n < i && (i = n);} else t = R(t, r), S(e, function (e, r, n) {((o = t(e, r, n)) < s || o === 1 / 0 && i === 1 / 0) && (i = e, s = o);});return i;}function H(e) {return X(e, 1 / 0);}function X(e, t, r) {if (null == t || r) return O(e) || (e = Xe(e)), e[Yt(e.length - 1)];var n = O(e) ? ut(e) : Xe(e),o = L(n);t = Math.max(Math.min(t, o), 0);for (var i = o - 1, s = 0; s < t; s++) {var a = Yt(s, i),c = n[s];n[s] = n[a], n[a] = c;}return n.slice(0, t);}function J(e, t, r) {var n = 0;return t = R(t, r), z(M(e, function (e, r, o) {return { value: e, index: n++, criteria: t(e, r, o) };}).sort(function (e, t) {var r = e.criteria,n = t.criteria;if (r !== n) {if (r > n || void 0 === r) return 1;if (r < n || void 0 === n) return -1;}return e.index - t.index;}), "value");}function $(e, t) {return function (r, n, o) {var i = t ? [[], []] : {};return n = R(n, o), S(r, function (t, o) {var s = n(t, o, r);e(i, t, s);}), i;};}var Z = $(function (e, t, r) {T(e, r) ? e[r].push(t) : e[r] = [t];}),Q = $(function (e, t, r) {e[r] = t;}),ee = $(function (e, t, r) {T(e, r) ? e[r]++ : e[r] = 1;}),te = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;function re(e) {return e ? vt(e) ? c.call(e) : Et(e) ? e.match(te) : O(e) ? M(e, Dt) : Xe(e) : [];}function ne(e) {return null == e ? 0 : O(e) ? e.length : We(e).length;}var oe = $(function (e, t, r) {e[r ? 0 : 1].push(t);}, !0);function ie(e, t, r) {return null == e || e.length < 1 ? null == t ? void 0 : [] : null == t || r ? e[0] : se(e, e.length - t);}function se(e, t, r) {return c.call(e, 0, Math.max(0, e.length - (null == t || r ? 1 : t)));}function ae(e, t, r) {return null == e || e.length < 1 ? null == t ? void 0 : [] : null == t || r ? e[e.length - 1] : ce(e, Math.max(0, e.length - t));}function ce(e, t, r) {return c.call(e, null == t || r ? 1 : t);}function ue(e) {return D(e, Boolean);}function le(e, t, r, n) {for (var o = (n = n || []).length, i = 0, s = L(e); i < s; i++) {var a = e[i];if (O(a) && (vt(a) || yt(a))) {if (t) for (var c = 0, u = a.length; c < u;) {n[o++] = a[c++];} else le(a, t, r, n), o = n.length;} else r || (n[o++] = a);}return n;}function he(e, t) {return le(e, t, !1);}var de = A(function (e, t) {return ve(e, t);});function ge(e, t, r, n) {wt(t) || (n = r, r = t, t = !1), null != r && (r = R(r, n));for (var o = [], i = [], s = 0, a = L(e); s < a; s++) {var c = e[s],u = r ? r(c, s, e) : c;t && !r ? (s && i === u || o.push(c), i = u) : r ? k(i, u) || (i.push(u), o.push(c)) : k(o, c) || o.push(c);}return o;}var pe = A(function (e) {return ge(le(e, !0, !0));});function fe(e) {for (var t = [], r = arguments.length, n = 0, o = L(e); n < o; n++) {var i = e[n];if (!k(t, i)) {var s;for (s = 1; s < r && k(arguments[s], i); s++) {;}s === r && t.push(i);}}return t;}var ve = A(function (e, t) {return t = le(t, !0, !0), D(e, function (e) {return !k(t, e);});});function _e(e) {for (var t = e && q(e, L).length || 0, r = Array(t), n = 0; n < t; n++) {r[n] = z(e, n);}return r;}var ye = A(_e);function me(e, t) {for (var r = {}, n = 0, o = L(e); n < o; n++) {t ? r[e[n]] = t[n] : r[e[n][0]] = e[n][1];}return r;}function Ee(e) {return function (t, r, n) {r = R(r, n);for (var o = L(t), i = e > 0 ? 0 : o - 1; i >= 0 && i < o; i += e) {if (r(t[i], i, t)) return i;}return -1;};}var xe = Ee(1),Re = Ee(-1);function Ae(e, t, r, n) {for (var o = (r = R(r, n, 1))(t), i = 0, s = L(e); i < s;) {var a = Math.floor((i + s) / 2);r(e[a]) < o ? i = a + 1 : s = a;}return i;}function Pe(e, t, r) {return function (n, o, i) {var s = 0,a = L(n);if ("number" == typeof i) e > 0 ? s = i >= 0 ? i : Math.max(i + a, s) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1;else if (r && i && a) return n[i = r(n, o)] === o ? i : -1;if (o != o) return (i = t(c.call(n, s, a), Mt)) >= 0 ? i + s : -1;for (i = e > 0 ? s : a - 1; i >= 0 && i < a; i += e) {if (n[i] === o) return i;}return -1;};}var Ve = Pe(1, xe, Ae),Te = Pe(-1, Re);function Ce(e, t, r) {null == t && (t = e || 0, e = 0), r || (r = t < e ? -1 : 1);for (var n = Math.max(Math.ceil((t - e) / r), 0), o = Array(n), i = 0; i < n; i++, e += r) {o[i] = e;}return o;}function be(e, t) {if (null == t || t < 1) return [];for (var r = [], n = 0, o = e.length; n < o;) {r.push(c.call(e, n, n += t));}return r;}function Le(e, t, r, n, o) {if (!(n instanceof t)) return e.apply(r, o);var i = P(e.prototype),s = e.apply(i, o);return _t(s) ? s : i;}var Oe = A(function (e, t, r) {if (!mt(e)) throw new TypeError("Bind must be called on a function");var n = A(function (o) {return Le(e, n, t, this, r.concat(o));});return n;}),Se = A(function (e, t) {var r = Se.placeholder,n = function n() {for (var o = 0, i = t.length, s = Array(i), a = 0; a < i; a++) {s[a] = t[a] === r ? arguments[o++] : t[a];}for (; o < arguments.length;) {s.push(arguments[o++]);}return Le(e, n, this, this, s);};return n;});Se.placeholder = _;var Me = A(function (e, t) {var r = (t = le(t, !1, !1)).length;if (r < 1) throw new Error("bindAll must be passed function names");for (; r--;) {var n = t[r];e[n] = Oe(e[n], e);}});function we(e, t) {var r = function r(n) {var o = r.cache,i = "" + (t ? t.apply(this, arguments) : n);return T(o, i) || (o[i] = e.apply(this, arguments)), o[i];};return r.cache = {}, r;}var Ne = A(function (e, t, r) {return setTimeout(function () {return e.apply(null, r);}, t);}),Fe = Se(Ne, _, 1);function Ie(e, t, r) {var n,o,i,s,a = 0;r || (r = {});var c = function c() {a = !1 === r.leading ? 0 : Kt(), n = null, s = e.apply(o, i), n || (o = i = null);},u = function u() {var u = Kt();a || !1 !== r.leading || (a = u);var l = t - (u - a);return o = this, i = arguments, l <= 0 || l > t ? (n && (clearTimeout(n), n = null), a = u, s = e.apply(o, i), n || (o = i = null)) : n || !1 === r.trailing || (n = setTimeout(c, l)), s;};return u.cancel = function () {clearTimeout(n), a = 0, n = o = i = null;}, u;}function De(e, t, r) {var n,o,i = function i(t, r) {n = null, r && (o = e.apply(t, r));},s = A(function (s) {if (n && clearTimeout(n), r) {var a = !n;n = setTimeout(i, t), a && (o = e.apply(this, s));} else n = Ne(i, t, this, s);return o;});return s.cancel = function () {clearTimeout(n), n = null;}, s;}function je(e, t) {return Se(t, e);}function Be(e) {return function () {return !e.apply(this, arguments);};}function Ue() {var e = arguments,t = e.length - 1;return function () {for (var r = t, n = e[t].apply(this, arguments); r--;) {n = e[r].call(this, n);}return n;};}function ke(e, t) {return function () {if (--e < 1) return t.apply(this, arguments);};}function Ge(e, t) {var r;return function () {return --e > 0 && (r = t.apply(this, arguments)), e <= 1 && (t = null), r;};}var ze = Se(Ge, 2),Ye = !{ toString: null }.propertyIsEnumerable("toString"),Ke = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];function qe(e, t) {var r = Ke.length,n = e.constructor,o = mt(n) && n.prototype || i,s = "constructor";for (T(e, s) && !k(t, s) && t.push(s); r--;) {(s = Ke[r]) in e && e[s] !== o[s] && !k(t, s) && t.push(s);}}function We(e) {if (!_t(e)) return [];if (d) return d(e);var t = [];for (var r in e) {T(e, r) && t.push(r);}return Ye && qe(e, t), t;}function He(e) {if (!_t(e)) return [];var t = [];for (var r in e) {t.push(r);}return Ye && qe(e, t), t;}function Xe(e) {for (var t = We(e), r = t.length, n = Array(r), o = 0; o < r; o++) {n[o] = e[t[o]];}return n;}function Je(e, t, r) {t = R(t, r);for (var n = We(e), o = n.length, i = {}, s = 0; s < o; s++) {var a = n[s];i[a] = t(e[a], a, e);}return i;}function $e(e) {for (var t = We(e), r = t.length, n = Array(r), o = 0; o < r; o++) {n[o] = [t[o], e[t[o]]];}return n;}function Ze(e) {for (var t = {}, r = We(e), n = 0, o = r.length; n < o; n++) {t[e[r[n]]] = r[n];}return t;}function Qe(e) {var t = [];for (var r in e) {mt(e[r]) && t.push(r);}return t.sort();}function et(e, t) {return function (r) {var n = arguments.length;if (t && (r = Object(r)), n < 2 || null == r) return r;for (var o = 1; o < n; o++) {for (var i = arguments[o], s = e(i), a = s.length, c = 0; c < a; c++) {var u = s[c];t && void 0 !== r[u] || (r[u] = i[u]);}}return r;};}var tt = et(He),rt = et(We);function nt(e, t, r) {t = R(t, r);for (var n, o = We(e), i = 0, s = o.length; i < s; i++) {if (t(e[n = o[i]], n, e)) return n;}}function ot(e, t, r) {return t in r;}var it = A(function (e, t) {var r = {},n = t[0];if (null == e) return r;mt(n) ? (t.length > 1 && (n = m(n, t[1])), t = He(e)) : (n = ot, t = le(t, !1, !1), e = Object(e));for (var o = 0, i = t.length; o < i; o++) {var s = t[o],a = e[s];n(a, s, e) && (r[s] = a);}return r;}),st = A(function (e, t) {var r,n = t[0];return mt(n) ? (n = Be(n), t.length > 1 && (r = t[1])) : (t = M(le(t, !1, !1), String), n = function n(e, r) {return !k(t, r);}), it(e, n, r);}),at = et(He, !0);function ct(e, t) {var r = P(e);return t && rt(r, t), r;}function ut(e) {return _t(e) ? vt(e) ? e.slice() : tt({}, e) : e;}function lt(e, t) {return t(e), e;}function ht(e, t) {var r = We(t),n = r.length;if (null == e) return !n;for (var o = Object(e), i = 0; i < n; i++) {var s = r[i];if (t[s] !== o[s] || !(s in o)) return !1;}return !0;}function dt(e, t) {return function e(t, r, n, o) {if (t === r) return 0 !== t || 1 / t == 1 / r;if (null == t || null == r) return !1;if (t != t) return r != r;var i = _typeof(t);return ("function" === i || "object" === i || "object" == _typeof(r)) && function (t, r, n, o) {t instanceof _ && (t = t._wrapped), r instanceof _ && (r = r._wrapped);var i = u.call(t);if (i !== u.call(r)) return !1;switch (i) {case "[object RegExp]":case "[object String]":return "" + t == "" + r;case "[object Number]":return +t != +t ? +r != +r : 0 == +t ? 1 / +t == 1 / r : +t == +r;case "[object Date]":case "[object Boolean]":return +t == +r;case "[object Symbol]":return s.valueOf.call(t) === s.valueOf.call(r);}var a = "[object Array]" === i;if (!a) {if ("object" != _typeof(t) || "object" != _typeof(r)) return !1;var c = t.constructor,l = r.constructor;if (c !== l && !(mt(c) && c instanceof c && mt(l) && l instanceof l) && "constructor" in t && "constructor" in r) return !1;}o = o || [];for (var h = (n = n || []).length; h--;) {if (n[h] === t) return o[h] === r;}if (n.push(t), o.push(r), a) {if ((h = t.length) !== r.length) return !1;for (; h--;) {if (!e(t[h], r[h], n, o)) return !1;}} else {var d,g = We(t);if (h = g.length, We(r).length !== h) return !1;for (; h--;) {if (!T(r, d = g[h]) || !e(t[d], r[d], n, o)) return !1;}}return n.pop(), o.pop(), !0;}(t, r, n, o);}(e, t);}function gt(e) {return null == e || (O(e) && (vt(e) || Et(e) || yt(e)) ? 0 === e.length : 0 === We(e).length);}function pt(e) {return !(!e || 1 !== e.nodeType);}function ft(e) {return function (t) {return u.call(t) === "[object " + e + "]";};}var vt = h || ft("Array");function _t(e) {var t = _typeof(e);return "function" === t || "object" === t && !!e;}var yt = ft("Arguments"),mt = ft("Function"),Et = ft("String"),xt = ft("Number"),Rt = ft("Date"),At = ft("RegExp"),Pt = ft("Error"),Vt = ft("Symbol"),Tt = ft("Map"),Ct = ft("WeakMap"),bt = ft("Set"),Lt = ft("WeakSet");!function () {yt(arguments) || (yt = function yt(e) {return T(e, "callee");});}();var Ot = n.document && n.document.childNodes;function St(e) {return !Vt(e) && f(e) && !p(parseFloat(e));}function Mt(e) {return xt(e) && p(e);}function wt(e) {return !0 === e || !1 === e || "[object Boolean]" === u.call(e);}function Nt(e) {return null === e;}function Ft(e) {return void 0 === e;}function It(e, t) {if (!vt(t)) return T(e, t);for (var r = t.length, n = 0; n < r; n++) {var o = t[n];if (null == e || !l.call(e, o)) return !1;e = e[o];}return !!r;}function Dt(e) {return e;}function jt(e) {return function () {return e;};}function Bt() {}function Ut(e) {return vt(e) ? function (t) {return C(t, e);} : V(e);}function kt(e) {return null == e ? function () {} : function (t) {return vt(t) ? C(e, t) : e[t];};}function Gt(e) {return e = rt({}, e), function (t) {return ht(t, e);};}function zt(e, t, r) {var n = Array(Math.max(0, e));t = m(t, r, 1);for (var o = 0; o < e; o++) {n[o] = t(o);}return n;}function Yt(e, t) {return null == t && (t = e, e = 0), e + Math.floor(Math.random() * (t - e + 1));}"object" != (typeof Int8Array === "undefined" ? "undefined" : _typeof(Int8Array)) && "function" != typeof Ot && (mt = function mt(e) {return "function" == typeof e || !1;});var Kt = Date.now || function () {return new Date().getTime();},qt = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" },Wt = Ze(qt);function Ht(e) {var t = function t(_t3) {return e[_t3];},r = "(?:" + We(e).join("|") + ")",n = RegExp(r),o = RegExp(r, "g");return function (e) {return e = null == e ? "" : "" + e, n.test(e) ? e.replace(o, t) : e;};}var Xt = Ht(qt),Jt = Ht(Wt);function $t(e, t, r) {vt(t) || (t = [t]);var n = t.length;if (!n) return mt(r) ? r.call(e) : r;for (var o = 0; o < n; o++) {var i = null == e ? void 0 : e[t[o]];void 0 === i && (i = r, o = n), e = mt(i) ? i.call(e) : i;}return e;}var Zt = 0;function Qt(e) {var t = ++Zt + "";return e ? e + t : t;}var er = _.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g },tr = /(.)^/,rr = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029" },nr = /\\|'|\r|\n|\u2028|\u2029/g,or = function or(e) {return "\\" + rr[e];};function ir(e, t, r) {!t && r && (t = r), t = at({}, t, _.templateSettings);var n,o = RegExp([(t.escape || tr).source, (t.interpolate || tr).source, (t.evaluate || tr).source].join("|") + "|$", "g"),i = 0,s = "__p+='";e.replace(o, function (t, r, n, o, a) {return s += e.slice(i, a).replace(nr, or), i = a + t.length, r ? s += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : n ? s += "'+\n((__t=(" + n + "))==null?'':__t)+\n'" : o && (s += "';\n" + o + "\n__p+='"), t;}), s += "';\n", t.variable || (s = "with(obj||{}){\n" + s + "}\n"), s = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + s + "return __p;\n";try {n = new Function(t.variable || "obj", "_", s);} catch (e) {throw e.source = s, e;}var a = function a(e) {return n.call(this, e, _);},c = t.variable || "obj";return a.source = "function(" + c + "){\n" + s + "}", a;}function sr(e) {var t = _(e);return t._chain = !0, t;}function ar(e, t) {return e._chain ? _(t).chain() : t;}function cr(e) {return S(Qe(e), function (t) {var r = _[t] = e[t];_.prototype[t] = function () {var e = [this._wrapped];return a.apply(e, arguments), ar(this, r.apply(_, e));};}), _;}S(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (e) {var t = o[e];_.prototype[e] = function () {var r = this._wrapped;return t.apply(r, arguments), "shift" !== e && "splice" !== e || 0 !== r.length || delete r[0], ar(this, r);};}), S(["concat", "join", "slice"], function (e) {var t = o[e];_.prototype[e] = function () {return ar(this, t.apply(this._wrapped, arguments));};}), _.prototype.value = function () {return this._wrapped;}, _.prototype.valueOf = _.prototype.toJSON = _.prototype.value, _.prototype.toString = function () {return String(this._wrapped);};}.call(this, r(57));}, function (e, t, r) {"use strict";e.exports = l;var n = r(21);((l.prototype = Object.create(n.prototype)).constructor = l).className = "Namespace";var o,i,s,a = r(22),c = r(5);function u(e, t) {if (e && e.length) {for (var r = {}, n = 0; n < e.length; ++n) {r[e[n].name] = e[n].toJSON(t);}return r;}}function l(e, t) {n.call(this, e, t), this.nested = void 0, this._nestedArray = null;}function h(e) {return e._nestedArray = null, e;}l.fromJSON = function (e, t) {return new l(e, t.options).addJSON(t.nested);}, l.arrayToJSON = u, l.isReservedId = function (e, t) {if (e) for (var r = 0; r < e.length; ++r) {if ("string" != typeof e[r] && e[r][0] <= t && e[r][1] >= t) return !0;}return !1;}, l.isReservedName = function (e, t) {if (e) for (var r = 0; r < e.length; ++r) {if (e[r] === t) return !0;}return !1;}, Object.defineProperty(l.prototype, "nestedArray", { get: function get() {return this._nestedArray || (this._nestedArray = c.toArray(this.nested));} }), l.prototype.toJSON = function (e) {return c.toObject(["options", this.options, "nested", u(this.nestedArray, e)]);}, l.prototype.addJSON = function (e) {if (e) for (var t, r = Object.keys(e), n = 0; n < r.length; ++n) {t = e[r[n]], this.add((void 0 !== t.fields ? o.fromJSON : void 0 !== t.values ? s.fromJSON : void 0 !== t.methods ? i.fromJSON : void 0 !== t.id ? a.fromJSON : l.fromJSON)(r[n], t));}return this;}, l.prototype.get = function (e) {return this.nested && this.nested[e] || null;}, l.prototype.getEnum = function (e) {if (this.nested && this.nested[e] instanceof s) return this.nested[e].values;throw Error("no such enum: " + e);}, l.prototype.add = function (e) {if (!(e instanceof a && void 0 !== e.extend || e instanceof o || e instanceof s || e instanceof i || e instanceof l)) throw TypeError("object must be a valid nested object");if (this.nested) {var t = this.get(e.name);if (t) {if (!(t instanceof l && e instanceof l) || t instanceof o || t instanceof i) throw Error("duplicate name '" + e.name + "' in " + this);for (var r = t.nestedArray, n = 0; n < r.length; ++n) {e.add(r[n]);}this.remove(t), this.nested || (this.nested = {}), e.setOptions(t.options, !0);}} else this.nested = {};return this.nested[e.name] = e, e.onAdd(this), h(this);}, l.prototype.remove = function (e) {if (!(e instanceof n)) throw TypeError("object must be a ReflectionObject");if (e.parent !== this) throw Error(e + " is not a member of " + this);return delete this.nested[e.name], Object.keys(this.nested).length || (this.nested = void 0), e.onRemove(this), h(this);}, l.prototype.define = function (e, t) {if (c.isString(e)) e = e.split(".");else if (!Array.isArray(e)) throw TypeError("illegal path");if (e && e.length && "" === e[0]) throw Error("path must be relative");for (var r = this; e.length > 0;) {var n = e.shift();if (r.nested && r.nested[n]) {if (!((r = r.nested[n]) instanceof l)) throw Error("path conflicts with non-namespace objects");} else r.add(r = new l(n));}return t && r.addJSON(t), r;}, l.prototype.resolveAll = function () {for (var e = this.nestedArray, t = 0; t < e.length;) {e[t] instanceof l ? e[t++].resolveAll() : e[t++].resolve();}return this.resolve();}, l.prototype.lookup = function (e, t, r) {if ("boolean" == typeof t ? (r = t, t = void 0) : t && !Array.isArray(t) && (t = [t]), c.isString(e) && e.length) {if ("." === e) return this.root;e = e.split(".");} else if (!e.length) return this;if ("" === e[0]) return this.root.lookup(e.slice(1), t);var n = this.get(e[0]);if (n) {if (1 === e.length) {if (!t || t.indexOf(n.constructor) > -1) return n;} else if (n instanceof l && (n = n.lookup(e.slice(1), t, !0))) return n;} else for (var o = 0; o < this.nestedArray.length; ++o) {if (this._nestedArray[o] instanceof l && (n = this._nestedArray[o].lookup(e, t, !0))) return n;}return null === this.parent || r ? null : this.parent.lookup(e, t);}, l.prototype.lookupType = function (e) {var t = this.lookup(e, [o]);if (!t) throw Error("no such type: " + e);return t;}, l.prototype.lookupEnum = function (e) {var t = this.lookup(e, [s]);if (!t) throw Error("no such Enum '" + e + "' in " + this);return t;}, l.prototype.lookupTypeOrEnum = function (e) {var t = this.lookup(e, [o, s]);if (!t) throw Error("no such Type or Enum '" + e + "' in " + this);return t;}, l.prototype.lookupService = function (e) {var t = this.lookup(e, [i]);if (!t) throw Error("no such Service '" + e + "' in " + this);return t;}, l._configure = function (e, t, r) {o = e, i = t, s = r;};}, function (e, t, r) {"use strict";var n = t,o = r(5),i = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64", "sint64", "fixed64", "sfixed64", "bool", "string", "bytes"];function s(e, t) {var r = 0,n = {};for (t |= 0; r < e.length;) {n[i[r + t]] = e[r++];}return n;}n.basic = s([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), n.defaults = s([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, !1, "", o.emptyArray, null]), n.long = s([0, 0, 0, 1, 1], 7), n.mapKey = s([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), n.packed = s([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]);}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Curve = void 0;var n = r(1),o = r(43),i = r(0),s = r(3),a = r(2),c = function c() {o.BaseGeometry.call(this), this._subrange = [];};(c.prototype = Object.create(o.BaseGeometry.prototype)).copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this._subrange = e.isLimited() ? [e._subrange[0], e._subrange[1]] : [];}, c.prototype.isLimited = function () {return this._subrange.length > 0;}, c.prototype.getRange = function () {return this.isLimited() ? this._subrange : this.getRangeUnlimited();}, c.prototype.getRangeUnlimited = function () {console.warn("Curve.getRangeUnlimited : abstract method invoked!");}, c.prototype.limitRange = function (e) {this._subrange = (0, s.limitRange)(this.getRange(), e, this.isPeriodic(), this.getPeriod());}, c.prototype.unlimitRange = function () {this._subrange = [];}, c.prototype.isPeriodic = function () {return this.isPeriodicUnlimited() && !this.isLimited();}, c.prototype.isPeriodicUnlimited = function () {console.warn("Curve.isPeriodicUnlimited : abstract method invoked!");}, c.prototype.getPeriod = function () {return this.isLimited() ? void 0 : this.getPeriodUnlimited();}, c.prototype.getPeriodUnlimited = function () {if (this.isPeriodicUnlimited()) {var e = this.getRangeUnlimited();return e[1] - e[0];}}, c.prototype.isClosed = function () {if (this.isClosedUnlimited()) {if (this.isLimited()) {var e = this.getRangeUnlimited(),t = e[1] - e[0];return this._subrange[1] - this._subrange[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, c.prototype.isClosedUnlimited = function () {console.warn("Curve.isClosedUnlimited : abstract method invoked!");}, c.prototype._restrictRangeToUnlimited = function (e) {a.ConsoleUtils.assert(2 === e.length), a.ConsoleUtils.assert(e[0] <= e[1]);var t = this.getRangeUnlimited(),r = [];if (this.isPeriodicUnlimited()) {var o = t[1] - t[0];if (e[1] - e[0] > o - i.PARAMETER_SPACE_TOLERANCE) r.push([t[0], t[1]]);else {var c = (0, s.foldAbove)(e[0], t[0], o) - e[0];r.push([e[0] + c, e[1] + c]), r[0][1] > t[1] + i.PARAMETER_SPACE_TOLERANCE && (r.push([t[0], r[0][1] - o]), r[0][1] = t[1]);}} else {var u = Math.max(e[0], t[0]),l = Math.min(e[1], t[1]);u > t[1] ? u < t[1] + n.FLOAT64_TOLERANCE && r.push([t[1], t[1]]) : l < t[0] ? l > t[0] - n.FLOAT64_TOLERANCE && r.push([t[0], t[0]]) : r.push([u, l]);}return r;}, c.prototype.transform = function (e) {console.warn("Curve.transform : abstract method invoked! Doing nothing.");}, c.prototype.evaluatePosition = function (e) {console.warn("Curve.evaluatePosition : abstract method invoked! Returning undefined.");}, c.prototype.evaluateDt = function (e) {console.warn("Curve.evaluateDt : abstract method invoked! Returning undefined.");}, c.prototype.evaluateCurvature = function (e, t) {var r = this.evaluateDt(e),o = this.evaluateDt(e + i.KERNEL_TOLERANCE);n.Vector3.sub(o, o, r);var s = n.Vector3.createFloat64();n.Vector3.scale(s, o, 1 / i.KERNEL_TOLERANCE), t && (n.Vector3.copy(t, s), n.Vector3.normalize(t, t));var a = n.Vector3.squaredLength(r);return n.Vector3.cross(s, r, s), n.Vector3.length(s) / Math.pow(a, 1.5);}, c.prototype.tangentLength = function (e) {return n.Vector3.length(this.evaluateDt(e));}, c.prototype.suggestSplittingParam = function (e) {console.warn("Curve.suggestSplittingParam : abstract method invoked! Returning undefined.");}, c.prototype.getTangentCone = function (e) {console.warn("Curve.getTangentCone : abstract method invoked! Returning undefined.");}, c.prototype.closestToRayParam = function (e, t, r) {console.warn("Curve.closestToRayParam : abstract method invoked! Returning undefined.");}, c.prototype.closestToPointParam = function (e, t) {console.warn("Curve.closestToPointParam : abstract method invoked! Returning undefined.");}, c.prototype.getArcLength = function (e) {console.warn("Curve.getArcLength : abstract method invoked!");}, c.prototype.getParameterFromArcLength = function (e, t) {console.warn("Curve.getParameterFromArcLength : abstract method invoked!");}, c.prototype.getBoundingBox = function (e) {console.warn("Curve.getBoundingBox : abstract method invoked! Returning undefined.");}, c.prototype.tessellate = function (e, t) {console.warn("Curve.tessellate : abstract method invoked! Returning undefined.");}, t.Curve = c;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BCurve = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(7),u = r(3),l = r(35),h = r(2),d = r(8),g = r(50),p = r(36),f = r(17),v = r(37),_ = r(102),y = r(73),m = function m() {a.Curve.call(this), this._controlPoints = [], this._weights = [], this._degree = 0, this._knots = [], this._isRational = void 0, this._isPeriodic = void 0, this._isClosed = void 0, this._isPlanarXY = void 0, this._discretizationCache = void 0, this._segments = void 0, this._hasDirtySegments = !0, this._isDirtyControlPoint = [], this._tessellationCache = new g.TessellationCache();};(m.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.BCURVE;}, m.prototype.clone = function () {var e = new m();return e.copy(this), e;}, m.prototype.getControlPointsVector3 = function () {for (var e = new Array(this._controlPoints.length / 3), t = 0; t < this._controlPoints.length / 3; t++) {e[t] = n.Vector3.createFloat64FromValues(this._controlPoints[3 * t], this._controlPoints[3 * t + 1], this._controlPoints[3 * t + 2]);}return e;}, m.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), this._isRational = e._isRational, this._weights = e._weights.slice(0), this._degree = e._degree, this._knots = e._knots.slice(0), this._isPeriodic = e._isPeriodic, this._isClosed = e._isClosed, this._weights = e._weights.slice(0), this._controlPoints = e._controlPoints.slice(0), this._isPlanarXY = e._isPlanarXY, this._hasDirtySegments = !0, this._tessellationCache.reset();}, m.prototype.set = function (e, t, r, o) {this.dirtyCurveRepresentation(), this._weights = Array.prototype.slice.call(t), this._degree = r;var i = 0;if (this._isRational = !1, this._weights.length !== t.length) {this._weights = Array.prototype.slice.call(t);var s = this._weights[0];for (i = 1; i < this._weights.length; ++i) {if (Math.abs(this._weights[i] - s) > n.FLOAT64_TOLERANCE) {this._isRational = !0;break;}}} else for (s = this._weights[0], i = 1; i < this._weights.length; ++i) {this._weights[i] = t[i], Math.abs(this._weights[i] - s) > n.FLOAT64_TOLERANCE && (this._isRational = !0);}if (this._knots.length !== o.length) this._knots = Array.prototype.slice.call(o);else for (i = 0; i < this._knots.length; ++i) {this._knots[i] = o[i];}var a = e.length / 3;if (0 === this._weights.length) for (this._weights = new Array(a), i = 0; i < a; ++i) {this._weights[i] = 1;}if (this._controlPoints.length !== e.length) this._controlPoints = Array.prototype.slice.call(e);else for (i = 0; i < e.length; ++i) {this._controlPoints[i] = e[i];}this._isDirtyControlPoint.length !== a && (this._isDirtyControlPoint = new Array(a)), this._isDirtyControlPoint.fill(!1);}, m.prototype.dirtyCurveRepresentation = function () {this._isPlanarXY = void 0, this._isRational = void 0, this._isClosed = void 0, this._isPeriodic = void 0, this._discretizationCache = void 0, this._hasDirtySegments = !0, this._tessellationCache.setDirty(!0);}, m.prototype.hasDirtyTessellation = function () {return this._tessellationCache.isDirty();}, m.prototype.getTessellationCacheTolerance = function () {return this._tessellationCache.getTolerance();}, m.prototype.weightedControlPoints = function () {for (var e = [], t = 0; t < this._controlPoints.length / 3; ++t) {var r = this._weights[t];e.push(this._controlPoints[3 * t] * r, this._controlPoints[3 * t + 1] * r, this._controlPoints[3 * t + 2] * r, r);}return e;}, m.prototype.getControlPoints = function () {return this._controlPoints;}, m.prototype._findChangedControlPoints = function (e) {var t = e.length === this._controlPoints.length;t || (this._isDirtyControlPoint = new Array(e.length / 3), this._isDirtyControlPoint.fill(!0));for (var r = 0; r < e.length / 3; ++r) {if (t) {var n = e[3 * r] - this._controlPoints[3 * r],o = e[3 * r + 1] - this._controlPoints[3 * r + 1],i = e[3 * r + 2] - this._controlPoints[3 * r + 2];n * n + o * o + i * i > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE && (this._isDirtyControlPoint[r] = !0);} else this._isDirtyControlPoint[r] = !0;}}, m.prototype.setControlPoints = function (e) {this._findChangedControlPoints(e), this._controlPoints = e, this.dirtyCurveRepresentation();}, m.prototype.copyControlPoints = function (e) {if (this._findChangedControlPoints(e), e !== this._controlPoints) {this._controlPoints.length = e.length;for (var t = 0; t < e.length; ++t) {this._controlPoints[t] = e[t];}}this.dirtyCurveRepresentation();}, m.prototype.transform = function (e) {for (var t = [], r = n.Vector3.createFloat64(), o = 0; o < this._controlPoints.length; o += 3) {n.Vector3.set(r, this._controlPoints[o], this._controlPoints[o + 1], this._controlPoints[o + 2]), n.Vector3.transformMatrix44(r, r, e), t.push(r[0], r[1], r[2]);}this.setControlPoints(t);}, m.prototype.getControlPointPosition = function (e) {return n.Vector3.createFloat64FromValues(this._controlPoints[3 * e], this._controlPoints[3 * e + 1], this._controlPoints[3 * e + 2]);}, m.prototype.extendBBoxFromControlPoints = function (e) {for (var t = n.Vector3.createFloat64(), r = 0; r < this._controlPoints.length; r += 3) {n.Vector3.set(t, this._controlPoints[r], this._controlPoints[r + 1], this._controlPoints[r + 2]), e.includePoint(t);}}, m.prototype.setControlPointPosition = function (e, t, r, n) {this._controlPoints[3 * e] = t, this._controlPoints[3 * e + 1] = r, this._controlPoints[3 * e + 2] = n, this._isDirtyControlPoint[e] = !0, this.dirtyCurveRepresentation();}, m.prototype.getWeights = function () {return this._weights;}, m.prototype.setWeights = function (e) {this._weights = e, this.dirtyCurveRepresentation();}, m.prototype.getKnotVector = function () {return this._knots;}, m.prototype.setKnotVector = function (e) {this._knots = e, this.dirtyCurveRepresentation();}, m.prototype.getDegree = function () {return this._degree;}, m.prototype.isRational = function () {if (void 0 === this._isRational && (this._isRational = !1, this._weights)) for (var e = this._weights[0], t = 0; t < this._weights.length; ++t) {if (Math.abs(this._weights[t] - e) > n.FLOAT64_TOLERANCE) return this._isRational = !0, !0;}return this._isRational;}, m.prototype.isSimpleBezier = function () {return this._knots.length === 2 * this._degree + 2;}, m.prototype.getNumControlPoints = function () {return this._controlPoints.length / 3;}, m.prototype.getTessellationCache = function () {return this._tessellationCache.getCache();}, m.prototype.getEvaluationCache = function () {return void 0 === this._discretizationCache && this.evaluate(), this._discretizationCache;}, m.prototype.getRangeUnlimited = function () {return [this._knots[0], this._knots[this._knots.length - 1]];}, m.prototype.isPeriodicUnlimited = function () {return this._checkClosure(), this._isPeriodic;}, m.prototype.isClosedUnlimited = function () {return this._checkClosure(), this._isClosed;}, m.prototype._checkClosure = function () {if (void 0 === this._isClosed || void 0 === this._isPeriodic) {this._isClosed = this._isPeriodic = !1;var e = this.getRangeUnlimited(),t = this.evaluatePosition(e[0]),r = this.evaluatePosition(e[1]);if (n.Vector3.equals(t, r, s.KERNEL_TOLERANCE)) {this._isClosed = !0;var o = this.evaluateDt(e[0]),i = this.evaluateDt(e[1]);n.Vector3.isParallel(o, i, 1, s.KERNEL_ANGULAR_TOLERANCE) && (this._isPeriodic = !0);}}}, m.prototype.getBezierSegments = function () {return this._decomposeCurve(), this.isSimpleBezier() ? [this] : this._segments;}, m.prototype.isPlanarXY = function () {if (void 0 === this._isPlanarXY) {var e = s.SPLINE_DISTANCE_TOLERANCE;this._isPlanarXY = !0;for (var t = 1 / 0, r = -1 / 0, n = 2; n < this._controlPoints.length; n += 3) {t = Math.min(t, this._controlPoints[n]), r = Math.max(r, this._controlPoints[n]);}Math.abs(r - t) > 2 * e && (this._isPlanarXY = !1);}return this._isPlanarXY;}, m.prototype.getBezierSegmentsInRange = function (e, t) {for (var r = this.getBezierSegments(), n = e || this._knots[0], o = t || this._knots[this._knots.length - 1], i = [], s = 0; s < r.length; ++s) {var a = r[s].getKnotVector();n <= a[a.length - 1] && a[0] >= o && i.push(r[s]);}return i;}, m.prototype.getApproxParameterSpaceTolerance = function () {if (12 === this.getControlPoints().length) return p.SplineCurveHelper.getApproxBezierParameterSpaceTolerance(this.getBoundingBox(), s.KERNEL_TOLERANCE);this._decomposeCurve();for (var e = 0, t = 0; t < this._segments.size(); ++t) {e += p.SplineCurveHelper.getApproxBezierParameterSpaceTolerance(this._segments[t].getBoundingBox(), s.KERNEL_TOLERANCE);}return e;}, m.prototype.getArcLength = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());for (var t = this._restrictRangeToUnlimited(e), r = 0, o = this.getBezierSegments(), i = 0; i < o.length; ++i) {for (var a = o[i], c = a.getRangeUnlimited(), u = 0; u < t.length; ++u) {var h = [Math.max(c[0], t[u][0]), Math.min(c[1], t[u][1])];h[1] - h[0] > s.PARAMETER_SPACE_TOLERANCE && (r += (0, l.integrateFunction1D)(function (e) {return n.Vector3.length(a.evaluateDt(e));}, h));}}return r;}, m.prototype.getParameterFromArcLength = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = this;return (0, l.invertIntegral1D)(function (e) {return n.Vector3.length(r.evaluateDt(e));}, e, t);}, m.prototype._decomposeCurve = function () {if (this._hasDirtySegments) if (this._hasDirtySegments = !1, this.isSimpleBezier()) this._segments = void 0;else {var e;this._isDirtyControlPoint.length === this.getNumControlPoints() ? e = (0, _.decomposeBCurveFlags)(this.getKnotVector(), this._isDirtyControlPoint) : (this._isDirtyControlPoint = new Array(this.getNumControlPoints()), (e = new Array(this.getNumControlPoints())).fill(!0)), this._isDirtyControlPoint.fill(!1);var t = (0, _.decomposeBCurveToBezier)(this._knots, this._controlPoints, this.isRational() ? this._weights : void 0);this._segments && this._segments.length === t.P.length || (this._segments = []);for (var r = 0; r < t.P.length; ++r) {void 0 === this._segments[r] && (this._segments[r] = new m(), e[r] = !0), e[r] && this._segments[r].set(t.P[r], t.w ? t.w[r] : new Array(2 * this._degree + 2).fill(1), this._degree, t.U[r]);}}}, m.prototype.evaluatePosition = function (e) {this.isPeriodicUnlimited() && (e = (0, u.normalizeParameterToShiftedRange)(e, [this._knots[0], this._knots[this._knots.length - 1]]));var t = this.isRational() ? this._weights : void 0;return (0, v.evaluateBCurvePoint)(e, this._degree, this._knots, this._controlPoints, t);}, m.prototype.evaluateDt = function (e) {this.isPeriodicUnlimited() && (e = (0, u.normalizeParameterToShiftedRange)(e, [this._knots[0], this._knots[this._knots.length - 1]]));var t = this.isRational() ? this._weights : void 0;return (0, v.evaluateBCurveDerivs)(e, 1, this._degree, this._knots, this._controlPoints, t)[1];}, m.prototype.closestToRayParam = function (e, t, r, o) {if (!(this._controlPoints.length < 9)) {if (this.isPlanarXY()) {var i = t[2],a = n.Vector3.createFloat64();if (Math.abs(i) < s.KERNEL_ANGULAR_TOLERANCE) n.Vector3.copy(a, e);else {var c = (this._controlPoints[2] - e[2]) / i;n.Vector3.add(a, n.Vector3.scale(a, t, c), e);}return this.closestToPointParam(a);}d.DebugUtils.warn("BCurve.closestToRayParam() only defined for planar curves");}}, m.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());for (var r = this._restrictRangeToUnlimited(t), o = n.FLOAT64_TOLERANCE, i = this.getBezierSegments(), s = (0, y.closestBCurveSegments)(e, i, void 0, r), a = Number.POSITIVE_INFINITY, c = void 0, l = 0; l < s.length; ++l) {if (!(s[l].minDistSqr > a)) for (var h = i[s[l].index], d = h.getRangeUnlimited(), g = 0; g < r.length; ++g) {var p = [Math.max(d[0], r[g][0]), Math.min(d[1], r[g][1])];if (!(p[1] - p[0] <= n.FLOAT64_TOLERANCE)) {var f = h.getEvaluationCache(),v = (0, u.closestPointToPolyline)(e, f.points, f.offset, p),_ = (0, y.relaxBCurveToPerpendicular)(this._knots, this._controlPoints, this.isRational() ? this._weights : void 0, e, v, p, o, 32),m = h.evaluatePosition(_),E = n.Vector3.squaredDistance(m, e);E < a && (a = E, c = _);var x = h.evaluatePosition(p[0]),R = n.Vector3.squaredDistance(x, e);R < a && (a = R, c = p[0]);var A = h.evaluatePosition(p[1]),P = n.Vector3.squaredDistance(A, e);P < a && (a = P, c = p[1]);}}}return this.isPeriodicUnlimited() && (c = (0, u.foldNearTo)(c, .5 * (t[0] + t[1]), this.getPeriodUnlimited())), c;}, m.prototype.evaluate = function () {var e = this.getBezierSegments();if (e[0] === this) void 0 === this._discretizationCache && (this._discretizationCache = p.SplineCurveHelper.evaluateCurve(this.getDegree(), this.getKnotVector(), this.getControlPoints(), this.getWeights(), !0));else for (var t = 0; t < e.length; ++t) {var r = e[t];void 0 === r._discretizationCache && (r._discretizationCache = p.SplineCurveHelper.evaluateCurve(r.getDegree(), r.getKnotVector(), r.getControlPoints(), r.getWeights(), !0));}}, m.prototype._getFullTessellation = function (e) {var t,r,o = this.getBezierSegments(),i = 0,s = !1;if (o[0] === this) {s = !0;var a = g.CurveTessellator.getAdaptiveRenderPoints(this, e, this.getRangeUnlimited());t = a.positions, r = a.params, i = Math.max(i, a.tolerance);} else {t = [], r = [];for (var c = 0; c < o.length; ++c) {var u = o[c];if (u.hasDirtyTessellation() || u.getTessellationCacheTolerance() > e + n.FLOAT64_TOLERANCE) {s = !0;var l = g.CurveTessellator.getAdaptiveRenderPoints(u, e, u.getRangeUnlimited());u._tessellationCache.setCache(l), i = Math.max(i, l.tolerance);}u._tessellationCache && (0 === c ? (t.push.apply(t, u._tessellationCache.getCache().positions), r.push.apply(r, u._tessellationCache.getCache().params)) : (t.push.apply(t, u._tessellationCache.getCache().positions.slice(1)), r.push.apply(r, u._tessellationCache.getCache().params.slice(1))));}}return { positions: t, params: r, didRetessellate: s, tolerance: i };}, m.prototype.tessellate = function (e, t) {return t = t || s.TESSELLATION.LINEAR_PRECISION, this._tessellationCache.getTessellation(e, this, t, this._getFullTessellation.bind(this));}, m.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this._restrictRangeToUnlimited(e),r = new o.BoundingBox(),n = this.getRangeUnlimited();if (t[0][0] < n[0] + s.PARAMETER_SPACE_TOLERANCE && t[0][1] > n[1] - s.PARAMETER_SPACE_TOLERANCE) this.extendBBoxFromControlPoints(r);else for (var i = this.getBezierSegments(), a = 0; a < t.length; a++) {for (var c = 0; c < i.length; c++) {var u = i[c];(u = u._getSubset(t[a][0], t[a][1])) && u.extendBBoxFromControlPoints(r);}}return r;}, m.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this.evaluatePosition(e[0]),r = this.evaluatePosition(e[1]);n.Vector3.sub(r, r, t), n.Vector3.squaredLength(r) < .01 * s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE && (r = this.evaluateDt(.5 * (e[0] + e[1]))), n.Vector3.normalize(r, r);for (var o = new i.TangentCone(r, 0), a = this._restrictRangeToUnlimited(e), c = n.Vector3.createFloat64FromValues(0, 0, 0), u = this.getBezierSegments(), l = 0; l < a.length; l++) {for (var h = 0; h < u.length; h++) {var d = u[h];if (d = d._getSubset(a[l][0], a[l][1])) for (var g = d._controlPoints, p = 0; p < g.length - 3; p += 3) {c[0] = g[p + 3] - g[p], c[1] = g[p + 4] - g[p + 1], c[2] = g[p + 5] - g[p + 2], n.Vector3.dot(c, r) >= 0 ? o.includeVector(c) : o.angle = Math.PI;}}}return o;}, m.prototype._getSubset = function (e, t) {var r;if (this.isPeriodicUnlimited()) return t - e > this.getPeriodUnlimited() - s.PARAMETER_SPACE_TOLERANCE ? this : ((r = this.clone())._periodicTrimToParams(e, t), r);var n = this.getRangeUnlimited();return e > n[1] - s.PARAMETER_SPACE_TOLERANCE || t < n[0] + s.PARAMETER_SPACE_TOLERANCE ? void 0 : e < n[0] + s.PARAMETER_SPACE_TOLERANCE && t > n[1] - s.PARAMETER_SPACE_TOLERANCE ? this : (r = this.clone(), e > n[0] + s.PARAMETER_SPACE_TOLERANCE && r.trimToParam(!0, e), t < n[1] - s.PARAMETER_SPACE_TOLERANCE && r.trimToParam(!1, t), r);}, m.prototype._periodicTrimToParams = function (e, t) {h.ConsoleUtils.assert(this._isPeriodic);var r = this.getRangeUnlimited(),n = (0, u.normalizeParametricRangeToShiftedRange)([e, t], r);if (n[1] > r[1]) this._isClosed = this._isPeriodic = !1, this.trimToParam(!0, n[1] - (r[1] - r[0]), void 0), this.trimToParam(!1, n[0], void 0);else {var o,i,s = this.getControlPoints(),a = this.getKnotVector(),c = this.getWeights(),l = this.getDegree(),d = this.getPeriodUnlimited(),g = [],f = a.slice(),v = a.slice(),_ = [];for (i = 0; i < s.length / 3; ++i) {g[4 * i + 0] = s[3 * i + 0] * c[i], g[4 * i + 1] = s[3 * i + 1] * c[i], g[4 * i + 2] = s[3 * i + 2] * c[i], g[4 * i + 3] = c[i];}for (o = g.slice(), p.SplineCurveHelper.extractCurveSegment(l, n[1], r[1], f, g), p.SplineCurveHelper.extractCurveSegment(l, r[0], n[0], v, o), i = 0; i < v.length; ++i) {v[i] = v[i] + d;}p.SplineCurveHelper.joinCurves(l, f, g, v, o);var y = g.length / 4,m = [];for (_.length = y, m.length = 3 * y, i = 0; i < y; ++i) {var E = g[4 * i + 3];m[3 * i] = g[4 * i] / E, m[3 * i + 1] = g[4 * i + 1] / E, m[3 * i + 2] = g[4 * i + 2] / E, _[i] = E;}this.set(m, _, l, f), this._isClosed = this._isPeriodic = !1;}}, m.prototype.trimToParam = function (e, t, r) {if (this.isPeriodicUnlimited()) return h.ConsoleUtils.assert(void 0 !== r), void this._periodicTrimToParams(t, r);var n,o,i = this.getControlPoints(),s = this.getKnotVector(),a = this.getWeights(),c = this.getDegree(),u = [];for (n = 0; n < i.length / 3; ++n) {u[4 * n + 0] = i[3 * n + 0] * a[n], u[4 * n + 1] = i[3 * n + 1] * a[n], u[4 * n + 2] = i[3 * n + 2] * a[n], u[4 * n + 3] = a[n];}var l = [],d = 0,g = p.SplineCurveHelper.insertKnot(c, s, u, t, c),v = (0, f.findKnotSpan)(t, g.U);for (e ? (g.U.splice(0, v - c + 1, t), o = g.U.length - c - 1, d = 4 * (g.Pw.length / 4 - o)) : (g.U.splice(v + 1, g.U.length, t), o = g.U.length - c - 1), u.length = 3 * o, l.length = o, n = 0; n < o; ++n) {var _ = g.Pw[4 * n + 3 + d];u[3 * n] = g.Pw[4 * n + 0 + d] / _, u[3 * n + 1] = g.Pw[4 * n + 1 + d] / _, u[3 * n + 2] = g.Pw[4 * n + 2 + d] / _, l[n] = _;}this.set(u, l, c, g.U);}, m.prototype.addControlPoint = function (e, t) {var r = this.getControlPoints(),o = this.getNumControlPoints(),i = this.getKnotVector(),a = this.getWeights(),u = this.getDegree(),l = this.getControlPointPosition(e),h = this.getControlPointPosition(e + 1),d = new c.Line();d.setFromEndpoints(l, h);var g = d.closestToPointParam(t),f = d.evaluatePosition(g),v = n.Vector3.distance(f, l),_ = n.Vector3.distance(f, h),y = a[e] * v + a[e + 1] * _;if (Math.abs(y) < s.KERNEL_TOLERANCE) console.warn("numerical error in addControlPoints -- coincident control points / negative weights?");else {for (var m = a[e] * v / y, E = i[e + 1] + m * (i[e + u + 1] - i[e + 1]), x = [], R = 0; R < r.length / 3; ++R) {x[4 * R] = r[3 * R] * a[R], x[4 * R + 1] = r[3 * R + 1] * a[R], x[4 * R + 2] = r[3 * R + 2] * a[R], x[4 * R + 3] = a[R];}var A = p.SplineCurveHelper.findKnotMultiplicity(E, i),P = p.SplineCurveHelper.insertKnot(u, i, x, E, A + 1),V = [];for (x.length = 3 * (o + 1), V.length = o + 1, R = 0; R <= o; ++R) {var T = P.Pw[4 * R + 3];x[3 * R] = P.Pw[4 * R] / T, x[3 * R + 1] = P.Pw[4 * R + 1] / T, x[3 * R + 2] = P.Pw[4 * R + 2] / T, V[R] = T;}this.set(x, V, u, P.U);}}, m.prototype.addControlPointOnCurve = function (e) {for (var t = this.getNumControlPoints(), r = Number.MAX_VALUE, o = -1, i = n.Vector3.createFloat64FromValues(0, 0, 0), s = n.Vector3.createFloat64FromValues(0, 0, 0), a = 0; a < t - 1; ++a) {i[0] = this._controlPoints[3 * a + 0], i[1] = this._controlPoints[3 * a + 1], s[0] = this._controlPoints[3 * a + 3], s[1] = this._controlPoints[3 * a + 4];var c = (0, u.distancePointToLineSegment)(i, s, e);c < r && (r = c, o = a);}-1 !== o && this.addControlPoint(o, e);}, m.prototype.makePeriodic = function () {if (!this.isPeriodicUnlimited()) {for (var e = this.getControlPoints(), t = this.getKnotVector(), r = this.getWeights(), n = this.getDegree(), o = [], i = 0; i < e.length / 3; ++i) {o[4 * i] = e[3 * i] * r[i], o[4 * i + 1] = e[3 * i + 1] * r[i], o[4 * i + 2] = e[3 * i + 2] * r[i], o[4 * i + 3] = r[i];}var s = t.slice();p.SplineCurveHelper.makePeriodic(n, s, o);var a = [],c = [],u = o.length / 4;for (a.length = u, c.length = 3 * u, i = 0; i < u; ++i) {var l = o[4 * i + 3];c[3 * i] = o[4 * i] / l, c[3 * i + 1] = o[4 * i + 1] / l, c[3 * i + 2] = o[4 * i + 2] / l, a[i] = l;}this.set(c, a, n, s), this._isClosed = this._isPeriodic = !0;}}, m.prototype.suggestSplittingParam = function (e) {var t,r = this.getKnotVector(),n = .5 * (e[0] + e[1]),o = (0, u.sortedIndex)(r, n);if (0 === o) t = r[o];else if (o === r.length) t = r[o - 1];else {var i = r[o - 1],s = r[o];t = n - i < s - n ? i : s;}return t >= e[0] && t <= e[1] ? t : void 0;}, m.prototype.toObject = function () {return { degree: this._degree, knots: this._knots, controlPoints: this._controlPoints, weights: this._weights, range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.BCurve = m;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TangentCone = void 0;var n = r(1),o = r(0),i = r(3),s = function s(e, t) {this.set(e, t);};s.prototype.set = function (e, t) {void 0 === e || void 0 === t ? (this.axis = void 0, this.angle = void 0) : (this.axis = n.Vector3.clone(e), this.angle = t);}, s.prototype.toString = function () {return this.isDegenerate() ? "degenerate" : "(x:" + this.axis[0] + ", y:" + this.axis[1] + ", z:" + this.axis[2] + ", radians:" + this.angle + ")";}, s.prototype.copy = function (e) {return e.isDegenerate() ? (this.axis = void 0, this.angle = void 0) : (this.axis = n.Vector3.clone(e.axis), this.angle = e.angle), this;}, s.prototype.clone = function () {return new s(this.axis, this.angle);}, s.prototype.isDegenerate = function () {return void 0 === this.axis || void 0 === this.angle;}, s.prototype.includeVector = function (e) {if (n.Vector3.squaredLength(e) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return this;if (this.isDegenerate()) return this.axis || (this.axis = n.Vector3.createFloat64()), n.Vector3.normalize(this.axis, e), this.angle = 0, this;var t = n.Vector3.dot(this.axis, e) / n.Vector3.length(e);t = (0, i.clamp)(t, -1, 1);var r = Math.acos(t);return this.angle = Math.max(this.angle, r), this;}, s.prototype.includeCone = function (e) {if (e.isDegenerate()) return this;if (this.isDegenerate()) return this.copy(e);var t = n.Vector3.dot(this.axis, e.axis),r = Math.acos((0, i.clamp)(t, -1, 1));if (this.angle >= e.angle + r) return this;if (e.angle >= this.angle + r) return this.copy(e);if (r > Math.PI - o.KERNEL_ANGULAR_TOLERANCE) return this.angle = Math.PI, this;var s = (this.angle + e.angle + r) / 2;if (s >= Math.PI) return this.angle = Math.PI, this;var a = Math.sin(s - e.angle),c = Math.sin(s - this.angle);return n.Vector3.scale(this.axis, this.axis, a), n.Vector3.scaleAndAdd(this.axis, this.axis, e.axis, c), n.Vector3.normalize(this.axis, this.axis), this.angle = s, this;}, s.prototype.contains = function (e, t) {if (t = "number" == typeof t ? t : o.KERNEL_ANGULAR_TOLERANCE, !this.isDegenerate()) return n.Vector3.squaredLength(e) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE || n.Vector3.angle(this.axis, e) < this.angle + t;}, t.TangentCone = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.invertIntegral1D = t.integrateFunction1D = t.newtonRaphson1D = void 0;var n = r(0),o = r(3),i = r(8),s = function () {var e = [.9914553711208126, .9491079123427585, .8648644233597691, .7415311855993945, .5860872354676911, .4058451513773972, .20778495500789848, 0],t = [.022935322010529224, .06309209262997856, .10479001032225019, .14065325971552592, .1690047266392679, .19035057806478542, .20443294007529889, .20948214108472782],r = [.1294849661688697, .27970539148927664, .3818300505051189, .4179591836734694];return function (o, a, c) {var u = function (n, o, i) {for (var s = .5 * (o + i), a = .5 * (i - o), c = n(s), u = c * t[7], l = c * r[3], h = 0; h < 7; ++h) {var d = a * e[h],g = n(s - d) + n(s + d);u += g * t[h], h % 2 == 1 && (l += g * r[Math.floor(h / 2)]);}var p = 200 * Math.abs(u - l) * a;return { length: u * a, error: p *= Math.sqrt(p) };}(o, a[0], a[1]);if (void 0 === c) c = 0;else if (c > 8) return i.DebugUtils.warn("Max depth reached in integrateFunction1D!"), u.length;if (u.error > n.KERNEL_TOLERANCE) {var l = .5 * (a[0] + a[1]);return s(o, [a[0], l], c + 1) + s(o, [l, a[1]], c + 1);}return u.length;};}();t.newtonRaphson1D = function (e, t, r, n, s) {var a,c = r;t && (c = (0, o.clamp)(c, t[0], t[1]));var u = 0;do {++u;var l = e(c),h = c - l.val / l.deriv;t && (h = (0, o.clamp)(h, t[0], t[1])), a = Math.abs(h - c), c = h;} while (a > n && u < s);return u >= s && i.DebugUtils.warn("Maximum number of iterations reached. Something wrong is going on here !!!"), c;}, t.integrateFunction1D = s, t.invertIntegral1D = function (e, t, r) {var i = n.KERNEL_TOLERANCE,a = s(e, r);if (t < i) return r[0];if (t > a - i) return r[1];for (var c = r[0], u = r[1], l = t; u - c > n.PARAMETER_SPACE_TOLERANCE;) {var h = l / a,d = c + (h = (0, o.clamp)(h, .01, .99)) * (u - c),g = s(e, [c, d]),p = a - (g = (0, o.clamp)(g, 0, a));if (Math.abs(l - g) < i) return d;g > l ? (u = d, a = g) : (c = d, l -= g, a = p);}return .5 * (c + u);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SplineCurveHelper = void 0;var n = r(1),o = r(0),i = r(3),s = r(8),a = r(17),c = r(37),u = r(72),l = function l() {};l.getApproxBezierParameterSpaceTolerance = function (e, t) {var r = e.getDiagonal(),i = 2 * t / n.Vector3.length(r);return i < .01 * o.PARAMETER_SPACE_TOLERANCE ? .01 * o.PARAMETER_SPACE_TOLERANCE : i;}, l.solve_cubic_uniqueRoots = function (e, t) {var r = e[2] * e[2] - 3 * e[1],n = e[2] * (2 * e[2] * e[2] - 9 * e[1]) + 27 * e[0];if (0 === n && 0 === r) return t[0] = -e[2] / 3, 1;if (n * n / 4 < r * r * r) {var o = -2 * Math.sqrt(r),i = Math.acos(-n / (r * o));return t[0] = (o * Math.cos(i / 3) - e[2]) / 3, t[1] = (o * Math.cos((i + 2 * Math.PI) / 3) - e[2]) / 3, t[2] = (o * Math.cos((i - 2 * Math.PI) / 3) - e[2]) / 3, 3;}var s = Math.pow(Math.abs(n) / 2 + Math.sqrt(n * n / 4 - r * r * r), 1 / 3) / 3;return n > 0 && (s = -s), t[0] = s + r / (9 * s) - e[2] / 3, 1;};var h = function h(e, t, r) {return 6 * ((1 - r) * (e[6 + t] - 2 * e[3 + t] + e[t]) + r * (e[9 + t] - 2 * e[6 + t] + e[3 + t]));},d = function d(e, t) {return 6 * (e[9 + t] - e[t] + 3 * (e[3 + t] - e[6 + t]));},g = function g(e, t) {var r = new Array(3);!function (e, t, r) {r[0] = 3 * (e[3 + t] - e[t]), r[1] = 6 * (e[t] + e[6 + t] - 2 * e[3 + t]), r[2] = 3 * (e[9 + t] - e[t] + 3 * (e[3 + t] - e[6 + t]));}(e, t, r);var n,o = new Array(2),i = function (e, t) {var r = e[1] * e[1] - 4 * e[2] * e[0];if (r < 0) return 0;if (0 === r) return t[0] = -.5 * e[1] / e[2], 1;var n = e[1] > 0 ? -.5 * (e[1] + Math.sqrt(r)) : -.5 * (e[1] - Math.sqrt(r));return t[0] = n / e[2], t[1] = e[0] / n, 2;}(r, o);2 === i && o[0] > o[1] && (n = o[0], o[0] = o[1], o[1] = n);for (var s = [], a = 0; a < i; a++) {o[a] > 0 && o[a] < 1 && ((n = Math.abs(h(e, t, o[a])) < 1e-12) ? (n = Math.abs(d(e, t)) < 1e-12) && s.push(o[a]) : s.push(o[a]));}return s;},p = function p(e, t, r) {return e + t[0] + t[1] * r + t[2] * r * r + t[3] * r * r * r;};l.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D = function (e, t, r, n) {var i = new Float64Array(4),s = new Float64Array(4);i[0] = t[0] - e[0], i[1] = 3 * (t[3] - t[0]), i[2] = 3 * (t[0] + t[6] - 2 * t[3]), i[3] = t[9] - t[0] + 3 * (t[3] - t[6]), s[0] = t[1] - e[1], s[1] = 3 * (t[4] - t[1]), s[2] = 3 * (t[1] + t[7] - 2 * t[4]), s[3] = t[10] - t[1] + 3 * (t[4] - t[7]);var a,c = s;if (Math.abs(c[3]) > 1e-4) c[0] /= c[3], c[1] /= c[3], c[2] /= c[3], c[3] = 1, a = this.solve_cubic_uniqueRoots(c, r);else {var l = [].slice.call(c).reverse();0 === l[0] && (l = l.slice(1));var h = (0, u.getRealPolynomialRoots)(l);a = h.length;for (var d = 0; d < a; d++) {r[d] = h[d];}}if (1 === a) return (f = r[0]) < 0 || f > 1 ? 0 : (r[0] = p(e[0], i, f), 1);d = 0;for (var g = 0; g < a; ++g) {(f = r[g]) >= 0 && f <= 1 && (r[d] = p(e[0], i, f), ++d);}if (void 0 !== n) {var f, v;if (Math.abs(s[3]) < 1e-12) Math.abs(s[2]) < 1e-12 ? v = -1 : (f = -s[1] / (2 * s[2]), v = 0);else {var _ = 2 / 3 * s[2] / s[3];v = _ * _ / 4 - 1 / 3 * s[1] / s[3], f = -_ / 2;}if (0 === v) {if (f < 0 || f > 1) {var y = p(e[0], s, 0),m = p(e[0], s, 1);Math.abs(y) > Math.abs(m) ? n.push([p(e[0], i, 0), y]) : n.push([p(e[0], i, 1), m]);} else n.push([p(e[0], i, f), p(e[0], s, f)]);} else if (v > 0) {for (g = 0; g < 2; g++) {(f = -_ / 2 + (0 === g ? -1 : 1) * Math.sqrt(v)) < -o.PARAMETER_SPACE_TOLERANCE || f > 1 + o.PARAMETER_SPACE_TOLERANCE || (f = Math.max(Math.min(1, f), 0), n.push([p(e[0], i, f), p(e[0], s, f)]));}if (n.length > 1 && n[0][0] > n[1][0]) {var E = n[0];n[0] = n[1], n[1] = E;}}}return d;}, l.isPointInsideSplineRegionXYPlanar3D = function (e, t, r) {var o,s,a = new Float64Array(3),c = t.getBezierSegments();if (t.isRational() || !c || 3 !== t.getDegree()) {for (var u = t.tessellate().positions, l = new Float64Array(2 * u.length), h = 0; h < u.length; ++h) {l[2 * h] = u[h].x, l[2 * h + 1] = u[h].y;}return (0, i.isPointInsidePolygon2D)(e, l);}var d,g = 0,p = n.Vector3.createFloat64();for (h = 0; h < c.length; ++h) {s = c[h].getControlPoints(), o = this.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D(e, s, a);for (var f = 0; f < o; ++f) {n.Vector3.set(p, a[f], e[1], 0), (d = t.closestToPointParam(p)) >= r[0] && d <= r[1] && a[f] > e[0] && ++g;}}var v = t.evaluatePosition(r[0]),_ = t.evaluatePosition(r[1]),y = n.Vector3.createFloat64();n.Vector3.normalize(y, n.Vector3.sub(y, _, v)), y[1] < 0 && n.Vector3.negate(y, y);var m = n.Vector2.createFloat64FromValues(e[0], e[1]);return (0, i.signedDistanceTo2DLine)(v, y, m) <= 0 && e[1] >= Math.min(v[1], _[1]) && e[1] <= Math.max(v[1], _[1]) && ++g, 1 & g;}, l.insertKnot = function (e, t, r, n, o) {var i,s,c,u = [],l = [],h = [],d = r.length / 4,g = d + e + 1,p = (0, a.findKnotSpanAndMultiplicity)(n, t),f = o - p.multiplicity;if (f < 1) return { U: u = t.slice(), Pw: l = r.slice() };for (i = 0; i <= p.span; ++i) {u[i] = t[i];}for (i = 1; i <= f; ++i) {u[p.span + i] = n;}for (i = p.span + 1; i < g; ++i) {u[i + f] = t[i];}for (i = 0; i <= p.span - e; ++i) {for (s = 0; s < 4; ++s) {l[4 * i + s] = r[4 * i + s];}}for (i = p.span - p.multiplicity; i < d; ++i) {for (s = 0; s < 4; ++s) {l[4 * (i + f) + s] = r[4 * i + s];}}for (i = 0; i <= e - p.multiplicity; ++i) {for (s = 0; s < 4; ++s) {h[4 * i + s] = r[4 * (p.span - e + i) + s];}}for (var v = 1; v <= f; ++v) {for (c = p.span - e + v, i = 0; i <= e - v - p.multiplicity; ++i) {var _ = (n - t[c + i]) / (t[i + p.span + 1] - t[c + i]);for (s = 0; s < 4; ++s) {h[4 * i + s] = h[4 * (i + 1) + s] * _ + h[4 * i + s] * (1 - _);}}for (s = 0; s < 4; ++s) {l[4 * c + s] = h[s], l[4 * (p.span + f - v - p.multiplicity) + s] = h[4 * (e - v - p.multiplicity) + s];}}for (i = c + 1; i < p.span - p.multiplicity; ++i) {for (s = 0; s < 4; ++s) {l[4 * i + s] = h[4 * (i - c) + s];}}return { U: u, Pw: l };}, l.refineKnotVector = function (e, t, r, n) {var i,s,c = [],u = [],l = r.length / 4 - 1,h = n.length - 1,d = l + e + 1,g = (0, a.findKnotSpan)(n[0], t),p = (0, a.findKnotSpan)(n[h], t) + 1;for (i = 0; i <= g - e; ++i) {for (s = 0; s < 4; ++s) {u[4 * i + s] = r[4 * i + s];}}for (i = p - 1; i <= l; ++i) {for (s = 0; s < 4; ++s) {u[4 * (i + h + 1) + s] = r[4 * i + s];}}for (i = 0; i <= g; ++i) {c[i] = t[i];}for (i = p + e; i <= d; ++i) {c[i + h + 1] = t[i];}var f = p + e - 1,v = p + e + h;for (i = h; i >= 0; --i) {for (; n[i] <= t[f] && f > g;) {for (s = 0; s < 4; ++s) {u[4 * (v - e - 1) + s] = r[4 * (f - e - 1) + s];}c[v] = t[f], --v, --f;}for (s = 0; s < 4; ++s) {u[4 * (v - e - 1) + 1] = u[4 * (v - e) + s];}for (var _ = 1; _ <= e; ++_) {var y = v - e + _,m = c[v + _] - n[i];if (Math.abs(m) < o.KERNEL_TOLERANCE) for (s = 0; s < 4; ++s) {u[4 * (y - 1) + s] = u[4 * y + s];} else for (m /= c[v + _] - t[f - e + _], s = 0; s < 4; ++s) {u[4 * (y - 1) + s] = u[4 * (y - 1) + s] * m + u[4 * y + s] * (1 - m);}}c[v] = n[i], --v;}return { U: c, Pw: u };};var f = function f(e, t, r, o) {var s = (0, i.projectPointToLineSegment)(t, r, e);return o && (s = (0, i.clamp)(s, 0, 1)), n.Vector3.lerp(n.Vector3.createFloat64(), t, r, s);};l.validControlPolygon = function (e) {for (var t = e.length / 3, r = e.length, o = n.Vector3.createFloat64(), i = n.Vector3.createFloat64(), s = n.Vector3.createFloat64(), a = 3, c = 1; c < t - 1; ++c) {n.Vector3.set(o, e[a], e[a + 1], e[a + 2]), n.Vector3.set(i, e[a - 3], e[a - 2], e[a - 1]), n.Vector3.set(s, e[a + 3], e[a + 4], e[a + 5]);var u = f(o, i, s, !1);if (n.Vector3.sub(o, o, u), c < t / 2 ? n.Vector3.sub(i, [e[r - 3], e[r - 2], e[r - 1]], u) : n.Vector3.sub(i, [e[0], e[1], e[2]], u), n.Vector3.dot(o, i) > 0) return !1;a += 3;}return !0;};var v = function v(e) {if (e) for (var t = 0; t < e.length; ++t) {if (Math.abs(e[t] - 1) > n.FLOAT64_TOLERANCE) return !0;}return !1;},_ = function () {var e = new Float64Array(4),t = new Float64Array(4),r = new Float64Array(4),n = new Float64Array(16);return function (o, i, s, a, c) {var u,l,h,d,g,p,f = 1 - s;if (e[0] = f * f * f, e[1] = 3 * s * f * f, e[2] = 3 * s * s * f, e[3] = s * s * s, t[0] = -3 * f * f, t[1] = 3 * (s - 1) * (3 * s - 1), t[2] = 3 * s * (2 - 3 * s), t[3] = 3 * s * s, r[0] = 6 * f, r[1] = 6 * (3 * s - 2), r[2] = 6 * (1 - 3 * s), r[3] = 6 * s, void 0 === c ? v(i) : c) {for (var _ = 0; _ < 4; ++_) {n[4 * _ + a] = o[3 * _ + a] * i[_], n[4 * _ + 3] = i[_];}for (u = n[a] * e[0], l = n[a] * t[0], h = n[a] * r[0], _ = 1; _ < 4; ++_) {u += n[4 * _ + a] * e[_], l += n[4 * _ + a] * t[_], h += n[4 * _ + a] * r[_];}for (d = n[3] * e[0], g = n[3] * t[0], p = n[3] * r[0], _ = 1; _ < 4; ++_) {d += n[4 * _ + 3] * e[_], g += n[4 * _ + 3] * t[_], p += n[4 * _ + 3] * r[_];}u /= d, l /= g, h /= p;} else for (u = o[a] * e[0], l = o[a] * t[0], h = o[a] * r[0], _ = 1; _ < 4; ++_) {u += o[3 * _ + a] * e[_], l += o[3 * _ + a] * t[_], h += o[3 * _ + a] * r[_];}return [u, l, h];};}(),y = function y(e, t, r, n) {var o = n;o[0] = r[0] - t[0], o[1] = r[1] - t[1];var i = o[0] * o[0] + o[1] * o[1],s = (e[0] - t[0]) * o[0] + (e[1] - t[1]) * o[1];if (0 === i || s <= 0) n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = 0;else if (s > i) n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = 1;else {var a = s / i;n[0] = t[0] + a * o[0] - e[0], n[1] = t[1] + a * o[1] - e[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = a;}},m = function m(e, t, r, n) {var o = n;o[0] = r[0] - t[0], o[1] = r[1] - t[1], o[2] = r[2] - t[2];var i = o[0] * o[0] + o[1] * o[1] + o[2] * o[2],s = (e[0] - t[0]) * o[0] + (e[1] - t[1]) * o[1] + (e[2] - t[2]) * o[2];if (0 === i || s <= 0) n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[1] * n[1], n[0] = 0;else if (s > i) n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[2] = e[2] - r[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[1] * n[1], n[0] = 1;else {var a = s / i;n[0] = t[0] + a * o[0] - e[0], n[1] = t[1] + a * o[1] - e[1], n[2] = t[2] + a * o[2] - e[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[2] * n[2], n[0] = a;}};l.closestStartPoint = function () {var e,t,r,n,o = new Float64Array(3),i = new Float64Array(3),s = new Float64Array(3),a = new Float64Array(2);return function (c, u, l, h) {if (l) for (a[0] = 0, a[1] = 1 / 0, r = u.points.length, n = 0; n < r - 3; n += 3) {o[0] = u.points[n], o[1] = u.points[n + 1], i[0] = u.points[n + 3], i[1] = u.points[n + 4], y(c, o, i, s), s[1] < a[1] && (e = n / 3, t = (1 - s[0]) * u.offset[e] + s[0] * u.offset[e + 1], (!h || t >= h[0] && t <= h[1]) && (a[0] = t, a[1] = s[1]));} else for (a[1] = 1 / 0, r = u.points.length, n = 0; n < r - 3; n += 3) {o[0] = u.points[n], o[1] = u.points[n + 1], o[2] = u.points[n + 2], i[0] = u.points[n + 3], i[1] = u.points[n + 4], i[2] = u.points[n + 5], m(c, o, i, s), s[1] < a[1] && (e = n / 3, t = (1 - s[0]) * u.offset[e] + s[0] * u.offset[e + 1], (!h || t >= h[0] && t <= h[1]) && (a[0] = t, a[1] = s[1]));}return a[0];};}(), l.extremalParams = function (e, t) {if (3 !== e.getDegree()) return s.DebugUtils.warn("SplineCurveHelper.extremalParams called with non-degree 3 curve"), [];var r,i,a = e.getBezierSegments(),c = [];for (r = 0; r < a.length; ++r) {var u = a[r].getControlPoints(),h = a[r].getWeights(),d = a[r].getKnotVector(),g = l.extremalParamsXYPlanarBezierCurve(u, h, t),p = [];for (i = 0; i < g.length; i++) {p.push(d[0] * (1 - g[i]) + d[d.length - 1] * g[i]);}c.push(p);}var f = [];for (r = 0; r < a.length; ++r) {if (f = f.concat(c[r]), r < a.length - 1 || e.isPeriodicUnlimited()) {var v = a[r],_ = a[(r + 1) % a.length],y = c[r],m = c[(r + 1) % a.length],E = v.getRangeUnlimited()[1],x = _.getRangeUnlimited()[0],R = 0 === y.length || E - y[y.length - 1] > o.PARAMETER_SPACE_TOLERANCE,A = 0 === m.length || m[0] - x > o.PARAMETER_SPACE_TOLERANCE;if (R && A) {var P = v.evaluateDt(E)[t],V = _.evaluateDt(x)[t];(Math.abs(P) < n.FLOAT64_TOLERANCE || Math.abs(V) < n.FLOAT64_TOLERANCE || Math.sign(P) !== Math.sign(V)) && f.push(E);}}}return f;}, l.extremalParamsXYPlanarBezierCurve = function (e, t, r, n, o) {var i = v(t);if (!i) return g(e, r);for (var s, a, c = n || 16, u = o || 1e-12, l = [], h = void 0, d = 0; d < 8; d++) {if (a = _(e, t, d / 7, r, i), void 0 !== h && Math.sign(a[1]) !== h) {var p = (d - 1 + Math.abs(s) / (Math.abs(a[1]) + Math.abs(s))) / 7;l.push(p);}h = Math.sign(a[1]), s = a[1];}0 === l.length && (l[0] = 0 + u, l[1] = 1 - u), l.length > 2 && console.error("More than two roots in the second derivative of a cubic polynomial. This should not happen.");var f,y,m,E = [],x = [];for (d = 0; d < l.length; d++) {var R = 0;do {++R, m = 0 !== (a = _(e, t, l[d], r, i))[2] ? l[d] - a[1] / a[2] : l[d], f = Math.abs(a[1]), y = Math.abs(l[d] - m), l[d] = m;} while ((f > u || y > 1e-6) && R < c);E[d] = f, x[d] = a[2];}for (d = 0; d < l.length; d++) {if (l[d] < 0 || l[d] > 1 || E[d] > u) l.splice(d, 1), d--;else if (Math.abs(x[d]) < 1e-6) {var A = (_(e, t, l[d] + 5e-7, r, i)[2] - _(e, t, l[d] - 5e-7, r, i)[2]) / 1e-6;Math.abs(A) > 1e-6 && (l.splice(d, 1), d--);}}if (2 === l.length) {if (Math.abs(l[0] - l[1]) < 1e-6) {var P = E[0] / (E[0] + E[1]);return [l[0] * (1 - P) + l[1] * P];}return l;}return l;}, l.evaluateNURBSCurvePointWithFactors = function (e, t, r, n, o, i) {var s,u,l,h = (0, a.findKnotSpan)(o, t),d = (0, c.evaluateBasisFunctions)(h, o, e, t),g = new Float64Array(3),p = 0,f = 3 * (h - e);for (i.rangeMin = h - e, i.rangeMax = h, u = 0; u <= e; ++u) {for (s = n[h - e + u] * d[u], i.factors[u] = s, l = 0; l < 3; ++l) {g[l] += r[f + l] * s;}p += s, f += 3;}for (u = 0; u < 3; ++u) {g[u] /= p;}for (u = 0; u <= e; ++u) {i.factors[u] /= p;}return g;};var E = function E(e, t, r, o, i, s, a, u, h, d, g, p, v) {var _ = .5 * (r + i),y = (0, c.evaluateBCurvePoint)(_, e, t, a, h ? u : void 0);if (p > v) g.push({ offset: _, point: y });else {var m = f(y, o, s, !1),x = n.Vector3.squaredDistance(s, o),R = n.Vector3.squaredDistance(m, y);l.validControlPolygon(a) && R < d * x ? g.push({ offset: _, point: y }) : (E(e, t, r, o, _, y, a, u, h, d, g, p + 1, v), E(e, t, _, y, i, s, a, u, h, d, g, p + 1, v));}};l.renderNURBSCurve = function (e, t, r, i, s, a, u, l) {var h = a || o.DEFAULT_CURVE_RESOLUTION,d = u || [t[0], t[t.length - 1]];l = void 0 === l || l;var g,p = v(i);if (s) {var f,_,y = [];f = (0, c.evaluateBCurvePoint)(d[0], e, t, r, p ? i : void 0), _ = (0, c.evaluateBCurvePoint)(d[1], e, t, r, p ? i : void 0), y.push({ offset: d[0], point: f }), E(e, t, d[0], f, d[1], _, r, i, p, o.SPLINE_DISTANCE_TOLERANCE, y, 0, 4), y.push({ offset: d[1], point: _ }), g = new Array(4 * y.length);for (var m = l ? 0 : 1, x = l ? 0 : 1; x < y.length; x++) {g[m] = y[x].point[0], g[m + 1] = y[x].point[1], g[m + 2] = y[x].point[2], g[m + 3] = y[x].offset, m += 4;}} else {for (var R = 0, A = 3; A < r.length; A += 3) {R += n.Vector3.distance([r[A - 3], r[A - 2], r[A - 1]], [r[A], r[A + 1], r[A + 2]]);}for (h = 10 * Math.round(R), l ? (A = 0, g = new Float32Array(3 * h)) : (A = 1, g = new Float32Array(3 * (h - 1))); A < h; ++A) {var P,V = d[0] + (d[1] - d[0]) * A / (h - 1);P = (0, c.evaluateBCurvePoint)(V, e, t, r, p ? i : void 0);for (var T = 3 * A, C = 0; C < 3; ++C) {g[T + C] = P[C];}}}return g;}, l.evaluateCurve = function (e, t, r, n, i, s) {if (i) {var a = (0, c.evaluateBCurvePoint)(t[0], e, t, r, n),u = (0, c.evaluateBCurvePoint)(t[t.length - 1], e, t, r, n),l = [];l.push({ offset: t[0], point: a }), E(e, t, t[0], a, t[t.length - 1], u, r, n, !0, o.SPLINE_DISTANCE_TOLERANCE, l, 0, 3), l.push({ offset: t[t.length - 1], point: u });for (var h = [], d = [], g = 0; g < l.length; ++g) {h.push(l[g].offset), d.push(l[g].point[0], l[g].point[1], l[g].point[2]);}} else {var p = s || .01,f = t[0],v = 0;h = [], d = [];do {var _ = (0, c.evaluateBCurvePoint)(f, e, t, r, n);for (h[v] = f, g = 0; g < 3; ++g) {d[3 * v + g] = _[g];}++v, f += p;} while (f <= t[t.length - 1]);}return { offset: h, points: d };};var x = function x(e, t, r) {var n = new Float64Array(2);n[0] = r[0] - t[0], n[1] = r[1] - t[1];var o = n[0] * n[0] + n[1] * n[1];if (0 === o) return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[0] * n[0] + n[1] * n[1];var i = (e[0] - t[0]) * n[0] + (e[1] - t[1]) * n[1];return i < 0 ? (n[0] = e[0] - t[0], n[1] = e[1] - t[1]) : i > o ? (n[0] = e[0] - r[0], n[1] = e[1] - r[1]) : (i /= o, n[0] = t[0] + i * n[0] - e[0], n[1] = t[1] + i * n[1] - e[1]), n[0] * n[0] + n[1] * n[1];},R = function R(e, t) {var r,n = !1,o = t.length;r = 0;for (var i = o - 3; r < o; r += 3) {t[r + 1] > e[1] != t[i + 1] > e[1] && e[0] < (t[i] - t[r]) * (e[1] - t[r + 1]) / (t[i + 1] - t[r + 1]) + t[r] && (n = !n), i = r;}return n;},A = function A(e, t) {for (var r, n = new Float64Array(2), o = Number.NEGATIVE_INFINITY, i = 0; i < t.length; i += 3) {n[0] = t[i] - e[0], n[1] = t[i + 1] - e[1], (r = n[0] * n[0] + n[1] * n[1]) > o && (o = r);}return o;},P = function P(e, t, r) {for (var n, o = t.length, i = new Float64Array(2), s = new Float64Array(2), a = Number.POSITIVE_INFINITY, c = 0; c < o - 3; c += 3) {i[0] = t[c], i[1] = t[c + 1], s[0] = t[c + 3], s[1] = t[c + 4], (n = x(e, i, s)) < a && (a = n);}return void 0 !== r && r && (i[0] = t[o - 3], i[1] = t[o - 2], s[0] = t[0], s[1] = t[1], (n = x(e, i, s)) < a && (a = n)), a;};l.closestSegmentsXYPlanar = function (e, t, r, n) {for (var o = Number.POSITIVE_INFINITY, i = [], s = 0; s < t.length; ++s) {var a,c = t[s],u = c.getRangeUnlimited();if (n) {a = !1;for (var l = 0; l < n.length; ++l) {if (u[1] >= n[l][0] && u[0] <= n[l][1]) {a = !0;break;}}} else a = !0;if (a) {var h,d,g = r ? r[s] : 0,p = c.getControlPoints();R(e, p) ? h = 0 : (h = P(e, p, !0), h = Math.max(0, h - g)), h <= o && (d = A(e, p) + g, i.push({ index: s, minDistSqr: h, maxDistSqr: d }), d < o && (o = d));}}var f = [];for (s = 0; s < i.length; ++s) {i[s].minDistSqr <= o && f.push(i[s]);}return f.sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), f;}, l.findKnotMultiplicity = function (e, t) {for (var r = 0, n = 0; n < t.length; ++n) {if (t[n] > e + 1e-8) return r;Math.abs(t[n] - e) < 1e-8 && r++;}return r;}, l.unclampCurve = function (e, t, r, n) {var o,i,s,a,c,u = r.length / 4 - 1,l = n || 1;for (o = 0; o < e - 1; ++o) {for (t[e - o - 1] = t[e - o] - (t[u - o + 1] - t[u - o]) * l, s = e - 1, i = o; i >= 0; --i) {for (a = (t[e] - t[s]) / (t[e + i + 1] - t[s]), c = 0; c < 4; ++c) {r[4 * i + c] = (r[4 * i + c] - a * r[4 * (i + 1) + c]) / (1 - a);}s -= 1;}}for (t[0] = t[1] - (t[u - e + 2] - t[u - e + 1]) * l, o = 0; o < e - 1; ++o) {for (t[u + o + 2] = t[u + o + 1] + (t[e + o + 1] - t[e + o]) * l, i = o; i >= 0; --i) {for (a = (t[u + 1] - t[u - i]) / (t[u - i + o + 2] - t[u - i]), c = 0; c < 4; ++c) {r[4 * (u - i) + c] = (r[4 * (u - i) + c] - (1 - a) * r[4 * (u - i - 1) + c]) / a;}}}t[u + e + 1] = t[u + e] + (t[2 * e] - t[2 * e - 1]) * l;}, l.extractCurveSegment = function (e, t, r, n, o) {var i = this.insertKnot(e, n, o, t, e);i = this.insertKnot(e, i.U, i.Pw, r, e);var s,c = (0, a.findKnotSpan)(t, i.U);for (n.length = i.U.length - (c - e), n[0] = t, s = 1; s < n.length; ++s) {n[s] = i.U[s + c - e];}var u = n.length - e - 1,l = 4 * (i.Pw.length / 4 - u);for (o.length = i.Pw.length - l, s = 0; s < o.length; ++s) {o[s] = i.Pw[s + l];}c = (0, a.findKnotSpan)(r, n), n.length = c + 1, n.push(r), o.length = 4 * (n.length - e - 1);};var V = function V(e, t, r, n) {for (var o = 0, i = 0; i < 4; ++i) {o += (e[t + i] - r[n + i]) * (e[t + i] - r[n + i]);}return Math.sqrt(o);};l.removeKnot = function (e, t, r, n, i) {if (t <= n[0] || t >= n[n.length - 1]) return 0;var s,c,u,l,h,d = [],g = e + 1,p = (0, a.findKnotSpanAndMultiplicity)(t, n);if (p.multiplicity < 1) return 0;for (var f, v, _, y, m = (2 * p.span - p.multiplicity - e) / 2, E = o.KERNEL_TOLERANCE, x = p.span - p.multiplicity, R = p.span - e, A = !1, P = [0, 0, 0, 0], T = 0; T < r; ++T) {for (f = R - 1, h = 0; h < 4; ++h) {d[0 + h] = i[4 * f + h], d[4 * (x + 1 - f) + h] = i[4 * (x + 1) + h];}for (s = R, c = x, u = 1, l = x - f, A = !1; c - s > T;) {for (v = (t - n[s]) / (n[s + g + T] - n[s]), _ = (t - n[c - T]) / (n[c + g] - n[c - T]), h = 0; h < 4; ++h) {d[4 * u + h] = (i[4 * s + h] - (1 - v) * d[4 * (u - 1) + h]) / v, d[4 * l + h] = (i[4 * c + h] - _ * d[4 * (l + 1) + h]) / (1 - _);}++s, ++u, --c, --l;}if (c - s < T) V(d, 4 * (u - 1), d, 4 * (l + 1)) <= E && (A = !0);else {for (v = (t - n[s]) / (n[s + g + T] - n[s]), h = 0; h < 4; ++h) {P[h] = v * d[4 * (u + T + 1) + h] + (1 - v) * d[4 * (u - 1) + h];}V(i, 4 * s, P, 0) <= E && (A = !0);}if (!A) break;for (s = R, c = x; c - s > T;) {for (h = 0; h < 4; ++h) {i[4 * s + h] = d[4 * (s - f) + h], i[4 * c + h] = d[4 * (c - f) + h];}++s, --c;}--R, ++x;}if (0 === T) return 0;for (y = p.span + 1; y < n.length; ++y) {n[y - T] = n[y];}for (n.length = n.length - T, s = c = m, y = 1; y < T; ++y) {y % 2 == 1 ? s += 1 : c -= 1;}for (y = s + 1; y < i.length / 4; ++y) {for (h = 0; h < 4; ++h) {i[4 * c + h] = i[4 * y + h];}c += 1;}return i.length = i.length - 4 * T, T;}, l.joinCurves = function (e, t, r, n, o) {var i,s = t[t.length - 1];for (t.length = t.length - 1, i = e + 1; i < n.length; ++i) {t.push(n[i]);}for (i = 4; i < o.length; ++i) {r.push(o[i]);}var a = this.removeKnot(e, s, e - 1, t, r);a !== e - 1 && console.warn("Failed knot removal, only removed seam knot " + a + " times.");}, l.clampCurve = function (e, t, r) {var n = t[e],o = t[t.length - e - 1];this.extractCurveSegment(e, n, o, t, r);}, l.makePeriodic = function (e, t, r) {var n,o,i = function (e, t, r) {var n,o,i,s = 0;for (n = 1; n < r.length / 4; ++n) {for (i = 0, o = 0; o < 3; ++o) {i += (r[4 * n + o] - r[4 * (n - 1) + o]) * (r[4 * n + o] - r[4 * (n - 1) + o]);}s += Math.sqrt(i);}for (i = 0, o = 0; o < 3; ++o) {i += (r[o] - r[r.length - 4 + o]) * (r[o] - r[r.length - 4 + o]);}var a = Math.sqrt(i),c = (t[t.length - 1] - t[0]) / s,u = r.length / 4 - 1,l = t.slice();for (n = 0; n < e - 1; ++n) {l[e - n - 1] = l[e - n] - (l[u - n + 1] - l[u - n]), l[u + n + 2] = l[u + n + 1] + (l[e + n + 1] - l[e + n]);}var h = l[1] - (l[u - e + 2] - l[u - e + 1]),d = l[u + e] + (l[2 * e] - l[2 * e - 1]);return c / ((t[0] - h + d - t[t.length - 1]) / a);}(e, t, r);this.unclampCurve(e, t, r, i);var s = t.length;for (n = e - 1; n >= 0; --n) {t[s - n] = t[s - n - 1] + (t[e - (n - 1)] - t[e - n]);}var a = r.length / 4;for (r.length = 4 * a + 4 * e, t.length = s + e, n = 0; n < e; ++n) {for (o = 0; o < 4; ++o) {r[4 * (a + n) + o] = r[4 * n + o];}t[s + n] = t[s + n - 1] + (t[e + n + 1] - t[e + n]);}this.clampCurve(e, t, r);}, t.SplineCurveHelper = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.evaluateBCurveDerivs = t.evaluateBCurvePoint = t.evaluateBasisDerivatives = t.evaluateBasisFunctions = void 0;var n = r(1),o = r(3),i = r(17),s = function () {var e = null,t = null;return function (r, n, o, i) {(null === e || e.length < o + 1) && (e = new Float64Array(o + 1), t = new Float64Array(o + 1));var s = new Float64Array(o + 1);s[0] = 1;for (var a = 1; a <= o; ++a) {e[a] = n - i[r + 1 - a], t[a] = i[r + a] - n;for (var c = 0, u = 0; u < a; ++u) {var l = s[u] / (t[u + 1] + e[a - u]);s[u] = c + t[u + 1] * l, c = e[a - u] * l;}s[a] = c;}return s;};}(),a = function () {var e = null,t = null,r = null,n = null;return function (o, i, s, a, c, u) {var l, h, d;if (null === t || t.length < s + 1) {for (e = [new Float64Array(s + 1), new Float64Array(s + 1)], t = new Array(s + 1), l = 0; l < s + 1; ++l) {t[l] = new Float64Array(s + 1);}r = new Float64Array(s + 1), n = new Float64Array(s + 1);}if (!u) for (u = new Array(a + 1), l = 0; l <= a; ++l) {u[l] = new Float64Array(s + 1);}for (t[0][0] = 1, l = 1; l <= s; ++l) {r[l] = i - c[o + 1 - l], n[l] = c[o + l] - i;var g = 0;for (d = 0; d < l; ++d) {t[l][d] = n[d + 1] + r[l - d];var p = t[d][l - 1] / t[l][d];t[d][l] = g + n[d + 1] * p, g = r[l - d] * p;}t[l][l] = g;}for (l = 0; l <= s; ++l) {u[0][l] = t[l][s];}for (d = 0; d <= s; ++d) {var f = 0,v = 1;for (e[0][0] = 1, h = 1; h <= a; ++h) {var _,y = 0,m = d - h,E = s - h;for (d >= h && (e[v][0] = e[f][0] / t[E + 1][m], y = e[v][0] * t[m][E]), _ = d - 1 <= E ? h - 1 : s - d, l = m >= -1 ? 1 : -m; l <= _; ++l) {e[v][l] = (e[f][l] - e[f][l - 1]) / t[E + 1][m + l], y += e[v][l] * t[m + l][E];}d <= E && (e[v][h] = -e[f][h - 1] / t[E + 1][d], y += e[v][h] * t[d][E]), u[h][d] = y, l = f, f = v, v = l;}}for (d = s, h = 1; h <= a; ++h) {for (l = 0; l <= s; ++l) {u[h][l] *= d;}d *= s - h;}return u;};}(),c = function () {var e = null,t = null;return function (r, s, c, u, l, h) {var d, g, p;if (null === e || e.length < c + 1) {for (e = new Array(c + 1), d = 0; d <= c; ++d) {e[d] = new Float64Array(c + 1);}t = new Float64Array(c + 1);}var f = Math.min(s, c),v = h && h.length > 0,_ = (0, i.findKnotSpan)(r, u);a(_, r, c, f, u, e);var y = new Array(s + 1);for (d = 0; d <= s; ++d) {y[d] = n.Vector3.createFloat64();}for (g = 0; g <= f; ++g) {var m = 3 * (_ - c);if (v) for (t[g] = 0, d = 0; d <= c; ++d) {p = h[_ - c + d] * e[g][d], y[g][0] += l[m] * p, y[g][1] += l[m + 1] * p, y[g][2] += l[m + 2] * p, t[g] += p, m += 3;} else for (d = 0; d <= c; ++d) {p = e[g][d], y[g][0] += l[m] * p, y[g][1] += l[m + 1] * p, y[g][2] += l[m + 2] * p, m += 3;}}if (v) for (g = 0; g <= f; ++g) {var E = y[g];for (d = 1; d <= g; ++d) {p = -o.binomialCoefficients[g][d] * t[d], n.Vector3.scaleAndAdd(E, E, y[g - d], p);}n.Vector3.scale(E, E, 1 / t[0]);}return y;};}();t.evaluateBasisFunctions = s, t.evaluateBasisDerivatives = a, t.evaluateBCurvePoint = function (e, t, r, o, a) {var c,u,l = (0, i.findKnotSpan)(e, r),h = s(l, e, t, r),d = a && a.length > 0,g = n.Vector3.createFloat64(),p = 0,f = 3 * (l - t);if (d) {for (c = 0; c <= t; ++c) {u = a[l - t + c] * h[c], g[0] += o[f] * u, g[1] += o[f + 1] * u, g[2] += o[f + 2] * u, p += u, f += 3;}n.Vector3.scale(g, g, 1 / p);} else for (c = 0; c <= t; ++c) {u = h[c], g[0] += o[f] * u, g[1] += o[f + 1] * u, g[2] += o[f + 2] * u, f += 3;}return g;}, t.evaluateBCurveDerivs = c;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Cylinder = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.CYLINDER;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t, u.ConsoleUtils.assert(n.Vector3.squaredLength(r) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, r), void 0 !== o && n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, o, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, o)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._uScale = s || 1, u.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, l.prototype.getRadius = function () {return this._radius;}, l.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.getUScale = function () {return this._uScale;}, l.prototype.setUScale = function (e) {u.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, l.prototype.evaluatePosition = function (e, t) {var r = this._radius * Math.cos(t),o = this._radius * Math.sin(t),i = this._uScale * e,s = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(s, s, this._xAxis, r), n.Vector3.scaleAndAdd(s, s, this._yAxis, o), n.Vector3.scaleAndAdd(s, s, this._zAxis, i), s;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.cos(t),o = Math.sin(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.evaluateDu = function (e, t) {var r = n.Vector3.createFloat64();return n.Vector3.scale(r, this._zAxis, this._uScale), r;}, l.prototype.evaluateDv = function (e, t) {var r = -this._radius * Math.sin(t),o = this._radius * Math.cos(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._xAxis),o = n.Vector3.dot(t, this._yAxis),s = n.Vector3.dot(t, this._zAxis) / this._uScale,a = 0;return r * r + o * o > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE && (a = Math.atan2(o, r)), { u: s, v: a };}, l.prototype.vParamLine = function (e) {var t = new c.Circle(),r = n.Vector3.clone(this._center),o = e * this._uScale;n.Vector3.scaleAndAdd(r, r, this._zAxis, o);var i = n.Vector3.clone(this._xAxis);n.Vector3.scale(i, i, this._radius);var s = n.Vector3.clone(this._zAxis);return n.Vector3.negate(s, s), t.set(r, s, i), t;}, l.prototype.uParamLine = function (e) {var t = new a.Line(),r = n.Vector3.clone(this._center),o = this._radius * Math.cos(e),i = this._radius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, l.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Cylinder = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.EllipticalCylinder = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(23),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s) {n.Vector3.copy(this._center, e), this._majorRadius = n.Vector3.length(t), u.ConsoleUtils.assert(this._majorRadius > i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, t), u.ConsoleUtils.assert(r <= 1), this._minorRadius = r * this._majorRadius, u.ConsoleUtils.assert(this._minorRadius > i.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, t, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._zAxis, o), this._uScale = s || 1, u.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, l.prototype.getMajorRadius = function () {return this._majorRadius;}, l.prototype.setMajorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._majorRadius = e;}, l.prototype.getMinorRadius = function () {return this._minorRadius;}, l.prototype.setMinorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._minorRadius = e;}, l.prototype.getMajorAxis = function () {return this._xAxis;}, l.prototype.setMajorAxis = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), this._computeYAxis();}, l.prototype.getUScale = function () {return this._uScale;}, l.prototype.setUScale = function (e) {u.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, l.prototype.evaluatePosition = function (e, t) {var r = this._majorRadius * Math.cos(t),o = this._minorRadius * Math.sin(t),i = this._uScale * e,s = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(s, s, this._xAxis, r), n.Vector3.scaleAndAdd(s, s, this._yAxis, o), n.Vector3.scaleAndAdd(s, s, this._zAxis, i), s;}, l.prototype.evaluateNormal = function (e, t) {var r = this._minorRadius * Math.cos(t),o = this._majorRadius * Math.sin(t),i = Math.sqrt(r * r + o * o),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, r / i), n.Vector3.scaleAndAdd(s, s, this._yAxis, o / i), s;}, l.prototype.evaluateDu = function (e, t) {var r = n.Vector3.createFloat64();return n.Vector3.scale(r, this._zAxis, this._uScale), r;}, l.prototype.evaluateDv = function (e, t) {var r = -this._majorRadius * Math.sin(t),o = this._minorRadius * Math.cos(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._zAxis) / this._uScale;return { u: r, v: this.vParamLine(r).closestToPointParam(e) };}, l.prototype.vParamLine = function (e) {var t = new c.Ellipse(),r = n.Vector3.clone(this._center),o = e * this._uScale;n.Vector3.scaleAndAdd(r, r, this._zAxis, o);var i = n.Vector3.clone(this._xAxis);n.Vector3.scale(i, i, this._majorRadius);var s = n.Vector3.clone(this._zAxis);return n.Vector3.negate(s, s), t.set(r, s, i, this._minorRadius / this._majorRadius), t;}, l.prototype.uParamLine = function (e) {var t = new a.Line(),r = n.Vector3.clone(this._center),o = this._majorRadius * Math.cos(e),i = this._minorRadius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, l.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.EllipticalCylinder = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Wire = void 0;var n = r(9),o = r(4),i = r(0),s = function s() {n.BaseTopology.call(this), this._wireBody = void 0, this._edges = [];};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.WIRE;}, s.prototype.getWireBody = function () {return this._wireBody;}, s.prototype.setWireBody = function (e) {this._wireBody = e;}, s.prototype.getEdges = function () {return this._edges;}, s.prototype.setEdges = function (e) {this._edges = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._edges[t] = e[t];}}, s.prototype.addEdge = function (e) {this._edges ? this._edges.push(e) : this._edges = [e], e.setWire(this), e.setCoedge(void 0);}, s.prototype.addEdges = function (e) {this._edges || (this._edges = []);for (var t = 0; t < e.length; ++t) {e[t].setWire(this), e[t].setCoedge(void 0);}this._edges = this._edges.concat(e);}, s.prototype.removeEdge = function (e) {var t = this._edges.indexOf(e);return t > -1 && (this._edges.splice(t, 1), e.getWire() === this && e.setWire(void 0), !0);}, s.prototype.getBody = function () {return this._wireBody;}, s.prototype.collectFaces = function (e) {return e || new Set();}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {e.add(this._edges[t]);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {this._edges[t].collectVertices(e);}return e;}, s.prototype.isBranched = function () {for (var e = 0; e < this._edges.length; ++e) {var t = this._edges[e],r = t.getStartVertex(),n = t.getEndVertex();if (r === n && r.getOtherEdge(t)) return !0;if (r.getEdges().length > 2 || n.getEdges().length > 2) return !0;}return !1;}, s.prototype.getOrderedEdges = function () {if (0 === this._edges.length) return { edges: [], start: void 0, end: void 0 };var e = [];e.push(this._edges[0]);for (var t = new Set(this._edges.slice(1)), r = e[0].getStartVertex(), n = e[0].getEndVertex(); t.size > 0;) {var o = t.size;if (t.forEach(function (o) {o.getEndVertex() === r ? (e.unshift(o), r = o.getStartVertex(), t.delete(o)) : o.getStartVertex() === r ? (e.unshift(o), r = o.getEndVertex(), t.delete(o)) : o.getEndVertex() === n ? (e.push(o), n = o.getStartVertex(), t.delete(o)) : o.getStartVertex() === n && (e.push(o), n = o.getEndVertex(), t.delete(o));}), o === t.size) {console.warn("Wire is disconnected or branching.");break;}}return { edges: e, start: r, end: n };}, s.prototype.isClosed = function () {if (1 === this._edges.length) return this._edges[0].getStartVertex() === this._edges[0].getEndVertex();for (var e = this._edges[0], t = void 0, r = 0; r < this._edges.length; ++r) {var n,o = e.getStartVertex(),i = e.getEndVertex();if (o === i || 2 !== o.getEdges().length || 2 !== i.getEdges().length) return !1;if (t && o.getOtherEdge(e) !== t) {if (i.getOtherEdge(e) !== t) return !1;n = o.getOtherEdge(e);} else n = i.getOtherEdge(e);t = e, e = n;}return e === this._edges[0];}, s.prototype.getBoundingBox = function () {for (var e = new o.BoundingBox(), t = 0; t < this._edges.length; ++t) {e.include(this._edges[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return "Wire";}, s.prototype.toObject = function () {return { edges: this.refsToStrings(this._edges), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._edges, this._attributes]);}, t.Wire = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.ProgenitorMap = void 0;var n = r(0),o = r(2),i = function i() {this._newToOldMap = new Map(), this._oldToNewMap = new Map(), this._labelMap = new Map();};i.prototype.addEntry = function (e, t, r) {t = Array.from(new Set(t)), o.ConsoleUtils.assert(!this._newToOldMap.has(e)), this._newToOldMap.set(e, t), r && this._labelMap.set(e, r);for (var n = 0; n < t.length; n++) {var i = t[n],s = this._oldToNewMap.get(i);s ? s.indexOf(e) < 0 && s.push(e) : this._oldToNewMap.set(i, [e]);}}, i.prototype.hasEntry = function (e) {return this._newToOldMap.has(e);}, i.prototype.removeEntry = function (e) {var t = this._newToOldMap.get(e);if (t) {this._newToOldMap.delete(e), this._labelMap.delete(e);for (var r = 0; r < t.length; r++) {var n = this._oldToNewMap.get(t[r]),i = n.indexOf(e);o.ConsoleUtils.assert(i >= 0), n.splice(i, 1), 0 === n.length && this._oldToNewMap.delete(t[r]);}}}, i.prototype.size = function () {return this._newToOldMap.size;}, i.prototype.getProgenitors = function (e) {return this._newToOldMap.get(e);}, i.prototype.getDescendants = function (e) {return this._oldToNewMap.get(e) || [];}, i.prototype.getLabel = function (e) {return this._labelMap.get(e) || "";}, i.prototype.getAllNewTopology = function () {return Array.from(this._newToOldMap.keys());}, i.prototype.getAllOldTopology = function () {return Array.from(this._oldToNewMap.keys());}, i.prototype.clear = function () {this._newToOldMap.clear(), this._oldToNewMap.clear(), this._labelMap.clear();}, i.prototype.mergeMaps = function (e) {var t = new i(),r = new Set(this._newToOldMap.keys());return e._newToOldMap.keys().forEach(function (e) {r.add(e);}), r.forEach(function (r) {var n = this.getProgenitors(r) || [],o = e.getProgenitors(r) || [],i = this.getLabel(r) || e.getLabel(r);t.addEntry(r, n.concat(o), i);}), t;}, i.prototype.collapseMaps = function (e, t) {var r = !1,n = !1;t && (void 0 !== t.keepIntermediates && (r = t.keepIntermediates), void 0 !== t.keepAllDescendants && (n = t.keepAllDescendants));var o = new i(),s = void 0;return n && (s = new Set(e._newToOldMap.keys())), this._newToOldMap.forEach(function (t, i) {for (var a = new Set(), c = 0; c < t.length; c++) {var u = t[c],l = e.getProgenitors(u);l && l.length > 0 ? (l.forEach(function (e) {a.add(e);}), r && a.add(u)) : a.add(u), n && s.delete(u);}o.addEntry(i, Array.from(a));}), n && s.forEach(function (t) {var r = e.getProgenitors(t);o.hasEntry(t) && (r = r.concat(o.getProgenitors(t)), o.removeEntry(t)), o.addEntry(t, r);}), o;}, i.prototype.toString = function () {for (var e = "ProgenitorMap:\n", t = this.getAllNewTopology(), r = 0; r < t.length; r++) {var o = t[r];e += n.TOPOLOGY_TYPES.toString(o.getTopologyType()) + ":" + o.getGuid();var i = this.getLabel(o);i && (e += " '" + i + "'"), e += " -> [ ";for (var s = this.getProgenitors(o), a = 0; a < s.length; a++) {a > 0 && (e += ", "), e += n.TOPOLOGY_TYPES.toString(s[a].getTopologyType()) + ":" + s[a].getGuid();}e += " ]\n";}return e;}, t.ProgenitorMap = i;}, function (e, t, r) {"use strict";r.r(t), r.d(t, "default", function () {return i;}), r.d(t, "VERSION", function () {return n.VERSION;}), r.d(t, "iteratee", function () {return n.iteratee;}), r.d(t, "restArguments", function () {return n.restArguments;}), r.d(t, "each", function () {return n.each;}), r.d(t, "forEach", function () {return n.forEach;}), r.d(t, "map", function () {return n.map;}), r.d(t, "collect", function () {return n.collect;}), r.d(t, "reduce", function () {return n.reduce;}), r.d(t, "foldl", function () {return n.foldl;}), r.d(t, "inject", function () {return n.inject;}), r.d(t, "reduceRight", function () {return n.reduceRight;}), r.d(t, "foldr", function () {return n.foldr;}), r.d(t, "find", function () {return n.find;}), r.d(t, "detect", function () {return n.detect;}), r.d(t, "filter", function () {return n.filter;}), r.d(t, "select", function () {return n.select;}), r.d(t, "reject", function () {return n.reject;}), r.d(t, "every", function () {return n.every;}), r.d(t, "all", function () {return n.all;}), r.d(t, "some", function () {return n.some;}), r.d(t, "any", function () {return n.any;}), r.d(t, "contains", function () {return n.contains;}), r.d(t, "includes", function () {return n.includes;}), r.d(t, "include", function () {return n.include;}), r.d(t, "invoke", function () {return n.invoke;}), r.d(t, "pluck", function () {return n.pluck;}), r.d(t, "where", function () {return n.where;}), r.d(t, "findWhere", function () {return n.findWhere;}), r.d(t, "max", function () {return n.max;}), r.d(t, "min", function () {return n.min;}), r.d(t, "shuffle", function () {return n.shuffle;}), r.d(t, "sample", function () {return n.sample;}), r.d(t, "sortBy", function () {return n.sortBy;}), r.d(t, "groupBy", function () {return n.groupBy;}), r.d(t, "indexBy", function () {return n.indexBy;}), r.d(t, "countBy", function () {return n.countBy;}), r.d(t, "toArray", function () {return n.toArray;}), r.d(t, "size", function () {return n.size;}), r.d(t, "partition", function () {return n.partition;}), r.d(t, "first", function () {return n.first;}), r.d(t, "head", function () {return n.head;}), r.d(t, "take", function () {return n.take;}), r.d(t, "initial", function () {return n.initial;}), r.d(t, "last", function () {return n.last;}), r.d(t, "rest", function () {return n.rest;}), r.d(t, "tail", function () {return n.tail;}), r.d(t, "drop", function () {return n.drop;}), r.d(t, "compact", function () {return n.compact;}), r.d(t, "flatten", function () {return n.flatten;}), r.d(t, "without", function () {return n.without;}), r.d(t, "uniq", function () {return n.uniq;}), r.d(t, "unique", function () {return n.unique;}), r.d(t, "union", function () {return n.union;}), r.d(t, "intersection", function () {return n.intersection;}), r.d(t, "difference", function () {return n.difference;}), r.d(t, "unzip", function () {return n.unzip;}), r.d(t, "zip", function () {return n.zip;}), r.d(t, "object", function () {return n.object;}), r.d(t, "findIndex", function () {return n.findIndex;}), r.d(t, "findLastIndex", function () {return n.findLastIndex;}), r.d(t, "sortedIndex", function () {return n.sortedIndex;}), r.d(t, "indexOf", function () {return n.indexOf;}), r.d(t, "lastIndexOf", function () {return n.lastIndexOf;}), r.d(t, "range", function () {return n.range;}), r.d(t, "chunk", function () {return n.chunk;}), r.d(t, "bind", function () {return n.bind;}), r.d(t, "partial", function () {return n.partial;}), r.d(t, "bindAll", function () {return n.bindAll;}), r.d(t, "memoize", function () {return n.memoize;}), r.d(t, "delay", function () {return n.delay;}), r.d(t, "defer", function () {return n.defer;}), r.d(t, "throttle", function () {return n.throttle;}), r.d(t, "debounce", function () {return n.debounce;}), r.d(t, "wrap", function () {return n.wrap;}), r.d(t, "negate", function () {return n.negate;}), r.d(t, "compose", function () {return n.compose;}), r.d(t, "after", function () {return n.after;}), r.d(t, "before", function () {return n.before;}), r.d(t, "once", function () {return n.once;}), r.d(t, "keys", function () {return n.keys;}), r.d(t, "allKeys", function () {return n.allKeys;}), r.d(t, "values", function () {return n.values;}), r.d(t, "mapObject", function () {return n.mapObject;}), r.d(t, "pairs", function () {return n.pairs;}), r.d(t, "invert", function () {return n.invert;}), r.d(t, "functions", function () {return n.functions;}), r.d(t, "methods", function () {return n.methods;}), r.d(t, "extend", function () {return n.extend;}), r.d(t, "extendOwn", function () {return n.extendOwn;}), r.d(t, "assign", function () {return n.assign;}), r.d(t, "findKey", function () {return n.findKey;}), r.d(t, "pick", function () {return n.pick;}), r.d(t, "omit", function () {return n.omit;}), r.d(t, "defaults", function () {return n.defaults;}), r.d(t, "create", function () {return n.create;}), r.d(t, "clone", function () {return n.clone;}), r.d(t, "tap", function () {return n.tap;}), r.d(t, "isMatch", function () {return n.isMatch;}), r.d(t, "isEqual", function () {return n.isEqual;}), r.d(t, "isEmpty", function () {return n.isEmpty;}), r.d(t, "isElement", function () {return n.isElement;}), r.d(t, "isArray", function () {return n.isArray;}), r.d(t, "isObject", function () {return n.isObject;}), r.d(t, "isArguments", function () {return n.isArguments;}), r.d(t, "isFunction", function () {return n.isFunction;}), r.d(t, "isString", function () {return n.isString;}), r.d(t, "isNumber", function () {return n.isNumber;}), r.d(t, "isDate", function () {return n.isDate;}), r.d(t, "isRegExp", function () {return n.isRegExp;}), r.d(t, "isError", function () {return n.isError;}), r.d(t, "isSymbol", function () {return n.isSymbol;}), r.d(t, "isMap", function () {return n.isMap;}), r.d(t, "isWeakMap", function () {return n.isWeakMap;}), r.d(t, "isSet", function () {return n.isSet;}), r.d(t, "isWeakSet", function () {return n.isWeakSet;}), r.d(t, "isFinite", function () {return n.isFinite;}), r.d(t, "isNaN", function () {return n.isNaN;}), r.d(t, "isBoolean", function () {return n.isBoolean;}), r.d(t, "isNull", function () {return n.isNull;}), r.d(t, "isUndefined", function () {return n.isUndefined;}), r.d(t, "has", function () {return n.has;}), r.d(t, "identity", function () {return n.identity;}), r.d(t, "constant", function () {return n.constant;}), r.d(t, "noop", function () {return n.noop;}), r.d(t, "property", function () {return n.property;}), r.d(t, "propertyOf", function () {return n.propertyOf;}), r.d(t, "matcher", function () {return n.matcher;}), r.d(t, "matches", function () {return n.matches;}), r.d(t, "times", function () {return n.times;}), r.d(t, "random", function () {return n.random;}), r.d(t, "now", function () {return n.now;}), r.d(t, "escape", function () {return n.escape;}), r.d(t, "unescape", function () {return n.unescape;}), r.d(t, "result", function () {return n.result;}), r.d(t, "uniqueId", function () {return n.uniqueId;}), r.d(t, "templateSettings", function () {return n.templateSettings;}), r.d(t, "template", function () {return n.template;}), r.d(t, "chain", function () {return n.chain;}), r.d(t, "mixin", function () {return n.mixin;});var n = r(29),o = Object(n.mixin)(n);o._ = o;var i = o;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseGeometry = void 0;var n = r(44),o = r(0),i = function i() {n.Base.call(this);};(i.prototype = Object.create(n.Base.prototype)).getGeometryType = function () {console.warn("BaseGeometry.getGeometryType : abstract method invoked!");}, i.prototype.clone = function () {console.warn("BaseGeometry.clone : abstract method invoked");}, i.prototype.copy = function (e) {this._guid = "";}, i.prototype.addToModelObject = function (e) {if (!e.geometries[this.getGuid()]) {var _t4 = {};_t4[o.GEOMETRY_TYPES.toString(this.getGeometryType()).toLowerCase()] = this.toObject(), e.geometries[this.getGuid()] = _t4;}}, t.BaseGeometry = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Base = void 0;var n = r(56);var o = r(45).Autodesk.lookup("SolidDef.paramrange_1_0_0.typeEnum");var i = function i() {this._guid = "";};i.prototype.setGuid = function (e) {this._guid = e;}, i.prototype.getGuid = function () {return this._guid || (this._guid = (0, n.generateGUID)()), this._guid;}, i.prototype.refsToStrings = function (e) {if (e) {var _t5 = new Array(e.length);for (var _r3 = 0; _r3 < e.length; ++_r3) {_t5[_r3] = e[_r3].getGuid();}return _t5;}return [];}, i.prototype.refToString = function (e) {return e ? e.getGuid() : "";}, i.prototype.toObject = function () {return console.warn("Base.toObject : abstract method invoked!"), {};}, i.prototype.vectorToObject = function (e) {return { x: e[0], y: e[1], z: e[2] };}, i.prototype.rangeToObject = function (e, t) {var r = 1,n = 0;t && void 0 !== e && 2 === e.length && isFinite(e[0]) && isFinite(e[1]) && (r = e[0], n = e[1]);var i = r <= n ? "finite" : "infinite";return { low: r, high: n, type: o.values[i] };}, i.prototype.addToModelObject = function (e) {console.warn("Base.addToModelObject : abstract method invoked!");}, t.Base = i;}, function (e, t, r) {"use strict";var n = r(87),o = (n.roots.default || (n.roots.default = new n.Root())).addJSON({ Autodesk: { nested: { SolidDef: { nested: { SolidDef_grpc: { methods: {} }, point3d_1_0_0: { fields: { x: { type: "double", id: 1 }, y: { type: "double", id: 2 }, z: { type: "double", id: 3 } } }, vector3d_1_0_0: { fields: { x: { type: "double", id: 1 }, y: { type: "double", id: 2 }, z: { type: "double", id: 3 } } }, geometry_1_0_0: { fields: {} }, geometry_1_0_0_Type: { oneofs: { geometry: { oneof: ["point", "bsurface", "cone", "cylinder", "ellipticalcone", "ellipticalcylinder", "plane", "sphere", "surface", "torus", "bcurve", "circle", "curve", "ellipse", "line"] } }, fields: { point: { type: "point_1_0_0", id: 1 }, bsurface: { type: "bsurface_1_0_0", id: 2 }, cone: { type: "cone_1_0_0", id: 3 }, cylinder: { type: "cylinder_1_0_0", id: 4 }, ellipticalcone: { type: "ellipticalcone_1_0_0", id: 5 }, ellipticalcylinder: { type: "ellipticalcylinder_1_0_0", id: 6 }, plane: { type: "plane_1_0_0", id: 7 }, sphere: { type: "sphere_1_0_0", id: 8 }, surface: { type: "surface_1_0_0", id: 9 }, torus: { type: "torus_1_0_0", id: 10 }, bcurve: { type: "bcurve_1_0_0", id: 11 }, circle: { type: "circle_1_0_0", id: 12 }, curve: { type: "curve_1_0_0", id: 13 }, ellipse: { type: "ellipse_1_0_0", id: 14 }, line: { type: "line_1_0_0", id: 15 } } }, paramrange_1_0_0: { fields: { low: { type: "double", id: 1 }, high: { type: "double", id: 2 }, type: { type: "typeEnum", id: 3 } }, nested: { typeEnum: { values: { infinite: 0, finite: 1, boundBelow: 2, boundAbove: 3 } } } }, point_1_0_0: { fields: { position: { type: "point3d_1_0_0", id: 1 } } }, bsurface_1_0_0: { fields: { uDegree: { type: "uint32", id: 1 }, vDegree: { type: "uint32", id: 2 }, uKnots: { rule: "repeated", type: "double", id: 3 }, vKnots: { rule: "repeated", type: "double", id: 4 }, controlPoints: { rule: "repeated", type: "double", id: 5 }, weights: { rule: "repeated", type: "double", id: 6 }, uRange: { type: "paramrange_1_0_0", id: 7 }, vRange: { type: "paramrange_1_0_0", id: 8 } } }, cone_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, radius: { type: "vector3d_1_0_0", id: 3 }, angle: { type: "double", id: 4 }, uCoordScale: { type: "double", id: 5 }, uRange: { type: "paramrange_1_0_0", id: 6 }, vRange: { type: "paramrange_1_0_0", id: 7 } } }, cylinder_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, radius: { type: "vector3d_1_0_0", id: 3 }, uCoordScale: { type: "double", id: 4 }, uRange: { type: "paramrange_1_0_0", id: 5 }, vRange: { type: "paramrange_1_0_0", id: 6 } } }, ellipticalcone_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "vector3d_1_0_0", id: 3 }, radiusRatio: { type: "double", id: 4 }, angle: { type: "double", id: 5 }, uCoordScale: { type: "double", id: 6 }, uRange: { type: "paramrange_1_0_0", id: 7 }, vRange: { type: "paramrange_1_0_0", id: 8 } } }, ellipticalcylinder_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "vector3d_1_0_0", id: 3 }, radiusRatio: { type: "double", id: 4 }, uCoordScale: { type: "double", id: 5 }, uRange: { type: "paramrange_1_0_0", id: 6 }, vRange: { type: "paramrange_1_0_0", id: 7 } } }, plane_1_0_0: { fields: { origin: { type: "point3d_1_0_0", id: 1 }, normal: { type: "vector3d_1_0_0", id: 2 }, uAxis: { type: "vector3d_1_0_0", id: 3 }, uRange: { type: "paramrange_1_0_0", id: 4 }, vRange: { type: "paramrange_1_0_0", id: 5 } } }, sphere_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, radius: { type: "vector3d_1_0_0", id: 2 }, axis: { type: "vector3d_1_0_0", id: 3 }, uRange: { type: "paramrange_1_0_0", id: 4 }, vRange: { type: "paramrange_1_0_0", id: 5 } } }, surface_1_0_0: { fields: { uRange: { type: "paramrange_1_0_0", id: 1 }, vRange: { type: "paramrange_1_0_0", id: 2 } } }, surface_1_0_0_Type: { oneofs: { surface: { oneof: ["bsurface", "cone", "cylinder", "ellipticalcone", "ellipticalcylinder", "plane", "sphere", "torus"] } }, fields: { bsurface: { type: "bsurface_1_0_0", id: 1 }, cone: { type: "cone_1_0_0", id: 2 }, cylinder: { type: "cylinder_1_0_0", id: 3 }, ellipticalcone: { type: "ellipticalcone_1_0_0", id: 4 }, ellipticalcylinder: { type: "ellipticalcylinder_1_0_0", id: 5 }, plane: { type: "plane_1_0_0", id: 6 }, sphere: { type: "sphere_1_0_0", id: 7 }, torus: { type: "torus_1_0_0", id: 8 } } }, torus_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "double", id: 3 }, minorRadius: { type: "double", id: 4 }, coordAxis: { type: "vector3d_1_0_0", id: 5 }, lemon: { type: "bool", id: 6 }, uRange: { type: "paramrange_1_0_0", id: 7 }, vRange: { type: "paramrange_1_0_0", id: 8 } } }, bcurve_1_0_0: { fields: { degree: { type: "uint32", id: 1 }, knots: { rule: "repeated", type: "double", id: 2 }, controlPoints: { rule: "repeated", type: "double", id: 3 }, weights: { rule: "repeated", type: "double", id: 4 }, range: { type: "paramrange_1_0_0", id: 5 } } }, circle_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, normal: { type: "vector3d_1_0_0", id: 2 }, radius: { type: "vector3d_1_0_0", id: 3 }, range: { type: "paramrange_1_0_0", id: 4 } } }, curve_1_0_0: { fields: { range: { type: "paramrange_1_0_0", id: 1 } } }, curve_1_0_0_Type: { oneofs: { curve: { oneof: ["bcurve", "circle", "ellipse", "line"] } }, fields: { bcurve: { type: "bcurve_1_0_0", id: 1 }, circle: { type: "circle_1_0_0", id: 2 }, ellipse: { type: "ellipse_1_0_0", id: 3 }, line: { type: "line_1_0_0", id: 4 } } }, ellipse_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, normal: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "vector3d_1_0_0", id: 3 }, radiusRatio: { type: "double", id: 4 }, range: { type: "paramrange_1_0_0", id: 5 } } }, line_1_0_0: { fields: { position: { type: "point3d_1_0_0", id: 1 }, direction: { type: "vector3d_1_0_0", id: 2 }, range: { type: "paramrange_1_0_0", id: 3 } } }, attribute_1_0_0: { fields: {} }, attribute_1_0_0_Type: { oneofs: { attribute: { oneof: ["nmiattribute", "nmiattributearr", "nmiattributestr", "textattribute"] } }, fields: { nmiattribute: { type: "nmiattribute_1_0_0", id: 1 }, nmiattributearr: { type: "nmiattributearr_1_0_0", id: 4 }, nmiattributestr: { type: "nmiattributestr_1_0_0", id: 2 }, textattribute: { type: "textattribute_1_0_0", id: 3 } } }, body_1_0_0: { fields: { lumps: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, coedge_1_0_0: { fields: { edge: { type: "string", id: 1 }, partner: { type: "string", id: 2 }, reversed: { type: "bool", id: 3 }, attributes: { rule: "repeated", type: "string", id: 4 } } }, edge_1_0_0: { fields: { vertex0: { type: "string", id: 1 }, vertex1: { type: "string", id: 2 }, precision: { type: "double", id: 3 }, range: { type: "paramrange_1_0_0", id: 4 }, reversed: { type: "bool", id: 5 }, geometry: { type: "string", id: 6 }, attributes: { rule: "repeated", type: "string", id: 7 } } }, face_1_0_0: { fields: { loops: { rule: "repeated", type: "string", id: 1 }, reversed: { type: "bool", id: 2 }, geometry: { type: "string", id: 3 }, attributes: { rule: "repeated", type: "string", id: 4 } } }, loop_1_0_0: { fields: { coedges: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, lump_1_0_0: { fields: { shells: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, model_1_0_0: { fields: { geometries: { keyType: "string", type: "geometry_1_0_0_Type", id: 1 }, topologies: { keyType: "string", type: "topology_1_0_0_Type", id: 2 }, attributes: { keyType: "string", type: "attribute_1_0_0_Type", id: 3 } } }, shell_1_0_0: { fields: { faces: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, topology_1_0_0: { fields: { attributes: { rule: "repeated", type: "string", id: 1 } } }, topology_1_0_0_Type: { oneofs: { topology: { oneof: ["body", "coedge", "edge", "face", "loop", "lump", "shell", "vertex", "wire", "wirebody"] } }, fields: { body: { type: "body_1_0_0", id: 1 }, coedge: { type: "coedge_1_0_0", id: 2 }, edge: { type: "edge_1_0_0", id: 3 }, face: { type: "face_1_0_0", id: 4 }, loop: { type: "loop_1_0_0", id: 5 }, lump: { type: "lump_1_0_0", id: 6 }, shell: { type: "shell_1_0_0", id: 7 }, vertex: { type: "vertex_1_0_0", id: 8 }, wire: { type: "wire_1_0_0", id: 9 }, wirebody: { type: "wirebody_1_0_0", id: 10 } } }, vertex_1_0_0: { fields: { precision: { type: "double", id: 1 }, geometry: { type: "string", id: 2 }, attributes: { rule: "repeated", type: "string", id: 3 } } }, wire_1_0_0: { fields: { edges: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, wirebody_1_0_0: { fields: { wires: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, nmiattribute_1_0_0: { fields: { primaryId: { type: "uint64", id: 1 }, secondaryId: { type: "int64", id: 2 }, approachId: { type: "int64", id: 3 }, operationIds: { rule: "repeated", type: "int64", id: 4 } } }, nmiattributearr_1_0_0: { fields: { tagInfo: { rule: "repeated", type: "nmiattributestr_1_0_0", id: 1 } } }, nmiattributestr_1_0_0: { fields: { primaryId: { type: "string", id: 1 }, secondaryId: { type: "string", id: 2 }, approachId: { type: "string", id: 3 }, operationIds: { rule: "repeated", type: "string", id: 4 } } }, textattribute_1_0_0: { fields: { text: { type: "string", id: 1 } } }, entity: { oneofs: { entity: { oneof: ["point3d", "vector3d", "geometry", "paramrange", "point", "bsurface", "cone", "cylinder", "ellipticalcone", "ellipticalcylinder", "plane", "sphere", "surface", "torus", "bcurve", "circle", "curve", "ellipse", "line", "attribute", "body", "coedge", "edge", "face", "loop", "lump", "model", "shell", "topology", "vertex", "wire", "wirebody", "nmiattribute", "nmiattributearr", "nmiattributestr", "textattribute"] } }, fields: { id: { type: "string", id: 1 }, point3d: { type: "point3d_1_0_0", id: 2 }, vector3d: { type: "vector3d_1_0_0", id: 3 }, geometry: { type: "geometry_1_0_0", id: 4 }, paramrange: { type: "paramrange_1_0_0", id: 5 }, point: { type: "point_1_0_0", id: 6 }, bsurface: { type: "bsurface_1_0_0", id: 7 }, cone: { type: "cone_1_0_0", id: 8 }, cylinder: { type: "cylinder_1_0_0", id: 9 }, ellipticalcone: { type: "ellipticalcone_1_0_0", id: 10 }, ellipticalcylinder: { type: "ellipticalcylinder_1_0_0", id: 11 }, plane: { type: "plane_1_0_0", id: 12 }, sphere: { type: "sphere_1_0_0", id: 13 }, surface: { type: "surface_1_0_0", id: 14 }, torus: { type: "torus_1_0_0", id: 15 }, bcurve: { type: "bcurve_1_0_0", id: 16 }, circle: { type: "circle_1_0_0", id: 17 }, curve: { type: "curve_1_0_0", id: 18 }, ellipse: { type: "ellipse_1_0_0", id: 19 }, line: { type: "line_1_0_0", id: 20 }, attribute: { type: "attribute_1_0_0", id: 21 }, body: { type: "body_1_0_0", id: 22 }, coedge: { type: "coedge_1_0_0", id: 23 }, edge: { type: "edge_1_0_0", id: 24 }, face: { type: "face_1_0_0", id: 25 }, loop: { type: "loop_1_0_0", id: 26 }, lump: { type: "lump_1_0_0", id: 27 }, model: { type: "model_1_0_0", id: 28 }, shell: { type: "shell_1_0_0", id: 29 }, topology: { type: "topology_1_0_0", id: 30 }, vertex: { type: "vertex_1_0_0", id: 31 }, wire: { type: "wire_1_0_0", id: 32 }, wirebody: { type: "wirebody_1_0_0", id: 33 }, nmiattribute: { type: "nmiattribute_1_0_0", id: 34 }, nmiattributearr: { type: "nmiattributearr_1_0_0", id: 37 }, nmiattributestr: { type: "nmiattributestr_1_0_0", id: 35 }, textattribute: { type: "textattribute_1_0_0", id: 36 } } } } } } } });e.exports = o;}, function (e, t, r) {"use strict";e.exports = l;var n,o = r(10),i = o.LongBits,s = o.base64,a = o.utf8;function c(e, t, r) {this.fn = e, this.len = t, this.next = void 0, this.val = r;}function u() {}function l() {this.len = 0, this.head = new c(u, 0, 0), this.tail = this.head, this.states = null;}function h(e, t, r) {t[r] = 255 & e;}function d(e, t) {this.len = e, this.next = void 0, this.val = t;}function g(e, t, r) {for (; e.hi;) {t[r++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;}for (; e.lo > 127;) {t[r++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;}t[r++] = e.lo;}function p(e, t, r) {t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;}l.create = o.Buffer ? function () {return (l.create = function () {return new n();})();} : function () {return new l();}, l.alloc = function (e) {return new o.Array(e);}, o.Array !== Array && (l.alloc = o.pool(l.alloc, o.Array.prototype.subarray)), l.prototype._push = function (e, t, r) {return this.tail = this.tail.next = new c(e, t, r), this.len += t, this;}, d.prototype = Object.create(c.prototype), d.prototype.fn = function (e, t, r) {for (; e > 127;) {t[r++] = 127 & e | 128, e >>>= 7;}t[r] = e;}, l.prototype.uint32 = function (e) {return this.len += (this.tail = this.tail.next = new d((e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;}, l.prototype.int32 = function (e) {return e < 0 ? this._push(g, 10, i.fromNumber(e)) : this.uint32(e);}, l.prototype.sint32 = function (e) {return this.uint32((e << 1 ^ e >> 31) >>> 0);}, l.prototype.uint64 = function (e) {var t = i.from(e);return this._push(g, t.length(), t);}, l.prototype.int64 = l.prototype.uint64, l.prototype.sint64 = function (e) {var t = i.from(e).zzEncode();return this._push(g, t.length(), t);}, l.prototype.bool = function (e) {return this._push(h, 1, e ? 1 : 0);}, l.prototype.fixed32 = function (e) {return this._push(p, 4, e >>> 0);}, l.prototype.sfixed32 = l.prototype.fixed32, l.prototype.fixed64 = function (e) {var t = i.from(e);return this._push(p, 4, t.lo)._push(p, 4, t.hi);}, l.prototype.sfixed64 = l.prototype.fixed64, l.prototype.float = function (e) {return this._push(o.float.writeFloatLE, 4, e);}, l.prototype.double = function (e) {return this._push(o.float.writeDoubleLE, 8, e);};var f = o.Array.prototype.set ? function (e, t, r) {t.set(e, r);} : function (e, t, r) {for (var n = 0; n < e.length; ++n) {t[r + n] = e[n];}};l.prototype.bytes = function (e) {var t = e.length >>> 0;if (!t) return this._push(h, 1, 0);if (o.isString(e)) {var r = l.alloc(t = s.length(e));s.decode(e, r, 0), e = r;}return this.uint32(t)._push(f, t, e);}, l.prototype.string = function (e) {var t = a.length(e);return t ? this.uint32(t)._push(a.write, t, e) : this._push(h, 1, 0);}, l.prototype.fork = function () {return this.states = new function (e) {this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;}(this), this.head = this.tail = new c(u, 0, 0), this.len = 0, this;}, l.prototype.reset = function () {return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new c(u, 0, 0), this.len = 0), this;}, l.prototype.ldelim = function () {var e = this.head,t = this.tail,r = this.len;return this.reset().uint32(r), r && (this.tail.next = e.next, this.tail = t, this.len += r), this;}, l.prototype.finish = function () {for (var e = this.head.next, t = this.constructor.alloc(this.len), r = 0; e;) {e.fn(e.val, t, r), r += e.len, e = e.next;}return t;}, l._configure = function (e) {n = e;};}, function (e, t, r) {"use strict";e.exports = c;var n,o = r(10),i = o.LongBits,s = o.utf8;function a(e, t) {return RangeError("index out of range: " + e.pos + " + " + (t || 1) + " > " + e.len);}function c(e) {this.buf = e, this.pos = 0, this.len = e.length;}var u = "undefined" != typeof Uint8Array ? function (e) {if (e instanceof Uint8Array || Array.isArray(e)) return new c(e);throw Error("illegal buffer");} : function (e) {if (Array.isArray(e)) return new c(e);throw Error("illegal buffer");};function l() {var e = new i(0, 0),t = 0;if (!(this.len - this.pos > 4)) {for (; t < 3; ++t) {if (this.pos >= this.len) throw a(this);if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;}return e.lo = (e.lo | (127 & this.buf[this.pos++]) << 7 * t) >>> 0, e;}for (; t < 4; ++t) {if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;}if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e.hi = (e.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e;if (t = 0, this.len - this.pos > 4) {for (; t < 5; ++t) {if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;}} else for (; t < 5; ++t) {if (this.pos >= this.len) throw a(this);if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;}throw Error("invalid varint encoding");}function h(e, t) {return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;}function d() {if (this.pos + 8 > this.len) throw a(this, 8);return new i(h(this.buf, this.pos += 4), h(this.buf, this.pos += 4));}c.create = o.Buffer ? function (e) {return (c.create = function (e) {return o.Buffer.isBuffer(e) ? new n(e) : u(e);})(e);} : u, c.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, c.prototype.uint32 = function () {var e = 4294967295;return function () {if (e = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return e;if ((this.pos += 5) > this.len) throw this.pos = this.len, a(this, 10);return e;};}(), c.prototype.int32 = function () {return 0 | this.uint32();}, c.prototype.sint32 = function () {var e = this.uint32();return e >>> 1 ^ -(1 & e) | 0;}, c.prototype.bool = function () {return 0 !== this.uint32();}, c.prototype.fixed32 = function () {if (this.pos + 4 > this.len) throw a(this, 4);return h(this.buf, this.pos += 4);}, c.prototype.sfixed32 = function () {if (this.pos + 4 > this.len) throw a(this, 4);return 0 | h(this.buf, this.pos += 4);}, c.prototype.float = function () {if (this.pos + 4 > this.len) throw a(this, 4);var e = o.float.readFloatLE(this.buf, this.pos);return this.pos += 4, e;}, c.prototype.double = function () {if (this.pos + 8 > this.len) throw a(this, 4);var e = o.float.readDoubleLE(this.buf, this.pos);return this.pos += 8, e;}, c.prototype.bytes = function () {var e = this.uint32(),t = this.pos,r = this.pos + e;if (r > this.len) throw a(this, e);return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t, r) : t === r ? new this.buf.constructor(0) : this._slice.call(this.buf, t, r);}, c.prototype.string = function () {var e = this.bytes();return s.read(e, 0, e.length);}, c.prototype.skip = function (e) {if ("number" == typeof e) {if (this.pos + e > this.len) throw a(this, e);this.pos += e;} else do {if (this.pos >= this.len) throw a(this);} while (128 & this.buf[this.pos++]);return this;}, c.prototype.skipType = function (e) {switch (e) {case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for (; 4 != (e = 7 & this.uint32());) {this.skipType(e);}break;case 5:this.skip(4);break;default:throw Error("invalid wire type " + e + " at offset " + this.pos);}return this;}, c._configure = function (e) {n = e;var t = o.Long ? "toLong" : "toNumber";o.merge(c.prototype, { int64: function int64() {return l.call(this)[t](!1);}, uint64: function uint64() {return l.call(this)[t](!0);}, sint64: function sint64() {return l.call(this).zzDecode()[t](!1);}, fixed64: function fixed64() {return d.call(this)[t](!0);}, sfixed64: function sfixed64() {return d.call(this)[t](!1);} });};}, function (e, t, r) {"use strict";e.exports = s;var n = r(21);((s.prototype = Object.create(n.prototype)).constructor = s).className = "OneOf";var o = r(22),i = r(5);function s(e, t, r, o) {if (Array.isArray(t) || (r = t, t = void 0), n.call(this, e, r), void 0 !== t && !Array.isArray(t)) throw TypeError("fieldNames must be an Array");this.oneof = t || [], this.fieldsArray = [], this.comment = o;}function a(e) {if (e.parent) for (var t = 0; t < e.fieldsArray.length; ++t) {e.fieldsArray[t].parent || e.parent.add(e.fieldsArray[t]);}}s.fromJSON = function (e, t) {return new s(e, t.oneof, t.options, t.comment);}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject(["options", this.options, "oneof", this.oneof, "comment", t ? this.comment : void 0]);}, s.prototype.add = function (e) {if (!(e instanceof o)) throw TypeError("field must be a Field");return e.parent && e.parent !== this.parent && e.parent.remove(e), this.oneof.push(e.name), this.fieldsArray.push(e), e.partOf = this, a(this), this;}, s.prototype.remove = function (e) {if (!(e instanceof o)) throw TypeError("field must be a Field");var t = this.fieldsArray.indexOf(e);if (t < 0) throw Error(e + " is not a member of " + this);return this.fieldsArray.splice(t, 1), (t = this.oneof.indexOf(e.name)) > -1 && this.oneof.splice(t, 1), e.partOf = null, this;}, s.prototype.onAdd = function (e) {n.prototype.onAdd.call(this, e);for (var t = 0; t < this.oneof.length; ++t) {var r = e.get(this.oneof[t]);r && !r.partOf && (r.partOf = this, this.fieldsArray.push(r));}a(this);}, s.prototype.onRemove = function (e) {for (var t, r = 0; r < this.fieldsArray.length; ++r) {(t = this.fieldsArray[r]).parent && t.parent.remove(t);}n.prototype.onRemove.call(this, e);}, s.d = function () {for (var e = new Array(arguments.length), t = 0; t < arguments.length;) {e[t] = arguments[t++];}return function (t, r) {i.decorateType(t.constructor).add(new s(r, e)), Object.defineProperty(t, r, { get: i.oneOfGetter(e), set: i.oneOfSetter(e) });};};}, function (e, t, r) {"use strict";e.exports = o;var n = r(10);function o(e) {if (e) for (var t = Object.keys(e), r = 0; r < t.length; ++r) {this[t[r]] = e[t[r]];}}o.create = function (e) {return this.$type.create(e);}, o.encode = function (e, t) {return this.$type.encode(e, t);}, o.encodeDelimited = function (e, t) {return this.$type.encodeDelimited(e, t);}, o.decode = function (e) {return this.$type.decode(e);}, o.decodeDelimited = function (e) {return this.$type.decodeDelimited(e);}, o.verify = function (e) {return this.$type.verify(e);}, o.fromObject = function (e) {return this.$type.fromObject(e);}, o.toObject = function (e, t) {return this.$type.toObject(e, t);}, o.prototype.toJSON = function () {return this.$type.toObject(this, n.toJSONOptions);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TessellationCache = t.CurveTessellator = void 0;var n = r(1),o = r(0),i = r(3),s = r(8),a = { getCircularArcRenderPoints: function getCircularArcRenderPoints(e, t, r, n, o) {var i = e.getRadius(),s = 2 * Math.acos((i - r) / i),a = t[1] - t[0],c = Math.ceil(a / s),u = 0;for (!1 === n && u++; u <= c; ++u) {var l = u / c,h = t[0] * (1 - l) + t[1] * l;o.push(e.evaluatePosition(h));}return i * (1 - Math.cos(a / c * .5));}, getAdaptiveRenderPoints: function getAdaptiveRenderPoints(e, t, r, i) {for (var a = t || .001, c = a * a, u = [], l = [], h = n.Vector3.createFloat64(), d = 0, g = function g(t, r, i, a, p) {var f = i - t,v = .5 * (t + i),_ = e.evaluatePosition(v);n.Vector3.scaleAndAdd(h, [0, 0, 0], r, .5), n.Vector3.scaleAndAdd(h, h, a, .5);var y = n.Vector3.squaredDistance(h, _);if (p > 64) s.DebugUtils.warn("Max recursion depth reach in getAdaptiveRenderPoints");else if (f > 10 * o.PARAMETER_SPACE_TOLERANCE && y > c) return g(t, r, v, _, p + 1), void g(v, _, i, a, p + 1);d = Math.max(d, y), u.push(r), l.push(t);}, p = i || function (e, t, r) {for (var n = new Array(7), o = t, i = (r - t) / 6, s = 0; s < 7; s++) {var a = o;s > 0 && s < 6 && (a += Math.sin(s) * i * .1), n[s] = a, o += i;}return n;}(0, r[0], r[1]), f = 0; f < p.length - 1; ++f) {var v = p[f],_ = p[f + 1],y = e.evaluatePosition(v),m = e.evaluatePosition(_);g(v, y, _, m, 0), f === p.length - 2 && (u.push(m), l.push(_));}return { positions: u, params: l, tolerance: Math.sqrt(d) };} },c = function c() {this._hasDirtyTessellation = !0, this._tessellationCache = void 0, this._trimmedTessellationCache = { positions: void 0, offsets: void 0, transitions: [1, -1] };};c.prototype.setDirty = function (e) {this._hasDirtyTessellation = e;}, c.prototype.isDirty = function () {return this._hasDirtyTessellation;}, c.prototype.reset = function () {this._hasDirtyTessellation = !0, this._tessellationCache = void 0, this._trimmedTessellationCache = { positions: void 0, offsets: void 0, transitions: [1, -1] };}, c.prototype.setCache = function (e) {this._tessellationCache = e, this._hasDirtyTessellation = !1;}, c.prototype.getCache = function () {return this._tessellationCache;}, c.prototype.getTolerance = function () {if (this._tessellationCache) return this._tessellationCache.tolerance;}, c.prototype.getTessellation = function (e, t, r, s) {var a = !1;if (!1 === this._hasDirtyTessellation && this._tessellationCache.tolerance > r + n.FLOAT64_TOLERANCE && (this._hasDirtyTessellation = !0), this._hasDirtyTessellation) {this._hasDirtyTessellation = !1;var c = s(r);this._tessellationCache = { positions: c.positions, params: c.params, tolerance: c.tolerance }, a = c.didRetessellate;}var u = [e[0], e[e.length - 1]],l = 0,h = t.getRangeUnlimited();t.isPeriodicUnlimited() && (l = (u = (0, i.normalizeParametricRangeToShiftedRange)(u, h))[0] - e[0]);var d = this._trimmedTessellationCache,g = d.transitions[0] - u[0],p = d.transitions[d.transitions.length - 1] - u[1],f = g * g + p * p < n.FLOAT64_TOLERANCE;if (f && e.length > 2) {f = d.transitions.length === e.length;for (var v = 1; f && v < e.length - 1; ++v) {f = d.transitions[v - 1] === e[v - 1] + l;}}if (!f || a) {var _;for (d.transitions.length = e.length, _ = 0; _ < e.length; ++_) {d.transitions[_] = e[_] + l;}d.positions = [t.evaluatePosition(e[0])], d.offsets = [0];var y,m,E = 1,x = u[0];for (_ = 1; _ < e.length; _++) {var R = e[_] + l;for (m = 0; m < this._tessellationCache.positions.length; m++) {if ((y = this._tessellationCache.params[m]) > x + o.PARAMETER_SPACE_TOLERANCE) {if (y >= R - o.PARAMETER_SPACE_TOLERANCE) break;n.Vector3.sqrDist(d.positions[E - 1], this._tessellationCache.positions[m]) > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (d.positions[E++] = n.Vector3.clone(this._tessellationCache.positions[m]));}}if (t.isPeriodicUnlimited() && R > h[1]) for (m = 1; m < this._tessellationCache.positions.length && (y = this._tessellationCache.params[m]) < R - (h[1] - h[0]) - o.PARAMETER_SPACE_TOLERANCE; m++) {n.Vector3.sqrDist(d.positions[E - 1], this._tessellationCache.positions[m]) > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (d.positions[E++] = n.Vector3.clone(this._tessellationCache.positions[m]));}var A = t.evaluatePosition(R);n.Vector3.sqrDist(d.positions[E - 1], A) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && E > d.offsets[d.offsets.length - 1] + 1 && E--, d.positions[E++] = A, d.offsets.push(d.positions.length - 1), x = R;}}return { positions: d.positions, offsets: d.offsets, tolerance: this._tessellationCache.tolerance };}, t.CurveTessellator = a, t.TessellationCache = c;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Cone = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(6),c = r(7),u = r(14),l = r(2),h = function h() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._angle = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(h.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.CONE;}, h.prototype.clone = function () {var e = new h();return e.copy(this), e;}, h.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, this._angle = e._angle, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, h.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, h.prototype.set = function (e, t, r, o, s, a) {n.Vector3.copy(this._center, e), l.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t, l.ConsoleUtils.assert(n.Vector3.squaredLength(r) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, r), l.ConsoleUtils.assert(Math.abs(o) < Math.PI / 2), this._angle = o, void 0 !== s && n.Vector3.squaredLength(s) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (l.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, s, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, s)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._uScale = a || 1, l.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, h.prototype.getRadius = function () {return this._radius;}, h.prototype.setRadius = function (e) {l.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, h.prototype.getCenter = function () {return this._center;}, h.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, h.prototype.getAxisDir = function () {return this._zAxis;}, h.prototype.setAxisDir = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, h.prototype.getUvOriginDir = function () {return this._xAxis;}, h.prototype.setUvOriginDir = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, h.prototype.getUScale = function () {return this._uScale;}, h.prototype.setUScale = function (e) {l.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, h.prototype.getAngle = function () {return this._angle;}, h.prototype.setAngle = function (e) {l.ConsoleUtils.assert(Math.abs(e) < Math.PI / 2 - i.KERNEL_ANGULAR_TOLERANCE), this._angle = e;}, h.prototype.isCylinder = function () {return Math.abs(this._angle) < i.KERNEL_ANGULAR_TOLERANCE;}, h.prototype.getApexParam = function () {return this.isCylinder() ? void 0 : -this._radius / (this._uScale * Math.sin(this._angle));}, h.prototype.getApexPosition = function () {if (!this.isCylinder()) {var e = -this._radius / Math.tan(this._angle),t = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(t, t, this._zAxis, e), t;}}, h.prototype.evaluatePosition = function (e, t) {var r = this._radius + e * this._uScale * Math.sin(this._angle),o = r * Math.cos(t),i = r * Math.sin(t),s = e * this._uScale * Math.cos(this._angle),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, h.prototype.evaluateNormal = function (e, t) {var r = Math.sin(this._angle),o = Math.cos(this._angle),i = o * Math.cos(t),s = o * Math.sin(t),a = -r,c = n.Vector3.createFloat64();return n.Vector3.scale(c, this._xAxis, i), n.Vector3.scaleAndAdd(c, c, this._yAxis, s), n.Vector3.scaleAndAdd(c, c, this._zAxis, a), c;}, h.prototype.evaluateDu = function (e, t) {var r = this._uScale * Math.sin(this._angle),o = r * Math.cos(t),i = r * Math.sin(t),s = this._uScale * Math.cos(this._angle),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, h.prototype.evaluateDv = function (e, t) {var r = this._radius + e * this._uScale * Math.sin(this._angle),o = -r * Math.sin(t),i = r * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, h.prototype.closestParam = function (e) {var t = Math.sin(this._angle),r = Math.cos(this._angle),o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center);var s = n.Vector3.dot(o, this._xAxis),a = n.Vector3.dot(o, this._yAxis),c = n.Vector3.dot(o, this._zAxis),u = Math.sqrt(s * s + a * a),l = this.getApexParam();if (void 0 !== l) {var h = l * this._uScale * r;(h > 0 && c > h || h < 0 && c < h) && (s = -s, a = -a, u = -u);}return { u: ((u - this._radius) * t + c * r) / this._uScale, v: Math.abs(u) > i.KERNEL_TOLERANCE ? Math.atan2(a, s) : 0 };}, h.prototype.vParamLine = function (e) {var t = this._radius + e * this._uScale * Math.sin(this._angle);if (Math.abs(t) > i.KERNEL_TOLERANCE) {var r = new u.Circle(),o = n.Vector3.clone(this._center),s = e * this._uScale * Math.cos(this._angle);n.Vector3.scaleAndAdd(o, o, this._zAxis, s);var c = n.Vector3.clone(this._xAxis);n.Vector3.scale(c, c, t);var l = n.Vector3.clone(this._zAxis);return n.Vector3.negate(l, l), r.set(o, l, c), r;}return new a.Point(this.getApexPosition());}, h.prototype.uParamLine = function (e) {var t = new c.Line(),r = n.Vector3.clone(this._center),o = this._radius * Math.cos(e),i = this._radius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, h.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, h.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, h.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, h.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, h.prototype.isPeriodicUnlimitedU = function () {return !1;}, h.prototype.isPeriodicUnlimitedV = function () {return !0;}, h.prototype.isClosedUnlimitedU = function () {return !1;}, h.prototype.isClosedUnlimitedV = function () {return !0;}, h.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), angle: this.getAngle(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Cone = h;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.EllipticalCone = void 0;var n = r(1),o = r(4),i = r(35),s = r(0),a = r(12),c = r(6),u = r(7),l = r(23),h = r(2),d = function d() {a.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._angle = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(d.prototype = Object.create(a.Surface.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.ELLIPTICAL_CONE;}, d.prototype.clone = function () {var e = new d();return e.copy(this), e;}, d.prototype.copy = function (e) {a.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._angle = e._angle, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, d.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, d.prototype.set = function (e, t, r, o, i, a) {n.Vector3.copy(this._center, e), this._majorRadius = n.Vector3.length(t), h.ConsoleUtils.assert(this._majorRadius > s.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, t), h.ConsoleUtils.assert(r <= 1), this._minorRadius = r * this._majorRadius, h.ConsoleUtils.assert(this._minorRadius > s.KERNEL_TOLERANCE), h.ConsoleUtils.assert(n.Vector3.squaredLength(o) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), h.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, t, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._zAxis, o), h.ConsoleUtils.assert(Math.abs(i) < Math.PI / 2), this._angle = i, this._uScale = a || 1, h.ConsoleUtils.assert(this._uScale > s.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, d.prototype.getMajorRadius = function () {return this._majorRadius;}, d.prototype.setMajorRadius = function (e) {h.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._majorRadius = e;}, d.prototype.getMinorRadius = function () {return this._minorRadius;}, d.prototype.setMinorRadius = function (e) {h.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._minorRadius = e;}, d.prototype.getMajorAxis = function () {return this._xAxis;}, d.prototype.setMajorAxis = function (e) {h.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, d.prototype.getCenter = function () {return this._center;}, d.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, d.prototype.getAxisDir = function () {return this._zAxis;}, d.prototype.setAxisDir = function (e) {h.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), this._computeYAxis();}, d.prototype.getUScale = function () {return this._uScale;}, d.prototype.setUScale = function (e) {h.ConsoleUtils.assert(e > s.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, d.prototype.getAngle = function () {return this._angle;}, d.prototype.setAngle = function (e) {h.ConsoleUtils.assert(Math.abs(e) < Math.PI / 2 - s.KERNEL_ANGULAR_TOLERANCE), this._angle = e;}, d.prototype.isCylinder = function () {return Math.abs(this._angle) < s.KERNEL_ANGULAR_TOLERANCE;}, d.prototype.getApexParam = function () {return this.isCylinder() ? void 0 : -this._majorRadius / (this._uScale * Math.sin(this._angle));}, d.prototype.getApexPosition = function () {if (!this.isCylinder()) {var e = -this._majorRadius / Math.tan(this._angle),t = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(t, t, this._zAxis, e), t;}}, d.prototype.evaluatePosition = function (e, t) {var r = 1 + e * this._uScale * Math.sin(this._angle) / this._majorRadius,o = r * this._majorRadius * Math.cos(t),i = r * this._minorRadius * Math.sin(t),s = e * this._uScale * Math.cos(this._angle),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, d.prototype.evaluateNormal = function (e, t) {var r = Math.cos(this._angle),o = r * this._minorRadius * Math.cos(t),i = r * this._majorRadius * Math.sin(t),s = -Math.sin(this._angle) * this._minorRadius,a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), n.Vector3.normalize(a, a), a;}, d.prototype.evaluateDu = function (e, t) {var r = this._uScale * Math.sin(this._angle) / this._majorRadius,o = r * this._majorRadius * Math.cos(t),i = r * this._minorRadius * Math.sin(t),s = this._uScale * Math.cos(this._angle),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, d.prototype.evaluateDv = function (e, t) {var r = 1 + e * this._uScale * Math.sin(this._angle) / this._majorRadius,o = -r * this._majorRadius * Math.sin(t),i = r * this._minorRadius * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, d.prototype.closestParam = function (e) {var t, r;if (this.isCylinder()) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center), t = n.Vector3.dot(o, this._zAxis) / this._uScale, r = this.vParamLine(t).closestToPointParam(e);} else {var a = n.Vector3.createFloat64();n.Vector3.sub(a, e, this.getApexPosition());var c = n.Vector3.dot(a, this._xAxis),u = n.Vector3.dot(a, this._yAxis),l = n.Vector3.dot(a, this._zAxis),h = this._uScale * Math.sin(this._angle),d = h * this._minorRadius / this._majorRadius,g = this._uScale * Math.cos(this._angle),p = this._majorRadius / h,f = function (e, t, r, o, a, c) {if (o * o + a * a + c * c < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) return { u: 0, v: 0 };var u = n.FLOAT64_TOLERANCE,l = c * e >= 0 ? 1 : -1,h = (o * l >= 0 ? .25 : .75) * (a * l >= 0 ? 1 : -1),d = h * Math.PI,g = [(h - .25) * Math.PI, (h + .25) * Math.PI],p = (0, i.newtonRaphson1D)(function (n) {var i = Math.sin(n),s = Math.cos(n),u = e * (t * t + r * r) * o,l = t * (e * e + r * r) * a,h = r * (e * e - t * t) * c;return { val: u * i - l * s - h * i * s, deriv: u * s + l * i - h * (s * s - i * i) };}, g, d, u, 32),f = e * Math.cos(p),v = t * Math.sin(p);return { u: (f * o + v * a + r * c) / (f * f + v * v + r * r), v: p };}(h, d, g, c, u, l);t = f.u - p, r = f.v;}return { u: t, v: r };}, d.prototype.vParamLine = function (e) {var t = this._majorRadius + e * this._uScale * Math.sin(this._angle);if (Math.abs(t) > s.KERNEL_TOLERANCE) {var r = new l.Ellipse(),o = n.Vector3.clone(this._center),i = e * this._uScale * Math.cos(this._angle);n.Vector3.scaleAndAdd(o, o, this._zAxis, i);var a = n.Vector3.clone(this._xAxis);n.Vector3.scale(a, a, t);var u = n.Vector3.clone(this._zAxis);return n.Vector3.negate(u, u), r.set(o, u, a, this._minorRadius / this._majorRadius), r;}return new c.Point(this.getApexPosition());}, d.prototype.uParamLine = function (e) {var t = new u.Line(),r = n.Vector3.clone(this._center),o = this._majorRadius * Math.cos(e),i = this._minorRadius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, d.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, d.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, d.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, d.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, d.prototype.isPeriodicUnlimitedU = function () {return !1;}, d.prototype.isPeriodicUnlimitedV = function () {return !0;}, d.prototype.isClosedUnlimitedU = function () {return !1;}, d.prototype.isClosedUnlimitedV = function () {return !0;}, d.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), angle: this.getAngle(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.EllipticalCone = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BSurface = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(33),c = r(3),u = r(76),l = r(103),h = r(104),d = r(105),g = r(77),p = r(2),f = function f() {s.Surface.call(this), this._uDegree = 0, this._vDegree = 0, this._uKnots = [], this._vKnots = [], this._controlPoints = [], this._weights = [], this._isClosedU = void 0, this._isClosedV = void 0, this._isPeriodicU = void 0, this._isPeriodicV = void 0, this._patches = void 0;};(f.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.BSURFACE;}, f.prototype.clone = function () {var e = new f();return e.copy(this), e;}, f.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._uDegree = e._uDegree, this._vDegree = e._vDegree, this._uKnots = e._uKnots.slice(0), this._vKnots = e._vKnots.slice(0), this._controlPoints = e._controlPoints.slice(0), this._weights = e._weights.slice(0), this._clearCaches();}, f.prototype.set = function (e, t, r, n, o, i) {p.ConsoleUtils.assert(e >= 1), this._uDegree = e, p.ConsoleUtils.assert(t >= 1), this._vDegree = t, p.ConsoleUtils.assert(r.length >= 2 * (e + 1)), this._uKnots = Array.prototype.slice.call(r), p.ConsoleUtils.assert(n.length >= 2 * (t + 1)), this._vKnots = Array.prototype.slice.call(n);var s = r.length - e - 1,a = n.length - t - 1;p.ConsoleUtils.assert(o.length === 3 * s * a), this._controlPoints = Array.prototype.slice.call(o), i && i.length > 0 ? (p.ConsoleUtils.assert(i.length === s * a), this._weights = Array.prototype.slice.call(i)) : this._weights = [], this._clearCaches();}, f.prototype.getDegreeU = function () {return this._uDegree;}, f.prototype.getDegreeV = function () {return this._vDegree;}, f.prototype.setDegreeU = function (e) {p.ConsoleUtils.assert(e >= 1), this._uDegree = e, this._clearCaches();}, f.prototype.setDegreeV = function (e) {p.ConsoleUtils.assert(e >= 1), this._vDegree = e, this._clearCaches();}, f.prototype.getNumKnotsU = function () {return this._uKnots.length;}, f.prototype.getNumKnotsV = function () {return this._vKnots.length;}, f.prototype.getKnotsU = function () {return this._uKnots;}, f.prototype.getKnotsV = function () {return this._vKnots;}, f.prototype.setKnotsU = function (e) {this._uKnots = e, this._clearCaches();}, f.prototype.setKnotsV = function (e) {this._vKnots = e, this._clearCaches();}, f.prototype.getNumControlPointsU = function () {return this._uKnots.length - this._uDegree - 1;}, f.prototype.getNumControlPointsV = function () {return this._vKnots.length - this._vDegree - 1;}, f.prototype.getControlPoints = function () {return this._controlPoints;}, f.prototype.setControlPoints = function (e) {this._controlPoints = e, this._clearCaches();}, f.prototype.getWeights = function () {return this._weights;}, f.prototype.setWeights = function (e) {e && e.length > 0 ? this._weights = e : this._weights = [], this._clearCaches();}, f.prototype.isRational = function () {return this._weights.length > 0;}, f.prototype.evaluate = function (e, t, r, n, o) {p.ConsoleUtils.assert(r >= 0), this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV()));var i = (0, u.evaluateBSurfaceDerivs)(e, t, Math.min(r, 3), this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),s = { pos: i[0][0] };return r >= 1 && (s.du = i[1][0], s.dv = i[0][1]), r >= 2 && (s.duu = i[2][0], s.duv = i[1][1], s.dvv = i[0][2]), r >= 3 && (s.duuu = i[3][0], s.duuv = i[2][1], s.duvv = i[1][2], s.dvvv = i[0][3]), s;}, f.prototype.evaluatePosition = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfacePoint)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);}, f.prototype.evaluateNormal = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), s.Surface.prototype.evaluateNormal.call(this, e, t);}, f.prototype.evaluateDu = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfaceDerivs)(e, t, 1, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights)[1][0];}, f.prototype.evaluateDv = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfaceDerivs)(e, t, 1, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights)[0][1];}, f.prototype.insertKnotU = function (e, t) {var r = (0, l.insertBSurfaceKnotU)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._uKnots = r.uknots, this._controlPoints = r.P, this._weights = r.weights || [], this._clearCaches();}, f.prototype.insertKnotV = function (e, t) {var r = (0, l.insertBSurfaceKnotV)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._vKnots = r.vknots, this._controlPoints = r.P, this._weights = r.weights || [], this._clearCaches();}, f.prototype.relaxToPerpendicular = function (e, t, r, o, i, s, a) {var c = this;o && 0 !== o.length || (o = this.getRangeU()), i && 0 !== i.length || (i = this.getRangeV());var u = (0, g.newtonRaphson2D)(function (t) {var r = c.evaluate(t[0], t[1], 2);n.Vector3.sub(r.pos, r.pos, e);var o = n.Vector3.dot(r.du, r.pos),i = n.Vector3.dot(r.dv, r.pos),s = n.Vector3.dot(r.duu, r.pos) + n.Vector3.dot(r.du, r.du),a = n.Vector3.dot(r.duv, r.pos) + n.Vector3.dot(r.du, r.dv);return { val: [o, i], deriv1: [s, a], deriv2: [a, n.Vector3.dot(r.dvv, r.pos) + n.Vector3.dot(r.dv, r.dv)] };}, [t, r], [o, i]);return { u: u.param[0], v: u.param[1], status: u.status };}, f.prototype.closestParam = function (e) {for (var t = n.FLOAT64_TOLERANCE, r = [[this.getRangeU(), this.getRangeV()]], o = this.getBezierPatches(), i = (0, d.closestBSurfacePatches)(e, o, r), s = Number.POSITIVE_INFINITY, a = { u: void 0, v: void 0 }, u = 0; u < i.length; ++u) {if (!(i[u].minDistSqr > s)) for (var l = i[u].index, h = o[l[0]][l[1]], g = h.getRangeUnlimitedU(), p = h.getRangeUnlimitedV(), f = 0; f < r.length; ++f) {var v = [Math.max(g[0], r[f][0][0]), Math.min(g[1], r[f][0][1])],_ = [Math.max(p[0], r[f][1][0]), Math.min(p[1], r[f][1][1])];if (!(v[1] - v[0] <= n.FLOAT64_TOLERANCE || _[1] - _[0] <= n.FLOAT64_TOLERANCE)) {var y = (0, d.closestBSurfacePointApprox)(e, h.getDegreeU(), h.getDegreeV(), h.getKnotsU(), h.getKnotsV(), h.getControlPoints(), h.isRational() ? h.getWeights() : void 0, v, _),m = this.relaxToPerpendicular(e, y.u, y.v, v, _, t, 64),E = h.evaluatePosition(m.u, m.v),x = n.Vector3.squaredDistance(E, e);x < s && (s = x, a.u = m.u, a.v = m.v);}}}return this.isPeriodicUnlimitedU() && (a.u = (0, c.foldNearTo)(a.u, .5 * (this.getRangeU()[0] + this.getRangeU()[1]), this.getPeriodUnlimitedU())), this.isPeriodicUnlimitedV() && (a.v = (0, c.foldNearTo)(a.v, .5 * (this.getRangeV()[0] + this.getRangeV()[1]), this.getPeriodUnlimitedV())), a;}, f.prototype.vParamLine = function (e) {var t = (0, l.extractBSurfaceParamLineV)(e, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),r = t.ctrlPts.length / 3;t.weights && 0 !== t.weights.length || (t.weights = new Array(r), t.weights.fill(1));var n = new a.BCurve();return n.set(t.ctrlPts, t.weights, this._vDegree, this._vKnots), n;}, f.prototype.uParamLine = function (e) {var t = (0, l.extractBSurfaceParamLineU)(e, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),r = t.ctrlPts.length / 3;t.weights && 0 !== t.weights.length || (t.weights = new Array(r), t.weights.fill(1));var n = new a.BCurve();return n.set(t.ctrlPts, t.weights, this._uDegree, this._uKnots), n;}, f.prototype.getBoundingBox = function (e, t) {for (var r = new o.BoundingBox(), i = n.Vector3.createFloat64(), s = 0; s < this._controlPoints.length; s += 3) {n.Vector3.set(i, this._controlPoints[s], this._controlPoints[s + 1], this._controlPoints[s + 2]), r.includePoint(i);}return r;}, f.prototype.transform = function (e) {for (var t = n.Vector3.createFloat64(), r = 0; r < this._controlPoints.length; r += 3) {n.Vector3.set(t, this._controlPoints[r], this._controlPoints[r + 1], this._controlPoints[r + 2]), n.Vector3.transformMatrix44(t, t, e), this._controlPoints[r] = t[0], this._controlPoints[r + 1] = t[1], this._controlPoints[r + 2] = t[2];}this._clearCaches();}, f.prototype.getRangeUnlimitedU = function () {return [this._uKnots[0], this._uKnots[this._uKnots.length - 1]];}, f.prototype.getRangeUnlimitedV = function () {return [this._vKnots[0], this._vKnots[this._vKnots.length - 1]];}, f.prototype.isPeriodicUnlimitedU = function () {return this._checkClosure(), this._isPeriodicU;}, f.prototype.isPeriodicUnlimitedV = function () {return this._checkClosure(), this._isPeriodicV;}, f.prototype.isClosedUnlimitedU = function () {return this._checkClosure(), this._isClosedU;}, f.prototype.isClosedUnlimitedV = function () {return this._checkClosure(), this._isClosedV;}, f.prototype._checkClosure = function () {void 0 !== this._isClosedU && void 0 !== this._isPeriodicU || (this._isClosedU = this._isPeriodicU = !1), void 0 !== this._isClosedV && void 0 !== this._isPeriodicV || (this._isClosedV = this._isPeriodicV = !1);}, f.prototype.isSimpleBezier = function () {return this._uKnots.length === 2 * this._uDegree + 2 && this._vKnots.length === 2 * this._vDegree + 2;}, f.prototype.getBezierPatches = function () {if (this.isSimpleBezier()) return this._patches = void 0, [[this]];if (!this._patches) {var e = (0, h.decomposeBSurfaceToBezier)(this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._patches = [];for (var t = 0; t < e.U.length; ++t) {this._patches[t] = [];for (var r = 0; r < e.V.length; ++r) {var n = new f();n.set(this._uDegree, this._vDegree, e.U[t], e.V[r], e.P[t][r], e.w ? e.w[t][r] : void 0), this._patches[t][r] = n;}}}return this._patches;}, f.prototype._clearCaches = function () {this._isClosedU = void 0, this._isClosedV = void 0, this._isPeriodicU = void 0, this._isPeriodicV = void 0, this._patches = void 0;}, f.prototype.toObject = function () {return { uDegree: this._uDegree, vDegree: this._vDegree, uKnots: this._uKnots, vKnots: this._vKnots, controlPoints: this._controlPoints, weights: this._weights, uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.BSurface = f;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.WireBody = void 0;var n = r(9),o = r(0),i = r(4),s = r(19),a = function a() {n.BaseTopology.call(this), this._wires = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.WIREBODY;}, a.prototype.getWires = function () {return this._wires;}, a.prototype.setWires = function (e) {this._wires = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._wires[t] = e[t];}}, a.prototype.addWire = function (e) {this._wires ? this._wires.push(e) : this._wires = [e], e.setWireBody(this);}, a.prototype.addWires = function (e) {this._wires || (this._wires = []);for (var t = 0; t < e.length; ++t) {e[t].setWireBody(this);}this._wires = this._wires.concat(e);}, a.prototype.removeWire = function (e) {var t = this._wires.indexOf(e);return t > -1 && (this._wires.splice(t, 1), e.getWireBody() === this && e.setWireBody(void 0), !0);}, a.prototype.getBody = function () {return this;}, a.prototype.collectFaces = function (e) {return e || new Set();}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._wires.length; ++t) {this._wires[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._wires.length; ++t) {this._wires[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._wires.length; ++t) {e.include(this._wires[t].getBoundingBox());}return e;}, a.prototype.transform = function (e) {(0, s.transformTopology)(this, e);}, a.prototype.toString = function () {return "WireBody";}, a.prototype.toObject = function () {return { wires: this.refsToStrings(this._wires), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._wires, this._attributes]);}, t.WireBody = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TopologyCloner = void 0;var n = r(16),o = r(20),i = r(27),s = r(13),a = r(15),c = r(26),u = r(25),l = r(24),h = r(41),d = function d() {this._edgeMap = {}, this._vertexMap = {}, this._coedgeMap = {}, this._progenitorMap = new h.ProgenitorMap();};d.prototype.cloneVertex = function (e) {var t = this._vertexMap[e.getGuid()];return t || (t = new n.Vertex(e.getPoint().clone()), this._vertexMap[e.getGuid()] = t, t.setPrecision(e.getPrecision()), this._progenitorMap.addEntry(t, [e])), t;}, d.prototype.cloneEdge = function (e) {var t = this._edgeMap[e.getGuid()];return t || (t = new o.Edge(e.getCurve().clone()), this._edgeMap[e.getGuid()] = t, t.setReversed(e.isReversed()), t.setRange(e.getRange()), t.setStartVertex(this.cloneVertex(e.getStartVertex())), t.setEndVertex(this.cloneVertex(e.getEndVertex())), t.setPrecision(e.getPrecision()), this._progenitorMap.addEntry(t, [e])), t;}, d.prototype.cloneCoedge = function (e) {var t,r,n = new i.Coedge();this._coedgeMap[e.getGuid()] = n, n.setReversed(e.isReversed()), n.setEdge(this.cloneEdge(e.getEdge())), n.getEdge().setCoedge(n);for (var o = e.getPartner(); o;) {var s = this._coedgeMap[o.getGuid()];s && (t || (t = s), r = s, e.getEdge().getCoedge() === o && n.getEdge().setCoedge(s)), (o = o.getPartner()) === e && (o = void 0);}return t && r && (n.setPartner(t), r.setPartner(n)), this._progenitorMap.addEntry(n, [e]), n;}, d.prototype.cloneLoop = function (e) {for (var t = new s.Loop(), r = e.getCoedges(), n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = this.cloneCoedge(r[o]);}return t.addCoedges(n), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneFace = function (e) {for (var t = new a.Face(), r = e.getLoops(), n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = this.cloneLoop(r[o]);}return t.addLoops(n), t.setSurface(e.getSurface().clone()), t.setReversed(e.isReversed()), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneFaces = function (e) {for (var t = new Array(e.length), r = 0; r < e.length; ++r) {t[r] = this.cloneFace(e[r]);}return t;}, d.prototype.cloneShell = function (e) {var t = new c.Shell();return t.addFaces(this.cloneFaces(e.getFaces())), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneLump = function (e) {for (var t = new u.Lump(), r = e.getShells(), n = 0; n < r.length; ++n) {t.addShell(this.cloneShell(r[n]));}return this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneBody = function (e) {for (var t = new l.Body(), r = e.getLumps(), n = 0; n < r.length; ++n) {t.addLump(this.cloneLump(r[n]));}return this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.getProgenitorMap = function () {return this._progenitorMap;}, t.TopologyCloner = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = function n(e, t) {if (t < 1) return "";for (var r = ""; t > 1;) {1 & t && (r += e), t >>= 1, e += e;}return r + e;},o = { isInitialized: !1, rngA: 4027999010, rngB: 3993266363, rngC: 3605298456, rotl32: function rotl32(e, t) {return (e << t >>> 0 | e >>> 32 - t) >>> 0;}, initialize: function initialize(e, t) {return o.isInitialized && !t ? 0 : (o.isInitialized && (o.rngA = 4027999010, o.rngB = 3993266363, o.rngC = 3605298456), o.isInitialized = !0, void 0 !== e ? r = e : (r = new Date().getTime(), r ^= Math.floor(2147483647 * Math.random() + 1)), o.rngA += 2097151 & r, o.rngB += r >> 7 & 524287, o.rngC += r >> 13, r);var r;}, genRandUInt32: function genRandUInt32() {return o.rngA = ~(2911329625 * o.rngA), o.rngA = o.rotl32(o.rngA, 17), o.rngB = 4031235431 * o.rngB, o.rngB = o.rotl32(o.rngB, 15), o.rngC = 3286325185 - o.rotl32(o.rngC, 19), o.rngA + o.rngB ^ o.rngC;} },i = function i(e) {for (var t = "", r = 0; r < 4; r++) {var o = e[r].toString(16);t += n("0", 8 - o.length) + o;}return t.substr(0, 8) + "-" + t.substr(8, 4) + "-" + t.substr(12, 4) + "-" + t.substr(16, 4) + "-" + t.substr(20, 12);},s = function s(e, t) {var r = t;return void 0 === r && (r = new Uint32Array(4)), r[0] = parseInt("0x" + e.substr(0, 8), 16), r[1] = parseInt("0x" + e.substr(9, 4) + e.substr(14, 4), 16), r[2] = parseInt("0x" + e.substr(19, 4) + e.substr(24, 4), 16), r[3] = parseInt("0x" + e.substr(28, 8), 16), r;},a = function a(e, t) {var r = new Uint32Array(t);return r[0] += 2654435769, r[1] += 104395303, r[2] += 452930477, r[3] += 982451653, r[0] += e[3] << 6, r[1] += e[0] << 6, r[2] += e[1] << 6, r[3] += e[2] << 6, r[0] += e[2] >> 2, r[1] += e[3] >> 2, r[2] += e[0] >> 2, r[3] += e[1] >> 2, r[0] = 16777619 * (r[0] ^ e[1]) >>> 0, r[1] = 16777619 * (r[1] ^ e[2]) >>> 0, r[2] = 16777619 * (r[2] ^ e[3]) >>> 0, r[3] = 16777619 * (r[3] ^ e[0]) >>> 0, r;};o.initialize(), t.uint32x4ToGUID = i, t.guidToUint32x4 = s, t.generateGUID = function () {var e = new Uint32Array(4);return e[0] = o.genRandUInt32(), e[1] = o.genRandUInt32(), e[2] = o.genRandUInt32(), e[3] = o.genRandUInt32(), i(e);}, t.isGUID = function (e) {return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(e);}, t.combineGuids = function (e, t) {var r = s(e),n = s(t),o = a(r, n);return i(o);}, t.hashCombine4xUint32 = a;}, function (e, t) {var r;r = function () {return this;}();try {r = r || new Function("return this")();} catch (e) {"object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && (r = window);}e.exports = r;}, function (e, t, r) {"use strict";e.exports = function (e, t) {for (var r = new Array(arguments.length - 1), n = 0, o = 2, i = !0; o < arguments.length;) {r[n++] = arguments[o++];}return new Promise(function (o, s) {r[n] = function (e) {if (i) if (i = !1, e) s(e);else {for (var t = new Array(arguments.length - 1), r = 0; r < t.length;) {t[r++] = arguments[r];}o.apply(null, t);}};try {e.apply(t || null, r);} catch (e) {i && (i = !1, s(e));}});};}, function (module, exports, __webpack_require__) {"use strict";function inquire(moduleName) {try {var mod = eval("quire".replace(/^/, "re"))(moduleName);if (mod && (mod.length || Object.keys(mod).length)) return mod;} catch (e) {}return null;}module.exports = inquire;}, function (e, t, r) {"use strict";t.Service = r(98);}, function (e, t, r) {"use strict";e.exports = {};}, function (e, t, r) {"use strict";e.exports = function (e) {for (var t, r = i.codegen(["m", "w"], e.name + "$encode")("if(!w)")("w=Writer.create()"), a = e.fieldsArray.slice().sort(i.compareFieldsById), c = 0; c < a.length; ++c) {var u = a[c].resolve(),l = e._fieldsArray.indexOf(u),h = u.resolvedType instanceof n ? "int32" : u.type,d = o.basic[h];t = "m" + i.safeProp(u.name), u.map ? (r("if(%s!=null&&m.hasOwnProperty(%j)){", t, u.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", t)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (u.id << 3 | 2) >>> 0, 8 | o.mapKey[u.keyType], u.keyType), void 0 === d ? r("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", l, t) : r(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | d, h, t), r("}")("}")) : u.repeated ? (r("if(%s!=null&&%s.length){", t, t), u.packed && void 0 !== o.packed[h] ? r("w.uint32(%i).fork()", (u.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", t)("w.%s(%s[i])", h, t)("w.ldelim()") : (r("for(var i=0;i<%s.length;++i)", t), void 0 === d ? s(r, u, l, t + "[i]") : r("w.uint32(%i).%s(%s[i])", (u.id << 3 | d) >>> 0, h, t)), r("}")) : (u.optional && r("if(%s!=null&&m.hasOwnProperty(%j))", t, u.name), void 0 === d ? s(r, u, l, t) : r("w.uint32(%i).%s(%s)", (u.id << 3 | d) >>> 0, h, t));}return r("return w");};var n = r(11),o = r(31),i = r(5);function s(e, t, r, n) {return t.resolvedType.group ? e("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", r, n, (t.id << 3 | 3) >>> 0, (t.id << 3 | 4) >>> 0) : e("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", r, n, (t.id << 3 | 2) >>> 0);}}, function (e, t, r) {"use strict";e.exports = y;var n = r(30);((y.prototype = Object.create(n.prototype)).constructor = y).className = "Type";var o = r(11),i = r(48),s = r(22),a = r(64),c = r(65),u = r(49),l = r(47),h = r(46),d = r(5),g = r(62),p = r(67),f = r(68),v = r(69),_ = r(70);function y(e, t) {n.call(this, e, t), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null;}function m(e) {return e._fieldsById = e._fieldsArray = e._oneofsArray = null, delete e.encode, delete e.decode, delete e.verify, e;}Object.defineProperties(y.prototype, { fieldsById: { get: function get() {if (this._fieldsById) return this._fieldsById;this._fieldsById = {};for (var e = Object.keys(this.fields), t = 0; t < e.length; ++t) {var r = this.fields[e[t]],n = r.id;if (this._fieldsById[n]) throw Error("duplicate id " + n + " in " + this);this._fieldsById[n] = r;}return this._fieldsById;} }, fieldsArray: { get: function get() {return this._fieldsArray || (this._fieldsArray = d.toArray(this.fields));} }, oneofsArray: { get: function get() {return this._oneofsArray || (this._oneofsArray = d.toArray(this.oneofs));} }, ctor: { get: function get() {return this._ctor || (this.ctor = y.generateConstructor(this)());}, set: function set(e) {var t = e.prototype;t instanceof u || ((e.prototype = new u()).constructor = e, d.merge(e.prototype, t)), e.$type = e.prototype.$type = this, d.merge(e, u, !0), this._ctor = e;for (var r = 0; r < this.fieldsArray.length; ++r) {this._fieldsArray[r].resolve();}var n = {};for (r = 0; r < this.oneofsArray.length; ++r) {n[this._oneofsArray[r].resolve().name] = { get: d.oneOfGetter(this._oneofsArray[r].oneof), set: d.oneOfSetter(this._oneofsArray[r].oneof) };}r && Object.defineProperties(e.prototype, n);} } }), y.generateConstructor = function (e) {for (var t, r = d.codegen(["p"], e.name), n = 0; n < e.fieldsArray.length; ++n) {(t = e._fieldsArray[n]).map ? r("this%s={}", d.safeProp(t.name)) : t.repeated && r("this%s=[]", d.safeProp(t.name));}return r("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");}, y.fromJSON = function (e, t) {var r = new y(e, t.options);r.extensions = t.extensions, r.reserved = t.reserved;for (var u = Object.keys(t.fields), l = 0; l < u.length; ++l) {r.add((void 0 !== t.fields[u[l]].keyType ? a.fromJSON : s.fromJSON)(u[l], t.fields[u[l]]));}if (t.oneofs) for (u = Object.keys(t.oneofs), l = 0; l < u.length; ++l) {r.add(i.fromJSON(u[l], t.oneofs[u[l]]));}if (t.nested) for (u = Object.keys(t.nested), l = 0; l < u.length; ++l) {var h = t.nested[u[l]];r.add((void 0 !== h.id ? s.fromJSON : void 0 !== h.fields ? y.fromJSON : void 0 !== h.values ? o.fromJSON : void 0 !== h.methods ? c.fromJSON : n.fromJSON)(u[l], h));}return t.extensions && t.extensions.length && (r.extensions = t.extensions), t.reserved && t.reserved.length && (r.reserved = t.reserved), t.group && (r.group = !0), t.comment && (r.comment = t.comment), r;}, y.prototype.toJSON = function (e) {var t = n.prototype.toJSON.call(this, e),r = !!e && Boolean(e.keepComments);return d.toObject(["options", t && t.options || void 0, "oneofs", n.arrayToJSON(this.oneofsArray, e), "fields", n.arrayToJSON(this.fieldsArray.filter(function (e) {return !e.declaringField;}), e) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : void 0, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "group", this.group || void 0, "nested", t && t.nested || void 0, "comment", r ? this.comment : void 0]);}, y.prototype.resolveAll = function () {for (var e = this.fieldsArray, t = 0; t < e.length;) {e[t++].resolve();}var r = this.oneofsArray;for (t = 0; t < r.length;) {r[t++].resolve();}return n.prototype.resolveAll.call(this);}, y.prototype.get = function (e) {return this.fields[e] || this.oneofs && this.oneofs[e] || this.nested && this.nested[e] || null;}, y.prototype.add = function (e) {if (this.get(e.name)) throw Error("duplicate name '" + e.name + "' in " + this);if (e instanceof s && void 0 === e.extend) {if (this._fieldsById ? this._fieldsById[e.id] : this.fieldsById[e.id]) throw Error("duplicate id " + e.id + " in " + this);if (this.isReservedId(e.id)) throw Error("id " + e.id + " is reserved in " + this);if (this.isReservedName(e.name)) throw Error("name '" + e.name + "' is reserved in " + this);return e.parent && e.parent.remove(e), this.fields[e.name] = e, e.message = this, e.onAdd(this), m(this);}return e instanceof i ? (this.oneofs || (this.oneofs = {}), this.oneofs[e.name] = e, e.onAdd(this), m(this)) : n.prototype.add.call(this, e);}, y.prototype.remove = function (e) {if (e instanceof s && void 0 === e.extend) {if (!this.fields || this.fields[e.name] !== e) throw Error(e + " is not a member of " + this);return delete this.fields[e.name], e.parent = null, e.onRemove(this), m(this);}if (e instanceof i) {if (!this.oneofs || this.oneofs[e.name] !== e) throw Error(e + " is not a member of " + this);return delete this.oneofs[e.name], e.parent = null, e.onRemove(this), m(this);}return n.prototype.remove.call(this, e);}, y.prototype.isReservedId = function (e) {return n.isReservedId(this.reserved, e);}, y.prototype.isReservedName = function (e) {return n.isReservedName(this.reserved, e);}, y.prototype.create = function (e) {return new this.ctor(e);}, y.prototype.setup = function () {for (var e = this.fullName, t = [], r = 0; r < this.fieldsArray.length; ++r) {t.push(this._fieldsArray[r].resolve().resolvedType);}this.encode = g(this)({ Writer: h, types: t, util: d }), this.decode = p(this)({ Reader: l, types: t, util: d }), this.verify = f(this)({ types: t, util: d }), this.fromObject = v.fromObject(this)({ types: t, util: d }), this.toObject = v.toObject(this)({ types: t, util: d });var n = _[e];if (n) {var o = Object.create(this);o.fromObject = this.fromObject, this.fromObject = n.fromObject.bind(o), o.toObject = this.toObject, this.toObject = n.toObject.bind(o);}return this;}, y.prototype.encode = function (e, t) {return this.setup().encode(e, t);}, y.prototype.encodeDelimited = function (e, t) {return this.encode(e, t && t.len ? t.fork() : t).ldelim();}, y.prototype.decode = function (e, t) {return this.setup().decode(e, t);}, y.prototype.decodeDelimited = function (e) {return e instanceof l || (e = l.create(e)), this.decode(e, e.uint32());}, y.prototype.verify = function (e) {return this.setup().verify(e);}, y.prototype.fromObject = function (e) {return this.setup().fromObject(e);}, y.prototype.toObject = function (e, t) {return this.setup().toObject(e, t);}, y.d = function (e) {return function (t) {d.decorateType(t, e);};};}, function (e, t, r) {"use strict";e.exports = s;var n = r(22);((s.prototype = Object.create(n.prototype)).constructor = s).className = "MapField";var o = r(31),i = r(5);function s(e, t, r, o, s, a) {if (n.call(this, e, t, o, void 0, void 0, s, a), !i.isString(r)) throw TypeError("keyType must be a string");this.keyType = r, this.resolvedKeyType = null, this.map = !0;}s.fromJSON = function (e, t) {return new s(e, t.id, t.keyType, t.type, t.options, t.comment);}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t ? this.comment : void 0]);}, s.prototype.resolve = function () {if (this.resolved) return this;if (void 0 === o.mapKey[this.keyType]) throw Error("invalid key type: " + this.keyType);return n.prototype.resolve.call(this);}, s.d = function (e, t, r) {return "function" == typeof r ? r = i.decorateType(r).name : r && "object" == _typeof(r) && (r = i.decorateEnum(r).name), function (n, o) {i.decorateType(n.constructor).add(new s(o, e, t, r));};};}, function (e, t, r) {"use strict";e.exports = a;var n = r(30);((a.prototype = Object.create(n.prototype)).constructor = a).className = "Service";var o = r(66),i = r(5),s = r(60);function a(e, t) {n.call(this, e, t), this.methods = {}, this._methodsArray = null;}function c(e) {return e._methodsArray = null, e;}a.fromJSON = function (e, t) {var r = new a(e, t.options);if (t.methods) for (var n = Object.keys(t.methods), i = 0; i < n.length; ++i) {r.add(o.fromJSON(n[i], t.methods[n[i]]));}return t.nested && r.addJSON(t.nested), r.comment = t.comment, r;}, a.prototype.toJSON = function (e) {var t = n.prototype.toJSON.call(this, e),r = !!e && Boolean(e.keepComments);return i.toObject(["options", t && t.options || void 0, "methods", n.arrayToJSON(this.methodsArray, e) || {}, "nested", t && t.nested || void 0, "comment", r ? this.comment : void 0]);}, Object.defineProperty(a.prototype, "methodsArray", { get: function get() {return this._methodsArray || (this._methodsArray = i.toArray(this.methods));} }), a.prototype.get = function (e) {return this.methods[e] || n.prototype.get.call(this, e);}, a.prototype.resolveAll = function () {for (var e = this.methodsArray, t = 0; t < e.length; ++t) {e[t].resolve();}return n.prototype.resolve.call(this);}, a.prototype.add = function (e) {if (this.get(e.name)) throw Error("duplicate name '" + e.name + "' in " + this);return e instanceof o ? (this.methods[e.name] = e, e.parent = this, c(this)) : n.prototype.add.call(this, e);}, a.prototype.remove = function (e) {if (e instanceof o) {if (this.methods[e.name] !== e) throw Error(e + " is not a member of " + this);return delete this.methods[e.name], e.parent = null, c(this);}return n.prototype.remove.call(this, e);}, a.prototype.create = function (e, t, r) {for (var n, o = new s.Service(e, t, r), a = 0; a < this.methodsArray.length; ++a) {var c = i.lcFirst((n = this._methodsArray[a]).resolve().name).replace(/[^$\w_]/g, "");o[c] = i.codegen(["r", "c"], i.isReserved(c) ? c + "_" : c)("return this.rpcCall(m,q,s,r,c)")({ m: n, q: n.resolvedRequestType.ctor, s: n.resolvedResponseType.ctor });}return o;};}, function (e, t, r) {"use strict";e.exports = i;var n = r(21);((i.prototype = Object.create(n.prototype)).constructor = i).className = "Method";var o = r(5);function i(e, t, r, i, s, a, c, u) {if (o.isObject(s) ? (c = s, s = a = void 0) : o.isObject(a) && (c = a, a = void 0), void 0 !== t && !o.isString(t)) throw TypeError("type must be a string");if (!o.isString(r)) throw TypeError("requestType must be a string");if (!o.isString(i)) throw TypeError("responseType must be a string");n.call(this, e, c), this.type = t || "rpc", this.requestType = r, this.requestStream = !!s || void 0, this.responseType = i, this.responseStream = !!a || void 0, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = u;}i.fromJSON = function (e, t) {return new i(e, t.type, t.requestType, t.responseType, t.requestStream, t.responseStream, t.options, t.comment);}, i.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return o.toObject(["type", "rpc" !== this.type && this.type || void 0, "requestType", this.requestType, "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream, "options", this.options, "comment", t ? this.comment : void 0]);}, i.prototype.resolve = function () {return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), n.prototype.resolve.call(this));};}, function (e, t, r) {"use strict";e.exports = function (e) {var t = i.codegen(["r", "l"], e.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (e.fieldsArray.filter(function (e) {return e.map;}).length ? ",k" : ""))("while(r.pos<c){")("var t=r.uint32()");e.group && t("if((t&7)===4)")("break"), t("switch(t>>>3){");for (var r = 0; r < e.fieldsArray.length; ++r) {var a = e._fieldsArray[r].resolve(),c = a.resolvedType instanceof n ? "int32" : a.type,u = "m" + i.safeProp(a.name);t("case %i:", a.id), a.map ? (t("r.skip().pos++")("if(%s===util.emptyObject)", u)("%s={}", u)("k=r.%s()", a.keyType)("r.pos++"), void 0 !== o.long[a.keyType] ? void 0 === o.basic[c] ? t('%s[typeof k==="object"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())', u, r) : t('%s[typeof k==="object"?util.longToHash(k):k]=r.%s()', u, c) : void 0 === o.basic[c] ? t("%s[k]=types[%i].decode(r,r.uint32())", u, r) : t("%s[k]=r.%s()", u, c)) : a.repeated ? (t("if(!(%s&&%s.length))", u, u)("%s=[]", u), void 0 !== o.packed[c] && t("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", u, c)("}else"), void 0 === o.basic[c] ? t(a.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", u, r) : t("%s.push(r.%s())", u, c)) : void 0 === o.basic[c] ? t(a.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", u, r) : t("%s=r.%s()", u, c), t("break");}for (t("default:")("r.skipType(t&7)")("break")("}")("}"), r = 0; r < e._fieldsArray.length; ++r) {var l = e._fieldsArray[r];l.required && t("if(!m.hasOwnProperty(%j))", l.name)("throw util.ProtocolError(%j,{instance:m})", s(l));}return t("return m");};var n = r(11),o = r(31),i = r(5);function s(e) {return "missing required '" + e.name + "'";}}, function (e, t, r) {"use strict";e.exports = function (e) {var t = o.codegen(["m"], e.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected"),r = {};e.oneofsArray.length && t("var p={}");for (var n = 0; n < e.fieldsArray.length; ++n) {var c = e._fieldsArray[n].resolve(),u = "m" + o.safeProp(c.name);if (c.optional && t("if(%s!=null&&m.hasOwnProperty(%j)){", u, c.name), c.map) t("if(!util.isObject(%s))", u)("return%j", i(c, "object"))("var k=Object.keys(%s)", u)("for(var i=0;i<k.length;++i){"), a(t, c, "k[i]"), s(t, c, n, u + "[k[i]]")("}");else if (c.repeated) t("if(!Array.isArray(%s))", u)("return%j", i(c, "array"))("for(var i=0;i<%s.length;++i){", u), s(t, c, n, u + "[i]")("}");else {if (c.partOf) {var l = o.safeProp(c.partOf.name);1 === r[c.partOf.name] && t("if(p%s===1)", l)("return%j", c.partOf.name + ": multiple values"), r[c.partOf.name] = 1, t("p%s=1", l);}s(t, c, n, u);}c.optional && t("}");}return t("return null");};var n = r(11),o = r(5);function i(e, t) {return e.name + ": " + t + (e.repeated && "array" !== t ? "[]" : e.map && "object" !== t ? "{k:" + e.keyType + "}" : "") + " expected";}function s(e, t, r, o) {if (t.resolvedType) {if (t.resolvedType instanceof n) {e("switch(%s){", o)("default:")("return%j", i(t, "enum value"));for (var s = Object.keys(t.resolvedType.values), a = 0; a < s.length; ++a) {e("case %i:", t.resolvedType.values[s[a]]);}e("break")("}");} else e("{")("var e=types[%i].verify(%s);", r, o)("if(e)")("return%j+e", t.name + ".")("}");} else switch (t.type) {case "int32":case "uint32":case "sint32":case "fixed32":case "sfixed32":e("if(!util.isInteger(%s))", o)("return%j", i(t, "integer"));break;case "int64":case "uint64":case "sint64":case "fixed64":case "sfixed64":e("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", o, o, o, o)("return%j", i(t, "integer|Long"));break;case "float":case "double":e('if(typeof %s!=="number")', o)("return%j", i(t, "number"));break;case "bool":e('if(typeof %s!=="boolean")', o)("return%j", i(t, "boolean"));break;case "string":e("if(!util.isString(%s))", o)("return%j", i(t, "string"));break;case "bytes":e('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', o, o, o)("return%j", i(t, "buffer"));}return e;}function a(e, t, r) {switch (t.keyType) {case "int32":case "uint32":case "sint32":case "fixed32":case "sfixed32":e("if(!util.key32Re.test(%s))", r)("return%j", i(t, "integer key"));break;case "int64":case "uint64":case "sint64":case "fixed64":case "sfixed64":e("if(!util.key64Re.test(%s))", r)("return%j", i(t, "integer|Long key"));break;case "bool":e("if(!util.key2Re.test(%s))", r)("return%j", i(t, "boolean key"));}return e;}}, function (e, t, r) {"use strict";var n = t,o = r(11),i = r(5);function s(e, t, r, n) {if (t.resolvedType) {if (t.resolvedType instanceof o) {e("switch(d%s){", n);for (var i = t.resolvedType.values, s = Object.keys(i), a = 0; a < s.length; ++a) {t.repeated && i[s[a]] === t.typeDefault && e("default:"), e("case%j:", s[a])("case %i:", i[s[a]])("m%s=%j", n, i[s[a]])("break");}e("}");} else e('if(typeof d%s!=="object")', n)("throw TypeError(%j)", t.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", n, r, n);} else {var c = !1;switch (t.type) {case "double":case "float":e("m%s=Number(d%s)", n, n);break;case "uint32":case "fixed32":e("m%s=d%s>>>0", n, n);break;case "int32":case "sint32":case "sfixed32":e("m%s=d%s|0", n, n);break;case "uint64":c = !0;case "int64":case "sint64":case "fixed64":case "sfixed64":e("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", n, n, c)('else if(typeof d%s==="string")', n)("m%s=parseInt(d%s,10)", n, n)('else if(typeof d%s==="number")', n)("m%s=d%s", n, n)('else if(typeof d%s==="object")', n)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", n, n, n, c ? "true" : "");break;case "bytes":e('if(typeof d%s==="string")', n)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", n, n, n)("else if(d%s.length)", n)("m%s=d%s", n, n);break;case "string":e("m%s=String(d%s)", n, n);break;case "bool":e("m%s=Boolean(d%s)", n, n);}}return e;}function a(e, t, r, n) {if (t.resolvedType) t.resolvedType instanceof o ? e("d%s=o.enums===String?types[%i].values[m%s]:m%s", n, r, n, n) : e("d%s=types[%i].toObject(m%s,o)", n, r, n);else {var i = !1;switch (t.type) {case "double":case "float":e("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", n, n, n, n);break;case "uint64":i = !0;case "int64":case "sint64":case "fixed64":case "sfixed64":e('if(typeof m%s==="number")', n)("d%s=o.longs===String?String(m%s):m%s", n, n, n)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", n, n, n, n, i ? "true" : "", n);break;case "bytes":e("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", n, n, n, n, n);break;default:e("d%s=m%s", n, n);}}return e;}n.fromObject = function (e) {var t = e.fieldsArray,r = i.codegen(["d"], e.name + "$fromObject")("if(d instanceof this.ctor)")("return d");if (!t.length) return r("return new this.ctor");r("var m=new this.ctor");for (var n = 0; n < t.length; ++n) {var a = t[n].resolve(),c = i.safeProp(a.name);a.map ? (r("if(d%s){", c)('if(typeof d%s!=="object")', c)("throw TypeError(%j)", a.fullName + ": object expected")("m%s={}", c)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", c), s(r, a, n, c + "[ks[i]]")("}")("}")) : a.repeated ? (r("if(d%s){", c)("if(!Array.isArray(d%s))", c)("throw TypeError(%j)", a.fullName + ": array expected")("m%s=[]", c)("for(var i=0;i<d%s.length;++i){", c), s(r, a, n, c + "[i]")("}")("}")) : (a.resolvedType instanceof o || r("if(d%s!=null){", c), s(r, a, n, c), a.resolvedType instanceof o || r("}"));}return r("return m");}, n.toObject = function (e) {var t = e.fieldsArray.slice().sort(i.compareFieldsById);if (!t.length) return i.codegen()("return {}");for (var r = i.codegen(["m", "o"], e.name + "$toObject")("if(!o)")("o={}")("var d={}"), n = [], s = [], c = [], u = 0; u < t.length; ++u) {t[u].partOf || (t[u].resolve().repeated ? n : t[u].map ? s : c).push(t[u]);}if (n.length) {for (r("if(o.arrays||o.defaults){"), u = 0; u < n.length; ++u) {r("d%s=[]", i.safeProp(n[u].name));}r("}");}if (s.length) {for (r("if(o.objects||o.defaults){"), u = 0; u < s.length; ++u) {r("d%s={}", i.safeProp(s[u].name));}r("}");}if (c.length) {for (r("if(o.defaults){"), u = 0; u < c.length; ++u) {var l = c[u],h = i.safeProp(l.name);if (l.resolvedType instanceof o) r("d%s=o.enums===String?%j:%j", h, l.resolvedType.valuesById[l.typeDefault], l.typeDefault);else if (l.long) r("if(util.Long){")("var n=new util.Long(%i,%i,%j)", l.typeDefault.low, l.typeDefault.high, l.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", h)("}else")("d%s=o.longs===String?%j:%i", h, l.typeDefault.toString(), l.typeDefault.toNumber());else if (l.bytes) {var d = "[" + Array.prototype.slice.call(l.typeDefault).join(",") + "]";r("if(o.bytes===String)d%s=%j", h, String.fromCharCode.apply(String, l.typeDefault))("else{")("d%s=%s", h, d)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", h, h)("}");} else r("d%s=%j", h, l.typeDefault);}r("}");}var g = !1;for (u = 0; u < t.length; ++u) {l = t[u];var p = e._fieldsArray.indexOf(l);h = i.safeProp(l.name), l.map ? (g || (g = !0, r("var ks2")), r("if(m%s&&(ks2=Object.keys(m%s)).length){", h, h)("d%s={}", h)("for(var j=0;j<ks2.length;++j){"), a(r, l, p, h + "[ks2[j]]")("}")) : l.repeated ? (r("if(m%s&&m%s.length){", h, h)("d%s=[]", h)("for(var j=0;j<m%s.length;++j){", h), a(r, l, p, h + "[j]")("}")) : (r("if(m%s!=null&&m.hasOwnProperty(%j)){", h, l.name), a(r, l, p, h), l.partOf && r("if(o.oneofs)")("d%s=%j", i.safeProp(l.partOf.name), l.name)), r("}");}return r("return d");};}, function (e, t, r) {"use strict";var n = t,o = r(49);n[".google.protobuf.Any"] = { fromObject: function fromObject(e) {if (e && e["@type"]) {var t = this.lookup(e["@type"]);if (t) {var r = "." === e["@type"].charAt(0) ? e["@type"].substr(1) : e["@type"];return this.create({ type_url: "/" + r, value: t.encode(t.fromObject(e)).finish() });}}return this.fromObject(e);}, toObject: function toObject(e, t) {if (t && t.json && e.type_url && e.value) {var r = e.type_url.substring(e.type_url.lastIndexOf("/") + 1),n = this.lookup(r);n && (e = n.decode(e.value));}if (!(e instanceof this.ctor) && e instanceof o) {var i = e.$type.toObject(e, t);return i["@type"] = e.$type.fullName, i;}return this.toObject(e, t);} };}, function (e, t, r) {"use strict";e.exports = h;var n = r(30);((h.prototype = Object.create(n.prototype)).constructor = h).className = "Root";var o,i,s,a = r(22),c = r(11),u = r(48),l = r(5);function h(e) {n.call(this, "", e), this.deferred = [], this.files = [];}function d() {}h.fromJSON = function (e, t) {return t || (t = new h()), e.options && t.setOptions(e.options), t.addJSON(e.nested);}, h.prototype.resolvePath = l.path.resolve, h.prototype.load = function e(t, r, n) {"function" == typeof r && (n = r, r = void 0);var o = this;if (!n) return l.asPromise(e, o, t, r);var a = n === d;function c(e, t) {if (n) {var r = n;if (n = null, a) throw e;r(e, t);}}function u(e, t) {try {if (l.isString(t) && "{" === t.charAt(0) && (t = JSON.parse(t)), l.isString(t)) {i.filename = e;var n,s = i(t, o, r),u = 0;if (s.imports) for (; u < s.imports.length; ++u) {(n = o.resolvePath(e, s.imports[u])) && h(n);}if (s.weakImports) for (u = 0; u < s.weakImports.length; ++u) {(n = o.resolvePath(e, s.weakImports[u])) && h(n, !0);}} else o.setOptions(t.options).addJSON(t.nested);} catch (e) {c(e);}a || g || c(null, o);}function h(e, t) {var r = e.lastIndexOf("google/protobuf/");if (r > -1) {var i = e.substring(r);i in s && (e = i);}if (!(o.files.indexOf(e) > -1)) if (o.files.push(e), e in s) a ? u(e, s[e]) : (++g, setTimeout(function () {--g, u(e, s[e]);}));else if (a) {var h;try {h = l.fs.readFileSync(e).toString("utf8");} catch (e) {return void (t || c(e));}u(e, h);} else ++g, l.fetch(e, function (r, i) {--g, n && (r ? t ? g || c(null, o) : c(r) : u(e, i));});}var g = 0;l.isString(t) && (t = [t]);for (var p, f = 0; f < t.length; ++f) {(p = o.resolvePath("", t[f])) && h(p);}if (a) return o;g || c(null, o);}, h.prototype.loadSync = function (e, t) {if (!l.isNode) throw Error("not supported");return this.load(e, t, d);}, h.prototype.resolveAll = function () {if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function (e) {return "'extend " + e.extend + "' in " + e.parent.fullName;}).join(", "));return n.prototype.resolveAll.call(this);};var g = /^[A-Z]/;function p(e, t) {var r = t.parent.lookup(t.extend);if (r) {var n = new a(t.fullName, t.id, t.type, t.rule, void 0, t.options);return n.declaringField = t, t.extensionField = n, r.add(n), !0;}return !1;}h.prototype._handleAdd = function (e) {if (e instanceof a) void 0 === e.extend || e.extensionField || p(0, e) || this.deferred.push(e);else if (e instanceof c) g.test(e.name) && (e.parent[e.name] = e.values);else if (!(e instanceof u)) {if (e instanceof o) for (var t = 0; t < this.deferred.length;) {p(0, this.deferred[t]) ? this.deferred.splice(t, 1) : ++t;}for (var r = 0; r < e.nestedArray.length; ++r) {this._handleAdd(e._nestedArray[r]);}g.test(e.name) && (e.parent[e.name] = e);}}, h.prototype._handleRemove = function (e) {if (e instanceof a) {if (void 0 !== e.extend) if (e.extensionField) e.extensionField.parent.remove(e.extensionField), e.extensionField = null;else {var t = this.deferred.indexOf(e);t > -1 && this.deferred.splice(t, 1);}} else if (e instanceof c) g.test(e.name) && delete e.parent[e.name];else if (e instanceof n) {for (var r = 0; r < e.nestedArray.length; ++r) {this._handleRemove(e._nestedArray[r]);}g.test(e.name) && delete e.parent[e.name];}}, h._configure = function (e, t, r) {o = e, i = t, s = r;};}, function (e, t, r) {"use strict";function n(e, t, r, n, o, i) {o[0] = i.b = n[0], o[1] = i.a = -t * i.b + n[1];for (var s = 2; s < e; s++) {o[s] = -(t * i.a + r * i.b) + n[s], i.b = i.a, i.a = o[s];}}function o(e, t, r, o, i, s, a, c, u) {var l = new Object(),h = 3;return l.b = l.a = 0, n(t, a, c, s, u, l), i.c = l.a, i.d = l.b, Math.abs(i.c) <= 100 * e * Math.abs(s[t - 1]) && Math.abs(i.d) <= 100 * e * Math.abs(s[t - 2]) || (i.h = c * o, Math.abs(i.d) >= Math.abs(i.c) ? (h = 2, i.e = r / i.d, i.f = i.c / i.d, i.g = a * o, i.a3 = i.e * (i.g + r) + i.h * (o / i.d), i.a1 = -r + i.f * o, i.a7 = i.h + (i.f + a) * r) : (h = 1, i.e = r / i.c, i.f = i.d / i.c, i.g = i.e * a, i.a3 = i.e * r + (i.g + i.h / i.c) * o, i.a1 = -r * (i.d / i.c) + o, i.a7 = i.g * i.d + i.h * i.f + r)), h;}function i(e, t, r, n, o, i, s, a, c) {var u;if (3 != r) {if (u = 1 == r ? o : n, Math.abs(i.a1) > 10 * e * Math.abs(u)) for (i.a7 /= i.a1, i.a3 /= i.a1, s[0] = c[0], s[1] = -c[0] * i.a7 + c[1], l = 2; l < t; l++) {s[l] = -c[l - 1] * i.a7 + a[l - 2] * i.a3 + c[l];} else for (s[0] = 0, s[1] = -c[0] * i.a7, l = 2; l < t; l++) {s[l] = -c[l - 1] * i.a7 + a[l - 2] * i.a3;}} else {s[1] = s[0] = 0;for (var l = 2; l < t; l++) {s[l] = a[l - 2];}}}function s(e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f, v) {var _, y, m, E, x, R, A, P;t.b = t.a = 0, 3 != e && (2 != e ? (_ = r + d * s + h * u, y = a + (d + g * u) * c) : (_ = (r + l) * u + h, y = (u + d) * a + g * c), 0 != (P = -(A = -((x = (m = -p[f - 1] / v[f]) * i) + (R = m * m * o)) + g * (E = -(p[f - 2] + m * v[f - 1]) / v[f]) * n) + y + m * _) && (t.a = -(d * (R + x) + g * (m * n + E * i)) / P + d, t.b = g * (1 + A / P)));}function a(e, t, r, n) {var o, i, s;n.sr = n.si = n.lr = n.li = 0, 0 != e ? 0 != r ? (o = t / 2, Math.abs(o) < Math.abs(r) ? (s = -(s = r >= 0 ? e : -e) + o * (o / Math.abs(r)), i = Math.sqrt(Math.abs(s)) * Math.sqrt(Math.abs(r))) : (s = -e / o * (r / o) + 1, i = Math.sqrt(Math.abs(s)) * Math.abs(o)), s >= 0 ? (i = o >= 0 ? -i : i, n.lr = (-o + i) / e, n.sr = 0 != n.lr ? r / n.lr / e : n.sr) : (n.lr = n.sr = -o / e, n.si = Math.abs(i / e), n.li = -n.si)) : n.lr = -t / e : n.sr = 0 != t ? -r / t : n.sr;}function c(e, t, r, c, u, l, h, d, g, p, f, v) {var _,y,m,E,x,R,A,P,V,T,C,b = new Object(),L = 0,O = 0;r.NZ = 0, R = c, P = u;do {if (b.li = b.lr = b.si = b.sr = 0, a(1, R, P, b), r.szr = b.sr, r.szi = b.si, r.lzr = b.lr, r.lzi = b.li, Math.abs(Math.abs(r.szr) - Math.abs(r.lzr)) > .01 * Math.abs(r.lzr)) break;for (n(h, R, P, g, l, d), y = Math.abs(-r.szr * d.b + d.a) + Math.abs(r.szi * d.b), T = Math.sqrt(Math.abs(P)), _ = 2 * Math.abs(l[0]), x = -r.szr * d.b, C = 1; C < t; C++) {_ = _ * T + Math.abs(l[C]);}if (y <= 20 * (_ = (9 * (_ = _ * T + Math.abs(x + d.a)) + 2 * Math.abs(x) - 7 * (Math.abs(d.a + x) + T * Math.abs(d.b))) * e)) {r.NZ = 2;break;}if (++L > 20) break;if (L >= 2 && E <= .01 && y >= m && !O) {for (n(h, R -= R * (E = E < e ? Math.sqrt(e) : Math.sqrt(E)), P += P * E, g, l, d), C = 0; C < 5; C++) {i(e, t, o(e, t, d.a, d.b, f, v, R, P, p), d.a, d.b, f, v, p, l);}O = 1, L = 0;}m = y, i(e, t, o(e, t, d.a, d.b, f, v, R, P, p), d.a, d.b, f, v, p, l), s(o(e, t, d.a, d.b, f, v, R, P, p), d, d.a, f.a1, f.a3, f.a7, d.b, f.c, f.d, f.f, f.g, f.h, R, P, v, t, g), A = d.a, 0 != (V = d.b) && (E = Math.abs((-P + V) / V), R = A, P = V);} while (0 != V);}function u(e, t, r, n, o, i, s, a, c) {var u,l,h,d,g,p,f,v,_,y,m,E = n - 1;for (t.NZ = m = _ = 0, f = r.a;;) {for (s[0] = p = o[0], y = 1; y < i; y++) {s[y] = p = p * f + o[y];}for (h = Math.abs(p), d = Math.abs(f), u = .5 * Math.abs(s[0]), y = 1; y < i; y++) {u = u * d + Math.abs(s[y]);}if (h <= 20 * e * (2 * u - h)) {t.NZ = 1, t.szr = f, t.szi = 0;break;}if (++m > 10) break;if (m >= 2 && Math.abs(v) <= .001 * Math.abs(-v + f) && h > g) {_ = 1, t.a = f;break;}for (g = h, c[0] = l = a[0], y = 1; y < n; y++) {c[y] = l = l * f + a[y];}if (Math.abs(l) > 10 * Math.abs(a[E]) * e) for (v = -p / l, a[0] = s[0], y = 1; y < n; y++) {a[y] = v * c[y - 1] + s[y];} else for (a[0] = 0, y = 1; y < n; y++) {a[y] = c[y - 1];}for (l = a[0], y = 1; y < n; y++) {l = l * f + a[y];}f += v = Math.abs(l) > 10 * Math.abs(a[E]) * e ? -p / l : 0;}return _;}function l(e, t, r, a, l, h, d, g, p, f, v) {var _,y,m,E,x,R,A,P,V,T,C,b,L,O,S,M,w,N,F,I,D,j,B,U,k,G,z,Y,K = new Object(),q = new Object(),W = new Array(t),H = new Array(t);for (v.NZ = 0, E = m = .25, S = -2 * a, x = a, P = w = l, q.h = q.g = q.f = q.e = q.d = q.c = q.a7 = q.a3 = q.a1 = K.b = K.a = 0, n(p, S, w, g, f, K), G = o(e, d, _ = K.a, y = K.b, q, h, S, w, W), B = 0; B < r; B++) {if (i(e, d, G, _, y, q, h, W, f), s(G = o(e, d, _, y, q, h, S, w, W), K, _, q.a1, q.a3, q.a7, y, q.c, q.d, q.f, q.g, q.h, S, w, h, d, g), M = K.a, F = N = K.b, T = 0 != h[d - 1] ? -g[d] / h[d - 1] : 0, C = L = 1, 0 != B && 3 != G && (z = (O = (L = 0 != F ? Math.abs((F - P) / F) : L) < A ? L * A : 1) < E ? 1 : 0, (U = (b = (C = 0 != T ? Math.abs((T - x) / T) : C) < R ? C * R : 1) < m ? 1 : 0) || z)) {for (D = 0; D < d; D++) {H[D] = h[D];}V = T, k = Y = 0, I = 1;do {if (j = 1, I && 0 == (I = 0) && U && (!z || b < O)) ;else {if (c(e, d, v, M, N, f, p, K, g, W, q, h), _ = K.a, y = K.b, v.NZ > 0) return;if (Y = 1, E *= .25, k || !U) j = 0;else for (D = 0; D < d; D++) {h[D] = H[D];}}if (0 != j) {if (K.a = V, j = u(e, v, K, d, g, p, f, h, W), V = K.a, v.NZ > 0) return;if (k = 1, m *= .25, 0 != j) {M = -(V + V), N = V * V;continue;}}for (D = 0; D < d; D++) {h[D] = H[D];}} while (z && !Y);n(p, S, w, g, f, K), G = o(e, d, _ = K.a, y = K.b, q, h, S, w, W);}P = F, x = T, A = L, R = C;}}Object.defineProperty(t, "__esModule", { value: !0 }), t.getRealPolynomialRoots = function (e) {var t = { Degree: e.length - 1 },r = new Array(e.length),n = new Array(e.length);!function (e, t, r, n) {var o,i,s,c,u,h,d,g,p,f,v,_,y,m,E,x,R,A,P,V,T,C,b = e.Degree,L = Math.LN2,O = e.Degree + 1,S = new Array(O),M = new Array(O),w = new Array(O),N = new Array(O),F = new Object(),I = new Object();_ = 1;do {i = _, y = 1 + (_ /= 2);} while (y > 1);var D = 117549435082229e-52 / i,j = Math.cos(1.6406094968746698),B = Math.sin(1.6406094968746698),U = Math.sqrt(.5),k = -U;for (I.NZ = R = 0, I.szr = I.szi = I.lzr = I.lzi = 0; 0 == t[b];) {r[R] = n[R] = 0, b--, R++;}for (T = b + 1; b >= 1;) {if (b <= 2) {b < 2 ? (r[e.Degree - 1] = -t[1] / t[0], n[e.Degree - 1] = 0) : (F.li = F.lr = F.si = F.sr = 0, a(t[0], t[1], t[2], F), r[e.Degree - 2] = F.sr, n[e.Degree - 2] = F.si, r[e.Degree - 1] = F.lr, n[e.Degree - 1] = F.li);break;}for (d = 0, g = 340282346638529e24, G = 0; G < T; G++) {(f = Math.abs(t[G])) > d && (d = f), 0 != f && f < g && (g = f);}if (((p = D / g) <= 1 && d >= 10 || p > 1 && 340282346638529e24 / p >= d) && (p = 0 == p ? 117549435082229e-52 : p, P = Math.floor(Math.log(p) / L + .5), 1 != (u = Math.pow(2, P)))) for (G = 0; G < T; G++) {t[G] *= u;}for (var G = 0; G < T; G++) {M[G] = Math.abs(t[G]);}M[b] = -M[b], V = b - 1, f = Math.exp((Math.log(-M[b]) - Math.log(M[0])) / b), 0 != M[V] && (f = (v = -M[b] / M[V]) < f ? v : f), v = f;do {for (v = .1 * (f = v), h = M[0], G = 1; G < T; G++) {h = h * v + M[G];}} while (h > 0);for (c = f; Math.abs(c / f) > .005;) {for (s = h = M[0], G = 1; G < b; G++) {s = f * s + (h = f * h + M[G]);}f -= c = (h = f * h + M[b]) / s;}for (o = f, G = 1; G < b; G++) {S[G] = (b - G) * t[G] / b;}for (S[0] = t[0], _ = t[b], y = t[V], C = 0 == S[V] ? 1 : 0, A = 0; A < 5; A++) {if (m = S[V], C) {for (G = 0; G < V; G++) {S[R = V - G] = S[R - 1];}S[0] = 0, C = 0 == S[V] ? 1 : 0;} else {for (E = -_ / m, G = 0; G < V; G++) {S[R = V - G] = E * S[R - 1] + t[R];}S[0] = t[0], C = Math.abs(S[V]) <= Math.abs(y) * i * 10 ? 1 : 0;}}for (G = 0; G < b; G++) {N[G] = S[G];}for (A = 1; A <= 20; A++) {if (x = -B * k + j * U, k = B * U + j * k, l(i, O, 20 * A, o * (U = x), o, S, b, t, T, w, I), 0 != I.NZ) {for (r[R = e.Degree - b] = I.szr, n[R] = I.szi, b = (T -= I.NZ) - 1, G = 0; G < T; G++) {t[G] = w[G];}1 != I.NZ && (r[R + 1] = I.lzr, n[R + 1] = I.lzi);break;}for (G = 0; G < b; G++) {S[G] = N[G];}}if (A > 20) {e.Degree -= b;break;}}}(t, e, r, n);for (var o = [], i = e.length - t.Degree - 1; i < e.length; i++) {Math.abs(n[i]) < 1e-8 && o.push(r[i]);}return o;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.relaxBCurveToPerpendicular = t.closestBCurveSegments = t.maxDistanceSqrToHull = t.minDistanceSqrToHull = void 0;var n = r(1),o = r(0),i = r(37),s = r(35),a = function a(e, t) {var r,i = t.length / 3,s = n.Vector3.asFloat64(0, 0, 0);for (r = 0; r < i; ++r) {s[0] += t[3 * r], s[1] += t[3 * r + 1], s[2] += t[3 * r + 2];}n.Vector3.scale(s, s, 1 / i), n.Vector3.sub(s, s, e);var a = n.Vector3.squaredLength(s);if (a < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return 0;var c = Number.POSITIVE_INFINITY;for (r = 0; r < i; ++r) {var u = s[0] * (t[3 * r] - e[0]) + s[1] * (t[3 * r + 1] - e[1]) + s[2] * (t[3 * r + 2] - e[2]);u < c && (c = u);}return c <= 0 ? 0 : c * c / a;},c = function c(e, t) {for (var r = t.length / 3, n = 0, o = 0; o < r; ++o) {var i = t[3 * o] - e[0],s = t[3 * o + 1] - e[1],a = t[3 * o + 2] - e[2],c = i * i + s * s + a * a;c > n && (n = c);}return n;};t.minDistanceSqrToHull = a, t.maxDistanceSqrToHull = c, t.closestBCurveSegments = function (e, t, r, o) {for (var i = Number.POSITIVE_INFINITY, s = [], u = 0; u < t.length; ++u) {var l,h = t[u],d = h.getRangeUnlimited();if (o) {l = !1;for (var g = 0; g < o.length; ++g) {if (d[1] >= o[g][0] + n.FLOAT64_TOLERANCE && d[0] <= o[g][1] - n.FLOAT64_TOLERANCE) {l = !0;break;}}} else l = !0;if (l) {var p = r ? r[u] : 0,f = h.getControlPoints(),v = a(e, f);if ((v = Math.max(0, v - p)) <= i) {var _ = c(e, f) + p;s.push({ index: u, minDistSqr: v, maxDistSqr: _ }), _ < i && (i = _);}}}return (s = s.filter(function (e) {return e.minDistSqr <= i;})).sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), s;}, t.relaxBCurveToPerpendicular = function (e, t, r, o, a, c, u, l) {var h = u || n.FLOAT64_TOLERANCE,d = l || 32,g = t.length / 3,p = e.length - g - 1;return (0, s.newtonRaphson1D)(function (n) {var s = (0, i.evaluateBCurveDerivs)(n, 2, p, e, t, r),a = s[0],c = s[1],u = s[2],l = [a[0] - o[0], a[1] - o[1], a[2] - o[2]];return { val: 2 * (l[0] * c[0] + l[1] * c[1] + l[2] * c[2]), deriv: 2 * (l[0] * u[0] + l[1] * u[1] + l[2] * u[2] + (c[0] * c[0] + c[1] * c[1] + c[2] * c[2])) };}, c, a, h, d);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Sphere = void 0;var n = r(1),o = r(3),i = r(0),s = r(12),a = r(6),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.SPHERE;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t;var s = void 0 === r || n.Vector3.squaredLength(r) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE,a = void 0 === o || n.Vector3.squaredLength(o) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE;s && a ? (n.Vector3.set(this._xAxis, 1, 0, 0), n.Vector3.set(this._zAxis, 0, 0, 1)) : s ? (n.Vector3.normalize(this._xAxis, o), n.Vector3.computeOrthogonal(this._zAxis, this._xAxis), n.Vector3.normalize(this._zAxis, this._zAxis)) : a ? (n.Vector3.normalize(this._zAxis, r), n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)) : (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, o, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, o), n.Vector3.normalize(this._zAxis, r)), this._computeYAxis();}, l.prototype.getRadius = function () {return this._radius;}, l.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), (n.Vector3.squaredLength(this._zAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._zAxis, this._xAxis), n.Vector3.normalize(this._zAxis, this._zAxis)), this._computeYAxis();}, l.prototype.evaluatePosition = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = Math.cos(t),a = this._radius * o * s,c = this._radius * o * i,u = this._radius * r,l = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(l, l, this._xAxis, a), n.Vector3.scaleAndAdd(l, l, this._yAxis, c), n.Vector3.scaleAndAdd(l, l, this._zAxis, u), l;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = o * Math.cos(t),a = o * i,c = r,u = n.Vector3.createFloat64();return n.Vector3.scale(u, this._xAxis, s), n.Vector3.scaleAndAdd(u, u, this._yAxis, a), n.Vector3.scaleAndAdd(u, u, this._zAxis, c), u;}, l.prototype.evaluateDu = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = Math.cos(t),a = -this._radius * r * s,c = -this._radius * r * i,u = this._radius * o,l = n.Vector3.createFloat64();return n.Vector3.scale(l, this._xAxis, a), n.Vector3.scaleAndAdd(l, l, this._yAxis, c), n.Vector3.scaleAndAdd(l, l, this._zAxis, u), l;}, l.prototype.evaluateDv = function (e, t) {var r = Math.cos(e),o = Math.sin(t),i = Math.cos(t),s = -this._radius * r * o,a = this._radius * r * i,c = n.Vector3.createFloat64();return n.Vector3.scale(c, this._xAxis, s), n.Vector3.scaleAndAdd(c, c, this._yAxis, a), c;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.length(t);if (r < i.KERNEL_TOLERANCE) return { u: 0, v: 0 };var s = n.Vector3.dot(t, this._xAxis),a = n.Vector3.dot(t, this._yAxis),c = n.Vector3.dot(t, this._zAxis);return { u: Math.asin((0, o.clamp)(c / r, -1, 1)), v: Math.atan2(a, s) };}, l.prototype.vParamLine = function (e) {var t = Math.cos(e),r = Math.sin(e),o = this._radius * t,s = this._radius * r;if (Math.abs(o) > i.KERNEL_TOLERANCE) {var u = new c.Circle(),l = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(l, l, this._zAxis, s);var h = n.Vector3.clone(this._xAxis);n.Vector3.scale(h, h, o);var d = n.Vector3.clone(this._zAxis);return n.Vector3.negate(d, d), u.set(l, d, h), u;}var g = n.Vector3.clone(this._center);return s = s < 0 ? -this._radius : this._radius, n.Vector3.scaleAndAdd(g, g, this._zAxis, s), new a.Point(g);}, l.prototype.uParamLine = function (e) {var t = new c.Circle(),r = Math.sin(e),o = Math.cos(e),i = this._radius * o,s = this._radius * r,a = n.Vector3.clone(this._xAxis);n.Vector3.scale(a, a, -s), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.normalize(a, a);var u = n.Vector3.clone(this._xAxis);return n.Vector3.scale(u, u, i), n.Vector3.scaleAndAdd(u, u, this._yAxis, s), t.set(this._center, a, u), t;}, l.prototype.getBoundingBox = function (e, t) {e = e || [-Math.PI / 2, Math.PI / 2], t = t || [-Math.PI, Math.PI];var r = e[0],i = e[1],s = t[0],a = t[1],c = this.vParamLine(r).getBoundingBox(t);c.include(this.vParamLine(i).getBoundingBox(t)), c.include(this.uParamLine(s).getBoundingBox(e)), c.include(this.uParamLine(a).getBoundingBox(e));for (var u = n.Vector3.createFloat64(), l = 0; l < 3; ++l) {for (var h = 0; h < 2; ++h) {var d = 0 === h ? 1 : -1,g = Math.atan2(d * this._yAxis[l], d * this._xAxis[l]),p = Math.asin(d * this._zAxis[l]);g = (0, o.adjustParameterToPeriodicRange)(g, t, o.PI2), p > r && p < i && g > s && g < a && (n.Vector3.set(u, 0, 0, 0), u[l] = d * this._radius, c.includePoint(n.Vector3.add(u, this._center, u)));}}return c;}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-Math.PI / 2, Math.PI / 2];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this.getCenter()), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Sphere = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Torus = void 0;var n = r(1),o = r(3),i = r(0),s = r(12),a = r(6),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._lemon = !1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.TORUS;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._lemon = e._lemon, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s, a) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._majorRadius = t, u.ConsoleUtils.assert(r > i.KERNEL_TOLERANCE), this._minorRadius = r, u.ConsoleUtils.assert(n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, o), void 0 !== s && n.Vector3.squaredLength(s) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, s, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, s)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._lemon = !0 === a, this._computeYAxis();}, l.prototype.getMajorRadius = function () {return this._majorRadius;}, l.prototype.setMajorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._majorRadius = e;}, l.prototype.getMinorRadius = function () {return this._minorRadius;}, l.prototype.setMinorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._minorRadius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.isDoughnut = function () {return this._majorRadius > this._minorRadius + i.KERNEL_TOLERANCE;}, l.prototype.isVortex = function () {return Math.abs(this._majorRadius - this._minorRadius) <= i.KERNEL_TOLERANCE;}, l.prototype.isApple = function () {return this._majorRadius < this._minorRadius - i.KERNEL_TOLERANCE && !this._lemon;}, l.prototype.isLemon = function () {return this._majorRadius < this._minorRadius - i.KERNEL_TOLERANCE && this._lemon;}, l.prototype.setLemon = function (e) {this._lemon = e;}, l.prototype.getSingularUParams = function () {var e, t, r;return this.isDoughnut() ? [] : this.isApple() ? (e = -this._majorRadius, t = this._minorRadius, [-(r = Math.acos(e / t)), r]) : this.isLemon() ? (e = this._minorRadius - this._majorRadius, t = this._minorRadius, [-(r = Math.acos(e / t)), r]) : [-Math.PI, Math.PI];}, l.prototype.evaluatePosition = function (e, t) {var r = this._minorRadius * Math.cos(e);this.isLemon() ? r -= this._majorRadius : r += this._majorRadius;var o = r * Math.cos(t),i = r * Math.sin(t),s = this._minorRadius * Math.sin(e),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = o * Math.cos(t),a = o * i,c = r,u = n.Vector3.createFloat64();return n.Vector3.scale(u, this._xAxis, s), n.Vector3.scaleAndAdd(u, u, this._yAxis, a), n.Vector3.scaleAndAdd(u, u, this._zAxis, c), u;}, l.prototype.evaluateDu = function (e, t) {var r = -this._minorRadius * Math.sin(e),o = r * Math.cos(t),i = r * Math.sin(t),s = this._minorRadius * Math.cos(e),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, l.prototype.evaluateDv = function (e, t) {var r = this._minorRadius * Math.cos(e);this.isLemon() ? r -= this._majorRadius : r += this._majorRadius;var o = -r * Math.sin(t),i = r * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._xAxis),o = n.Vector3.dot(t, this._yAxis),s = n.Vector3.dot(t, this._zAxis),a = Math.sqrt(r * r + o * o);return this.isLemon() ? a += this._majorRadius : a -= this._majorRadius, { u: s * s + a * a > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? Math.atan2(s, a) : 0, v: r * r + o * o > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? Math.atan2(o, r) : 0 };}, l.prototype.vParamLine = function (e) {var t = this._minorRadius * Math.cos(e);this.isLemon() ? t -= this._majorRadius : t += this._majorRadius;var r = this._minorRadius * Math.sin(e);if (Math.abs(t) > i.KERNEL_TOLERANCE) {var o = new c.Circle(),s = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(s, s, this._zAxis, r);var u = n.Vector3.clone(this._xAxis);n.Vector3.scale(u, u, t);var l = n.Vector3.clone(this._zAxis);return n.Vector3.negate(l, l), o.set(s, l, u), o;}var h = n.Vector3.clone(this._center),d = this.getSingularUParams();return d[0] && r < 0 ? r = this._minorRadius * Math.sin(d[0]) : d[1] && r > 0 && (r = this._minorRadius * Math.sin(d[1])), n.Vector3.scaleAndAdd(h, h, this._zAxis, r), new a.Point(h);}, l.prototype.uParamLine = function (e) {var t = new c.Circle(),r = Math.sin(e),o = Math.cos(e),i = this._majorRadius * o,s = this._majorRadius * r;this.isLemon() && (i = -i, s = -s);var a = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(a, a, this._xAxis, i), n.Vector3.scaleAndAdd(a, a, this._yAxis, s);var u = this._minorRadius * o,l = this._minorRadius * r,h = n.Vector3.clone(this._xAxis);n.Vector3.scale(h, h, -l), n.Vector3.scaleAndAdd(h, h, this._yAxis, u), n.Vector3.normalize(h, h);var d = n.Vector3.clone(this._xAxis);return n.Vector3.scale(d, d, u), n.Vector3.scaleAndAdd(d, d, this._yAxis, l), t.set(a, h, d), t;}, l.prototype.getBoundingBox = function (e, t) {e = e || (this.isDoughnut() ? [-Math.PI, Math.PI] : this.getSingularUParams()), t = t || [-Math.PI, Math.PI];var r = e[0],i = e[1],s = t[0],a = t[1],c = this.vParamLine(r).getBoundingBox(t);c.include(this.vParamLine(i).getBoundingBox(t)), c.include(this.uParamLine(s).getBoundingBox(e)), c.include(this.uParamLine(a).getBoundingBox(e));for (var u = n.Vector3.createFloat64(), l = n.Vector3.createFloat64(), h = 0; h < 3; ++h) {for (var d = 0; d < 2; ++d) {var g = 0 === d ? -1 : 1,p = Math.atan2(g * this._yAxis[h], g * this._xAxis[h]);if ((p = (0, o.adjustParameterToPeriodicRange)(p, t, o.PI2)) > s && p < a) {var f = this.uParamLine(p);u = f.evaluatePosition(0), n.Vector3.sub(u, u, f.getCenter()), l = f.evaluatePosition(Math.PI / 2), n.Vector3.sub(l, l, f.getCenter());var v = (0, o.minMaxCosSinFunc)(u[h], l[h], f.getCenter()[h], e);0 === h ? c.includeX(v[d]) : 1 === h ? c.includeY(v[d]) : c.includeZ(v[d]);}}}return c;}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return this.isDoughnut() ? [-Math.PI, Math.PI] : this.getSingularUParams();}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return this.isDoughnut();}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return this.isDoughnut() || this.isVortex();}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this.getCenter()), coordAxis: this.vectorToObject(this.getUvOriginDir()), axis: this.vectorToObject(this.getAxisDir()), majorRadius: this.getMajorRadius(), minorRadius: this.getMinorRadius(), lemon: this.isLemon(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Torus = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.evaluateBSurfaceDerivs = t.evaluateBSurfacePoint = void 0;var n = r(1),o = r(3),i = r(17),s = r(37);t.evaluateBSurfacePoint = function (e, t, r, o, a, c, u, l) {return l && l.length > 0 ? function (e, t, r, o, a, c, u, l) {for (var h, d = c.length - o - 1, g = (0, i.findKnotSpan)(e, a), p = (0, s.evaluateBasisFunctions)(g, e, r, a), f = (0, i.findKnotSpan)(t, c), v = (0, s.evaluateBasisFunctions)(f, t, o, c), _ = g - r, y = n.Vector4.createFloat64(), m = n.Vector4.createFloat64(), E = 0; E <= o; E++) {n.Vector4.set(m, 0, 0, 0, 0), h = f - o + E;for (var x = 0; x <= r; x++) {var R = (_ + x) * d + h,A = p[x] * l[R];m[0] += A * u[3 * R], m[1] += A * u[3 * R + 1], m[2] += A * u[3 * R + 2], m[3] += A;}y[0] += v[E] * m[0], y[1] += v[E] * m[1], y[2] += v[E] * m[2], y[3] += v[E] * m[3];}return n.Vector3.createFloat64FromValues(y[0] / y[3], y[1] / y[3], y[2] / y[3]);}(e, t, r, o, a, c, u, l) : function (e, t, r, o, a, c, u) {for (var l, h = c.length - o - 1, d = (0, i.findKnotSpan)(e, a), g = (0, s.evaluateBasisFunctions)(d, e, r, a), p = (0, i.findKnotSpan)(t, c), f = (0, s.evaluateBasisFunctions)(p, t, o, c), v = d - r, _ = n.Vector3.createFloat64(), y = n.Vector3.createFloat64(), m = 0; m <= o; m++) {n.Vector3.set(y, 0, 0, 0), l = p - o + m;for (var E = 0; E <= r; E++) {var x = (v + E) * h + l;y[0] += g[E] * u[3 * x], y[1] += g[E] * u[3 * x + 1], y[2] += g[E] * u[3 * x + 2];}_[0] += f[m] * y[0], _[1] += f[m] * y[1], _[2] += f[m] * y[2];}return _;}(e, t, r, o, a, c, u);}, t.evaluateBSurfaceDerivs = function (e, t, r, a, c, u, l, h, d) {return function (e, t, r, a, c, u, l, h, d) {var g,p,f,v,_,y,m = new Array(r + 1),E = new Array(r + 1),x = new Array(r + 1),R = new Array(r + 1);for (g = 0; g <= r; g++) {for (m[g] = new Array(r + 1 - g), E[g] = new Array(r + 1 - g), p = 0; p <= r - g; p++) {m[g][p] = n.Vector3.createFloat64(), E[g][p] = 0;}x[g] = new Array(a + 1), R[g] = new Array(c + 1);}var A = Math.min(r, a),P = (0, i.findKnotSpan)(e, u);(0, s.evaluateBasisDerivatives)(P, e, a, A, u, x);var V = Math.min(r, c),T = (0, i.findKnotSpan)(t, l);(0, s.evaluateBasisDerivatives)(T, t, c, V, l, R);var C = d && d.length > 0,b = l.length - c - 1,L = new Array(c + 1);for (g = 0; g <= A; g++) {for (f = 0; f <= c; f++) {for (L[f] = [0, 0, 0, 0], v = 0; v <= a; v++) {var O = (P - a + v) * b + (T - c + f),S = x[g][v];C && (S *= d[O], L[f][3] += S), L[f][0] += S * h[3 * O], L[f][1] += S * h[3 * O + 1], L[f][2] += S * h[3 * O + 2];}}var M = Math.min(r - g, V);for (p = 0; p <= M; p++) {for (f = 0; f <= c; f++) {m[g][p][0] += R[p][f] * L[f][0], m[g][p][1] += R[p][f] * L[f][1], m[g][p][2] += R[p][f] * L[f][2], C && (E[g][p] += R[p][f] * L[f][3]);}}}if (C) {var w = o.binomialCoefficients,N = n.Vector3.createFloat64();for (g = 0; g <= r; g++) {for (p = 0; p <= r - g; p++) {var F = m[g][p];for (y = 1; y <= p; y++) {n.Vector3.scaleAndAdd(F, F, m[g][p - y], -w[p][y] * E[0][y]);}for (_ = 1; _ <= g; _++) {for (n.Vector3.scaleAndAdd(F, F, m[g - _][p], -w[g][_] * E[_][0]), n.Vector3.set(N, 0, 0, 0), y = 1; y <= p; y++) {n.Vector3.scaleAndAdd(N, N, m[g - _][p - y], w[p][y] * E[_][y]);}n.Vector3.scaleAndAdd(F, F, N, -w[g][_]);}n.Vector3.scale(F, F, 1 / E[0][0]);}}}return m;}(e, t, r, a, c, u, l, h, d);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.newtonRaphson2D = t.RelaxResult = void 0;var n = r(1),o = {};o[o.Success = 0] = "Success", o[o.OutOfRange = 1] = "OutOfRange", o[o.DegenerateStep = 2] = "DegenerateStep", o[o.TooManySteps = 3] = "TooManySteps", o[o.RootNotFound = 4] = "RootNotFound", t.RelaxResult = o, t.newtonRaphson2D = function (e, t, r, i, s) {i = i || 1e-12, s = s || 100;var a = [void 0, void 0];r && 2 === r.length && (r[0] && 2 === r[0].length && (a[0] = r[0]), r[1] && 2 === r[1].length && (a[1] = r[1])), a[0] && (a[0][0], a[0][1]), a[1] && (a[1][0], a[1][1]);for (var c = [0, 0], u = 1 / 0, l = 1 / 0, h = !1, d = n.Matrix22.createFloat64(), g = n.Matrix22.createFloat64(), p = n.Vector2.clone(t), f = o.Success, v = 0; v <= s; v++) {var _ = e(p);if (u = n.Vector2.squaredLength(_.val), p[0], p[1], u < n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {f = o.Success;break;}if (v > 0) {var y = Math.max(Math.abs(c[0]), Math.abs(c[1]));if (y < i) {u >= l && (n.Vector2.sub(p, p, c), u = l, _ = e(p));var m = 10 * i * (n.Vector2.len(_.deriv1) + n.Vector2.len(_.deriv2)),E = m * m;f = u > E ? h ? o.OutOfRange : o.RootNotFound : o.Success;break;}}if (v === s) {u >= l && (n.Vector2.sub(p, p, c), u = l), f = o.TooManySteps;break;}if (v > 0 && u >= l) {var x = l / (l + u);x = Math.max(x, .1), n.Vector2.sub(p, p, c), n.Vector2.scale(c, c, x), n.Vector2.add(p, p, c), u = l;} else {if (l = u, n.Matrix22.set(d, -_.deriv1[0], -_.deriv1[1], -_.deriv2[0], -_.deriv2[1]), Math.abs(n.Matrix22.determinant(d)) < n.FLOAT64_TOLERANCE) {f = o.DegenerateStep;break;}n.Matrix22.invert(g, d), n.Vector2.transformMatrix22(c, _.val, g), c[0], c[1], n.Vector2.add(p, p, c), h = !1;for (var R = 0; R < 3; R++) {var A = R >= 2,P = R % 2;if (a[P]) {var V = 0;if (p[P] < a[P][0] ? (V = p[P] - a[P][0], p[P] = a[P][0]) : p[P] > a[P][1] && (V = p[P] - a[P][1], p[P] = a[P][1]), 0 !== V) {p[P];var T = c[P];if (c[P] -= V, A) ;else {var C = 1 - P;if (p[C] -= c[C], Math.abs(c[P]) > i) {var b = c[P] / T;c[C] *= b;} else {h = !0;var L = 0 === C ? _.deriv1 : _.deriv2;c[C] = -n.Vector2.dot(_.val, L) / Math.max(n.Vector2.dot(L, L), n.FLOAT64_TOLERANCE);}p[C] += c[C], c[0], c[1];}}}}}}return o[f], p[0], p[1], { param: p, status: f };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.getOrderedFacesOnVertex = function (e) {var t = e.getEdges(),r = new n(e),o = [];return t.forEach(function (t) {var n = t.getCoedges();for (var _t6 = 0; _t6 < n.length; ++_t6) {if (n[_t6].getStartVertex() === e) {var _e3 = r.marchFan(n[_t6]);_e3.faces.length > 0 && o.push(_e3);break;}}}), o;};var n = /*#__PURE__*/function () {function n(e) {_classCallCheck(this, n);this._vertex = e, this._visitedCoeds = new Set(), this._unvisitedCoeds = new Set(), this._faces = [], this._type = "unset";}_createClass(n, [{ key: "addVisitedCoedge", value: function addVisitedCoedge(e) {this._visitedCoeds.add(e), this._unvisitedCoeds.delete(e);} }, { key: "getNextFace", value: function getNextFace(e) {var t = e.getFace();t && this._faces.push(t), this.addVisitedCoedge(e);} }, { key: "getPrevFace", value: function getPrevFace(e) {var t = e.getFace();t && this._faces.unshift(t), this.addVisitedCoedge(e);} }, { key: "collectUnvisitedCoeds", value: function collectUnvisitedCoeds(e) {var _this = this;e.getEdge().getCoedges().forEach(function (e) {_this._visitedCoeds.has(e) || e.getStartVertex() !== _this._vertex || _this._unvisitedCoeds.add(e);});} }, { key: "nextFace", value: function nextFace(e) {var t = e.getPartner();if (!t) return void ("unset" === this._type && (this._type = "chain"));if (this._visitedCoeds.has(t)) return;if (t.getPartner() !== e && (this._type = "unordered", this.collectUnvisitedCoeds(e)), t.getEndVertex() !== this._vertex) return this._type = "unordered", void this.collectUnvisitedCoeds(t);this.addVisitedCoedge(t);var r = t.getNext();if (!this._visitedCoeds.has(r)) return this.getNextFace(r), r;"unset" === this._type && (this._type = "cycle");} }, { key: "prevFace", value: function prevFace(e) {var t = e.getPrevious();if (this._visitedCoeds.has(t)) return;var r = t.getPartner();return r && !this._visitedCoeds.has(r) ? (r.getPartner() !== t && (this._type = "unordered", this.collectUnvisitedCoeds(t)), r.getStartVertex() !== this._vertex ? (this._type = "unordered", void this.collectUnvisitedCoeds(r.getNext())) : (this.addVisitedCoedge(t), this.getPrevFace(r), r)) : void 0;} }, { key: "collectFanFaces", value: function collectFanFaces(e) {if (this._visitedCoeds.has(e)) return;var t = e;this.getNextFace(t);var r = t;for (; r;) {r = this.nextFace(r);}for (r = t; r;) {r = this.prevFace(r);}} }, { key: "marchFan", value: function marchFan(e) {for (this._faces = [], this._type = "unset", this.collectFanFaces(e); this._unvisitedCoeds.size > 0;) {var _e4 = this._unvisitedCoeds.values();this.collectFanFaces(_e4.next().value);}return { faces: this._faces, type: this._type };} }]);return n;}();}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Attribute = void 0;var n = r(44);var o = { "autodesk.brep:nmiattributestr-1.0.0": "nmiattributestr", "autodesk.brep:nmiattributearr-1.0.0": "nmiattributearr", "autodesk.brep:textattribute-1.0.0": "textattribute" };var i = function i(e, t) {n.Base.call(this), this._topologies = [], this.typeid = e, this.values = t || {};};(i.prototype = Object.create(n.Base.prototype)).getValues = function () {return this.values;}, i.prototype.getTypeid = function () {return this.typeid;}, i.prototype.getTopologies = function () {return this._topologies;}, i.prototype.addTopology = function (e) {this._topologies ? this._topologies.push(e) : this._topologies = [e];}, i.prototype.removeTopology = function (e) {var t = this._topologies.indexOf(e);return t > -1 && (this._topologies.splice(t, 1), !0);}, i.prototype.toObject = function () {return this.values;}, i.prototype.addToModelObject = function (e) {if (!e.attributes[this.getGuid()]) {var _t7 = o[this.typeid];if (_t7) {var _r4 = {};_r4[_t7] = this.toObject(), e.attributes[this.getGuid()] = _r4;} else console.warn("Attribute.addToModelObject : Unknown attribute type for proto object!");}}, t.Attribute = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SketchRegionSolver = void 0;var n = r(1),o = r(3),i = r(0),s = r(18),a = r(7),c = r(14),u = r(33),l = r(23),h = r(6),d = r(13),g = r(27),p = r(81),f = r(82),v = r(56),_ = r(36),y = r(55),m = r(41),E = r(112),x = r(113),R = r(2),A = r(8),P = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),V = function V() {this.SIDE = { LEFT: 0, RIGHT: 1 }, this._sketch = void 0, this._intersectionVertices = [], this._edgeSegments = [], this._cells = [], this._faces = [], this._workspace = { edgeIntersections: [], edgeOverlapRegions: [], segmentBlackList: [], edges: [], edgeIDs: [], sweepLineIntersections: void 0, sweepLineRegions: void 0, currentVertex: void 0, nextVertex: void 0, edgesPerCell: void 0 }, this._sketchRegionTopologies = {}, this._planeGeometry = new s.Plane(), this._planeGeometry.set([0, 0, 0], [0, 0, 1], [1, 0, 0]), this._sketchSummary = {}, this._internalToFinalMap = null, this._finalFaces = [], this._progenitorMap = null;};V.prototype.compute = function (e) {this._sketchEdges = e, this._initializeWorkspace(), this._findIntersections(), this._addGraphEdges(), this._mergeCoincidentSegments(), this._sortEdgesAroundVertex(), this._assignAdjacentEdges(), this._sweepRegions(), this._assignleftmostEdges(), this._removeGrazingIntersectionVertices(), this._updateVertexGuidLists(), this._removeTemporaryVertices(), this._assignLoops(), this._updateSketchRegionTopology(), this._clearWorkspace(), this._prepareResult();}, V.prototype._initializeWorkspace = function () {var e = this._workspace;e.edges = {};for (var t = 0; t < this._sketchEdges.length; ++t) {e.edges[this._sketchEdges[t].getGuid()] = this._sketchEdges[t];}for (e.edgeIDs = Object.getOwnPropertyNames(e.edges).sort(), e.edgeIntersections = {}, e.edgeOverlapRegions = {}, e.segmentBlackList = {}, t = 0; t < e.edgeIDs.length; t++) {e.edgeIntersections[e.edgeIDs[t]] = [], e.edgeOverlapRegions[e.edgeIDs[t]] = [], e.segmentBlackList[e.edgeIDs[t]] = [];}e.sweepLineIntersections = void 0, e.sweepLineRegions = void 0, e.edgesPerCell = [], this._faces = [];}, V.prototype._clearWorkspace = function () {this._workspace = { edgeIntersections: [], edgeOverlapRegions: [], segmentBlackList: [], edges: [], edgeIDs: [], sweepLineIntersections: void 0, sweepLineRegions: void 0, currentVertex: void 0, nextVertex: void 0, sweepLinePosition: void 0, edgesPerCell: [] };}, V.prototype._findIntersections = function () {for (var e = this._workspace, t = 0; t < e.edgeIDs.length; t++) {for (var r = e.edges[e.edgeIDs[t]], s = t; s < e.edgeIDs.length; s++) {var a = e.edges[e.edgeIDs[s]];if (s > t || r.getCurveType() === i.GEOMETRY_TYPES.BCURVE) for (var c = (0, p.computeCurveCurveIntersections)(r, a, !0, !1, i.KERNEL_TOLERANCE), u = 0; u < c.length; u++) {var l = c[u];if (l.rangeInfo) e.edgeIntersections[e.edgeIDs[t]].push(P.default.extend(l.rangeInfo[0], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[t]].push(P.default.extend(l.rangeInfo[1], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.extend(l.rangeByInfo[0], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.extend(l.rangeByInfo[1], { temporary: !1 })), e.edgeOverlapRegions[e.edgeIDs[t]].push({ overlapRange: (0, o.convertToOtherPeriodicRange)([l.rangeInfo[0].param, l.rangeInfo[1].param], r.getRange(), r.getCurve().getPeriod(), i.KERNEL_TOLERANCE), otherEdge: e.edgeIDs[s], otherRange: (0, o.convertToOtherPeriodicRange)([l.rangeByInfo[0].param, l.rangeByInfo[1].param], a.getRange(), a.getCurve().getPeriod(), i.KERNEL_TOLERANCE) }), e.edgeOverlapRegions[e.edgeIDs[s]].push({ overlapRange: (0, o.convertToOtherPeriodicRange)([l.rangeByInfo[0].param, l.rangeByInfo[1].param], a.getRange(), a.getCurve().getPeriod(), i.KERNEL_TOLERANCE), otherEdge: e.edgeIDs[t], otherRange: (0, o.convertToOtherPeriodicRange)([l.rangeInfo[0].param, l.rangeInfo[1].param], r.getRange(), r.getCurve().getPeriod(), i.KERNEL_TOLERANCE) });else {if (l.cutInfo.param < r.t0() || l.cutInfo.param > r.t1()) {A.DebugUtils.warn("Intersection outside the bounds of the edge, ignoring");continue;}e.edgeIntersections[e.edgeIDs[t]].push(P.default.defaults(l.cutInfo, { temporary: !1, virtualIntersection: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.defaults(l.cutByInfo, { temporary: !1, virtualIntersection: !1 }));}}}var h = r.getStartVertex(),d = r.getEndVertex(),g = r.t0();h && void 0 !== P.default.findWhere(e.edgeIntersections[e.edgeIDs[t]], { param: g, atVertex: h }) || e.edgeIntersections[e.edgeIDs[t]].push({ param: g, atVertex: h, temporary: !1, virtualIntersection: void 0 });var f = r.t1();d && void 0 !== P.default.findWhere(e.edgeIntersections[e.edgeIDs[t]], { param: f, atVertex: d }) || e.edgeIntersections[e.edgeIDs[t]].push({ param: f, atVertex: d, temporary: !1, virtualIntersection: void 0 }), this._makeEdgeXMonotone(r, e.edgeIntersections[e.edgeIDs[t]]);}var v = [];for (t = 0; t < e.edgeIDs.length; t++) {for (s = 0; s < e.edgeIntersections[e.edgeIDs[t]].length; s++) {v.push({ position: e.edges[e.edgeIDs[t]].evaluatePosition(e.edgeIntersections[e.edgeIDs[t]][s].param), virtualIntersection: e.edgeIntersections[e.edgeIDs[t]][s].virtualIntersection });}}for (t = 0; t < e.edgeIDs.length; t++) {var _ = e.edges[e.edgeIDs[t]];for (s = 0; s < v.length; s++) {var y = v[s];if (_.getBoundingBox().isPointInsideWithTolerance(y.position, i.KERNEL_TOLERANCE)) {var m = _.closestToPointParam(y.position);n.Vector3.distance(y.position, _.evaluatePosition(m)) < i.KERNEL_TOLERANCE && m > _.t0() + i.PARAMETER_SPACE_TOLERANCE && m < _.t1() - i.PARAMETER_SPACE_TOLERANCE && e.edgeIntersections[e.edgeIDs[t]].push({ param: m, atVertex: null, temporary: !0, virtualIntersection: y.virtualIntersection });}}}}, V.prototype._addGraphEdges = function () {var e = this._workspace;this._intersectionVertices = [], this._edgeSegments = [];for (var t = function t(_t8, r) {var n = e.segmentBlackList[_t8],s = e.edges[_t8].getCurve(),a = s.getPeriod(),c = e.edges[_t8].isReversed() ? -1 : 1,u = i.KERNEL_TOLERANCE / s.tangentLength(c * r[0]),l = i.KERNEL_TOLERANCE / s.tangentLength(c * r[1]);if (e.edges[_t8].getCurve().isPeriodic()) {for (var h = 0; h < n.length; h++) {if ((0, o.periodicDifference)(n[h].range[0], r[0], a) < u && (0, o.periodicDifference)(n[h].range[1], r[1], a) < l) return n[h].edge;}} else for (h = 0; h < n.length; h++) {if (Math.abs(n[h].range[0] - r[0]) < u && Math.abs(n[h].range[1] - r[1]) < l) return n[h].edge;}}, r = 0; r < e.edgeIDs.length; r++) {var s = e.edges[e.edgeIDs[r]],a = 1,c = this._createGUIDfromEdgeAndLocalID(s, a);e.edgeIntersections[e.edgeIDs[r]] = e.edgeIntersections[e.edgeIDs[r]].sort(function (e, t) {return e.param - t.param;});for (var u = e.edgeIntersections[e.edgeIDs[r]], l = void 0, h = 0; h < u.length; h++) {var d = s.evaluatePosition(u[h].param),g = this._findVertexIndex(d);void 0 === g ? (g = this._intersectionVertices.length, this._intersectionVertices.push({ position: d, adjacentEdges: [], vertices: [], index: g, guidList: [], mergedPositions: [], topologyVertex: void 0, temporary: u[h].temporary, virtualIntersection: u[h].virtualIntersection })) : (this._intersectionVertices[g].temporary = this._intersectionVertices[g].temporary && u[h].temporary, void 0 !== u[h].virtualIntersection && (void 0 === this._intersectionVertices[g].virtualIntersection ? this._intersectionVertices[g].virtualIntersection = u[h].virtualIntersection : this._intersectionVertices[g].virtualIntersection = this._intersectionVertices[g].virtualIntersection && u[h].virtualIntersection), this._intersectionVertices[g].mergedPositions.push(d));var p = this._intersectionVertices[g];if (u[h].atVertex && -1 === p.vertices.indexOf(u[h].atVertex) && p.vertices.push(u[h].atVertex), h > 0 && l !== g) {c = this._createGUIDfromEdgeAndLocalID(s, a), a++;var f = [u[h - 1].param, u[h].param],v = t(s.getGuid(), f);if (void 0 === v) {var _ = { originalEdge: s, parameterRange: f, startVertex: this._intersectionVertices[l], endVertex: this._intersectionVertices[g], coincidentRanges: [], adjacent: [{ prevEdge: void 0, nextEdge: void 0, face: void 0 }, { prevEdge: void 0, nextEdge: void 0, face: void 0 }], index: this._edgeSegments.length, localGuid: c, topologyEdge: void 0 };this._edgeSegments.push(_), this._intersectionVertices[l].adjacentEdges.push(_), this._intersectionVertices[g].adjacentEdges.push(_);for (var y = 0; y < e.edgeOverlapRegions[e.edgeIDs[r]].length; y++) {var m = e.edgeOverlapRegions[e.edgeIDs[r]][y],E = f,x = i.KERNEL_TOLERANCE;if (s.getCurve().isPeriodic() && (s.getCurveType() === i.GEOMETRY_TYPES.CIRCLE && (x /= s.getCurve().getRadius()), E = (0, o.convertToOtherPeriodicRange)(E, s.getRange(), s.getCurve().getPeriod(), x)), E[0] >= m.overlapRange[0] - i.KERNEL_TOLERANCE && E[1] <= m.overlapRange[1] + i.KERNEL_TOLERANCE) {var R = m.otherEdge,A = [e.edges[R].getCurve().closestToPointParam(_.startVertex.position), e.edges[R].getCurve().closestToPointParam(_.endVertex.position)];if (e.edges[R].getCurve().isPeriodic()) {var P = _.originalEdge.getCurve().evaluateDt(_.parameterRange[0]),V = e.edges[R].getCurve().evaluateDt(A[0]);for (n.Vector3.dot(P, V) < 0 && (T = A[0], A[0] = A[1], A[1] = T); A[1] < A[0];) {A[1] += e.edges[R].getCurve().getPeriod();}} else if (A[0] > A[1]) {var T = A[0];A[0] = A[1], A[1] = T;}e.segmentBlackList[m.otherEdge].push({ range: A, edge: _ });}}} else {var C,b = n.Vector3.distance(v.startVertex.position, s.evaluatePosition(f[0])) > n.Vector3.distance(v.startVertex.position, s.evaluatePosition(f[1]));if (v.coincidentRanges.push({ originalEdge: s, parameterRange: f, localGuid: c, flipped: b }), 0 === p.adjacentEdges.length && ((C = n.Vector3.distance(d, v.startVertex.position) < n.Vector3.distance(d, v.endVertex.position) ? v.startVertex : v.endVertex).mergedPositions.push(d), d = C.position, g = C.index, u[h].atVertex && -1 === C.vertices.indexOf(u[h].atVertex) && C.vertices.push(u[h].atVertex), this._intersectionVertices.pop()), v.startVertex.index !== l && v.endVertex.index !== l) {var L = v.startVertex.index === g ? v.endVertex : v.startVertex,O = this._intersectionVertices[l];for (y = 0; y < O.adjacentEdges.length; y++) {var S = O.adjacentEdges[y];S.startVertex === O && (S.startVertex = L), S.endVertex === O && (S.endVertex = L), L.adjacentEdges.push(S);}for (L.mergedPositions.push(O.position), y = 0; y < O.mergedPositions.length; y++) {L.mergedPositions.push(O.mergedPositions[y]);}for (u[h].atVertex && -1 === L.vertices.indexOf(u[h].atVertex) && L.vertices.push(u[h].atVertex), this._intersectionVertices.splice(l, 1), y = l; y < this._intersectionVertices.length; y++) {this._intersectionVertices[y].index = y;}}}}l = g;}}}, V.prototype._mergeCoincidentSegments = function () {for (var e, t = {}, r = 0; r < this._intersectionVertices.length; r++) {for (var n = this._intersectionVertices[r], o = {}, s = 0; s < n.adjacentEdges.length; s++) {var a = (e = n.adjacentEdges[s]).startVertex === n ? e.endVertex : e.startVertex;t[String(n.index) + "_" + String(a.index)] || (o[String(a.index)] = o[String(a.index)] || [], o[String(a.index)].push(e));}var c = P.default.keys(o);for (s = 0; s < c.length; s++) {if (t[c[s] + "_" + String(n.index)] = !0, o[c[s]].length > 1) for (var u = o[c[s]], l = 0; l < u.length; l++) {for (var h = [], d = l + 1; d < u.length; d++) {(0, f.curvesAreCoincident)(u[l].originalEdge.getCurve(), u[d].originalEdge.getCurve(), u[l].parameterRange, u[d].parameterRange, i.KERNEL_TOLERANCE) && (h.push(u[d]), u.splice(d, 1), d--);}for (d = 0; d < h.length; d++) {var g = h[d];u[l].coincidentRanges.push({ originalEdge: g.originalEdge, parameterRange: g.parameterRange, localGuid: g.localGuid, flipped: g.startVertex !== u[l].startVertex }), g.startVertex.adjacentEdges.splice(g.startVertex.adjacentEdges.indexOf(g), 1), g.endVertex.adjacentEdges.splice(g.endVertex.adjacentEdges.indexOf(g), 1);var p = this._edgeSegments.indexOf(g);this._edgeSegments.splice(p, 1);for (var v = p; v < this._edgeSegments.length; v++) {this._edgeSegments[v].index = v;}}}}}}, V.prototype._sortEdgesAroundVertex = function () {for (var e = 0; e < this._intersectionVertices.length; e++) {for (var t = this._intersectionVertices[e], r = [], s = 0; s < t.adjacentEdges.length; s++) {var a = this._computeAngleAndPositionForEdge(s, t);r.push({ index: s, originalAngle: a.angle, angle: a.angle, position: a.position, derivative: void 0 });}for (var c = 0, u = !1; !u;) {u = !0;var l = -Math.PI + c;for (s = 0; s < r.length; s++) {if ((0, o.angleDifference)(l, r[s].angle) < 1e-5) {u = !1;break;}}if (u) break;c += 2e-5;}for (s = 0; s < t.adjacentEdges.length; s++) {r[s].angle = (0, o.normalizeParameterToShiftedRange)(r[s].angle - c, [-Math.PI, Math.PI]);}var h = this;r = r.sort(function (e, r) {if ((0, o.angleDifference)(e.angle, r.angle) > 1e-5) return e.angle - r.angle;var s = t.adjacentEdges[e.index],a = t.adjacentEdges[r.index],c = s.startVertex === t ? s.parameterRange[0] : s.parameterRange[1],u = a.startVertex === t ? a.parameterRange[0] : a.parameterRange[1],l = s.originalEdge.evaluatePosition(c),d = a.originalEdge.evaluatePosition(u),g = n.Vector3.distance(l, d),p = n.Vector3.createFloat64(),f = n.Vector3.createFloat64(),v = s.originalEdge.evaluateCurvature(c, p),_ = a.originalEdge.evaluateCurvature(u, f);if (0 === v && 0 === _) return e.angle - r.angle;if (0 === v || 0 === _) {var y = 1 / Math.max(v, _);g += 1.5 * Math.sqrt(Math.pow(y, 2) - Math.pow(y - g, 2)) + i.KERNEL_TOLERANCE;} else {var m = 1 / v,E = 1 / _;if (m < E) {var x = m;m = E, E = x;}n.Vector3.dot(p, f) < 0 ? g += -Math.sqrt(-.25 * Math.pow(g, 4) + Math.pow(g, 3) * m - g * g * m * m - (g * g - 2 * g * m) * E * E + (g * g * g - 3 * g * g * m + 2 * g * m * m) * E) / (g - m - E) * 1.5 : g += Math.sqrt(-.25 * Math.pow(g, 4) - Math.pow(g, 3) * m - g * g * m * m - (g * g + 2 * g * m) * E * E + (g * g * g + 3 * g * g * m + 2 * g * m * m) * E) / (g + m - E) * 1.5;}var R = Math.min(n.Vector3.distance(s.endVertex.position, s.startVertex.position), n.Vector3.distance(a.endVertex.position, a.startVertex.position));g = Math.max(i.KERNEL_TOLERANCE, g), g = Math.min(.9 * R, g);var A = !1;do {var P = h._computeEdgeDirectionAtVertex(e, t, g),V = h._computeEdgeDirectionAtVertex(r, t, g);A = (0, o.angleDifference)(P, V) > 1e-8, g *= 5;} while (!A && g < R);var T = P - V;return T > Math.PI ? T -= o.PI2 : T < -Math.PI && (T += o.PI2), T;}), t.adjacentEdges = P.default.map(r, function (e) {return t.adjacentEdges[e.index];});}}, V.prototype._assignAdjacentEdges = function () {for (var e = 0; e < this._edgeSegments.length; e++) {var t = this._edgeSegments[e];this._assignAdjacentEdgesToSegment(t);}}, V.prototype._assignAdjacentEdgesToSegment = function (e) {var t = e.startVertex.adjacentEdges,r = t.indexOf(e);R.ConsoleUtils.assert(-1 !== r, "Error in topology");for (var n = 0, i = e.endVertex.adjacentEdges; n < i.length && i[n] !== e;) {n++;}R.ConsoleUtils.assert(n < i.length, "Error in topology"), e.adjacent[this.SIDE.LEFT].nextEdge = i[(0, o.modulus)(n - 1, i.length)], e.adjacent[this.SIDE.LEFT].prevEdge = t[(0, o.modulus)(r + 1, t.length)], e.adjacent[this.SIDE.RIGHT].nextEdge = i[(0, o.modulus)(n + 1, i.length)], e.adjacent[this.SIDE.RIGHT].prevEdge = t[(0, o.modulus)(r - 1, t.length)];}, V.prototype._sweepRegions = function () {var e = this._workspace,t = P.default.clone(this._intersectionVertices).sort(function (e, t) {if (Math.abs(e.position[0] - t.position[0]) < 1e-9) {for (var r = 0; r < e.adjacentEdges.length; r++) {for (var o = 0; o < t.adjacentEdges.length; o++) {if (e.adjacentEdges[r].originalEdge === t.adjacentEdges[o].originalEdge) {var s = e.adjacentEdges[r],a = t.adjacentEdges[o],c = s.startVertex === e ? s.parameterRange[0] : s.parameterRange[1],u = a.startVertex === t ? a.parameterRange[0] : a.parameterRange[1],l = !0,h = n.Vector3.createFloat64();n.Vector3.normalize(h, s.originalEdge.evaluateDt(c));var d = n.Vector3.createFloat64();if (n.Vector3.normalize(d, a.originalEdge.evaluateDt(u)), Math.sign(h[0]) !== Math.sign(d[0])) continue;if (Math.abs(h[0]) > i.KERNEL_TOLERANCE && Math.abs(d[0]) > i.KERNEL_TOLERANCE) l = h[0] > 0;else {if (Math.abs(e.position[1] - t.position[1]) < i.KERNEL_TOLERANCE) continue;l = h[1] > 0;}return (c - u) * (l ? 1 : -1);}}}return e.position[1] - t.position[1];}return e.position[0] - t.position[0];});this._cells = [];var r = { index: -1, loops: [], loopOrientations: [], dangling: [], leftmostVertex: void 0 };e.sweepLineIntersections = [-1 / 0, 1 / 0], e.sweepLineRegions = e.sweepLineRegions = [r];for (var o = [], s = 0; s < t.length; s++) {e.sweepLineRegions.length !== e.sweepLineIntersections.length - 1 && console.error("Error during sweep computation");var a = t[s],c = P.default.clone(a.adjacentEdges),u = void 0;if (o[a.index]) {for (var l = o[a.index], h = [], d = 0; d < e.sweepLineIntersections.length - 1; d++) {P.default.contains(l, e.sweepLineIntersections[d]) && (void 0 === u && (u = d - 1), P.default.contains(l, e.sweepLineIntersections[d + 1]) && h.push(d));}for (d = 0; d < l.length; d++) {for (var g = l[d], p = 0; p < e.sweepLineIntersections.length; p++) {e.sweepLineIntersections[p] === g && e.sweepLineIntersections.splice(p, 1);}for (p = 0; p < c.length; p++) {c[p] === g && c.splice(p, 1);}}for (d = h.length - 1; d >= 0; d--) {e.sweepLineRegions.splice(h[d], 1);}} else u = this._findVertexOnSweepLine(a), e.sweepLineRegions.splice(u + 1, 0, e.sweepLineRegions[u]);if (c.length > 0) {var f = u + 1;for (d = 0; d < c.length; d++) {var v = c[d];e.sweepLineIntersections.splice(f, 0, v);var _ = v.startVertex === a ? v.endVertex : v.startVertex;if (void 0 === o[_.index] && (o[_.index] = []), o[_.index].push(v), d > 0) {var y = { index: this._cells.length, loops: [], loopOrientations: [], dangling: [], leftmostVertex: a };this._cells.push(y), e.sweepLineRegions.splice(f - 1, 0, y);}f++;}for (f = u, d = 0; d < c.length; d++) {var m = (v = c[d]).startVertex !== a;v.adjacent[m ? this.SIDE.RIGHT : this.SIDE.LEFT].face = e.sweepLineRegions[f + 1], v.adjacent[m ? this.SIDE.LEFT : this.SIDE.RIGHT].face = e.sweepLineRegions[f], f++;}} else if (e.sweepLineRegions[u] !== e.sweepLineRegions[u + 1]) {var E = e.sweepLineRegions[u + 1],x = e.sweepLineRegions[u];for (x === r ? (x = E, E = r, e.sweepLineRegions.splice(u, 1)) : (void 0 !== x.leftmostVertex && (void 0 === E.leftmostVertex || E.leftmostVertex.position[0] > x.leftmostVertex.position[0]) && (E.leftmostVertex = x.leftmostVertex), e.sweepLineRegions.splice(u + 1, 1)), d = 0; d < this._edgeSegments.length; d++) {this._edgeSegments[d].adjacent[this.SIDE.LEFT].face === x && (this._edgeSegments[d].adjacent[this.SIDE.LEFT].face = E), this._edgeSegments[d].adjacent[this.SIDE.RIGHT].face === x && (this._edgeSegments[d].adjacent[this.SIDE.RIGHT].face = E);}for (d = 0; d < e.sweepLineRegions.length; d++) {e.sweepLineRegions[d] === x && (e.sweepLineRegions[d] = E);}this._cells[x.index] = void 0;} else e.sweepLineRegions.splice(u + 1, 1);}for (s = 0; s < this._cells.length; s++) {void 0 === this._cells[s] && (this._cells.splice(s, 1), s--);}for (s = 0; s < this._cells.length; s++) {this._cells[s].index = s;}}, V.prototype._assignleftmostEdges = function () {for (var e = this, t = 0; t < this._cells.length; t++) {var r = this._cells[t],n = r.leftmostVertex,o = P.default.filter(n.adjacentEdges, function (t) {var n = t.adjacent[e.SIDE.LEFT].face,o = t.adjacent[e.SIDE.RIGHT].face;return (n === r || o === r) && n !== o;});if (R.ConsoleUtils.assert(o.length >= 2, "In each loop there should be at least two adjacent edges"), o.length > 2) for (var i = 0; i < o.length; i++) {var s = o[i].adjacent[e.SIDE.LEFT].face === r ? e.SIDE.LEFT : e.SIDE.RIGHT,a = o[i].adjacent[s],c = o[i].startVertex === n ? a.prevEdge : a.nextEdge;if (P.default.contains(o, c)) {o = [o[i], c];break;}}var u = o[0];u.loopsCurveAligned = !!(u.startVertex === n ^ o[0].adjacent[e.SIDE.RIGHT].face === r), r.leftmostEdge = u, r.leftmostVertex = void 0;}}, V.prototype._removeGrazingIntersectionVertices = function () {for (var e = {}, t = 0, r = this._intersectionVertices.slice(); r.length > 0;) {var n = r.pop();if (2 === n.adjacentEdges.length && (1 === n.adjacentEdges[0].coincidentRanges.length || 1 === n.adjacentEdges[1].coincidentRanges.length) && n.virtualIntersection) {var i,s,a = 1 === n.adjacentEdges[0].coincidentRanges.length && 1 === n.adjacentEdges[1].coincidentRanges.length,c = n.adjacentEdges.slice();if (a) {if (i = [c[0].originalEdge, c[0].coincidentRanges[0].originalEdge], s = [c[1].originalEdge, c[1].coincidentRanges[0].originalEdge], !(i[0] === s[0] && i[1] === s[1] || i[0] === s[1] && i[1] === s[0])) continue;e[c[0].originalEdge.getGuid()] = !0, e[c[0].coincidentRanges[0].originalEdge.getGuid()] = !0, e[c[1].originalEdge.getGuid()] = !0, e[c[1].coincidentRanges[0].originalEdge] = !0;var u = [c[0].startVertex === n ? c[0].endVertex : c[0].startVertex, n, c[1].startVertex === n ? c[1].endVertex : c[1].startVertex];} else {var l;c[0].coincidentRanges.length > 0 ? (l = 0, i = [c[0].originalEdge, c[0].coincidentRanges[0].originalEdge]) : (l = 1, i = [c[1].originalEdge, c[1].coincidentRanges[0].originalEdge]), e[i[0].getGuid()] = !0, e[i[1].getGuid()] = !0, u = [c[l].startVertex === n ? c[l].endVertex : c[l].startVertex, n], c = [c[l]];}var h = void 0,d = void 0;if (u[0].vertices.length > 0 ? (h = u[0], d = a ? [u[1], u[2]] : [u[1]]) : a && u[2].vertices.length > 0 ? (h = u[2], d = [u[0], u[1]]) : (h = u[1], d = a ? [u[0], u[2]] : [u[0]]), d[0].vertices.length > 0 || d[1] && (d[1].vertices.length > 0 || d[0] === d[1])) continue;for (var g = !0, p = P.default.without(d, n), f = 0; f < p.length; f++) {var v = p[f].adjacentEdges;if ((v = P.default.difference(v, c)).length > 2) {g = !1;break;}for (var _ = 0; _ < v.length; _++) {if (v[_].coincidentRanges.length > 0 || v[_].originalEdge !== i[0] && v[_].originalEdge !== i[1]) {g = !1;break;}}}if (!g) continue;for (f = 0; f < p.length; f++) {var y = p[f],m = P.default.intersection(c, y.adjacentEdges)[0],E = n !== h && a ? P.default.without(c, m)[0] : m,x = P.default.without(y.adjacentEdges, m);for (y.adjacentEdges[1] === m && (x = x.reverse()), _ = 0; _ < x.length; _++) {var R = x[_],A = E.startVertex === h ? 0 : 1,V = void 0;if (E.originalEdge === R.originalEdge) V = E.parameterRange[A];else {var T = E.coincidentRanges[0].flipped ? 1 - A : A;V = E.coincidentRanges[0].parameterRange[T];}R.startVertex === y ? (R.startVertex = h, R.parameterRange[0] = V) : (R.endVertex = h, R.parameterRange[1] = V);for (var C = 0; C < R.adjacent.length; C++) {var b = R.adjacent[C].face;b.leftmostEdge !== m && b.leftmostEdge !== E || (R.loopsCurveAligned = b.leftmostEdge.loopsCurveAligned, b.leftmostEdge = R), (b.leftmostVertex === d[0] || void 0 !== d[1] && b.leftmostVertex === d[1]) && (b.leftmostVertex = h);}}var L = h.adjacentEdges.indexOf(E);Array.prototype.splice.apply(h.adjacentEdges, [L, 1].concat(x));var O = h.adjacentEdges.length,S = [(0, o.modulus)(L - 1, O), L, L + 1, (L + 2) % O];for (_ = 0; _ < S.length; _++) {var M = h.adjacentEdges[S[_]];this._assignAdjacentEdgesToSegment(M);}}this._intersectionVertices = P.default.difference(this._intersectionVertices, d), r = P.default.difference(r, d), this._edgeSegments = P.default.difference(this._edgeSegments, c), t++;}}if (t > 0) {for (var w = 0; w < this._intersectionVertices.length; w++) {this._intersectionVertices[w].index = w;}for (w = 0; w < this._edgeSegments.length; w++) {this._edgeSegments[w].index = w;}}var N = P.default.keys(e);for (w = 0; w < N.length; w++) {var F = N[w],I = [];for (f = 0; f < this._edgeSegments.length; f++) {for ((D = this._edgeSegments[f]).originalEdge.getGuid() === F && I.push([D, D.parameterRange[0]]), _ = 0; _ < D.coincidentRanges.length; _++) {D.coincidentRanges[_].originalEdge.getGuid() === F && I.push([D, D.coincidentRanges[_].parameterRange[0]]);}}for (I.sort(function (e, t) {return e[1] - t[1];}), f = 0; f < I.length; f++) {var D;for ((D = I[f][0]).originalEdge.getGuid() === F && (D.localGuid = this._createGUIDfromEdgeAndLocalID(D.originalEdge, f + 1)), _ = 0; _ < D.coincidentRanges.length; _++) {D.coincidentRanges[_].originalEdge.getGuid() === F && (D.coincidentRanges[_].localGuid = this._createGUIDfromEdgeAndLocalID(D.coincidentRanges[_].originalEdge, f + 1));}}}}, V.prototype._removeTemporaryVertices = function () {for (var e = 0, t = 0; t < this._intersectionVertices.length; t++) {var r = this._intersectionVertices[t];if (r.temporary && 2 === r.adjacentEdges.length && r.adjacentEdges[0].originalEdge === r.adjacentEdges[1].originalEdge && r.adjacentEdges[0] !== r.adjacentEdges[1]) {var n, o;r.adjacentEdges[0].endVertex === r ? (n = r.adjacentEdges[0], o = r.adjacentEdges[1]) : (n = r.adjacentEdges[1], o = r.adjacentEdges[0]), R.ConsoleUtils.assert(n.adjacent[this.SIDE.LEFT].face === o.adjacent[this.SIDE.LEFT].face), R.ConsoleUtils.assert(n.adjacent[this.SIDE.RIGHT].face === o.adjacent[this.SIDE.RIGHT].face);var s = n.parameterRange[1] - o.parameterRange[0],a = (n.originalEdge.isReversed() ? -1 : 1) * n.parameterRange[0],c = i.KERNEL_TOLERANCE / n.originalEdge.getCurve().tangentLength(a);if (n.originalEdge.getCurve().isPeriodic() && Math.abs(s - n.originalEdge.getCurve().getPeriod()) < c) n.parameterRange[1] = o.parameterRange[1] + s;else {if (Math.abs(s) > c) continue;n.parameterRange[1] = o.parameterRange[1];}n.endVertex = o.endVertex, n.adjacent[this.SIDE.LEFT].nextEdge = o.adjacent[this.SIDE.LEFT].nextEdge, n.adjacent[this.SIDE.RIGHT].nextEdge = o.adjacent[this.SIDE.RIGHT].nextEdge, n.adjacent[this.SIDE.LEFT].prevEdge === o && (n.adjacent[this.SIDE.LEFT].prevEdge = n), n.adjacent[this.SIDE.RIGHT].prevEdge === o && (n.adjacent[this.SIDE.RIGHT].prevEdge = n);var u = n.adjacent[this.SIDE.LEFT].nextEdge;u.adjacent[this.SIDE.LEFT].prevEdge === o && (u.adjacent[this.SIDE.LEFT].prevEdge = n), u.adjacent[this.SIDE.LEFT].nextEdge === o && (u.adjacent[this.SIDE.LEFT].nextEdge = n), u.adjacent[this.SIDE.RIGHT].prevEdge === o && (u.adjacent[this.SIDE.RIGHT].prevEdge = n), u.adjacent[this.SIDE.RIGHT].nextEdge === o && (u.adjacent[this.SIDE.RIGHT].nextEdge = n);var l = n.adjacent[this.SIDE.RIGHT].nextEdge;l.adjacent[this.SIDE.LEFT].prevEdge === o && (l.adjacent[this.SIDE.LEFT].prevEdge = n), l.adjacent[this.SIDE.LEFT].nextEdge === o && (l.adjacent[this.SIDE.LEFT].nextEdge = n), l.adjacent[this.SIDE.RIGHT].prevEdge === o && (l.adjacent[this.SIDE.RIGHT].prevEdge = n), l.adjacent[this.SIDE.RIGHT].nextEdge === o && (l.adjacent[this.SIDE.RIGHT].nextEdge = n), o.adjacent[this.SIDE.LEFT].face.leftmostEdge === o && (o.adjacent[this.SIDE.LEFT].face.leftmostEdge = n), o.adjacent[this.SIDE.RIGHT].face.leftmostEdge === o && (o.adjacent[this.SIDE.RIGHT].face.leftmostEdge = n), void 0 === n.loopsCurveAligned && (n.loopsCurveAligned = o.loopsCurveAligned), (0, v.hashCombine4xUint32)(n.localGuid, o.localGuid, n.localGuid);var h = n.endVertex.adjacentEdges.indexOf(o);n.endVertex.adjacentEdges[h] = n, this._intersectionVertices.splice(t, 1), this._edgeSegments.splice(o.index - e, 1), t--, e++;} else this._intersectionVertices[t].index -= e;}for (t = 0; t < this._edgeSegments.length; t++) {this._edgeSegments[t].index = t;}}, V.prototype._updateVertexGuidLists = function () {for (var e = 0; e < this._intersectionVertices.length; e++) {var t = this._intersectionVertices[e];if (t.vertices.length > 0) for (var r = 0; r < t.vertices.length; r++) {t.guidList.push((0, v.guidToUint32x4)(t.vertices[r].getGuid()));} else {var n = {};for (r = 0; r < t.adjacentEdges.length; r++) {var o = t.adjacentEdges[r];if (!n[o.index]) {n[o.index] = !0, t.guidList.push(o.localGuid);for (var i = 0; i < o.coincidentRanges.length; i++) {t.guidList.push(o.coincidentRanges[i].localGuid);}}}}}}, V.prototype._assignLoops = function () {var e = this._workspace;e.edgesPerCell = [];for (var t = 0; t < this._cells.length; t++) {e.edgesPerCell[t] = [];}for (t = 0; t < this._edgeSegments.length; t++) {var r = this._edgeSegments[t],n = r.adjacent[this.SIDE.LEFT].face.index;n >= 0 && e.edgesPerCell[n].push(r);var o = r.adjacent[this.SIDE.RIGHT].face.index;o >= 0 && n !== o && e.edgesPerCell[o].push(r);}var i = [];for (t = 0; t < this._cells.length; t++) {var s = [];i[t] = s;for (var a = this._followLoopFromEdge(this._cells[t].leftmostEdge, this._cells[t], !1, !0), c = 0; c < a.loop.length; c++) {s[a.loop[c].index] = !0;}this._cells[t].loops.push(a.loop), this._cells[t].loopOrientations.push(a.orientations);}for (t = 0; t < this._cells.length; t++) {s = i[t];for (var u = 0; u < e.edgesPerCell[t].length; u++) {var l = e.edgesPerCell[t][u];if (l.adjacent[this.SIDE.LEFT].face !== l.adjacent[this.SIDE.RIGHT].face) {if (!0 !== s[l.index]) {for (a = this._followLoopFromEdge(l, this._cells[t], !0, !1), c = 0; c < a.loop.length; c++) {s[a.loop[c].index] = !0;}this._cells[t].loops.push(a.loop), this._cells[t].loopOrientations.push(a.orientations);}} else this._cells[t].dangling.push(l);}}}, V.prototype._updateSketchRegionTopology = function () {for (var e = this._workspace, t = P.default.keys(this._sketchRegionTopologies), r = 0; r < t.length; r++) {var n = t[r];this._sketchRegionTopologies[n].updated = !1, "FaceID" === this._sketchRegionTopologies[n].topology.tuid && this._sketchRegionTopologies[n].topology.removeAllEdges();}var o = {},s = {};for (r = 0; r < this._intersectionVertices.length; r++) {var a = this._addOrFindTopologySubcomponent("VertexID", i.GEOMETRY_TYPES.POINT, this._intersectionVertices[r].guidList, s);a.setPoint(new h.Point(this._intersectionVertices[r].position)), a.setAssociatedEntities(P.default.clone(this._intersectionVertices[r].vertices));for (var c = 0; c < this._intersectionVertices[r].vertices.length; ++c) {var u = this._intersectionVertices[r].vertices[c].getGuid();R.ConsoleUtils.assert(!o[u], "vertex should only map to one topology vertex"), o[u] = a;}this._intersectionVertices[r].topologyVertex = a;}for (r = 0; r < this._edgeSegments.length; r++) {var l = this._edgeSegments[r],p = [l.localGuid];for (c = 0; c < l.coincidentRanges.length; c++) {p.push(l.coincidentRanges[c].localGuid);}(V = this._addOrFindTopologySubcomponent("EdgeID", l.originalEdge.getCurveType(), p, s)).setToEdgeSegment(l.originalEdge, l.parameterRange), V.setStartVertex(l.startVertex.topologyVertex), V.setEndVertex(l.endVertex.topologyVertex);var f = [{ edge: l.originalEdge, range: P.default.clone(l.parameterRange), flipped: !1 }];for (c = 0; c < l.coincidentRanges.length; c++) {f.push({ edge: l.coincidentRanges[c].originalEdge, range: P.default.clone(l.coincidentRanges[c].parameterRange), flipped: l.coincidentRanges[c].flipped });}V.setAssociatedEdges(f), l.topologyEdge = V;}for (r = 0; r < this._cells.length; r++) {var _ = this._cells[r];for (p = [], c = 0; c < e.edgesPerCell[r].length; c++) {p.push((0, v.guidToUint32x4)(e.edgesPerCell[r][c].topologyEdge.getGuid()));}var y = this._addOrFindTopologySubcomponent("FaceID", i.GEOMETRY_TYPES.PLANE, p, s);y.setSurface(this._planeGeometry);var m = [];for (c = 0; c < _.loops.length; c++) {var E = new d.Loop();E.setFace(y), m.push(E);for (var x = [], A = 0; A < _.loops[c].length; A++) {var V = _.loops[c][A].topologyEdge,T = new g.Coedge();T.setLoop(E), x.push(T), T.setEdge(V), T.setReversed(!_.loopOrientations[c][A]), V.getCoedge() ? V.getCoedge().getPartner() || (V.getCoedge().setPartner(T), T.setPartner(V.getCoedge())) : V.setCoedge(T), _.loops[c][A].topologyEdge.setIsDangling(!1);}E.setCoedges(x);}for (y.setLoops(m), this._faces.push(y), c = 0; c < _.dangling.length; c++) {y.addDanglingEdge(_.dangling[c].topologyEdge), _.dangling[c].topologyEdge.setIsDangling(!0);}}for (r = 0; r < t.length; r++) {this._sketchRegionTopologies[t[r]].updated || delete this._sketchRegionTopologies[t[r]];}}, V.prototype._followLoopFromEdge = function (e, t, r, n) {var o = [],i = [],s = e,a = [],c = e.adjacent[this.SIDE.LEFT].face === t ? this.SIDE.LEFT : this.SIDE.RIGHT,u = !!(s.loopsCurveAligned ^ c !== this.SIDE.LEFT),l = u ? e.startVertex : e.endVertex;do {if (s.adjacent[c].face !== t) {console.error("REGION: Adjacent edge face does not match cell! FIXME!");break;}if (a[s.index]) {console.error("REGION: Malformed edges; walking edge lead us to despair");break;}a[s.index] = !0, o.push(s), i.push(u);do {u ? (l = s.endVertex, s = s.adjacent[c].nextEdge) : (l = s.startVertex, s = s.adjacent[c].prevEdge), s.startVertex === s.endVertex ? c = s.adjacent[this.SIDE.LEFT].face === t ? this.SIDE.LEFT : this.SIDE.RIGHT : (c = s.startVertex === l ? this.SIDE.LEFT : this.SIDE.RIGHT, s.adjacent[this.SIDE.LEFT].face === s.adjacent[this.SIDE.RIGHT].face && (c = 1 - c, l = s.startVertex === l ? s.endVertex : s.startVertex)), u = c === this.SIDE.LEFT;} while (s.adjacent[this.SIDE.LEFT].face === s.adjacent[this.SIDE.RIGHT].face);n && void 0 === s.loopsCurveAligned && (s.loopsCurveAligned = !!(u ^ c !== this.SIDE.LEFT));} while (s !== e);return { loop: o, orientations: i };}, V.prototype._addNewRegionTopology = function (e) {switch (e.tuid) {case "VertexID":var t = new E.RegionTopologyVertex(new h.Point());return t.setGuid(e.guid), t;case "EdgeID":var r = void 0;switch (e.minortype) {case i.GEOMETRY_TYPES.LINE:r = new a.Line();break;case i.GEOMETRY_TYPES.CIRCLE:r = new c.Circle();break;case i.GEOMETRY_TYPES.ELLIPSE:r = new l.Ellipse();break;case i.GEOMETRY_TYPES.BCURVE:r = new u.BCurve();break;default:console.error("Unhandled curve type");}var n = new E.RegionTopologyEdge(r);return n.setGuid(e.guid), n;case "FaceID":switch (r = void 0, e.minortype) {case i.GEOMETRY_TYPES.PLANE:r = new s.Plane();break;default:console.error("Unhandled surface type");}var o = new E.RegionTopologyFace(r);return o.setGuid(e.guid), o;default:console.error("Unhandled topology type");}}, V.prototype._addOrFindTopologySubcomponent = function (e, t, r, n) {var o = this._createNameFromGuidList(e, t, r, n);if (this._sketchRegionTopologies[o]) {var i = this._sketchRegionTopologies[o];return i.updated = !0, i.topology;}var s = this._addNewRegionTopology({ tuid: e, minortype: t, guid: o });return this._sketchRegionTopologies[o] = { topology: s, updated: !0 }, s;};var T = { VertexID: [1168004130, 3764602020, 2270554856, 1368826480], EdgeID: [2942887333, 1472546498, 2159971906, 413489693], FaceID: [2166479754, 2329626594, 2838556660, 1584616933] },C = {};C[i.GEOMETRY_TYPES.POINT] = [2299429810, 2248164535, 3202574069, 2684287321], C[i.GEOMETRY_TYPES.LINE] = [910992607, 3428993096, 3010390753, 2966835859], C[i.GEOMETRY_TYPES.CIRCLE] = [2229232555, 842549819, 2526558959, 4217038233], C[i.GEOMETRY_TYPES.PLANE] = [2122299449, 3667741317, 2812958731, 939246365], C[i.GEOMETRY_TYPES.BCURVE] = [420548527, 2703575863, 2792852189, 2595995847], C[i.GEOMETRY_TYPES.ELLIPSE] = [902753991, 1129557208, 9277753211, 1913737389];var b = function b(e, t) {var r = 2166136261;return t && (r = 16777619 * (r ^ t) >>> 0), 16777619 * (((r = 16777619 * (((r = 16777619 * (((r = 16777619 * ((r ^ 255 & e) >>> 0) >>> 0) ^ e >> 8 & 255) >>> 0) >>> 0) ^ e >> 16 & 255) >>> 0) >>> 0) ^ e >> 24 & 255) >>> 0) >>> 0;},L = function () {var e = new Uint32Array(4);return function (t) {return e[0] = t, e[1] = 16777619, e[2] = t, e[3] = t, (0, v.hashCombine4xUint32)(e, e);};}(),O = function O(e, t) {for (var r = 0; r < e.length; r++) {e[r] = (e[r] ^ t[r]) >>> 0;}};V.prototype._createNameFromGuidList = function (e, t, r, n) {var o = P.default.clone(T[e]),i = C[t];R.ConsoleUtils.assert(o && i, "Unsupported tuid or minortype!"), O(o, i);for (var s = 0; s < r.length; s++) {O(o, r[s]);}var a = (0, v.uint32x4ToGUID)(o);if (n[a]) {var c = ++n[a];return (r = P.default.clone(r)).push(L(b(c))), this._createNameFromGuidList(e, t, r, n);}return n[a] = 1, a;}, V.prototype._createGUIDfromEdgeAndLocalID = function (e, t) {var r = (0, v.guidToUint32x4)(e.getGuid()),n = L(b(t));return (0, v.hashCombine4xUint32)(r, n);}, V.prototype._findVertexIndex = function (e) {for (var t = 0; t < this._intersectionVertices.length; t++) {if (n.Vector3.distance(this._intersectionVertices[t].position, e) < i.KERNEL_TOLERANCE) return t;for (var r = 0; r < this._intersectionVertices[t].mergedPositions.length; r++) {if (n.Vector3.distance(this._intersectionVertices[t].mergedPositions[r], e) < i.KERNEL_TOLERANCE) return t;}}}, V.prototype._findVertexOnSweepLine = function (e) {for (var t = this._workspace, r = 0, n = t.sweepLineIntersections.length - 1; n >= r;) {if (r + 1 >= n) return r;var o = Math.floor((r + n) / 2);this._isVertexAboveEdgeSegment(t.sweepLineIntersections[o], e) ? r = o : n = o;}console.error("Error in binary search function!");}, V.prototype._isVertexAboveEdgeSegment = function (e, t) {if (e === -1 / 0) return !0;if (e === 1 / 0) return !1;var r = e.originalEdge;switch (r.getCurveType()) {case i.GEOMETRY_TYPES.LINE:var o = r.getStartVertex().getPosition(),s = n.Vector3.createFloat64();n.Vector3.subtract(s, r.getEndVertex().getPosition(), o);var a = n.Vector3.createFloat64();return n.Vector3.subtract(a, t.position, o), (s[0] < 0 || 0 === s[0] && s[1] < 0) && n.Vector3.negate(s, s), a[1] * s[0] - a[0] * s[1] > 0;case i.GEOMETRY_TYPES.CIRCLE:var c = t.position[0] - r.getCurve().getCenter()[0],u = .5 * (e.parameterRange[0] + e.parameterRange[1]),l = r.getCurve().evaluateDtt(u)[1] > 0 ? -1 : 1;return Math.abs(c) > r.getCurve().getRadius() ? r.getCurve().getCenter()[1] < t.position[1] : r.getCurve().getCenter()[1] + l * Math.sqrt(r.getCurve().getRadius() * r.getCurve().getRadius() - c * c) < t.position[1];default:return this.getYvalueForX(e, t.position[0]) < t.position[1];}}, V.prototype._makeEdgeXMonotone = function (e, t) {var r = e.getCurve(),s = [];switch (e.getCurveType()) {case i.GEOMETRY_TYPES.LINE:break;case i.GEOMETRY_TYPES.CIRCLE:var a = r.evaluatePosition(0);n.Vector3.subtract(a, a, r.getCenter());var c = r.getNormal()[2] > 0 ? -1 : 1;s[0] = c * Math.atan2(a[1], a[0]), s[1] = s[0] - Math.PI;break;case i.GEOMETRY_TYPES.ELLIPSE:var u = r.getMajorAxis()[0] * r.getMajorRadius(),l = r.getMinorAxis()[0] * r.getMinorRadius();s[0] = Math.atan2(l, u), s[1] = s[0] - Math.PI;break;case i.GEOMETRY_TYPES.BCURVE:s = _.SplineCurveHelper.extremalParams(r, 0);break;default:console.warn("Unsupported edge type in sketch region op");}for (var h = 0; h < s.length; h++) {var d = s[h];e.isReversed() && (d = -d), r.isPeriodicUnlimited() && (d = (0, o.adjustParameterToPeriodicRange)(d, e.getRange(), r.getPeriodUnlimited())), d >= e.t0() && d <= e.t1() && (t.push({ param: d, atVertex: null, temporary: !0 }), A.DebugUtils.level("region3D") > 0 && A.DebugUtils.drawPoint3D(e.evaluatePosition(d), { color: 16711935, label: "x monotonic" }));}}, V.prototype.plotSegments = function (e, t) {var r = this._workspace;Debug.hold("on"), Debug.clearFigure(), Debug.delayUpdates(!0);for (var o = 0; o < this._intersectionVertices.length; o++) {var i = Debug.plotColorForIndex(this._intersectionVertices[o].adjacentEdges.length);if ("sweepLineState" === e && (i = "k", this._intersectionVertices[o] === r.currentVertex && (i = "g"), this._intersectionVertices[o] === r.nextVertex && (i = "b")), Debug.plot([this._intersectionVertices[o].position], i + "o"), "orderColored" === e) for (var s = this._intersectionVertices[o], a = [], c = 0; c < s.adjacentEdges.length; c++) {i = Debug.plotColorForIndex(c);var u = s.adjacentEdges[c],l = P.default.clone(u.parameterRange);u.startVertex !== s || a[u.index] ? l[0] = .5 * (l[0] + l[1]) : l[1] = .5 * (l[0] + l[1]), a[u.index] = !0;var h = u.originalEdge.tessellate(l).positions;Debug.plot(h, i + "-");}}if ("orderColored" !== e) for (o = 0; o < this._edgeSegments.length; o++) {if (u = this._edgeSegments[o], "coincidenceCount" === e) {var d = u.coincidentRanges.length + 1;i = Debug.plotColorForIndex(d);} else i = Debug.plotColorForIndex(o);if ("sweepLineState" === e && (i = r.sweepLineIntersections.indexOf(u) > -1 ? "r" : "k"), t && t.highlightLoop && (i = P.default.contains(t.highlightLoop, u) ? "R" : "k"), h = u.originalEdge.tessellate(u.parameterRange).positions, "regions" === e) {var g = [],p = [];for (c = 0; c < h.length; c++) {if (c < h.length - 1) {var f = n.Vector3.createFloat64();n.Vector3.subtract(f, h[c + 1], h[c]);} else f = n.Vector3.createFloat64(), n.Vector3.subtract(f, h[c], h[c - 1]);n.Vector3.normalize(f, f), n.Vector3.scale(f, f, .05), n.Vector3.cross(f, [0, 0, 1], f);var v = n.Vector3.clone(h[c]);g.push(n.Vector3.add(v, v, f));var _ = n.Vector3.clone(h[c]);p.push(n.Vector3.subtract(_, _, f));}var y = u.adjacent[this.SIDE.LEFT].face.index;i = Debug.plotColorForIndex(y), Debug.plot(g, i + "-");var m = u.adjacent[this.SIDE.RIGHT].face.index;i = Debug.plotColorForIndex(m), Debug.plot(p, i + "-");} else Debug.plot(h, i + "-");}if ("sweepLineState" === e && r.sweepLinePosition) {var E = r.sweepLinePosition,x = void 0;for (o = 0; o < r.sweepLineIntersections.length; o++) {var R,A = r.sweepLineIntersections[o];void 0 !== (R = A === 1 / 0 ? 5 : A === -1 / 0 ? -5 : this.getYvalueForX(A, E)) && (Debug.plot([E], [R], "y."), void 0 !== x && (i = Debug.plotColorForIndex(r.sweepLineRegions[o - 1].index), Debug.plot([E, E], [x, R], i + "-")), x = R);}}if (t && t.showOrientation) {h = [];var V = [],T = [];for (o = 0; o < this._edgeSegments.length; o++) {var C = !(void 0 === (u = this._edgeSegments[o]).loopsCurveAligned || !0 === u.loopsCurveAligned),b = C ? .05 : .95,L = u.parameterRange[0] * (1 - b) + u.parameterRange[1] * b,O = u.originalEdge.evaluatePosition(L);h.push(O);var S = t.arrowSize || .1,M = C ? -S : S;if (u.adjacent[this.SIDE.LEFT].face.index >= 0) {var w = u.originalEdge.evaluateDt(L);n.Vector3.normalize(w, w);var N = [O[0] - S * w[1], O[1] + S * w[0]];V.push(N), T.push([M * w[0], M * w[1]]);}if (u.adjacent[this.SIDE.RIGHT].face.index >= 0) {var F = u.parameterRange[0] * b + u.parameterRange[1] * (1 - b),I = u.originalEdge.evaluatePosition(F),D = u.originalEdge.evaluateDt(F);n.Vector3.normalize(D, D);var j = [I[0] + S * D[1], I[1] - S * D[0]];V.push(j), T.push([-M * D[0], -M * D[1]]);}}Debug.plot(h, "k."), Debug.quiver(V, T, "g", "c");}Debug.delayUpdates(!1), Debug.equalAxis();}, V.prototype.plotEdgeSegment = function (e, t) {Debug.plotEdgeList([e.originalEdge], !1, t + "-", { ranges: [e.parameterRange] });}, V.prototype.plotEdgesAroundVertex = function (e, t) {Debug.plot([e.position], "gx");for (var r = 0; r < e.adjacentEdges.length; r++) {var n,o = e.adjacentEdges[r];console.log(r), n = o.startVertex === e ? [o.parameterRange[0], o.parameterRange[0] + t / o.originalEdge.getCurve().tangentLength(o.parameterRange[0])] : [o.parameterRange[1] - t / o.originalEdge.getCurve().tangentLength(o.parameterRange[0]), o.parameterRange[1]], Debug.plotEdgeList([o.originalEdge], !1, "-" + Debug.plotColorForIndex(r), { ranges: [n], showOrientation: !1, resolution: 1e4 });}}, V.prototype.getYvalueForX = function (e, t) {var r = e.parameterRange[0],n = e.parameterRange[1],o = e.originalEdge.evaluatePosition(r),s = e.originalEdge.evaluatePosition(n),a = o[0],c = s[0];if (a > c) {var u = r;r = n, n = u, u = a, a = c, c = u, u = o, o = s, s = u;}if (t <= a + i.KERNEL_TOLERANCE || t >= c - i.KERNEL_TOLERANCE) return Math.abs(t - a) <= i.KERNEL_TOLERANCE ? o[1] : Math.abs(t - c) <= i.KERNEL_TOLERANCE ? s[1] : void console.warn("Failure in getYvalueForX, in_x oustide segment range, returning undefined");for (; c >= a;) {if (a + i.KERNEL_TOLERANCE >= c) return h[1];var l = (r + n) / 2,h = e.originalEdge.evaluatePosition(l);if (Math.abs(r - n) <= i.PARAMETER_SPACE_TOLERANCE) return R.ConsoleUtils.assert(!1, "Could not converge to a solution for getYvalueForX"), h[1];h[0] < t ? (a = h[0], r = l) : (c = h[0], n = l);}console.warn("Failure in getYvalueForX, returning undefined");}, V.prototype._computeAngleAndPositionForEdge = function (e, t, r) {var o = t.adjacentEdges[e],i = o.startVertex === t,s = o.parameterRange[i ? 0 : 1];if (void 0 === r || !((s += (i ? 1 : -1) * r) < o.parameterRange[0] || s > o.parameterRange[1])) {var a = n.Vector3.createFloat64();return n.Vector3.normalize(a, o.originalEdge.evaluateDt(s)), i || n.Vector3.negate(a, a), { angle: Math.atan2(a[1], a[0]), position: o.originalEdge.evaluatePosition(s) };}}, V.prototype._computeEdgeDirectionAtVertex = function (e, t, r) {var o = t.adjacentEdges[e.index],i = o.startVertex === t,s = o.parameterRange[i ? 0 : 1],a = s + (i ? 1 : -1) * r / n.Vector3.length(o.originalEdge.evaluateDt(s)),c = o.originalEdge.evaluatePosition(a),u = n.Vector3.subtract(c, c, t.position);return Math.atan2(u[1], u[0]);}, V.prototype._prepareResult = function () {var e = new y.TopologyCloner();this._finalFaces = e.cloneFaces(this._faces), this._internalToFinalMap = e.getProgenitorMap(), this._progenitorMap = new m.ProgenitorMap();for (var t = e.getProgenitorMap().getAllNewTopology(), r = 0; r < t.length; r++) {var n = t[r],o = e.getProgenitorMap().getProgenitors(n)[0],s = void 0;n.getTopologyType() === i.TOPOLOGY_TYPES.FACE ? (s = new Set(), o.collectEdges().forEach(function (e) {e.getAssociatedEntities().forEach(function (e) {s.add(e);});}), s = Array.from(s)) : (n.getTopologyType() === i.TOPOLOGY_TYPES.EDGE || n.getTopologyType() === i.TOPOLOGY_TYPES.VERTEX) && (s = o.getAssociatedEntities()), s && this._progenitorMap.addEntry(n, s);}this._sketchSummary = { regionFaces: [], regionEdges: [], regionVertices: [], sketchEdges: {} };for (var a = P.default.keys(this._sketchRegionTopologies), c = 0; c < a.length; c++) {var u = this._sketchRegionTopologies[a[c]].topology;u instanceof E.RegionTopologyFace ? this._sketchSummary.regionFaces.push(u) : u instanceof E.RegionTopologyEdge ? this._sketchSummary.regionEdges.push(u) : u instanceof E.RegionTopologyVertex ? this._sketchSummary.regionVertices.push(u) : R.ConsoleUtils.assert(!1);}for (var l = 0; l < this._sketchEdges.length; l++) {var h = this._sketchEdges[l];this._sketchSummary.sketchEdges[h.getGuid()] = h;}}, V.prototype.getFaces = function () {return this._finalFaces;}, V.prototype.getRegionTopologyFaces = function () {return this._faces;}, V.prototype.getProgenitorMap = function () {return this._progenitorMap;}, V.prototype.createFaceRecipe = function (e) {var t = this._finalFaces.indexOf(e);if (t < 0) return "";var r = this._faces[t],n = (0, x.createRecipeFromRegionFace)(r, this._sketchSummary);return (0, x.serializeRegionFaceRecipe)(n);}, V.prototype.matchFaceRecipe = function (e) {for (var t = (0, x.deserializeRegionFaceRecipe)(e), r = (0, x.matchRegionFaceRecipe)(t, this._sketchSummary), n = [], o = 0; o < r.regions.length; o++) {var i = this._faces.indexOf(r.regions[o]);R.ConsoleUtils.assert(i >= 0), n.push(this._finalFaces[i]);}return n;}, V.prototype.createEdgeRecipe = function (e) {var t = this._internalToFinalMap.getProgenitors(e);if (!t || 1 !== t.length) return "";var r = (0, x.createRecipeFromRegionEdge)(t[0], this._sketchSummary);return (0, x.serializeRegionEdgeRecipe)(r);}, V.prototype.matchEdgeRecipe = function (e) {for (var t = (0, x.deserializeRegionEdgeRecipe)(e), r = (0, x.matchRegionEdgeRecipe)(t, this._sketchSummary), n = [], o = 0; o < r.edges.length; o++) {var i = this._internalToFinalMap.getDescendants(r.edges[o]);R.ConsoleUtils.assert(1 === i.length), n.push(i[0]);}return n;}, t.SketchRegionSolver = V;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.computeCurveCurveIntersections = void 0;var n = r(1),o = r(0),i = r(6),s = r(7),a = r(20),c = r(16),u = r(72),l = r(36),h = r(3),d = r(110),g = o.KERNEL_TOLERANCE,p = function p(e, t, r, o) {var i = t,s = e.getRange();if (e.getCurve().isPeriodicUnlimited() && (i < s[0] - n.FLOAT64_TOLERANCE || i > s[1] + n.FLOAT64_TOLERANCE)) {var a = e.getCurve().getPeriodUnlimited();i = (0, h.foldNearTo)(i, .5 * (s[0] + s[1]), a);}var c = Math.abs(i - s[0]) < Math.abs(i - s[1]) ? 0 : 1,u = n.Vector3.length(e.evaluateDt(i));return Math.abs(i - s[c]) * u < r ? { param: s[c], atVertex: e.getVertex(c) } : i >= s[0] && i <= s[1] ? { param: i, atVertex: void 0 } : !e.isClosed() && o.distanceToPoint(e.getVertex(c).getPosition()) < r ? { param: s[c], atVertex: e.getVertex(c) } : void 0;},f = function f(e, t, r, o, i) {var s = p(e, t, i, r);if (s) {if (s.atVertex) {var a = r.getRange();e === r && (a = [o - .1 * (l = Math.abs(a[1] - a[0])), o + .1 * l]);var c = r.closestToPointParam(s.atVertex.getPosition(), a);n.Vector3.distance(r.evaluatePosition(c), s.atVertex.getPosition()) < i && (o = c);}var u = p(r, o, i, e);if (u) {var l;if (u.atVertex) a = e.getRange(), e === r && (a = [t - .1 * (l = Math.abs(a[1] - a[0])), t + .1 * l]), c = e.closestToPointParam(u.atVertex.getPosition(), a), n.Vector3.distance(e.evaluatePosition(c), u.atVertex.getPosition()) < i && (s = p(e, t = c, i, r));if (s) return { cutInfo: s, cutByInfo: u };}}},v = function v(e, t, r) {var n = [t - e.getRange()[0], t - e.getRange()[1]];if (n[0] >= r && n[1] <= -r) return { param: t, atVertex: void 0 };var o = Math.abs(n[0]) < Math.abs(n[1]) ? 0 : 1;return Math.abs(n[o]) < r ? { param: e.getRange()[o], atVertex: e.getVertex(o) } : void 0;},_ = function _(e, t, r, i, s, a, c) {var u = e.getCurve().getPeriodUnlimited(),l = t.getCurve().getPeriodUnlimited(),d = [r[0], r[2]],g = [i[0], i[2]],f = [s / n.Vector3.length(e.evaluateDt(d[0])), s / n.Vector3.length(e.evaluateDt(d[1]))],v = [s / n.Vector3.length(t.evaluateDt(g[0])), s / n.Vector3.length(t.evaluateDt(g[1]))];if (((0, h.isParameterWithinPeriodicRange)(d[0], e.getRange(), u, f[0]) || (0, h.isParameterWithinPeriodicRange)(d[1], e.getRange(), u, f[1])) && ((0, h.isParameterWithinPeriodicRange)(g[0], t.getRange(), l, v[0]) || (0, h.isParameterWithinPeriodicRange)(g[1], t.getRange(), l, v[1]))) {for (var _ = 0; _ < 2; _++) {d[_] = (0, h.adjustParameterToPeriodicRange)(d[_], e.getRange(), u, !1, !0), g[_] = (0, h.adjustParameterToPeriodicRange)(g[_], t.getRange(), l, !1, !0);var y = (0, h.periodicDifference)(d[_], e.getRange()[0], u) < 3e-15 || (0, h.periodicDifference)(d[_], e.getRange()[1], u) < 3e-15,m = (0, h.periodicDifference)(g[_], t.getRange()[0], l) < 3e-15 || (0, h.periodicDifference)(g[_], t.getRange()[1], l) < 3e-15;if (d[_] - e.getRange()[0] < f[_] && (d[_] = e.getRange()[0], y = !0), e.getRange()[1] - d[_] < f[_] && (d[_] = e.getRange()[1], y = !0), g[_] - t.getRange()[0] < v[_] && (g[_] = t.getRange()[0], m = !0), t.getRange()[1] - g[_] < v[_] && (g[_] = t.getRange()[1], m = !0), y) {var E = t.closestToPointParam(e.evaluatePosition(d[_]));g[_] = (0, h.adjustParameterToPeriodicRange)(E, t.getRange(), l, !1, !0);}if (m) {var x = e.closestToPointParam(t.evaluatePosition(g[_]));d[_] = (0, h.adjustParameterToPeriodicRange)(x, e.getRange(), u, !1, !0), ((0, h.periodicDifference)(d[_], e.getRange()[0], u) < 3e-15 || (0, h.periodicDifference)(d[_], e.getRange()[1], u) < 3e-15) && (E = t.closestToPointParam(e.evaluatePosition(d[_])), g[_] = (0, h.adjustParameterToPeriodicRange)(E, t.getRange(), l, !1, !0));}}var R, A;if ((0, h.periodicDifference)(d[0], d[1], u) < Math.min(f[0], f[1]) && (0, h.periodicDifference)(g[0], g[1], l) < Math.min(v[0], v[1])) R = p(e, .5 * (d[0] + d[1]), s, e), A = p(t, .5 * (g[0] + g[1]), s, t);else for (R = p(e, r[1], s, e), A = p(t, i[1], s, t), _ = 0; _ < 2; _++) {if (!((0, h.periodicDifference)(d[_], R.param, u) < f[_] && (0, h.periodicDifference)(g[_], A.param, l) < v[_])) {var P,V,T = p(e, d[_], s, e),C = p(t, g[_], s, t);if (isFinite(u)) {var b = (0, h.getShortestParametricRange)(T.param, R.param, u);P = (0, h.periodicDifference)(R.param, b[0], u) <= o.KERNEL_ANGULAR_TOLERANCE;} else P = T.param > R.param;isFinite(l) ? (b = (0, h.getShortestParametricRange)(C.param, A.param, l), V = (0, h.periodicDifference)(A.param, b[0], l) <= o.KERNEL_ANGULAR_TOLERANCE) : V = C.param > A.param, a.push({ rangeInfo: P ? [R, T] : [T, R], rangeByInfo: V ? [A, C] : [C, A] });}}c && c.push({ firstParam: R.param, secondParam: A.param });}},y = function y(e, t, r, o) {var i = e.getRange(),s = e.evaluatePosition(0),a = e.evaluateDt(0),c = n.Vector2.length(a),u = t.getRange(),l = t.evaluatePosition(0),d = t.evaluateDt(0),g = n.Vector2.length(d),p = [a[1] / c, -a[0] / c],_ = t.evaluatePosition(u[0]);n.Vector2.subtract(_, _, s);var y = n.Vector2.dot(_, p),m = t.evaluatePosition(u[1]);n.Vector2.subtract(m, m, s);var E = n.Vector2.dot(m, p);if (Math.abs(y) <= o && Math.abs(E) <= o) {var x = n.Vector2.dot(_, a) / (c * c),R = n.Vector2.dot(m, a) / (c * c),A = [Math.min(x, R), Math.max(x, R)],P = o / c,V = o / g;if (A[1] < i[0] - P || A[0] > i[1] + P) return [];var T = [Math.max(i[0], A[0]), Math.min(i[1], A[1])];if (T[1] - T[0] < P) {var C = .5 * (T[0] + T[1]),b = Math.abs(R - x) > n.FLOAT64_TOLERANCE ? u[0] + (u[1] - u[0]) * (C - x) / (R - x) : .5 * (u[0] + u[1]);return [{ cutInfo: v(e, C, P), cutByInfo: v(t, b, V) }];}if (!r) return [];var L = u[0] + (u[1] - u[0]) * (T[0] - x) / (R - x),O = u[0] + (u[1] - u[0]) * (T[1] - x) / (R - x);return [{ rangeInfo: [v(e, T[0], P), v(e, T[1], P)], rangeByInfo: [v(t, Math.min(L, O), V), v(t, Math.max(L, O), V)] }];}if (y > o && E > o || y < -o && E < -o) return [];var S = [[a[0], -d[0], l[0] - s[0]], [a[1], -d[1], l[1] - s[1]]],M = (0, h.solveTwoEquationsTwoVariables)(S);if (M) {var w = f(e, M[0], t, M[1], o);if (w) return [w];}return [];},m = function m(e, t, r) {var o,i = t.getCenter(),s = e.closestToPointParam(i, []),a = e.evaluatePosition(s),c = n.Vector3.squaredDistance(a, i),u = [],l = t.getRadius(),h = l - Math.sqrt(c);if (h < -r) ;else if (h < r) o = t.closestToPointParam(a, []), u.push({ lineParam: s, circleParam: o });else for (var d = Math.sqrt(l * l - c) / n.Vector3.length(e.evaluateDt(0)), g = 0; g < 2; ++g) {var p = s + (0 === g ? -1 : 1) * d,f = e.evaluatePosition(p);o = t.closestToPointParam(f, []), u.push({ lineParam: p, circleParam: o });}return u;},E = function E(e, t, r, n, o, i) {var s = [r[0] + t * n[0] - e * n[1], r[1] + t * n[1] + e * n[0], 0];return { firstParam: o.closestToPointParam(s, [0, 2 * Math.PI]), secondParam: i.closestToPointParam(s, [0, 2 * Math.PI]) };},x = function x(e, t) {t || (t = o.KERNEL_TOLERANCE);for (var r = [], n = !1, i = [], s = [], a = 0; a < e.length; ++a) {e[a].hasOwnProperty("rangeInfo") ? (!1 === n ? (i = e[a].rangeInfo, s = e[a].rangeByInfo) : Math.abs(i[1].param - e[a].rangeInfo[0].param) < t && Math.abs(s[1].param - e[a].rangeByInfo[0].param) < t ? (i[1] = e[a].rangeInfo[1], s[1] = e[a].rangeByInfo[1]) : (r.push({ rangeInfo: i, rangeByInfo: s }), i = e[a].rangeInfo, s = e[a].rangeByInfo), n = !0) : e[a].hasOwnProperty("cutInfo") ? (n && r.push({ rangeInfo: i, rangeByInfo: s }), r.push(e[a]), n = !1) : console.warn("unknown segment type in intersection code");}return n && r.push({ rangeInfo: i, rangeByInfo: s }), r;},R = function R(e, t, r, o, i) {var s = r.getControlPoints(),a = r.getKnotVector(),c = e.getBoundingBox(),u = [];if (!r.getBoundingBox([a[0], a[a.length - 1]]).intersectsWithTolerance(c, i)) return u;var d = new Float64Array(s.length),g = s.length / 3 - 1,y = n.Vector2.createFloat64FromValues(e.getStartVertex().getPosition()[0], e.getStartVertex().getPosition()[1]),m = n.Vector3.createFloat64();n.Vector3.sub(m, e.getEndVertex().getPosition(), e.getStartVertex().getPosition()), n.Vector3.normalize(m, m);for (var E = n.Vector2.createFloat64FromValues(m[0], m[1]), x = n.Vector2.createFloat64(), R = !0, A = 0; A <= g; ++A) {x[0] = s[3 * A + 0], x[1] = s[3 * A + 1], d[3 * A + 0] = A / g, d[3 * A + 1] = (0, h.signedDistanceTo2DLine)(y, E, x), Math.abs(d[3 * A + 1]) > i && (R = !1), d[3 * A + 2] = 0;}if (R) return o ? u = function (e, t, r, o, i) {var s = o.length / 3 - 1,a = n.Vector3.createFloat64FromValues(o[0], o[1], o[2]),c = e.closestToPointParam(a),u = n.Vector3.createFloat64FromValues(o[3 * s + 0], o[3 * s + 1], o[3 * s + 2]),l = e.closestToPointParam(u),h = [v(e, c, r), v(e, l, r)];if (h[0].param > h[1].param) {var d = h[0];h[0] = h[1], h[1] = d;}var g = i[0],f = i[i.length - 1];if (t.isReversed()) {var _ = g;g = -f, f = -_;}var y = [p(t, g, r, e), p(t, f, r, e)];return h[0] && h[1] && y[0] && y[1] ? [{ rangeInfo: h, rangeByInfo: y }] : (console.warn("Error in intersection computation."), []);}(e, t, i, s, a) : [];var P = new Float64Array(3),V = [];return function (e, t, r, n, o, i, s, a, c) {var u,l = [],h = n.length / 3 - 1;3 === i ? (s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u), s[1] > s[2] && (u = s[1], s[1] = s[2], s[2] = u), s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u)) : 2 === i && s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u);var d = [!1, !1, !1],g = o[o.length - 1] - o[0],v = t.getCurve().tangentLength(o[0]) * g;Math.abs(n[1]) < r && (0 === i || s[0] > r / v) && (i++, s[2] = s[1], s[1] = s[0], s[0] = 0, d[0] = !0);var y = t.getCurve().tangentLength(o[o.length - 1]) * g;Math.abs(n[3 * h + 1]) < r && (0 === i || 1 - s[i - 1] > r / y) && (s[i] = 1, d[i] = !0, i++);for (var m = e.isReversed() ? -1 : 1, E = t.isReversed() ? -1 : 1, x = 0, R = 0; R < i + 1; ++R) {var A = !1;if (R !== i) {var P = s[R];s[R] = o[0] + (o[o.length - 1] - o[0]) * s[R];var V = t.getCurve().evaluatePosition(s[R]),T = e.getCurve().closestToPointParam(V, []),C = f(e, T * m, t, s[R] * E, r);C && (C.cutInfo.virtualIntersection = d[R], C.cutByInfo.virtualIntersection = d[R], l.push(C));} else P = o[o.length - 1], A = Math.abs(n[3 * h + 1]) > r;if (0 === R && P > 0 && Math.abs(n[0]) > r && (A = !0), c) {var b = void 0;if (a.length > 0 && a[0][0] >= x && a[0][0] <= P && (b = a[0]), a.length > 1 && a[1][0] >= x && a[1][0] <= P && (b = a[1]), void 0 !== b && Math.abs(b[1]) < r && !A) {var L = [o[0] + (o[o.length - 1] - o[0]) * x, o[0] + (o[o.length - 1] - o[0]) * P],O = [e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(L[0]), []), e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(L[1]), [])];if (Math.abs(O[0] - O[1]) > r) {var S = [p(e, O[0] * m, r, t), p(e, O[1] * m, r, t)],M = [p(t, L[0] * E, r, e), p(t, L[1] * E, r, e)];if (S[0] && S[1] && M[0] && M[1]) {var w = o[0] + (o[o.length - 1] - o[0]) * b[0];w !== L[0] && w !== L[1] || (w = .5 * (L[0] + L[1]));var N = e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(w), []);_(e, t, [O[0] * m, N * m, O[1] * m], [L[0] * E, w * E, L[1] * E], r, l);var F = { cutInfo: p(e, N * m, r, e), cutByInfo: p(t, w * E, r, e) };F.cutInfo.virtualIntersection = !0, F.cutByInfo.virtualIntersection = !0, l.push(F);}}}}x = P;}return l;}(e, t, i, d, a, l.SplineCurveHelper.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D([0, 0, 0], d, P, V), P, V, o);},A = function A(e, t, r, n) {var o = e.getBoundingBox(),i = [];if (!t.getBoundingBox().intersectsWithTolerance(o, n)) return i;for (var s = t.getCurve().getBezierSegments(), a = s.length, c = 0; c < a; c++) {for (var u = R(e, t, s[c], r, n), l = 0; l < u.length; ++l) {i.push(u[l]);}}return x(i);},P = function P(e, t, r, o, i) {var a = r.getControlPoints(),c = r.getKnotVector(),l = e.getBoundingBox(),d = [];if (!r.getBoundingBox([c[0], c[c.length - 1]]).intersectsWithTolerance(l, i)) return d;for (var v = !0, _ = n.Vector2.createFloat64(), y = n.Vector2.createFloat64(), E = n.Vector2.createFloat64(), x = 0; x < a.length / 3 - 2 && v; ++x) {_[0] = a[3 * x + 0], _[1] = a[3 * x + 1], y[0] = a[3 * x + 3], y[1] = a[3 * x + 4], E[0] = a[3 * x + 6], E[1] = a[3 * x + 7], v = Math.abs((0, h.orient2D)(_, y, E)) < g;}if (v) {var R = new s.Line(),A = n.Vector3.createFloat64FromValues(a[0], a[1], a[2]),P = n.Vector3.createFloat64FromValues(a[a.length - 3], a[a.length - 2], a[a.length - 1]);R.setFromEndpoints(A, P);var V = n.Vector3.distance(P, A),T = m(R, e.getCurve(), i);for (x = 0; x < T.length; ++x) {if (T[x].lineParam >= 0 && T[x].lineParam <= V) {T[x].lineParam = t.getCurve().closestToPointParam(R.evaluatePosition(T[x].lineParam), []);var C = p(e, T[x].circleParam * (e.isReversed() ? -1 : 1), i, t),b = p(t, T[x].lineParam * (t.isReversed() ? -1 : 1), i, e);b && C && d.push({ cutInfo: C, cutByInfo: b });}}return d;}var L = n.Vector2.createFloat64(),O = n.Vector2.createFloat64(),S = n.Vector2.createFloat64(),M = n.Vector2.createFloat64();L[0] = -a[0] + 3 * a[3] - 3 * a[6] + a[9], L[1] = -a[1] + 3 * a[4] - 3 * a[7] + a[10], O[0] = 3 * a[0] - 6 * a[3] + 3 * a[6], O[1] = 3 * a[1] - 6 * a[4] + 3 * a[7], S[0] = -3 * a[0] + 3 * a[3], S[1] = -3 * a[1] + 3 * a[4], M[0] = a[0], M[1] = a[1];var w = e.getCurve().getCenter(),N = e.getCurve().getRadius() * e.getCurve().getRadius(),F = N,I = new Float64Array(7);I[0] = F * L[0] * L[0] + N * L[1] * L[1], I[1] = 2 * F * L[0] * O[0] + 2 * O[1] * N * L[1], I[2] = 2 * S[0] * F * L[0] + O[1] * O[1] * N + F * O[0] * O[0] + 2 * S[1] * N * L[1], I[3] = -2 * w[1] * N * L[1] + 2 * O[1] * S[1] * N + 2 * S[0] * F * O[0] - 2 * F * L[0] * w[0] + 2 * F * L[0] * M[0] + 2 * M[1] * N * L[1], I[4] = -2 * F * w[0] * O[0] + S[1] * S[1] * N - 2 * w[1] * O[1] * N + 2 * F * M[0] * O[0] + S[0] * S[0] * F + 2 * M[1] * O[1] * N, I[5] = -2 * w[1] * S[1] * N - 2 * S[0] * F * w[0] + 2 * S[0] * F * M[0] + 2 * M[1] * S[1] * N, I[6] = F * w[0] * w[0] - 2 * M[1] * w[1] * N - F * N + w[1] * w[1] * N + M[1] * M[1] * N - 2 * F * w[0] * M[0] + F * M[0] * M[0];var D = (0, u.getRealPolynomialRoots)(I);for (x = 0; x < D.length; ++x) {if (D[x] >= 0 && D[x] <= 1) {D[x] = c[0] + (c[c.length - 1] - c[0]) * D[x];var j = t.getCurve().evaluatePosition(D[x]),B = e.getCurve().closestToPointParam(j, []),U = f(e, B * (e.isReversed() ? -1 : 1), t, D[x] * (t.isReversed() ? -1 : 1), i);U && d.push(U);}}return d;},V = function V(e, t, r, n, o) {var i = e.getBoundingBox(),s = [];if (!t.getBoundingBox().intersectsWithTolerance(i, o)) return s;var a = 0;e.isClosed() && n && (a = 1);for (var c = t.getCurve().getBezierSegments(), u = c.length, l = 0; l < u; l++) {for (var h = P(e, t, c[l], 0, o), d = 0; d < h.length; ++d) {for (var g = -a; g <= a; ++g) {s.push({ cutInfo: { atVertex: h[d].cutInfo.atVertex, param: h[d].cutInfo.param + g * Math.PI * 2 }, cutByInfo: h[d].cutByInfo });}}}return x(s);},T = function T(e, t, r, l, d, v, _) {var m = r.getControlPoints(),E = r.getKnotVector(),x = l.getControlPoints(),A = l.getKnotVector(),P = r.getBoundingBox([E[0], E[E.length - 1]]),V = l.getBoundingBox([A[0], A[A.length - 1]]),T = e === t,C = !1,b = !1;T && Math.abs(m[m.length - 3] - x[0]) < v && Math.abs(m[x.length - 2] - x[1]) < v && Math.abs(m[x.length - 1] - x[2]) < v && (C = !0), T && Math.abs(m[0] - x[m.length - 3]) < v && Math.abs(m[1] - x[x.length - 2]) < v && Math.abs(m[2] - x[x.length - 1]) < v && (b = !0);var L = [];if (!P.intersectsWithTolerance(V, v)) return L;var O = !0,S = !0,M = n.Vector2.createFloat64(),w = n.Vector2.createFloat64(),N = n.Vector2.createFloat64();for (we = 0; we < m.length / 3 - 2 && O; ++we) {M[0] = m[3 * we + 0], M[1] = m[3 * we + 1], w[0] = m[3 * we + 3], w[1] = m[3 * we + 4], N[0] = m[3 * we + 6], N[1] = m[3 * we + 7], O = Math.abs((0, h.orient2D)(M, w, N)) < g;}for (we = 0; we < x.length / 3 - 2 && S; ++we) {M[0] = x[3 * we + 0], M[1] = x[3 * we + 1], w[0] = x[3 * we + 3], w[1] = x[3 * we + 4], N[0] = x[3 * we + 6], N[1] = x[3 * we + 7], S = Math.abs((0, h.orient2D)(M, w, N)) < g;}if (O || S) return function (e, t, r, u, l, h, d, g, v) {var _ = l.getControlPoints(),m = h.getControlPoints(),E = [];if (e && !t || !e && t) {var x,A,P = new s.Line();e ? (x = n.Vector3.createFloat64FromValues(_[0], _[1], _[2]), A = n.Vector3.createFloat64FromValues(_[_.length - 3], _[_.length - 2], _[_.length - 1])) : (x = n.Vector3.createFloat64FromValues(m[0], m[1], m[2]), A = n.Vector3.createFloat64FromValues(m[m.length - 3], m[m.length - 2], m[m.length - 1])), P.setFromEndpoints(x, A);var V = new a.Edge(P),T = n.Vector3.distance(A, x);V.setRange([0, T]);var C = new i.Point();C.setPosition(x[0], x[1], x[2]);var b = new i.Point();b.setPosition(A[0], A[1], A[2]);var L,O = new c.Vertex(C),S = new c.Vertex(b);V.setStartVertex(O), V.setEndVertex(S), ee = e ? R(V, u, h, d, g) : R(V, r, l, d, g);for (var M = 0; M < ee.length; ++M) {if (ee[M].hasOwnProperty("cutInfo") && ee[M].hasOwnProperty("cutByInfo")) {if (ee[M].cutInfo.param >= 0 && ee[M].cutInfo.param <= T && (e ? (ee[M].cutInfo.param = r.closestToPointParam(P.evaluatePosition(ee[M].cutInfo.param)), L = f(r, ee[M].cutInfo.param, u, ee[M].cutByInfo.param, g)) : (ee[M].cutInfo.param = u.closestToPointParam(P.evaluatePosition(ee[M].cutInfo.param)), L = f(r, ee[M].cutByInfo.param, u, ee[M].cutInfo.param, g)), L)) if (v) {var w = L.cutInfo.param,N = L.cutByInfo.param;(F = Math.abs(w - N) * n.Vector3.length(r.evaluateDt(w))) > o.KERNEL_TOLERANCE && !ee[M].cutInfo.virtualIntersection && E.push(L);} else E.push(L);} else if (ee[M].hasOwnProperty("rangeInfo") && ee[M].hasOwnProperty("rangeByInfo") && ee[M].rangeInfo[0].param >= 0 && ee[M].rangeInfo[0].param <= T && ee[M].rangeInfo[1].param >= 0 && ee[M].rangeInfo[1].param <= T) if (e ? (ee[M].rangeInfo[0].param = r.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = r.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[1].param))) : (ee[M].rangeInfo[0].param = u.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = u.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[1].param))), e ? (te = [p(r, ee[M].rangeInfo[0].param, g, u), p(r, ee[M].rangeInfo[1].param, g, u)], re = [p(u, ee[M].rangeByInfo[0].param, g, r), p(u, ee[M].rangeByInfo[1].param, g, r)]) : (te = [p(r, ee[M].rangeByInfo[0].param, g, u), p(r, ee[M].rangeByInfo[1].param, g, u)], re = [p(u, ee[M].rangeInfo[0].param, g, r), p(u, ee[M].rangeInfo[1].param, g, r)]), te[0] && te[1] && re[0] && re[1]) {var F = Math.abs(te[1].param - re[0].param) * n.Vector3.length(r.evaluateDt(te[1]));(!v || v && F > o.KERNEL_TOLERANCE) && E.push({ rangeInfo: te, rangeByInfo: re });} else console.warn("Error in intersection computation.");}} else {var I = new s.Line(),D = new s.Line(),j = n.Vector3.createFloat64FromValues(_[0], _[1], _[2]),B = n.Vector3.createFloat64FromValues(_[_.length - 3], _[_.length - 2], _[_.length - 1]),U = n.Vector3.createFloat64FromValues(m[0], m[1], m[2]),k = n.Vector3.createFloat64FromValues(m[m.length - 3], m[m.length - 2], m[m.length - 1]);I.setFromEndpoints(j, B), D.setFromEndpoints(U, k);var G = new a.Edge(I),z = n.Vector3.distance(B, j),Y = new a.Edge(D),K = n.Vector3.distance(k, U);G.setRange([0, z]), Y.setRange([0, K]);var q = new i.Point();q.setPosition(j[0], j[1], j[2]);var W = new i.Point();W.setPosition(B[0], B[1], B[2]);var H = new i.Point();H.setPosition(U[0], U[1], U[2]);var X = new i.Point();X.setPosition(k[0], k[1], k[2]);var J = new c.Vertex(q),$ = new c.Vertex(W),Z = new c.Vertex(H),Q = new c.Vertex(X);G.setStartVertex(J), G.setEndVertex($), Y.setStartVertex(Z), Y.setEndVertex(Q);var ee = y(G, Y, d, g);for (M = 0; M < ee.length; ++M) {if (ee[M].hasOwnProperty("cutInfo") && ee[M].hasOwnProperty("cutByInfo")) ee[M].cutInfo.param >= 0 && ee[M].cutInfo.param <= z && ee[M].cutByInfo.param >= 0 && ee[M].cutByInfo.param <= K && (ee[M].cutInfo.param = r.closestToPointParam(I.evaluatePosition(ee[M].cutInfo.param)), ee[M].cutByInfo.param = u.closestToPointParam(D.evaluatePosition(ee[M].cutByInfo.param)), L = f(r, ee[M].cutInfo.param, u, ee[M].cutByInfo.param, g)) && (w = L.cutInfo.param, N = L.cutByInfo.param, F = Math.abs(w - N) * n.Vector3.length(r.evaluateDt(w)), (!v || v && F > o.KERNEL_TOLERANCE) && E.push(L));else if (ee[M].hasOwnProperty("rangeInfo") && ee[M].hasOwnProperty("rangeByInfo") && ee[M].rangeInfo[0].param >= 0 && ee[M].rangeInfo[0].param <= z && ee[M].rangeInfo[1].param >= 0 && ee[M].rangeInfo[1].param <= z && ee[M].rangeByInfo[0].param >= 0 && ee[M].rangeByInfo[0].param <= K && ee[M].rangeByInfo[1].param >= 0 && ee[M].rangeByInfo[1].param <= K) {ee[M].rangeInfo[0].param = r.closestToPointParam(I.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = r.closestToPointParam(I.evaluatePosition(ee[M].rangeInfo[1].param)), ee[M].rangeByInfo[0].param = u.closestToPointParam(D.evaluatePosition(ee[M].rangeByInfo[0].param)), ee[M].rangeByInfo[1].param = u.closestToPointParam(D.evaluatePosition(ee[M].rangeByInfo[1].param));var te = [p(r, ee[M].rangeInfo[0].param, g, u), p(r, ee[M].rangeInfo[1].param, g, u)],re = [p(u, ee[M].rangeByInfo[0].param, g, r), p(u, ee[M].rangeByInfo[1].param, g, r)];te[0] && te[1] && re[0] && re[1] ? (F = Math.abs(te[1].param - re[0].param) * n.Vector3.length(r.evaluateDt(te[1])), (!v || v && F > o.KERNEL_TOLERANCE) && E.push({ rangeInfo: te, rangeByInfo: re })) : console.warn("Error in intersection computation.");}}}return E;}(O, S, e, t, r, l, d, v, _);var F = -m[0] + 3 * m[3] - 3 * m[6] + m[9],I = 3 * m[0] - 6 * m[3] + 3 * m[6],D = -3 * m[0] + 3 * m[3],j = m[0],B = -m[1] + 3 * m[4] - 3 * m[7] + m[10],U = 3 * m[1] - 6 * m[4] + 3 * m[7],k = -3 * m[1] + 3 * m[4],G = m[1],z = j * j,Y = D * D,K = I * I,q = F * F,W = j * j * j,H = D * D * D,X = I * I * I,J = F * F * F,$ = G * G,Z = k * k,Q = U * U,ee = B * B,te = G * G * G,re = k * k * k,ne = U * U * U,oe = B * B * B,ie = -x[0] + 3 * x[3] - 3 * x[6] + x[9],se = 3 * x[0] - 6 * x[3] + 3 * x[6],ae = -3 * x[0] + 3 * x[3],ce = x[0],ue = -x[1] + 3 * x[4] - 3 * x[7] + x[10],le = 3 * x[1] - 6 * x[4] + 3 * x[7],he = -3 * x[1] + 3 * x[4],de = x[1],ge = ce * ce,pe = ce * ce * ce,fe = de * de,ve = de * de * de,_e = ae * ae,ye = ae * ae * ae,me = he * he,Ee = he * he * he,xe = se * se,Re = se * se * se,Ae = le * le,Pe = le * le * le,Ve = ie * ie,Te = ue * ue,Ce = new Float64Array(10),be = F * ue - B * ie;Ce[0] = be * be * be, Ce[1] = 3 * (F * le - B * se) * be * be, Ce[2] = 3 * (F * ue - B * ie) * (q * he * ue + q * Ae - F * B * ae * ue - 2 * F * B * se * le - F * B * ie * he + ee * ae * ie + ee * xe), Ce[3] = 3 * j * q * B * Te - 6 * j * F * ee * ie * ue + 3 * j * oe * Ve - 3 * D * I * F * B * Te + 3 * D * I * ee * ie * ue + 2 * D * q * U * Te - D * F * U * B * ie * ue - D * U * ee * Ve + X * B * Te - K * F * U * Te - 2 * K * U * B * ie * ue + I * q * k * Te + I * F * k * B * ie * ue + 2 * I * F * Q * ie * ue - 2 * I * k * ee * Ve + I * Q * B * Ve - 3 * J * G * Te + 3 * J * de * Te + 6 * J * he * le * ue + J * Pe + 6 * q * G * B * ie * ue - 3 * q * k * U * ie * ue - 3 * q * B * ce * Te - 6 * q * B * ae * le * ue - 6 * q * B * se * he * ue - 3 * q * B * se * Ae - 6 * q * B * ie * de * ue - 6 * q * B * ie * he * le - 3 * F * G * ee * Ve + 3 * F * k * U * B * Ve - F * ne * Ve + 6 * F * ee * ce * ie * ue + 6 * F * ee * ae * se * ue + 6 * F * ee * ae * ie * le + 3 * F * ee * xe * le + 6 * F * ee * se * ie * he + 3 * F * ee * Ve * de - 3 * oe * ce * Ve - 6 * oe * ae * se * ie - oe * Re, Ce[4] = 6 * j * q * B * le * ue - 6 * j * F * ee * se * ue - 6 * j * F * ee * ie * le + 6 * j * oe * se * ie - 6 * D * I * F * B * le * ue + 3 * D * I * ee * se * ue + 3 * D * I * ee * ie * le + 4 * D * q * U * le * ue - D * F * U * B * se * ue - D * F * U * B * ie * le - 2 * D * U * ee * se * ie + 2 * X * B * le * ue - 2 * K * F * U * le * ue - 2 * K * U * B * se * ue - 2 * K * U * B * ie * le + 2 * I * q * k * le * ue + I * F * k * B * se * ue + I * F * k * B * ie * le + 2 * I * F * Q * se * ue + 2 * I * F * Q * ie * le - 4 * I * k * ee * se * ie + 2 * I * Q * B * se * ie - 6 * J * G * le * ue + 6 * J * de * le * ue + 3 * J * me * ue + 3 * J * he * Ae + 6 * q * G * B * se * ue + 6 * q * G * B * ie * le - 3 * q * k * U * se * ue - 3 * q * k * U * ie * le - 6 * q * B * ce * le * ue - 6 * q * B * ae * he * ue - 3 * q * B * ae * Ae - 6 * q * B * se * de * ue - 6 * q * B * se * he * le - 6 * q * B * ie * de * le - 3 * q * B * ie * me - 6 * F * G * ee * se * ie + 6 * F * k * U * B * se * ie - 2 * F * ne * se * ie + 6 * F * ee * ce * se * ue + 6 * F * ee * ce * ie * le + 3 * F * ee * _e * ue + 6 * F * ee * ae * se * le + 6 * F * ee * ae * ie * he + 3 * F * ee * xe * he + 6 * F * ee * se * ie * de - 6 * oe * ce * se * ie - 3 * oe * _e * ie - 3 * oe * ae * xe, Ce[5] = 6 * j * q * B * he * ue + 3 * j * q * B * Ae - 6 * j * F * ee * ae * ue - 6 * j * F * ee * se * le - 6 * j * F * ee * ie * he + 6 * j * oe * ae * ie + 3 * j * oe * xe - 6 * D * I * F * B * he * ue - 3 * D * I * F * B * Ae + 3 * D * I * ee * ae * ue + 3 * D * I * ee * se * le + 3 * D * I * ee * ie * he + 4 * D * q * U * he * ue + 2 * D * q * U * Ae - D * F * U * B * ae * ue - D * F * U * B * se * le - D * F * U * B * ie * he - 2 * D * U * ee * ae * ie - D * U * ee * xe + 2 * X * B * he * ue + X * B * Ae - 2 * K * F * U * he * ue - K * F * U * Ae - 2 * K * U * B * ae * ue - 2 * K * U * B * se * le - 2 * K * U * B * ie * he + 2 * I * q * k * he * ue + I * q * k * Ae + I * F * k * B * ae * ue + I * F * k * B * se * le + I * F * k * B * ie * he + 2 * I * F * Q * ae * ue + 2 * I * F * Q * se * le + 2 * I * F * Q * ie * he - 4 * I * k * ee * ae * ie - 2 * I * k * ee * xe + 2 * I * Q * B * ae * ie + I * Q * B * xe - 6 * J * G * he * ue - 3 * J * G * Ae + 6 * J * de * he * ue + 3 * J * de * Ae + 3 * J * me * le + 6 * q * G * B * ae * ue + 6 * q * G * B * se * le + 6 * q * G * B * ie * he - 3 * q * k * U * ae * ue - 3 * q * k * U * se * le - 3 * q * k * U * ie * he - 6 * q * B * ce * he * ue - 3 * q * B * ce * Ae - 6 * q * B * ae * de * ue - 6 * q * B * ae * he * le - 6 * q * B * se * de * le - 3 * q * B * se * me - 6 * q * B * ie * de * he - 6 * F * G * ee * ae * ie - 3 * F * G * ee * xe + 6 * F * k * U * B * ae * ie + 3 * F * k * U * B * xe - 2 * F * ne * ae * ie - F * ne * xe + 6 * F * ee * ce * ae * ue + 6 * F * ee * ce * se * le + 6 * F * ee * ce * ie * he + 3 * F * ee * _e * le + 6 * F * ee * ae * se * he + 6 * F * ee * ae * ie * de + 3 * F * ee * xe * de - 6 * oe * ce * ae * ie - 3 * oe * ce * xe - 3 * oe * _e * se, Ce[6] = 3 * z * F * ee * ue - 3 * z * oe * ie - 3 * j * D * I * ee * ue + j * D * F * U * B * ue + 2 * j * D * U * ee * ie + 2 * j * K * U * B * ue - j * I * F * k * B * ue - 2 * j * I * F * Q * ue + 4 * j * I * k * ee * ie - 2 * j * I * Q * B * ie - 6 * j * q * G * B * ue + 3 * j * q * k * U * ue + 6 * j * q * B * de * ue + 6 * j * q * B * he * le + 6 * j * F * G * ee * ie - 6 * j * F * k * U * B * ie + 2 * j * F * ne * ie - 6 * j * F * ee * ce * ue - 6 * j * F * ee * ae * le - 6 * j * F * ee * se * he - 6 * j * F * ee * ie * de + 6 * j * oe * ce * ie + 6 * j * oe * ae * se + H * ee * ue - Y * I * U * B * ue - 2 * Y * F * k * B * ue + Y * F * Q * ue - Y * k * ee * ie + D * K * k * B * ue + 6 * D * I * F * G * B * ue - D * I * F * k * U * ue - 6 * D * I * F * B * de * ue - 6 * D * I * F * B * he * le - 3 * D * I * G * ee * ie + D * I * k * U * B * ie + 3 * D * I * ee * ce * ue + 3 * D * I * ee * ae * le + 3 * D * I * ee * se * he + 3 * D * I * ee * ie * de - 4 * D * q * G * U * ue + D * q * Z * ue + 4 * D * q * U * de * ue + 4 * D * q * U * he * le + D * F * G * U * B * ie + 2 * D * F * Z * B * ie - D * F * k * Q * ie - D * F * U * B * ce * ue - D * F * U * B * ae * le - D * F * U * B * se * he - D * F * U * B * ie * de - 2 * D * U * ee * ce * ie - 2 * D * U * ee * ae * se - 2 * X * G * B * ue + 2 * X * B * de * ue + 2 * X * B * he * le + 2 * K * F * G * U * ue - 2 * K * F * U * de * ue - 2 * K * F * U * he * le + 2 * K * G * U * B * ie - K * Z * B * ie - 2 * K * U * B * ce * ue - 2 * K * U * B * ae * le - 2 * K * U * B * se * he - 2 * K * U * B * ie * de - 2 * I * q * G * k * ue + 2 * I * q * k * de * ue + 2 * I * q * k * he * le - I * F * G * k * B * ie - 2 * I * F * G * Q * ie + I * F * Z * U * ie + I * F * k * B * ce * ue + I * F * k * B * ae * le + I * F * k * B * se * he + I * F * k * B * ie * de + 2 * I * F * Q * ce * ue + 2 * I * F * Q * ae * le + 2 * I * F * Q * se * he + 2 * I * F * Q * ie * de - 4 * I * k * ee * ce * ie - 4 * I * k * ee * ae * se + 2 * I * Q * B * ce * ie + 2 * I * Q * B * ae * se + 3 * J * $ * ue - 6 * J * G * de * ue - 6 * J * G * he * le + 3 * J * fe * ue + 6 * J * de * he * le + J * Ee - 3 * q * $ * B * ie + 3 * q * G * k * U * ie + 6 * q * G * B * ce * ue + 6 * q * G * B * ae * le + 6 * q * G * B * se * he + 6 * q * G * B * ie * de - q * re * ie - 3 * q * k * U * ce * ue - 3 * q * k * U * ae * le - 3 * q * k * U * se * he - 3 * q * k * U * ie * de - 6 * q * B * ce * de * ue - 6 * q * B * ce * he * le - 6 * q * B * ae * de * le - 3 * q * B * ae * me - 6 * q * B * se * de * he - 3 * q * B * ie * fe - 6 * F * G * ee * ce * ie - 6 * F * G * ee * ae * se + 6 * F * k * U * B * ce * ie + 6 * F * k * U * B * ae * se - 2 * F * ne * ce * ie - 2 * F * ne * ae * se + 3 * F * ee * ge * ue + 6 * F * ee * ce * ae * le + 6 * F * ee * ce * se * he + 6 * F * ee * ce * ie * de + 3 * F * ee * _e * he + 6 * F * ee * ae * se * de - 3 * oe * ge * ie - 6 * oe * ce * ae * se - oe * ye, Ce[7] = 3 * z * F * ee * le - 3 * z * oe * se - 3 * j * D * I * ee * le + j * D * F * U * B * le + 2 * j * D * U * ee * se + 2 * j * K * U * B * le - j * I * F * k * B * le - 2 * j * I * F * Q * le + 4 * j * I * k * ee * se - 2 * j * I * Q * B * se - 6 * j * q * G * B * le + 3 * j * q * k * U * le + 6 * j * q * B * de * le + 3 * j * q * B * me + 6 * j * F * G * ee * se - 6 * j * F * k * U * B * se + 2 * j * F * ne * se - 6 * j * F * ee * ce * le - 6 * j * F * ee * ae * he - 6 * j * F * ee * se * de + 6 * j * oe * ce * se + 3 * j * oe * _e + H * ee * le - Y * I * U * B * le - 2 * Y * F * k * B * le + Y * F * Q * le - Y * k * ee * se + D * K * k * B * le + 6 * D * I * F * G * B * le - D * I * F * k * U * le - 6 * D * I * F * B * de * le - 3 * D * I * F * B * me - 3 * D * I * G * ee * se + D * I * k * U * B * se + 3 * D * I * ee * ce * le + 3 * D * I * ee * ae * he + 3 * D * I * ee * se * de - 4 * D * q * G * U * le + D * q * Z * le + 4 * D * q * U * de * le + 2 * D * q * U * me + D * F * G * U * B * se + 2 * D * F * Z * B * se - D * F * k * Q * se - D * F * U * B * ce * le - D * F * U * B * ae * he - D * F * U * B * se * de - 2 * D * U * ee * ce * se - D * U * ee * _e - 2 * X * G * B * le + 2 * X * B * de * le + X * B * me + 2 * K * F * G * U * le - 2 * K * F * U * de * le - K * F * U * me + 2 * K * G * U * B * se - K * Z * B * se - 2 * K * U * B * ce * le - 2 * K * U * B * ae * he - 2 * K * U * B * se * de - 2 * I * q * G * k * le + 2 * I * q * k * de * le + I * q * k * me - I * F * G * k * B * se - 2 * I * F * G * Q * se + I * F * Z * U * se + I * F * k * B * ce * le + I * F * k * B * ae * he + I * F * k * B * se * de + 2 * I * F * Q * ce * le + 2 * I * F * Q * ae * he + 2 * I * F * Q * se * de - 4 * I * k * ee * ce * se - 2 * I * k * ee * _e + 2 * I * Q * B * ce * se + I * Q * B * _e + 3 * J * $ * le - 6 * J * G * de * le - 3 * J * G * me + 3 * J * fe * le + 3 * J * de * me - 3 * q * $ * B * se + 3 * q * G * k * U * se + 6 * q * G * B * ce * le + 6 * q * G * B * ae * he + 6 * q * G * B * se * de - q * re * se - 3 * q * k * U * ce * le - 3 * q * k * U * ae * he - 3 * q * k * U * se * de - 6 * q * B * ce * de * le - 3 * q * B * ce * me - 6 * q * B * ae * de * he - 3 * q * B * se * fe - 6 * F * G * ee * ce * se - 3 * F * G * ee * _e + 6 * F * k * U * B * ce * se + 3 * F * k * U * B * _e - 2 * F * ne * ce * se - F * ne * _e + 3 * F * ee * ge * le + 6 * F * ee * ce * ae * he + 6 * F * ee * ce * se * de + 3 * F * ee * _e * de - 3 * oe * ge * se - 3 * oe * ce * _e, Ce[8] = 3 * z * F * ee * he - 3 * z * oe * ae - 3 * j * D * I * ee * he + j * D * F * U * B * he + 2 * j * D * U * ee * ae + 2 * j * K * U * B * he - j * I * F * k * B * he - 2 * j * I * F * Q * he + 4 * j * I * k * ee * ae - 2 * j * I * Q * B * ae - 6 * j * q * G * B * he + 3 * j * q * k * U * he + 6 * j * q * B * de * he + 6 * j * F * G * ee * ae - 6 * j * F * k * U * B * ae + 2 * j * F * ne * ae - 6 * j * F * ee * ce * he - 6 * j * F * ee * ae * de + 6 * j * oe * ce * ae + H * ee * he - Y * I * U * B * he - 2 * Y * F * k * B * he + Y * F * Q * he - Y * k * ee * ae + D * K * k * B * he + 6 * D * I * F * G * B * he - D * I * F * k * U * he - 6 * D * I * F * B * de * he - 3 * D * I * G * ee * ae + D * I * k * U * B * ae + 3 * D * I * ee * ce * he + 3 * D * I * ee * ae * de - 4 * D * q * G * U * he + D * q * Z * he + 4 * D * q * U * de * he + D * F * G * U * B * ae + 2 * D * F * Z * B * ae - D * F * k * Q * ae - D * F * U * B * ce * he - D * F * U * B * ae * de - 2 * D * U * ee * ce * ae - 2 * X * G * B * he + 2 * X * B * de * he + 2 * K * F * G * U * he - 2 * K * F * U * de * he + 2 * K * G * U * B * ae - K * Z * B * ae - 2 * K * U * B * ce * he - 2 * K * U * B * ae * de - 2 * I * q * G * k * he + 2 * I * q * k * de * he - I * F * G * k * B * ae - 2 * I * F * G * Q * ae + I * F * Z * U * ae + I * F * k * B * ce * he + I * F * k * B * ae * de + 2 * I * F * Q * ce * he + 2 * I * F * Q * ae * de - 4 * I * k * ee * ce * ae + 2 * I * Q * B * ce * ae + 3 * J * $ * he - 6 * J * G * de * he + 3 * J * fe * he - 3 * q * $ * B * ae + 3 * q * G * k * U * ae + 6 * q * G * B * ce * he + 6 * q * G * B * ae * de - q * re * ae - 3 * q * k * U * ce * he - 3 * q * k * U * ae * de - 6 * q * B * ce * de * he - 3 * q * B * ae * fe - 6 * F * G * ee * ce * ae + 6 * F * k * U * B * ce * ae - 2 * F * ne * ce * ae + 3 * F * ee * ge * he + 6 * F * ee * ce * ae * de - 3 * oe * ge * ae, Ce[9] = W * oe - z * D * U * ee - 2 * z * I * k * ee + z * I * Q * B - 3 * z * F * G * ee + 3 * z * F * k * U * B - z * F * ne + 3 * z * F * ee * de - 3 * z * oe * ce + j * Y * k * ee + 3 * j * D * I * G * ee - j * D * I * k * U * B - 3 * j * D * I * ee * de - j * D * F * G * U * B - 2 * j * D * F * Z * B + j * D * F * k * Q + j * D * F * U * B * de + 2 * j * D * U * ee * ce - 2 * j * K * G * U * B + j * K * Z * B + 2 * j * K * U * B * de + j * I * F * G * k * B + 2 * j * I * F * G * Q - j * I * F * Z * U - j * I * F * k * B * de - 2 * j * I * F * Q * de + 4 * j * I * k * ee * ce - 2 * j * I * Q * B * ce + 3 * j * q * $ * B - 3 * j * q * G * k * U - 6 * j * q * G * B * de + j * q * re + 3 * j * q * k * U * de + 3 * j * q * B * fe + 6 * j * F * G * ee * ce - 6 * j * F * k * U * B * ce + 2 * j * F * ne * ce - 6 * j * F * ee * ce * de + 3 * j * oe * ge - H * G * ee + H * ee * de + Y * I * G * U * B - Y * I * U * B * de + 2 * Y * F * G * k * B - Y * F * G * Q - 2 * Y * F * k * B * de + Y * F * Q * de - Y * k * ee * ce - D * K * G * k * B + D * K * k * B * de - 3 * D * I * F * $ * B + D * I * F * G * k * U + 6 * D * I * F * G * B * de - D * I * F * k * U * de - 3 * D * I * F * B * fe - 3 * D * I * G * ee * ce + D * I * k * U * B * ce + 3 * D * I * ee * ce * de + 2 * D * q * $ * U - D * q * G * Z - 4 * D * q * G * U * de + D * q * Z * de + 2 * D * q * U * fe + D * F * G * U * B * ce + 2 * D * F * Z * B * ce - D * F * k * Q * ce - D * F * U * B * ce * de - D * U * ee * ge + X * $ * B - 2 * X * G * B * de + X * B * fe - K * F * $ * U + 2 * K * F * G * U * de - K * F * U * fe + 2 * K * G * U * B * ce - K * Z * B * ce - 2 * K * U * B * ce * de + I * q * $ * k - 2 * I * q * G * k * de + I * q * k * fe - I * F * G * k * B * ce - 2 * I * F * G * Q * ce + I * F * Z * U * ce + I * F * k * B * ce * de + 2 * I * F * Q * ce * de - 2 * I * k * ee * ge + I * Q * B * ge - J * te + 3 * J * $ * de - 3 * J * G * fe + J * ve - 3 * q * $ * B * ce + 3 * q * G * k * U * ce + 6 * q * G * B * ce * de - q * re * ce - 3 * q * k * U * ce * de - 3 * q * B * ce * fe - 3 * F * G * ee * ge + 3 * F * k * U * B * ge - F * ne * ge + 3 * F * ee * ge * de - oe * pe;var Le = (0, u.getRealPolynomialRoots)(Ce),Oe = l.getApproxParameterSpaceTolerance(),Se = -Oe,Me = 1 + Oe;C && (Se = Oe), b && (Me = 1 - Oe);for (var we = 0; we < Le.length; ++we) {if (Le[we] >= Se && Le[we] <= Me) {Le[we] < 0 ? Le[we] = 0 : Le[we] > 1 && (Le[we] = 1), Le[we] = A[0] + (A[A.length - 1] - A[0]) * Le[we];var Ne = t.getCurve().evaluatePosition(Le[we]);if (P.isPointInsideWithTolerance(Ne)) {var Fe = r.closestToPointParam(Ne, []);if (Fe >= E[0] && Fe <= E[E.length - 1]) {var Ie = e.getCurve().evaluatePosition(Fe);if (n.Vector3.squaredDistance(Ie, Ne) <= v * v) {var De = f(e, Fe * (e.isReversed() ? -1 : 1), t, Le[we] * (t.isReversed() ? -1 : 1), v);De && L.push(De);}}}}}return L;},C = function C(e, t, r, o) {var i = [],a = t.getControlPoints(),c = e.isReversed() ? -1 : 1,u = new s.Line(),h = n.Vector3.createFloat64FromValues(a[0], a[1], a[2]),d = n.Vector3.createFloat64FromValues(a[a.length - 3], a[a.length - 2], a[a.length - 1]);u.setFromEndpoints(h, d);var g = n.Vector3.distance(d, h),p = n.Vector3.createFloat64FromValues(a[3], a[4], a[5]),v = n.Vector3.createFloat64FromValues(a[6], a[7], a[8]);if (u.closestToPointParam(p, []) > 0 && u.closestToPointParam(p, []) < g && u.closestToPointParam(v, []) > 0 && u.closestToPointParam(v, []) < g) return i;var _,y = -a[0] + 3 * a[3] - 3 * a[6] + a[9],m = -a[1] + 3 * a[4] - 3 * a[7] + a[10],E = 3 * a[0] - 6 * a[3] + 3 * a[6],x = 3 * a[1] - 6 * a[4] + 3 * a[7],R = -3 * a[0] + 3 * a[3],A = -3 * a[1] + 3 * a[4],P = E / y,V = R / y,T = x / m,C = A / m;if (Math.abs(P - T) < o || Math.abs(C - V) < o) return i;var b = new Float64Array(4);if (Math.abs(y) < o && Math.abs(m) < o) return i;Math.abs(y) < o ? (_ = -R / E, P = T, V = C) : _ = Math.abs(m) < o ? -A / x : (C - V) / (P - T), b[0] = (-_ * _ * _ - P * _ * _ - V * _) / 2, b[1] = (3 * _ * _ + 2 * _ * P + 2 * V) / 2, b[2] = -1.5 * _, b[3] = 1;var L,O = new Float64Array(3);if (3 !== l.SplineCurveHelper.solve_cubic_uniqueRoots(b, O)) return i;if (O[1] < O[0] && (L = O[0], O[0] = O[1], O[1] = L), O[2] < O[0] && (L = O[0], O[0] = O[2], O[2] = L), O[2] < O[1] && (L = O[1], O[1] = O[2], O[2] = L), O[0] >= 0 && O[0] <= 1 && O[2] >= 0 && O[2] <= 1) {var S = t.getKnotVector();O[0] = S[0] + (S[S.length - 1] - S[0]) * O[0], O[2] = S[0] + (S[S.length - 1] - S[0]) * O[2];var M = f(e, O[0] * c, e, O[2] * c, o);M && i.push(M);}return i;};t.computeCurveCurveIntersections = function (e, t, r, i, s) {s = void 0 === s ? o.KERNEL_TOLERANCE : s;var a = e.getCurveType(),c = a === o.GEOMETRY_TYPES.CIRCLE,u = a === o.GEOMETRY_TYPES.LINE,l = a === o.GEOMETRY_TYPES.BCURVE && !e.getCurve().isRational() && 3 === e.getCurve().getDegree(),g = t.getCurveType(),v = g === o.GEOMETRY_TYPES.CIRCLE,R = g === o.GEOMETRY_TYPES.LINE,P = g === o.GEOMETRY_TYPES.BCURVE && !t.getCurve().isRational() && 3 === t.getCurve().getDegree();return u && v ? function (e, t, r) {for (var n = m(e.getCurve(), t.getCurve(), r), o = [], i = 0; i < n.length; ++i) {var s = (e.isReversed() ? -1 : 1) * n[i].lineParam,a = (t.isReversed() ? -1 : 1) * n[i].circleParam,c = f(e, s, t, a, r);c && o.push(c);}return o;}(e, t, s) : c && R ? function (e, t, r, n) {var o = m(t.getCurve(), e.getCurve(), n),i = [],s = 0;e.isClosed() && r && (s = 1);for (var a = 0; a < o.length; ++a) {var c = (e.isReversed() ? -1 : 1) * o[a].circleParam,u = (t.isReversed() ? -1 : 1) * o[a].lineParam,l = f(e, c, t, u, n);if (l) for (var h = -s; h <= s; ++h) {i.push({ cutInfo: { atVertex: l.cutInfo.atVertex, param: l.cutInfo.param + h * Math.PI * 2 }, cutByInfo: l.cutByInfo });}}return i;}(e, t, i, s) : u && R ? y(e, t, r, s) : c && v ? function (e, t, r, o, i) {var s = [],a = e.getCurve().getCenter(),c = e.getCurve().getRadius(),u = t.getCurve().getCenter(),l = t.getCurve().getRadius(),d = 2 * Math.PI,g = n.Vector3.createFloat64();n.Vector3.sub(g, u, a);var v = n.Vector3.length(g),y = Math.abs(c - l);if (v < y - i) return s;if (v + y < i) {var m = i / c;if (e.getRange()[1] - e.getRange()[0] > d - m && t.getRange()[1] - t.getRange()[0] > d - m) return s.push({ rangeInfo: [p(e, e.getRange()[0], i, t), p(e, e.getRange()[1], i, t)], rangeByInfo: [p(t, t.getRange()[0], i, e), p(t, t.getRange()[1], i, e)] }), s;var x = [],R = e.closestToPointParam(t.evaluatePosition(0), [0, d]),A = n.Vector3.dot(e.evaluateDt(R), t.evaluateDt(0)) < 0,P = e.getRange(),V = t.getRange();V = A ? [R - V[1], R - V[0]] : [R + V[0], R + V[1]];var T = (0, h.foldAbove)(V[0], P[0], d) - V[0];if ((V = [V[0] + T, V[1] + T])[0] < P[1] + m && x.push([Math.min(V[0], P[1]), Math.min(P[1], V[1])]), V[1] > P[0] + d - m && x.push([P[0], Math.max(P[0], Math.min(P[1], V[1] - d))]), P[1] - P[0] > d - m || V[1] - V[0] > d - m) for (var C = x.length - 1; C >= 0 && 1 !== x.length; --C) {x[C][1] - x[C][0] < m && x.splice(C, 1);}for (C = 0; C < x.length; ++C) {var b = x[C],L = A ? [R - b[1], R - b[0]] : [b[0] - R, b[1] - R],O = (0, h.foldAbove)(L[0], t.getRange()[0], d) - L[0];if (L = [L[0] + O, L[1] + O], b[1] - b[0] < m) {var S = .5 * (b[0] + b[1]),M = .5 * (L[0] + L[1]),w = p(e, S, i, t),N = p(t, M, i, e);w && N && s.push({ cutInfo: w, cutByInfo: N });} else {var F = [p(e, b[0], i, t), p(e, b[1], i, t)],I = [p(t, L[0], i, e), p(t, L[1], i, e)];F[0] && F[1] && I[0] && I[1] && s.push({ rangeInfo: F, rangeByInfo: I });}}return s;}var D = (c * c - l * l + v * v) / (2 * v),j = c * c - D * D,B = c - Math.abs(D),U = [],k = [];if (B < -i) ;else {var G = Math.sqrt(Math.max(0, j));if (n.Vector3.scale(g, g, 1 / v), G < 2 * i) U.push(E(0, D, a, g, e, t)), k.push(!1);else if (B < i) {if (k.push(!1), r) {k[k.length - 1] = !0;var z = E(0, D, a, g, e, t),Y = [E(G, D, a, g, e, t), E(-G, D, a, g, e, t)];_(e, t, [Y[0].firstParam, z.firstParam, Y[1].firstParam], [Y[0].secondParam, z.secondParam, Y[1].secondParam], i, s, U);} else U.push(E(0, D, a, g, e, t));} else U.push(E(G, D, a, g, e, t)), U.push(E(-G, D, a, g, e, t));}var K = 0;for (e.isClosed() && o && (K = 1), C = 0; C < U.length; ++C) {var q = f(e, U[C].firstParam, t, U[C].secondParam, i);if (q) for (var W = -K; W <= K; ++W) {s.push({ cutInfo: { atVertex: q.cutInfo.atVertex, param: q.cutInfo.param + W * Math.PI * 2 }, cutByInfo: q.cutByInfo }), k[C] && (s[s.length - 1].cutInfo.virtualIntersection = !0, s[s.length - 1].cutByInfo.virtualIntersection = !0);}}return s;}(e, t, r, i, s) : u && P ? A(e, t, r, s) : l && R ? function (e, t, r, n, o) {var i = A(t, e, r, o),s = [],a = 0,c = 0;n && e.getCurve().isPeriodicUnlimited() && (a = 1, c = e.getCurve().getPeriodUnlimited());for (var u = 0; u < i.length; ++u) {if (i[u].hasOwnProperty("cutInfo") && i[u].hasOwnProperty("cutByInfo")) for (var l = -a; l <= a; ++l) {s.push({ cutInfo: { atVertex: i[u].cutByInfo.atVertex, param: i[u].cutByInfo.param + l * c }, cutByInfo: i[u].cutInfo });} else i[u].hasOwnProperty("rangeInfo") && i[u].hasOwnProperty("rangeByInfo") && s.push({ rangeInfo: i[u].rangeByInfo, rangeByInfo: i[u].rangeInfo });}return s;}(e, t, r, i, s) : c && P ? V(e, t, 0, i, s) : l && v ? function (e, t, r, n, o) {var i = V(t, e, 0, !1, o),s = [],a = 0,c = 0;n && e.getCurve().isPeriodicUnlimited() && (a = 1, c = e.getCurve().getPeriodUnlimited());for (var u = 0; u < i.length; ++u) {if (i[u].hasOwnProperty("cutInfo") && i[u].hasOwnProperty("cutByInfo")) for (var l = -a; l <= a; ++l) {s.push({ cutInfo: { atVertex: i[u].cutByInfo.atVertex, param: i[u].cutByInfo.param + l * c }, cutByInfo: i[u].cutInfo });} else i[u].hasOwnProperty("rangeInfo") && i[u].hasOwnProperty("rangeByInfo") && s.push({ rangeInfo: i[u].rangeByInfo, rangeByInfo: i[u].rangeInfo });}return s;}(e, t, 0, i, s) : l && P ? function (e, t, r, n, o) {var i = e === t,s = e.getBoundingBox(),a = t.getBoundingBox(),c = [];if (!s.intersectsWithTolerance(a, o)) return c;var u,l,h,d,g = e.getCurve().getBezierSegments(),p = g.length,f = t.getCurve().getBezierSegments(),v = f.length,_ = [],y = 0,m = 0,E = 0;for (n && e.getCurve().isPeriodic() && e.isClosed() && (m = 1, E = e.getCurve().getPeriod()), u = 0; u < p; u++) {for (i && (y = u + 1), l = y; l < v; l++) {var R = i && l === u + 1;for (_ = T(e, t, g[u], f[l], r, o, R), h = 0; h < _.length; ++h) {for (d = -m; d <= m; ++d) {_[h].cutInfo && c.push({ cutInfo: { atVertex: _[h].cutInfo.atVertex, param: _[h].cutInfo.param + d * E }, cutByInfo: _[h].cutByInfo }), _[h].rangeInfo && c.push(_[h]);}}}}if (i) for (u = 0; u < p; ++u) {for (_ = C(e, g[u], 0, o), h = 0; h < _.length; ++h) {for (d = -m; d <= m; ++d) {_[h].cutInfo && c.push({ cutInfo: { atVertex: _[h].cutInfo.atVertex, param: _[h].cutInfo.param + d * E }, cutByInfo: _[h].cutByInfo }), _[h].rangeInfo && c.push(_[h]);}}}return x(c);}(e, t, r, i, s) : function (e, t, r, n, i) {var s = e.getBoundingBox(),a = t.getBoundingBox(),c = [];if (!s.intersectsWithTolerance(a, i)) return c;var u = e.isReversed(),l = t.isReversed(),h = e.getRange();u && (h = [-h[1], -h[0]]);var g = t.getRange();l && (g = [-g[1], -g[0]]), c = new d.CCI(e.getCurve(), h, t.getCurve(), g, o.KERNEL_TOLERANCE).intersect();for (var p = 0; p < c.length; ++p) {u && (c[p].cutInfo ? c[p].cutInfo.param *= -1 : c[p].rangeInfo && (c[p].rangeInfo = [c[p].rangeInfo[1], c[p].rangeInfo[0]], c[p].rangeInfo[0].param *= -1, c[p].rangeInfo[1].param *= -1)), l && (c[p].cutByInfo ? c[p].cutByInfo.param *= -1 : c[p].rangeByInfo && (c[p].rangeByInfo[0].param *= -1, c[p].rangeByInfo[1].param *= -1));}return c;}(e, t, 0, 0, s);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.edgesAreCoincident = t.curvesAreCoincident = void 0;var n = r(1),o = r(0),i = r(2),s = r(8);function a(e, t, r, o, i) {var s = e.evaluatePosition(t),a = r.closestToPointParam(s, o),c = r.evaluatePosition(a);return n.Vector3.squaredDistance(s, c) < i * i;}function c(e, t, r, o, i, s) {var c = [0, 0, 0];if (n.Vector3.isParallel(e, t.getNormal())) return !0;n.Vector3.add(c, t.getCenter(), e);var u = t.closestToPointParam(c, o);if (u > o[0] && u < o[1] && !a(t, u, r, i, s)) return !1;n.Vector3.sub(c, t.getCenter(), e);var l = t.closestToPointParam(c, o);return !(l > o[0] && l < o[1] && !a(t, l, r, i, s));}function u(e, t, r, n, o) {if (!a(e, .5 * (r[0] + r[1]), t, n, o)) return !1;var i = t.closestToPointParam(e.getCenter(), n);return !(i > n[0] && i < n[1] && !a(t, i, e, r, o));}var l = function l(e, t, r, _l, h) {r ? 0 === r.length && (r = e.getRangeUnlimited()) : r = e.getRange(), _l ? 0 === _l.length && (_l = t.getRangeUnlimited()) : _l = t.getRange(), h || (h = o.KERNEL_TOLERANCE);var d = e.getGeometryType(),g = t.getGeometryType();if (!(isFinite(r[0]) && isFinite(r[1]) && isFinite(_l[0]) && isFinite(_l[1]))) {var p = r[0] === Number.NEGATIVE_INFINITY && r[1] === Number.POSITIVE_INFINITY,f = _l[0] === Number.NEGATIVE_INFINITY && _l[1] === Number.POSITIVE_INFINITY;return !(!p || !f) && (i.ConsoleUtils.assert(d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.LINE), function (e, t, r) {if (e === t) return !0;if (!a(e, 0, t, [], r) || !a(t, 0, e, [], r)) return !1;var o = e.evaluateDt(0);n.Vector3.normalize(o, o);var i = t.evaluateDt(0);return n.Vector3.normalize(i, i), n.Vector3.dot(o, i) < 0 && n.Vector3.negate(i, i), n.Vector3.equals(o, i, n.FLOAT64_TOLERANCE);}(e, t, h));}return e === t && Math.abs(r[0] - _l[0]) < n.FLOAT64_TOLERANCE && Math.abs(r[1] - _l[1]) < n.FLOAT64_TOLERANCE || !!(a(e, r[0], t, _l, h) && a(e, r[1], t, _l, h) && a(t, _l[0], e, r, h) && a(t, _l[1], e, r, h)) && (d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.LINE || (d === o.GEOMETRY_TYPES.CIRCLE && g === o.GEOMETRY_TYPES.CIRCLE ? function (e, t, r, o, i) {var s = .5 * (r[0] + r[1]),u = .5 * (o[0] + o[1]);if (!a(e, s, t, o, i) || !a(t, u, e, r, i)) return !1;var l = n.Vector3.sub([0, 0, 0], t.getCenter(), e.getCenter());if (n.Vector3.squaredLength(l) > n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {if (n.Vector3.normalize(l, l), !c(l, e, t, r, o, i)) return !1;if (!c(l, t, e, o, r, i)) return !1;}if (n.Vector3.dot(e.getNormal(), t.getNormal()) < 0 ? n.Vector3.add(l, e.getNormal(), t.getNormal()) : n.Vector3.sub(l, e.getNormal(), t.getNormal()), n.Vector3.squaredLength(l) > n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {if (n.Vector3.normalize(l, l), !c(l, e, t, r, o, i)) return !1;if (!c(l, t, e, o, r, i)) return !1;}if (r[1] - r[0] < 2 * Math.PI - n.FLOAT64_TOLERANCE) {var h = e.evaluatePosition(s + Math.PI),d = t.closestToPointParam(h, o);if (d > o[0] && d < o[1] && !a(t, d, e, r, i)) return !1;}if (o[1] - o[0] < 2 * Math.PI - n.FLOAT64_TOLERANCE) {var g = t.evaluatePosition(u + Math.PI),p = e.closestToPointParam(g, r);if (p > r[0] && p < r[1] && !a(e, p, t, o, i)) return !1;}return !0;}(e, t, r, _l, h) : d === o.GEOMETRY_TYPES.CIRCLE && g === o.GEOMETRY_TYPES.LINE ? u(e, t, r, _l, h) : d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.CIRCLE ? u(t, e, _l, r, h) : function (e, t, r, o, i) {for (var a = [r[0], r[1]], c = [e.evaluatePosition(r[0]), e.evaluatePosition(r[1])], u = 0; u < 100; ++u) {var l = .5 * (a[0] + a[1]),h = e.evaluatePosition(l),d = t.closestToPointParam(h, o),g = t.evaluatePosition(d),p = n.Vector3.sub([0, 0, 0], g, h);if (n.Vector3.squaredLength(p) > i * i) return !1;if (n.Vector3.distance(c[0], h) + n.Vector3.distance(h, c[1]) < i) return !0;var f = e.evaluateDt(l);n.Vector3.dot(f, p) < 0 ? (a[0] = l, c[0] = h) : (a[1] = l, c[1] = h);}return s.DebugUtils.warn("Binary search in coincidence check exceeded maximum iterations"), !0;}(e, t, r, _l, h)));};t.curvesAreCoincident = l, t.edgesAreCoincident = function (e, t) {if (e === t) return !0;var r = Math.max(o.KERNEL_TOLERANCE, e.getPrecision(), t.getPrecision()),i = e.getCurve(),s = t.getCurve();if (!i || !s) {if (i || s) return !1;var a = e.getStartVertex(),c = t.getStartVertex();r = Math.max(r, a.getPrecision(), c.getPrecision());var u = a.getPosition(),h = c.getPosition();return n.Vector3.squaredDistance(u, h) < r * r;}var d = e.getRange();e.isReversed() && (d = [-d[1], -d[0]]);var g = t.getRange();return t.isReversed() && (g = [-g[1], -g[0]]), l(i, s, d, g, r);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.extrudeFace = void 0;var n = r(1),o = r(0),i = r(2),s = r(18),a = r(38),c = r(39),u = r(53),l = r(13),h = r(15),d = r(26),g = r(25),p = r(24),f = r(55),v = r(19),_ = r(28);function y(e, t, r) {var i = n.Vector3.length(r),s = n.Vector3.dot(e.getAxisDir(), r) > 0 ? [0, i] : [-i, 0];e.limitRangeU(s), t[1] - t[0] < 2 * Math.PI - o.PARAMETER_SPACE_TOLERANCE && e.limitRangeV(t);}var m = function m(e, t) {var r = e.getEdge().getCurve(),i = e.getRange(),l = !0;e.isReversed() !== e.getEdge().isReversed() && (i = [-i[1], -i[0]], l = !1);var h,d = l ? e.t0() : e.t1(),g = e.evaluateDt(d);if (n.Vector3.cross(g, g, t), n.Vector3.normalize(g, g), n.Vector3.negate(g, g), r.getGeometryType() === o.GEOMETRY_TYPES.LINE) h = function (e, t, r) {var o = new s.Plane(),i = e.evaluateDt(0),a = n.Vector3.createFloat64();n.Vector3.normalize(a, r);var c = n.Vector3.createFloat64();n.Vector3.cross(c, a, i), o.set(e.evaluatePosition(0), c, a);var u = n.Vector3.length(r),l = n.Vector3.dot(a, r) > 0 ? [0, u] : [-u, 0];return o.limitRangeV(t), o.limitRangeU(l), o;}(r, i, t);else if (r.getGeometryType() === o.GEOMETRY_TYPES.CIRCLE) h = function (e, t, r) {var o = e.evaluatePosition(0);n.Vector3.subtract(o, o, e.getCenter());var i = n.Vector3.createFloat64();n.Vector3.negate(i, e.getNormal());var s = new a.Cylinder();return s.set(e.getCenter(), e.getRadius(), i, o, 1), y(s, t, r), s;}(r, i, t);else if (r.getGeometryType() === o.GEOMETRY_TYPES.ELLIPSE) h = function (e, t, r) {var o = e.evaluatePosition(0);n.Vector3.subtract(o, o, e.getCenter());var i = n.Vector3.createFloat64();n.Vector3.negate(i, e.getNormal());var s = new c.EllipticalCylinder();return s.set(e.getCenter(), o, e.getMinorRadius() / e.getMajorRadius(), i, 1), y(s, t, r), s;}(r, i, t);else {if (r.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE) throw new Error("createSideFaceRuledSurface: Curve type not supported.");h = function (e, t, r) {for (var n = new u.BSurface(), o = e.getDegree(), i = e.getKnotVector().slice(0), s = e.getControlPoints().slice(0), a = (s = s.concat(s)).length / 2; a < s.length; a += 3) {s[a] += r[0], s[a + 1] += r[1], s[a + 2] += r[2];}var c = void 0;return e.isRational() && (c = (c = e.getWeights().slice(0)).concat(c)), n.set(1, o, [0, 0, 1, 1], i, s, c), n.limitRangeU([0, 1]), n.limitRangeV(t), n;}(r, i, t);}var p = h.evaluateNormal(0, i[0]);return { surface: h, isReversed: n.Vector3.dot(p, g) < 0 };};t.extrudeFace = function (e, t) {i.ConsoleUtils.assert(e.getSurfaceType() === o.GEOMETRY_TYPES.PLANE);var r = e.evaluateNormal(0, 0);n.Vector3.scale(r, r, t);var s = new f.TopologyCloner().cloneFace(e),a = n.Matrix44.fromTranslation(n.Matrix44.createFloat64(), r);(0, v.transformTopology)(s, a), t > 0 ? (0, v.reverseFace)(e) : (0, v.reverseFace)(s);var c = function (e, t, r) {for (var n = [], o = e.getLoops(), i = t.getLoops(), s = 0; s < o.length; ++s) {for (var a = o[s].getCoedges(), c = i[s].getCoedges(), u = new Array(a.length), d = 0; d < a.length; ++d) {var g = new Array(4),p = a[d],f = c[a.length - 1 - d],v = p.getStartVertex(),y = p.getEndVertex(),E = f.getStartVertex(),x = f.getEndVertex();g[0] = (0, _.createCoedgeOnEdge)(p.getEdge()), 0 === d && (u[d] = (0, _.createLineEdgeBetweenVertices)(v, x)), g[1] = (0, _.createCoedgeOnEdge)(u[d]), g[2] = (0, _.createCoedgeOnEdge)(f.getEdge()), d !== a.length - 1 && (u[d + 1] = (0, _.createLineEdgeBetweenVertices)(E, y)), g[3] = (0, _.createCoedgeOnEdge)(u[(d + 1) % a.length]);var R = new l.Loop();R.addCoedges(g);var A = m(p, r),P = new h.Face(A.surface);P.setReversed(A.isReversed), P.addLoop(R), n.push(P);}}return n;}(e, s, r),u = e.getShell();u || (u = new d.Shell()).addFace(e), i.ConsoleUtils.assert(1 === u.getFaces().length), u.addFaces(c), u.addFace(s);var y = u.getLump();y || (y = new g.Lump()).addShell(u);var E = y.getBody();return E || (E = new p.Body()).addLump(y), E;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.getBoundedRegionFaces = t.getRegionEdges = t.mergeSketchRegions = void 0;var n = r(0),o = r(19),i = r(80),s = function s(e, t) {var r = e.getProgenitorMap(),o = new Set();return t.forEach(function (e) {r.getDescendants(e).forEach(function (e) {e.getTopologyType() === n.TOPOLOGY_TYPES.EDGE && o.add(e);});}), Array.from(o);},a = function a(e, t) {var r = [];return (0, o.findConnectedFaces)(e, { allowVertexConnections: !1, barrierEdges: t }).forEach(function (e) {(function (e, t) {e = new Set(e), t = new Set(t);var r = new Set();e.forEach(function (e) {e.collectEdges(r);}), r = Array.from(r);for (var n = 0; n < r.length; n++) {var o = r[n];if (!t.has(o)) {var i = o.getCoedges();if (i.length < 2) return !1;for (var s = 0; s < i.length; s++) {if (!e.has(i[s].getFace())) return !1;}}}return !0;})(e, t) && (r = r.concat(e));}), r;},c = function c(e, t) {for (var r = 0; r < e.length; r++) {if (t.indexOf(e[r]) < 0) return !1;}return !0;};t.mergeSketchRegions = function (e) {var t,r,n = [];e.forEach(function (e) {n = n.concat(e.getEdges());});var u = new i.SketchRegionSolver();u.compute(n);var l = u.getFaces(),h = [],d = [];for (t = 0; t < e.length; t++) {var g = s(u, e[t].getEdges());if (0 !== g.length) {var p = a(l, g);0 !== p.length && (d.push(g), h.push(p));}}for (var f = [], v = new Set(l), _ = !0; h.length > 0;) {var y = [];for (t = 0; t < h.length; t++) {var m = !1;for (r = 0; r < h.length; r++) {if (t !== r && c(h[t], h[r])) {m = !0;break;}}y.push(m);}var E = new Set();for (t = h.length - 1; t >= 0; t--) {y[t] ? h[t].forEach(function (e) {E.add(e), v.delete(e);}) : (h.splice(t, 1), d.splice(t, 1));}_ && (f = f.concat(Array.from(v))), v = E, _ = !_;}return (0, o.mergeConnectedFaces)(f);}, t.getRegionEdges = s, t.getBoundedRegionFaces = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.propertyToRange = t.GeometrySetters = void 0;var n = r(1),o = function o(e, t, r) {var n = t[r];e[0] = n.x, e[1] = n.y, e[2] = n.z;},i = function i(e, t) {var r = e[t];var n = r.type;return "infinite" === n || 0 === n ? [] : [r.low, r.high];},s = function s(e, t) {var r = i(e, "uRange");t.unlimitRangeU(), r.length > 0 && t.limitRangeU(r);var n = i(e, "vRange");t.unlimitRangeV(), n.length > 0 && t.limitRangeV(n);},a = function a(e, t) {var r = i(e, "range");t.unlimitRange(), r.length > 0 && t.limitRange(r);},c = { setBCurveFromProperty: function setBCurveFromProperty(e, t) {var r,n,o = t.degree,i = t.knots,s = t.controlPoints,c = t.weights,u = s.length / 3;if (0 === c.length) for (n = new Array(u), r = 0; r < u; ++r) {n[r] = 1;} else n = c;e.set(s, n, o, i), a(t, e);}, setBSurfaceFromProperty: function setBSurfaceFromProperty(e, t) {var r,n,o = t.uDegree,i = t.vDegree,a = t.uKnots,c = t.vKnots,u = t.controlPoints,l = t.weights;if (0 === l.length) {var h = u.length / 3;for (n = new Array(h), r = 0; r < h; ++r) {n[r] = 1;}} else n = l;e.set(o, i, a, c, u, n), s(t, e);}, setCircleFromProperty: function setCircleFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),s = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "normal"), o(s, t, "radius"), e.set(r, i, s), a(t, e);}, setConeFromProperty: function setConeFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "radius");var c = n.Vector3.length(a);n.Vector3.normalize(a, a);var u = t.angle,l = t.uCoordScale;e.set(r, c, i, u, a, l), s(t, e);}, setCylinderFromProperty: function setCylinderFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "radius");var c = n.Vector3.length(a);n.Vector3.normalize(a, a);var u = t.uCoordScale;e.set(r, c, i, a, u), s(t, e);}, setEllipseFromProperty: function setEllipseFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),s = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "normal"), o(s, t, "majorRadius");var c = t.radiusRatio;e.set(r, i, s, c), a(t, e);}, setEllipticalConeFromProperty: function setEllipticalConeFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "majorRadius");var c = t.angle,u = t.radiusRatio,l = t.uCoordScale;e.set(r, a, u, i, c, l), s(t, e);}, setEllipticalCylinderFromProperty: function setEllipticalCylinderFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "majorRadius");var c = t.radiusRatio,u = t.uCoordScale;e.set(r, a, c, i, u), s(t, e);}, setLineFromProperty: function setLineFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64();o(r, t, "position"), o(i, t, "direction"), e.set(r, i), a(t, e);}, setPlaneFromProperty: function setPlaneFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "origin"), o(i, t, "normal"), o(a, t, "uAxis"), e.set(r, i, a), s(t, e);}, setPointFromProperty: function setPointFromProperty(e, t) {e.setPosition(t.position.x, t.position.y, t.position.z);}, setSphereFromProperty: function setSphereFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "radius"), o(a, t, "axis");var c = n.Vector3.length(i);n.Vector3.normalize(i, i), e.set(r, c, a, i), s(t, e);}, setTorusFromProperty: function setTorusFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "coordAxis");var c = t.majorRadius,u = t.minorRadius,l = t.lemon;e.set(r, c, u, i, a, l), s(t, e);}, setHapCurveFromProperty: function setHapCurveFromProperty(e, t) {for (var r = t.spans, n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = {}, n[o].polyOrder = r[o].polyOrder, n[o].lowParam = r[o].lowParam, n[o].highParam = r[o].highParam, n[o].coefs = r[o].coefs.slice(0);}var i = {};i.spans = n;var s = t.periodic;void 0 === s && (s = !1), i.periodic = s, i.closed = s, e.setHapDefinition(i), a(t, e);}, setCurveRangeFromProperty: a, setSurfaceRangeFromProperty: s };t.GeometrySetters = c, t.propertyToRange = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.getBoundedRegionFaces = t.getRegionEdges = t.mergeConnectedFaces = t.getOrderedFacesOnVertex = t.saveToProtoMessage = t.saveToProtoBinary = t.SolidDefSaver = t.SolidDefLoader = t.Path2D = t.DebugUtils = t.svgFromWire = t.transformTopology = t.TopologyStitcher = t.TopologyCloner = t.extrudeFace = t.createEdgeFromCurve = t.createFaceFromPolyline = t.createShellsFromFaces = t.createPolyhedron = t.createLineEdgeBetweenVertices = t.createLineEdge = t.createCylinder = t.createCone = t.createBlock = t.computeCurveCurveIntersections = t.SketchRegionSolver = t.facetPlanarFace = t.checkValidity = t.BoundingBox = t.Attribute = t.Wire = t.WireBody = t.Vertex = t.Edge = t.Coedge = t.Loop = t.Face = t.Shell = t.Lump = t.Body = t.BSurface = t.Torus = t.EllipticalCone = t.Cone = t.Sphere = t.EllipticalCylinder = t.Cylinder = t.Plane = t.BCurve = t.Ellipse = t.Circle = t.Line = t.Point = t.TOPOLOGY_TYPES = t.GEOMETRY_TYPES = t.KERNEL_TOLERANCE = void 0;var n = r(0),o = r(4),i = r(6),s = r(7),a = r(14),c = r(23),u = r(33),l = r(18),h = r(38),d = r(39),g = r(74),p = r(51),f = r(52),v = r(75),_ = r(53),y = r(24),m = r(25),E = r(26),x = r(15),R = r(13),A = r(27),P = r(20),V = r(16),T = r(54),C = r(40),b = r(79),L = r(106),O = r(107),S = r(80),M = r(81),w = r(115),N = r(116),F = r(117),I = r(28),D = r(83),j = r(55),B = r(118),U = r(19),k = r(121),G = r(8),z = r(122),Y = r(123),K = r(126),q = r(84),W = r(78);t.KERNEL_TOLERANCE = n.KERNEL_TOLERANCE, t.GEOMETRY_TYPES = n.GEOMETRY_TYPES, t.TOPOLOGY_TYPES = n.TOPOLOGY_TYPES, t.Point = i.Point, t.Line = s.Line, t.Circle = a.Circle, t.Ellipse = c.Ellipse, t.BCurve = u.BCurve, t.Plane = l.Plane, t.Cylinder = h.Cylinder, t.EllipticalCylinder = d.EllipticalCylinder, t.Sphere = g.Sphere, t.Cone = p.Cone, t.EllipticalCone = f.EllipticalCone, t.Torus = v.Torus, t.BSurface = _.BSurface, t.Body = y.Body, t.Lump = m.Lump, t.Shell = E.Shell, t.Face = x.Face, t.Loop = R.Loop, t.Coedge = A.Coedge, t.Edge = P.Edge, t.Vertex = V.Vertex, t.WireBody = T.WireBody, t.Wire = C.Wire, t.Attribute = b.Attribute, t.BoundingBox = o.BoundingBox, t.checkValidity = L.checkValidity, t.facetPlanarFace = O.facetPlanarFace, t.SketchRegionSolver = S.SketchRegionSolver, t.computeCurveCurveIntersections = M.computeCurveCurveIntersections, t.createBlock = w.createBlock, t.createCone = N.createCone, t.createCylinder = N.createCylinder, t.createLineEdge = I.createLineEdge, t.createLineEdgeBetweenVertices = I.createLineEdgeBetweenVertices, t.createPolyhedron = F.createPolyhedron, t.createShellsFromFaces = I.createShellsFromFaces, t.createFaceFromPolyline = I.createFaceFromPolyline, t.createEdgeFromCurve = I.createEdgeFromCurve, t.extrudeFace = D.extrudeFace, t.TopologyCloner = j.TopologyCloner, t.TopologyStitcher = B.TopologyStitcher, t.transformTopology = U.transformTopology, t.svgFromWire = k.svgFromWire, t.DebugUtils = G.DebugUtils, t.Path2D = z.Path2D, t.SolidDefLoader = Y.SolidDefLoader, t.SolidDefSaver = K.SolidDefSaver, t.saveToProtoBinary = K.saveToProtoBinary, t.saveToProtoMessage = K.saveToProtoMessage, t.getOrderedFacesOnVertex = W.getOrderedFacesOnVertex, t.mergeConnectedFaces = U.mergeConnectedFaces, t.getRegionEdges = q.getRegionEdges, t.getBoundedRegionFaces = q.getBoundedRegionFaces;}, function (e, t, r) {"use strict";e.exports = r(88);}, function (e, t, r) {"use strict";var n = e.exports = r(89);n.build = "light", n.load = function (e, t, r) {return "function" == typeof t ? (r = t, t = new n.Root()) : t || (t = new n.Root()), t.load(e, r);}, n.loadSync = function (e, t) {return t || (t = new n.Root()), t.loadSync(e);}, n.encoder = r(62), n.decoder = r(67), n.verifier = r(68), n.converter = r(69), n.ReflectionObject = r(21), n.Namespace = r(30), n.Root = r(71), n.Enum = r(11), n.Type = r(63), n.Field = r(22), n.OneOf = r(48), n.MapField = r(64), n.Service = r(65), n.Method = r(66), n.Message = r(49), n.wrappers = r(70), n.types = r(31), n.util = r(5), n.ReflectionObject._configure(n.Root), n.Namespace._configure(n.Type, n.Service, n.Enum), n.Root._configure(n.Type), n.Field._configure(n.Type);}, function (e, t, r) {"use strict";var n = t;function o() {n.Reader._configure(n.BufferReader), n.util._configure();}n.build = "minimal", n.Writer = r(46), n.BufferWriter = r(96), n.Reader = r(47), n.BufferReader = r(97), n.util = r(10), n.rpc = r(60), n.roots = r(61), n.configure = o, n.Writer._configure(n.BufferWriter), o();}, function (e, t, r) {"use strict";var n = t;n.length = function (e) {var t = e.length;if (!t) return 0;for (var r = 0; --t % 4 > 1 && "=" === e.charAt(t);) {++r;}return Math.ceil(3 * e.length) / 4 - r;};for (var o = new Array(64), i = new Array(123), s = 0; s < 64;) {i[o[s] = s < 26 ? s + 65 : s < 52 ? s + 71 : s < 62 ? s - 4 : s - 59 | 43] = s++;}n.encode = function (e, t, r) {for (var n, i = null, s = [], a = 0, c = 0; t < r;) {var u = e[t++];switch (c) {case 0:s[a++] = o[u >> 2], n = (3 & u) << 4, c = 1;break;case 1:s[a++] = o[n | u >> 4], n = (15 & u) << 2, c = 2;break;case 2:s[a++] = o[n | u >> 6], s[a++] = o[63 & u], c = 0;}a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, s)), a = 0);}return c && (s[a++] = o[n], s[a++] = 61, 1 === c && (s[a++] = 61)), i ? (a && i.push(String.fromCharCode.apply(String, s.slice(0, a))), i.join("")) : String.fromCharCode.apply(String, s.slice(0, a));}, n.decode = function (e, t, r) {for (var n, o = r, s = 0, a = 0; a < e.length;) {var c = e.charCodeAt(a++);if (61 === c && s > 1) break;if (void 0 === (c = i[c])) throw Error("invalid encoding");switch (s) {case 0:n = c, s = 1;break;case 1:t[r++] = n << 2 | (48 & c) >> 4, n = c, s = 2;break;case 2:t[r++] = (15 & n) << 4 | (60 & c) >> 2, n = c, s = 3;break;case 3:t[r++] = (3 & n) << 6 | c, s = 0;}}if (1 === s) throw Error("invalid encoding");return r - o;}, n.test = function (e) {return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);};}, function (e, t, r) {"use strict";function n() {this._listeners = {};}e.exports = n, n.prototype.on = function (e, t, r) {return (this._listeners[e] || (this._listeners[e] = [])).push({ fn: t, ctx: r || this }), this;}, n.prototype.off = function (e, t) {if (void 0 === e) this._listeners = {};else if (void 0 === t) this._listeners[e] = [];else for (var r = this._listeners[e], n = 0; n < r.length;) {r[n].fn === t ? r.splice(n, 1) : ++n;}return this;}, n.prototype.emit = function (e) {var t = this._listeners[e];if (t) {for (var r = [], n = 1; n < arguments.length;) {r.push(arguments[n++]);}for (n = 0; n < t.length;) {t[n].fn.apply(t[n++].ctx, r);}}return this;};}, function (e, t, r) {"use strict";function n(e) {return "undefined" != typeof Float32Array ? function () {var t = new Float32Array([-0]),r = new Uint8Array(t.buffer),n = 128 === r[3];function o(e, n, o) {t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3];}function i(e, n, o) {t[0] = e, n[o] = r[3], n[o + 1] = r[2], n[o + 2] = r[1], n[o + 3] = r[0];}function s(e, n) {return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], t[0];}function a(e, n) {return r[3] = e[n], r[2] = e[n + 1], r[1] = e[n + 2], r[0] = e[n + 3], t[0];}e.writeFloatLE = n ? o : i, e.writeFloatBE = n ? i : o, e.readFloatLE = n ? s : a, e.readFloatBE = n ? a : s;}() : function () {function t(e, t, r, n) {var o = t < 0 ? 1 : 0;if (o && (t = -t), 0 === t) e(1 / t > 0 ? 0 : 2147483648, r, n);else if (isNaN(t)) e(2143289344, r, n);else if (t > 34028234663852886e22) e((o << 31 | 2139095040) >>> 0, r, n);else if (t < 11754943508222875e-54) e((o << 31 | Math.round(t / 1401298464324817e-60)) >>> 0, r, n);else {var i = Math.floor(Math.log(t) / Math.LN2);e((o << 31 | i + 127 << 23 | 8388607 & Math.round(t * Math.pow(2, -i) * 8388608)) >>> 0, r, n);}}function r(e, t, r) {var n = e(t, r),o = 2 * (n >> 31) + 1,i = n >>> 23 & 255,s = 8388607 & n;return 255 === i ? s ? NaN : o * (1 / 0) : 0 === i ? 1401298464324817e-60 * o * s : o * Math.pow(2, i - 150) * (s + 8388608);}e.writeFloatLE = t.bind(null, o), e.writeFloatBE = t.bind(null, i), e.readFloatLE = r.bind(null, s), e.readFloatBE = r.bind(null, a);}(), "undefined" != typeof Float64Array ? function () {var t = new Float64Array([-0]),r = new Uint8Array(t.buffer),n = 128 === r[7];function o(e, n, o) {t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3], n[o + 4] = r[4], n[o + 5] = r[5], n[o + 6] = r[6], n[o + 7] = r[7];}function i(e, n, o) {t[0] = e, n[o] = r[7], n[o + 1] = r[6], n[o + 2] = r[5], n[o + 3] = r[4], n[o + 4] = r[3], n[o + 5] = r[2], n[o + 6] = r[1], n[o + 7] = r[0];}function s(e, n) {return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], r[4] = e[n + 4], r[5] = e[n + 5], r[6] = e[n + 6], r[7] = e[n + 7], t[0];}function a(e, n) {return r[7] = e[n], r[6] = e[n + 1], r[5] = e[n + 2], r[4] = e[n + 3], r[3] = e[n + 4], r[2] = e[n + 5], r[1] = e[n + 6], r[0] = e[n + 7], t[0];}e.writeDoubleLE = n ? o : i, e.writeDoubleBE = n ? i : o, e.readDoubleLE = n ? s : a, e.readDoubleBE = n ? a : s;}() : function () {function t(e, t, r, n, o, i) {var s = n < 0 ? 1 : 0;if (s && (n = -n), 0 === n) e(0, o, i + t), e(1 / n > 0 ? 0 : 2147483648, o, i + r);else if (isNaN(n)) e(0, o, i + t), e(2146959360, o, i + r);else if (n > 17976931348623157e292) e(0, o, i + t), e((s << 31 | 2146435072) >>> 0, o, i + r);else {var a;if (n < 22250738585072014e-324) e((a = n / 5e-324) >>> 0, o, i + t), e((s << 31 | a / 4294967296) >>> 0, o, i + r);else {var c = Math.floor(Math.log(n) / Math.LN2);1024 === c && (c = 1023), e(4503599627370496 * (a = n * Math.pow(2, -c)) >>> 0, o, i + t), e((s << 31 | c + 1023 << 20 | 1048576 * a & 1048575) >>> 0, o, i + r);}}}function r(e, t, r, n, o) {var i = e(n, o + t),s = e(n, o + r),a = 2 * (s >> 31) + 1,c = s >>> 20 & 2047,u = 4294967296 * (1048575 & s) + i;return 2047 === c ? u ? NaN : a * (1 / 0) : 0 === c ? 5e-324 * a * u : a * Math.pow(2, c - 1075) * (u + 4503599627370496);}e.writeDoubleLE = t.bind(null, o, 0, 4), e.writeDoubleBE = t.bind(null, i, 4, 0), e.readDoubleLE = r.bind(null, s, 0, 4), e.readDoubleBE = r.bind(null, a, 4, 0);}(), e;}function o(e, t, r) {t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;}function i(e, t, r) {t[r] = e >>> 24, t[r + 1] = e >>> 16 & 255, t[r + 2] = e >>> 8 & 255, t[r + 3] = 255 & e;}function s(e, t) {return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;}function a(e, t) {return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;}e.exports = n(n);}, function (e, t, r) {"use strict";var n = t;n.length = function (e) {for (var t = 0, r = 0, n = 0; n < e.length; ++n) {(r = e.charCodeAt(n)) < 128 ? t += 1 : r < 2048 ? t += 2 : 55296 == (64512 & r) && 56320 == (64512 & e.charCodeAt(n + 1)) ? (++n, t += 4) : t += 3;}return t;}, n.read = function (e, t, r) {if (r - t < 1) return "";for (var n, o = null, i = [], s = 0; t < r;) {(n = e[t++]) < 128 ? i[s++] = n : n > 191 && n < 224 ? i[s++] = (31 & n) << 6 | 63 & e[t++] : n > 239 && n < 365 ? (n = ((7 & n) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, i[s++] = 55296 + (n >> 10), i[s++] = 56320 + (1023 & n)) : i[s++] = (15 & n) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], s > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), s = 0);}return o ? (s && o.push(String.fromCharCode.apply(String, i.slice(0, s))), o.join("")) : String.fromCharCode.apply(String, i.slice(0, s));}, n.write = function (e, t, r) {for (var n, o, i = r, s = 0; s < e.length; ++s) {(n = e.charCodeAt(s)) < 128 ? t[r++] = n : n < 2048 ? (t[r++] = n >> 6 | 192, t[r++] = 63 & n | 128) : 55296 == (64512 & n) && 56320 == (64512 & (o = e.charCodeAt(s + 1))) ? (n = 65536 + ((1023 & n) << 10) + (1023 & o), ++s, t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128) : (t[r++] = n >> 12 | 224, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128);}return r - i;};}, function (e, t, r) {"use strict";e.exports = function (e, t, r) {var n = r || 8192,o = n >>> 1,i = null,s = n;return function (r) {if (r < 1 || r > o) return e(r);s + r > n && (i = e(n), s = 0);var a = t.call(i, s, s += r);return 7 & s && (s = 1 + (7 | s)), a;};};}, function (e, t, r) {"use strict";e.exports = o;var n = r(10);function o(e, t) {this.lo = e >>> 0, this.hi = t >>> 0;}var i = o.zero = new o(0, 0);i.toNumber = function () {return 0;}, i.zzEncode = i.zzDecode = function () {return this;}, i.length = function () {return 1;};var s = o.zeroHash = "\0\0\0\0\0\0\0\0";o.fromNumber = function (e) {if (0 === e) return i;var t = e < 0;t && (e = -e);var r = e >>> 0,n = (e - r) / 4294967296 >>> 0;return t && (n = ~n >>> 0, r = ~r >>> 0, ++r > 4294967295 && (r = 0, ++n > 4294967295 && (n = 0))), new o(r, n);}, o.from = function (e) {if ("number" == typeof e) return o.fromNumber(e);if (n.isString(e)) {if (!n.Long) return o.fromNumber(parseInt(e, 10));e = n.Long.fromString(e);}return e.low || e.high ? new o(e.low >>> 0, e.high >>> 0) : i;}, o.prototype.toNumber = function (e) {if (!e && this.hi >>> 31) {var t = 1 + ~this.lo >>> 0,r = ~this.hi >>> 0;return t || (r = r + 1 >>> 0), -(t + 4294967296 * r);}return this.lo + 4294967296 * this.hi;}, o.prototype.toLong = function (e) {return n.Long ? new n.Long(0 | this.lo, 0 | this.hi, Boolean(e)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e) };};var a = String.prototype.charCodeAt;o.fromHash = function (e) {return e === s ? i : new o((a.call(e, 0) | a.call(e, 1) << 8 | a.call(e, 2) << 16 | a.call(e, 3) << 24) >>> 0, (a.call(e, 4) | a.call(e, 5) << 8 | a.call(e, 6) << 16 | a.call(e, 7) << 24) >>> 0);}, o.prototype.toHash = function () {return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);}, o.prototype.zzEncode = function () {var e = this.hi >> 31;return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;}, o.prototype.zzDecode = function () {var e = -(1 & this.lo);return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;}, o.prototype.length = function () {var e = this.lo,t = (this.lo >>> 28 | this.hi << 4) >>> 0,r = this.hi >>> 24;return 0 === r ? 0 === t ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : r < 128 ? 9 : 10;};}, function (e, t, r) {"use strict";e.exports = s;var n = r(46);(s.prototype = Object.create(n.prototype)).constructor = s;var o = r(10),i = o.Buffer;function s() {n.call(this);}s.alloc = function (e) {return (s.alloc = o._Buffer_allocUnsafe)(e);};var a = i && i.prototype instanceof Uint8Array && "set" === i.prototype.set.name ? function (e, t, r) {t.set(e, r);} : function (e, t, r) {if (e.copy) e.copy(t, r, 0, e.length);else for (var n = 0; n < e.length;) {t[r++] = e[n++];}};function c(e, t, r) {e.length < 40 ? o.utf8.write(e, t, r) : t.utf8Write(e, r);}s.prototype.bytes = function (e) {o.isString(e) && (e = o._Buffer_from(e, "base64"));var t = e.length >>> 0;return this.uint32(t), t && this._push(a, t, e), this;}, s.prototype.string = function (e) {var t = i.byteLength(e);return this.uint32(t), t && this._push(c, t, e), this;};}, function (e, t, r) {"use strict";e.exports = i;var n = r(47);(i.prototype = Object.create(n.prototype)).constructor = i;var o = r(10);function i(e) {n.call(this, e);}o.Buffer && (i.prototype._slice = o.Buffer.prototype.slice), i.prototype.string = function () {var e = this.uint32();return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len));};}, function (e, t, r) {"use strict";e.exports = o;var n = r(10);function o(e, t, r) {if ("function" != typeof e) throw TypeError("rpcImpl must be a function");n.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(r);}(o.prototype = Object.create(n.EventEmitter.prototype)).constructor = o, o.prototype.rpcCall = function e(t, r, o, i, s) {if (!i) throw TypeError("request must be specified");var a = this;if (!s) return n.asPromise(e, a, t, r, o, i);if (a.rpcImpl) try {return a.rpcImpl(t, r[a.requestDelimited ? "encodeDelimited" : "encode"](i).finish(), function (e, r) {if (e) return a.emit("error", e, t), s(e);if (null !== r) {if (!(r instanceof o)) try {r = o[a.responseDelimited ? "decodeDelimited" : "decode"](r);} catch (e) {return a.emit("error", e, t), s(e);}return a.emit("data", r, t), s(null, r);}a.end(!0);});} catch (e) {return a.emit("error", e, t), void setTimeout(function () {s(e);}, 0);} else setTimeout(function () {s(Error("already ended"));}, 0);}, o.prototype.end = function (e) {return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;};}, function (e, t, r) {"use strict";function n(e, t) {"string" == typeof e && (t = e, e = void 0);var r = [];function o(e) {if ("string" != typeof e) {var t = i();if (n.verbose && console.log("codegen: " + t), t = "return " + t, e) {for (var s = Object.keys(e), a = new Array(s.length + 1), c = new Array(s.length), u = 0; u < s.length;) {a[u] = s[u], c[u] = e[s[u++]];}return a[u] = t, Function.apply(null, a).apply(null, c);}return Function(t)();}for (var l = new Array(arguments.length - 1), h = 0; h < l.length;) {l[h] = arguments[++h];}if (h = 0, e = e.replace(/%([%dfijs])/g, function (e, t) {var r = l[h++];switch (t) {case "d":case "f":return String(Number(r));case "i":return String(Math.floor(r));case "j":return JSON.stringify(r);case "s":return String(r);}return "%";}), h !== l.length) throw Error("parameter count mismatch");return r.push(e), o;}function i(n) {return "function " + (n || t || "") + "(" + (e && e.join(",") || "") + "){\n  " + r.join("\n  ") + "\n}";}return o.toString = i, o;}e.exports = n, n.verbose = !1;}, function (e, t, r) {"use strict";e.exports = i;var n = r(58),o = r(59)("fs");function i(e, t, r) {return "function" == typeof t ? (r = t, t = {}) : t || (t = {}), r ? !t.xhr && o && o.readFile ? o.readFile(e, function (n, o) {return n && "undefined" != typeof XMLHttpRequest ? i.xhr(e, t, r) : n ? r(n) : r(null, t.binary ? o : o.toString("utf8"));}) : i.xhr(e, t, r) : n(i, this, e, t);}i.xhr = function (e, t, r) {var n = new XMLHttpRequest();n.onreadystatechange = function () {if (4 === n.readyState) {if (0 !== n.status && 200 !== n.status) return r(Error("status " + n.status));if (t.binary) {var e = n.response;if (!e) {e = [];for (var o = 0; o < n.responseText.length; ++o) {e.push(255 & n.responseText.charCodeAt(o));}}return r(null, "undefined" != typeof Uint8Array ? new Uint8Array(e) : e);}return r(null, n.responseText);}}, t.binary && ("overrideMimeType" in n && n.overrideMimeType("text/plain; charset=x-user-defined"), n.responseType = "arraybuffer"), n.open("GET", e), n.send();};}, function (e, t, r) {"use strict";var n = t,o = n.isAbsolute = function (e) {return /^(?:\/|\w+:)/.test(e);},i = n.normalize = function (e) {var t = (e = e.replace(/\\/g, "/").replace(/\/{2,}/g, "/")).split("/"),r = o(e),n = "";r && (n = t.shift() + "/");for (var i = 0; i < t.length;) {".." === t[i] ? i > 0 && ".." !== t[i - 1] ? t.splice(--i, 2) : r ? t.splice(i, 1) : ++i : "." === t[i] ? t.splice(i, 1) : ++i;}return n + t.join("/");};n.resolve = function (e, t, r) {return r || (t = i(t)), o(t) ? t : (r || (e = i(e)), (e = e.replace(/(?:\/|^)[^/]+$/, "")).length ? i(e + "/" + t) : t);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.decomposeBCurveFlags = t.decomposeBCurveToBezier = t.decomposeBCurveControlPoints = void 0;var n = r(17),o = r(2),i = function i(e, t, r) {o.ConsoleUtils.assert(t.length % r == 0);var n,i,s,a = e.length - t.length / r - 1;o.ConsoleUtils.assert(a > 0);var c = e.length - 1,u = a,l = a + 1,h = 0,d = [],g = [];for (g[h] = new Array((a + 1) * r), n = 0; n <= a; ++n) {for (s = 0; s < r; ++s) {g[h][n * r + s] = t[n * r + s];}}for (; l < c;) {for (var p = 1; l < c && e[l + 1] === e[l];) {++l, ++p;}var f = l === c;if (f || (g[h + 1] = new Array((a + 1) * r)), p < a) {var v = e[l] - e[u];for (i = a; i > p; --i) {d[i - p - 1] = v / (e[u + i] - e[u]);}var _ = a - p;for (i = 1; i <= _; ++i) {for (var y = _ - i, m = p + i, E = a; E >= m; --E) {var x = d[E - m];for (s = 0; s < r; ++s) {g[h][E * r + s] = g[h][E * r + s] * x + g[h][(E - 1) * r + s] * (1 - x);}}if (!f) for (s = 0; s < r; ++s) {g[h + 1][y * r + s] = g[h][a * r + s];}}}if (f) break;for (++h, n = a - p; n <= a; ++n) {for (s = 0; s < r; ++s) {g[h][n * r + s] = t[(l - a + n) * r + s];}}u = l, ++l;}return g;};t.decomposeBCurveControlPoints = i, t.decomposeBCurveToBezier = function (e, t, r) {var s,a = r && r.length > 0;o.ConsoleUtils.assert(t.length > 0 && t.length % 3 == 0), o.ConsoleUtils.assert(!a || t.length === 3 * r.length);var c,u,l = e.length - t.length / 3 - 1;if (o.ConsoleUtils.assert(l > 0), a) {var h = (0, n.controlPointsToHomogeneous)(t, r);for (c = i(e, h, 4), u = [], s = 0; s < c.length; ++s) {var d = (0, n.controlPointsFromHomogeneous)(c[s]);c[s] = d.P, u[s] = d.w;}} else c = i(e, t, 3), u = void 0;var g = (0, n.getUniqueKnots)(e);o.ConsoleUtils.assert(g.length === c.length + 1);var p = new Array(g.length - 1);for (s = 0; s < p.length; ++s) {p[s] = new Array(2 * l + 2), p[s].fill(g[s], 0, l + 1), p[s].fill(g[s + 1], l + 1);}return { U: p, P: c, w: u };}, t.decomposeBCurveFlags = function (e, t) {var r,n = e.length - t.length - 1,o = new Array(t.length);o.fill(!1);var i = n - 1;for (r = 0; r < t.length; ++r) {if (t[r]) {var s = Math.max(r - i, 0),a = Math.min(r + i, o.length - 1);o.fill(!0, s, a + 1);}}var c = [],u = e.length - 1,l = n + 1,h = 0;for (c[h] = !1, r = 0; r <= n; ++r) {o[r] && (c[h] = !0);}for (; l < u;) {for (var d = 1; l < u && e[l + 1] === e[l];) {++l, ++d;}if (l === u) break;for (c[++h] = !1, r = n - d; r <= n; ++r) {o[l - n + r] && (c[h] = !0);}++l;}return c;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.extractBSurfaceParamLineV = t.extractBSurfaceParamLineU = t.insertBSurfaceKnotV = t.insertBSurfaceKnotU = void 0;var n = r(1),o = r(17),i = r(0),s = function s(e, t, r, o, i, _s, a) {var c,u,l = new Array(o);for (u = 0; u < o; ++u) {l[u] = new Array(i - u - r);var h = t - i + u + 1;for (c = 0; c < i - u - r; ++c) {l[u][c] = (e - _s[h + c]) / (_s[c + t + 1] - _s[h + c]);}}for (var d = a.length, g = new Array(d), p = new Array(i - r + 1), f = 0; f < d; ++f) {for (g[f] = new Array(i - r + o - 1), c = 0; c <= i - r; ++c) {p[c] = n.Vector4.clone(a[f][c]);}for (u = 0; u < o; ++u) {for (c = 0; c < i - u - r; ++c) {n.Vector4.lerp(p[c], p[c], p[c + 1], l[u][c]);}g[f][u] = n.Vector4.clone(p[0]), g[f][i + o - r - u - 2] = n.Vector4.clone(p[i - u - r - 1]);}for (c = o; c < i - r - 1; c++) {g[f][c] = n.Vector4.clone(p[c - o + 1]);}}return g;};t.insertBSurfaceKnotU = function (e, t, r, a, c, u, l, h) {t = Math.min(t, r);var d = h && h.length > 0,g = (0, o.findKnotSpanAndMultiplicity)(e, c);e = g.knot;var p = g.span,f = g.multiplicity,v = t - f;if (e < c[0] + i.PARAMETER_SPACE_TOLERANCE || e > c[c.length - 1] - i.PARAMETER_SPACE_TOLERANCE || f >= t) return { uknots: c.slice(), P: l.slice(), weights: d ? h.slice() : void 0 };var _,y,m = c.length - r - 1,E = u.length - a - 1,x = new Array(E),R = p - r,A = p - f;for (y = 0; y < E; ++y) {for (x[y] = new Array(A - R + 1), _ = R; _ <= A; ++_) {var P = _ * E + y,V = d ? h[P] : 1;x[y][_ - R] = n.Vector4.createFloat64FromValues(V * l[3 * P], V * l[3 * P + 1], V * l[3 * P + 2], V);}}var T = s(e, p, f, v, r, c, x),C = c.slice(0, p + 1);for (_ = 0; _ < v; ++_) {C.push(e);}C = C.concat(c.slice(p + 1));var b,L = new Array(3 * (m + v) * E),O = new Array((m + v) * E);for (y = 0; y < E; ++y) {for (_ = 0; _ <= R; ++_) {P = b = _ * E + y, L[3 * b] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}for (_ = 0; _ < T[y].length; ++_) {b = (_ + R + 1) * E + y;var S = T[y][_];L[3 * b] = S[0] / S[3], L[3 * b + 1] = S[1] / S[3], L[3 * b + 2] = S[2] / S[3], O[b] = S[3];}for (_ = A; _ < m; ++_) {P = _ * E + y, L[3 * (b = (_ + v) * E + y)] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}}return { uknots: C, P: L, weights: d ? O : void 0 };}, t.insertBSurfaceKnotV = function (e, t, r, a, c, u, l, h) {t = Math.min(t, a);var d = h && h.length > 0,g = (0, o.findKnotSpanAndMultiplicity)(e, u);e = g.knot;var p = g.span,f = g.multiplicity,v = t - f;if (e < u[0] + i.PARAMETER_SPACE_TOLERANCE || e > u[u.length - 1] - i.PARAMETER_SPACE_TOLERANCE || f >= t) return { vknots: u.slice(), P: l.slice(), weights: d ? h.slice() : void 0 };var _,y,m = c.length - r - 1,E = u.length - a - 1,x = new Array(m),R = p - a,A = p - f;for (_ = 0; _ < m; ++_) {for (x[_] = new Array(A - R + 1), y = R; y <= A; ++y) {var P = _ * E + y,V = d ? h[P] : 1;x[_][y - R] = n.Vector4.createFloat64FromValues(V * l[3 * P], V * l[3 * P + 1], V * l[3 * P + 2], V);}}var T = s(e, p, f, v, a, u, x),C = u.slice(0, p + 1);for (y = 0; y < v; ++y) {C.push(e);}C = C.concat(u.slice(p + 1));var b,L = new Array(3 * m * (E + v)),O = new Array(m * (E + v));for (_ = 0; _ < m; ++_) {for (y = 0; y <= R; ++y) {P = _ * E + y, L[3 * (b = _ * (E + v) + y)] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}for (y = 0; y < T[_].length; ++y) {b = _ * (E + v) + (y + R + 1);var S = T[_][y];L[3 * b] = S[0] / S[3], L[3 * b + 1] = S[1] / S[3], L[3 * b + 2] = S[2] / S[3], O[b] = S[3];}for (y = A; y < E; ++y) {P = _ * E + y, L[3 * (b = _ * (E + v) + (y + v))] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}}return { vknots: C, P: L, weights: d ? O : void 0 };}, t.extractBSurfaceParamLineU = function (e, t, r, i, a, c, u) {var l = u && u.length > 0,h = (0, o.findKnotSpanAndMultiplicity)(e, a);e = h.knot;var d,g,p,f = h.span,v = e === a[a.length - 1],_ = v ? r + 1 : h.multiplicity,y = r - _,m = i.length - t - 1,E = a.length - r - 1,x = new Array(3 * m),R = new Array(m);if (_ >= r) for (g = v ? E - 1 : f - r, d = 0; d < m; ++d) {p = d * E + g, x[3 * d] = c[3 * p], x[3 * d + 1] = c[3 * p + 1], x[3 * d + 2] = c[3 * p + 2], R[d] = l ? u[p] : 1;} else {var A = new Array(m),P = f - r,V = f - _;for (d = 0; d < m; ++d) {for (A[d] = new Array(V - P + 1), g = P; g <= V; ++g) {p = d * E + g;var T = l ? u[p] : 1;A[d][g - P] = n.Vector4.createFloat64FromValues(T * c[3 * p], T * c[3 * p + 1], T * c[3 * p + 2], T);}}var C = s(e, f, _, y, r, a, A);for (g = y - 1, d = 0; d < m; ++d) {var b = C[d][g];x[3 * d] = b[0] / b[3], x[3 * d + 1] = b[1] / b[3], x[3 * d + 2] = b[2] / b[3], R[d] = b[3];}}return { ctrlPts: x, weights: l ? R : void 0 };}, t.extractBSurfaceParamLineV = function (e, t, r, i, a, c, u) {var l = u && u.length > 0,h = (0, o.findKnotSpanAndMultiplicity)(e, i);e = h.knot;var d,g,p,f = h.span,v = e === i[i.length - 1],_ = v ? t + 1 : h.multiplicity,y = t - _,m = i.length - t - 1,E = a.length - r - 1,x = new Array(3 * E),R = new Array(E);if (_ >= t) for (d = v ? m - 1 : f - t, g = 0; g < E; ++g) {p = d * E + g, x[3 * g] = c[3 * p], x[3 * g + 1] = c[3 * p + 1], x[3 * g + 2] = c[3 * p + 2], R[g] = l ? u[p] : 1;} else {var A = new Array(E),P = f - t,V = f - _;for (g = 0; g < E; ++g) {for (A[g] = new Array(V - P + 1), d = P; d <= V; ++d) {p = d * E + g;var T = l ? u[p] : 1;A[g][d - P] = n.Vector4.createFloat64FromValues(T * c[3 * p], T * c[3 * p + 1], T * c[3 * p + 2], T);}}var C = s(e, f, _, y, t, i, A);for (d = y - 1, g = 0; g < E; ++g) {var b = C[g][d];x[3 * g] = b[0] / b[3], x[3 * g + 1] = b[1] / b[3], x[3 * g + 2] = b[2] / b[3], R[g] = b[3];}}return { ctrlPts: x, weights: l ? R : void 0 };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.decomposeBSurfaceToBezier = t.decomposeBSurfaceControlPoints = t.decomposeBSurfaceControlPointsV = t.decomposeBSurfaceControlPointsU = void 0;var n = r(17),o = r(2),i = function i(e, t, r, n) {o.ConsoleUtils.assert(r.length % n == 0);var i = t.length - e - 1;o.ConsoleUtils.assert(r.length / n % i == 0);var s,a,c,u,l = r.length / (n * i),h = e + 1,d = l,g = t.length - 1,p = e,f = e + 1,v = 0,_ = [],y = [];for (y[v] = new Array(h * d * n), s = 0; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s * d + c) * n + u] = r[(s * l + c) * n + u];}}}for (; f < g;) {for (var m = 1; f < g && t[f + 1] === t[f];) {++f, ++m;}var E = f === g;if (E || (y[v + 1] = new Array(h * d * n)), m < e) {var x = t[f] - t[p];for (a = e; a > m; --a) {_[a - m - 1] = x / (t[p + a] - t[p]);}var R = e - m;for (a = 1; a <= R; ++a) {for (var A = R - a, P = m + a, V = e; V >= P; --V) {var T = _[V - P];for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(V * d + c) * n + u] = y[v][(V * d + c) * n + u] * T + y[v][((V - 1) * d + c) * n + u] * (1 - T);}}}if (!E) for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v + 1][(A * d + c) * n + u] = y[v][(e * d + c) * n + u];}}}}if (E) break;for (++v, s = e - m; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s * d + c) * n + u] = r[((f - e + s) * l + c) * n + u];}}}p = f, ++f;}return y;},s = function s(e, t, r, n) {o.ConsoleUtils.assert(r.length % n == 0);var i = t.length - e - 1;o.ConsoleUtils.assert(r.length / n % i == 0);var s,a,c,u,l = r.length / (n * i),h = l,d = e + 1,g = t.length - 1,p = e,f = e + 1,v = 0,_ = [],y = [];for (y[v] = new Array(h * d * n), s = 0; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s + c * d) * n + u] = r[(s + c * i) * n + u];}}}for (; f < g;) {for (var m = 1; f < g && t[f + 1] === t[f];) {++f, ++m;}var E = f === g;if (E || (y[v + 1] = new Array(h * d * n)), m < e) {var x = t[f] - t[p];for (a = e; a > m; --a) {_[a - m - 1] = x / (t[p + a] - t[p]);}var R = e - m;for (a = 1; a <= R; ++a) {for (var A = R - a, P = m + a, V = e; V >= P; --V) {var T = _[V - P];for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(V + c * d) * n + u] = y[v][(V + c * d) * n + u] * T + y[v][(V - 1 + c * d) * n + u] * (1 - T);}}}if (!E) for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v + 1][(A + c * d) * n + u] = y[v][(e + c * d) * n + u];}}}}if (E) break;for (++v, s = e - m; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s + c * d) * n + u] = r[(f - e + s + c * i) * n + u];}}}p = f, ++f;}return y;},a = function a(e, t, r, n, _a, c) {o.ConsoleUtils.assert(_a.length % c == 0), o.ConsoleUtils.assert(_a.length / c == (r.length - e - 1) * (n.length - t - 1));var u,l = r.length > 2 * e + 2,h = n.length > 2 * t + 2;if (!l && !h) return [[_a.slice()]];u = l ? i(e, r, _a, c) : [_a];for (var d = 0; d < u.length; ++d) {u[d] = h ? s(t, n, u[d], c) : [u[d]];}return u;};t.decomposeBSurfaceControlPointsU = i, t.decomposeBSurfaceControlPointsV = s, t.decomposeBSurfaceControlPoints = a, t.decomposeBSurfaceToBezier = function (e, t, r, i, s, c) {var u,l,h,d,g = c && c.length > 0;if (o.ConsoleUtils.assert(s.length > 0 && s.length % 3 == 0), o.ConsoleUtils.assert(!g || s.length === 3 * c.length), g) {var p = (0, n.controlPointsToHomogeneous)(s, c);for (h = a(e, t, r, i, p, 4), d = [], u = 0; u < h.length; ++u) {for (d[u] = [], l = 0; l < h[u].length; ++l) {var f = (0, n.controlPointsFromHomogeneous)(h[u][l]);h[u][l] = f.P, d[u][l] = f.w;}}} else h = a(e, t, r, i, s, 3), d = void 0;var v = (0, n.getUniqueKnots)(r);o.ConsoleUtils.assert(v.length === h.length + 1);var _ = new Array(v.length - 1);for (u = 0; u < _.length; ++u) {_[u] = new Array(2 * e + 2), _[u].fill(v[u], 0, e + 1), _[u].fill(v[u + 1], e + 1);}var y = (0, n.getUniqueKnots)(i);o.ConsoleUtils.assert(y.length === h[0].length + 1);var m = new Array(y.length - 1);for (u = 0; u < m.length; ++u) {m[u] = new Array(2 * t + 2), m[u].fill(y[u], 0, t + 1), m[u].fill(y[u + 1], t + 1);}return { U: _, V: m, P: h, w: d };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.closestBSurfacePointApprox = t.closestBSurfacePatches = void 0;var n = r(1),o = r(3),i = r(73),s = r(76);t.closestBSurfacePatches = function (e, t, r) {for (var o = Number.POSITIVE_INFINITY, s = [], a = 0; a < t.length; ++a) {for (var c = 0; c < t[a].length; ++c) {var u,l = t[a][c],h = l.getRangeUnlimitedU(),d = l.getRangeUnlimitedV();if (r) {u = !1;for (var g = 0; g < r.length; ++g) {if (h[1] >= r[g][0][0] + n.FLOAT64_TOLERANCE && h[0] <= r[g][0][1] - n.FLOAT64_TOLERANCE && d[1] >= r[g][1][0] + n.FLOAT64_TOLERANCE && d[0] <= r[g][1][1] - n.FLOAT64_TOLERANCE) {u = !0;break;}}} else u = !0;if (u) {var p = l.getControlPoints(),f = (0, i.minDistanceSqrToHull)(e, p, !0);if (f <= o) {var v = (0, i.maxDistanceSqrToHull)(e, p);s.push({ index: [a, c], minDistSqr: f, maxDistSqr: v }), v < o && (o = v);}}}}return (s = s.filter(function (e) {return e.minDistSqr <= o;})).sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), s;}, t.closestBSurfacePointApprox = function (e, t, r, i, a, c, u, l, h) {var d = t > 1 ? 2 * t : 1,g = r > 1 ? 2 * r : 1,p = (l[1] - l[0]) / (i[i.length - 1] - i[0]),f = (h[1] - h[0]) / (a[a.length - 1] - a[0]);d = Math.max(1, Math.round(d * p)), g = Math.max(1, Math.round(g * f));for (var v = (l[1] - l[0]) / d, _ = (h[1] - h[0]) / g, y = Number.POSITIVE_INFINITY, m = { u: void 0, v: void 0 }, E = void 0, x = n.Vector3.createFloat64(), R = 0; R <= g; ++R) {for (var A = h[0] + R * _, P = [], V = 0; V <= d; ++V) {var T,C,b = l[0] + V * v;P[V] = (0, s.evaluateBSurfacePoint)(b, A, t, r, i, a, c, u), V > 0 && R > 0 && (T = (0, o.closestPointToTriangle)(e, E[V - 1], E[V], P[V - 1], x), (C = n.Vector3.squaredDistance(e, x)) < y && (y = C, m.u = b + v * (T.coordA - 1), m.v = A + _ * (T.coordB - 1)), T = (0, o.closestPointToTriangle)(e, P[V], P[V - 1], E[V], x), (C = n.Vector3.squaredDistance(e, x)) < y && (y = C, m.u = b - v * T.coordA, m.v = A - _ * T.coordB));}E = P;}return m;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.checkValidity = void 0;var n = r(1),o = r(0),i = r(32),s = r(6),a = r(12),c = r(19);function u(e) {var t = [],r = e.getGuid();return r && "string" == typeof r || t.push({ error: "BaseTopology has invalid GUID", source: [e] }), t;}function l(e) {var t = u(e),r = 0,n = 0,i = 0,s = e.getLumps();if (s.length > 0) {for (var a = new Set(), c = 0; c < s.length; ++c) {var l = s[c];a.add(l), l && l.getTopologyType() === o.TOPOLOGY_TYPES.LUMP ? l.getBody() !== e && t.push({ error: "Body is not the parent of child Lump", source: [e, l] }) : t.push({ error: "Body has invalid element in Lump array", source: [e, l] }), r += l.collectFaces().size, n += l.collectEdges().size, i += l.collectVertices().size;}a.size !== s.length && t.push({ error: "Body has non-unique Lumps", source: [e] });}return r !== e.collectFaces().size && t.push({ error: "Body has Lumps which share Faces", source: [e] }), n !== e.collectEdges().size && t.push({ error: "Body has Lumps which share Edges", source: [e] }), i !== e.collectVertices().size && t.push({ error: "Body has Lumps which share Vertices", source: [e] }), t;}function h(e) {var t = u(e),r = e.getBody();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.BODY && t.push({ error: "Lump has invalid parent Body", source: [e] });var n = 0,i = 0,s = 0,a = e.getShells();if (a.length > 0) {for (var c = new Set(), l = 0; l < a.length; ++l) {var h = a[l];c.add(h), h && h.getTopologyType() === o.TOPOLOGY_TYPES.SHELL ? h.getLump() !== e && t.push({ error: "Lump is not the parent of child Shell", source: [e, h] }) : t.push({ error: "Lump has invalid element in Shell array", source: [e, h] }), n += h.collectFaces().size, i += h.collectEdges().size, s += h.collectVertices().size;}c.size !== a.length && t.push({ error: "Lump has non-unique Shells", source: [e] });} else t.push({ error: "Lump has no Shells", source: [e] });return n !== e.collectFaces().size && t.push({ error: "Lump has Shells which share Faces", source: [e] }), i !== e.collectEdges().size && t.push({ error: "Lump has Shells which share Edges", source: [e] }), s !== e.collectVertices().size && t.push({ error: "Lump has Shells which share Vertices", source: [e] }), t;}function d(e) {var t = u(e),r = e.getLump();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.LUMP && t.push({ error: "Shell has invalid parent Lump", source: [e] });var n = e.getFaces();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.FACE ? a.getShell() !== e && t.push({ error: "Shell is not the parent of child Face", source: [e, a] }) : t.push({ error: "Shell has invalid element in Face array", source: [e, a] });}i.size !== n.length && t.push({ error: "Shell has non-unique Faces", source: [e] });} else t.push({ error: "Shell has no Faces", source: [e] });1 !== (0, c.findConnectedFaces)(e.getFaces()).length && t.push({ error: "Shell is disconnected", source: [e] });var l = e.collectVertices(),h = e.collectEdges(),d = new Set(),g = new Set();return l.forEach(function (e) {e.collectEdges(d), e.collectFaces(g);}), d.size !== h.size && t.push({ error: "Shell has rogue edges", source: [e] }), l.size > 0 && g.size !== e.getFaces().length && t.push({ error: "Shell has rogue faces", source: [e] }), t;}function g(e) {var t = u(e),r = e.getShell();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.SHELL && t.push({ error: "Face has invalid parent Shell", source: [e] });var n = 0,i = 0,s = e.getLoops(),c = e.getSurface();if (s.length > 0) {for (var l = new Set(), h = 0; h < s.length; ++h) {var d = s[h];l.add(d), d && d.getTopologyType() === o.TOPOLOGY_TYPES.LOOP ? d.getFace() !== e && t.push({ error: "Face is not the parent of child Loop", source: [e, d] }) : t.push({ error: "Face has invalid element in Loop array", source: [e, d] }), n += d.collectEdges().size, i += d.collectVertices().size;}l.size !== s.length && t.push({ error: "Face has non-unique Loops", source: [e] });} else {var g = c.getGeometryType() === o.GEOMETRY_TYPES.SPHERE,p = c.getGeometryType() === o.GEOMETRY_TYPES.TORUS && c.isDoughnut();g || p || t.push({ error: "Face has no Loops", source: [e] });}return n !== e.collectEdges().size && t.push({ error: "Face has Loops which share Edges", source: [e] }), i !== e.collectVertices().size && t.push({ error: "Face has Loops which share Vertices", source: [e] }), c ? c instanceof a.Surface || t.push({ error: "Face has invalid Surface geometry", source: [e, c] }) : t.push({ error: "Face has no Surface geometry", source: [e] }), t;}function p(e) {var t = u(e),r = e.getFace();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.FACE && t.push({ error: "Loop has invalid parent Face", source: [e] });var n = e.getCoedges();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];if (i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.COEDGE) {a.getLoop() !== e && t.push({ error: "Loop is not the parent of child Coedge", source: [e, a] });var c = n[(s + 1) % n.length];a.getEndVertex() !== c.getStartVertex() && t.push({ error: "Loop has disconnected Coedges", source: [e, a, c] });} else t.push({ error: "Loop has invalid element in Coedge array", source: [e, a] });}i.size !== n.length && t.push({ error: "Loop has non-unique Coedges", source: [e] });} else t.push({ error: "Loop has no Coedges", source: [e] });return t;}function f(e) {var t = u(e),r = e.getLoop();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.LOOP && t.push({ error: "Coedge has invalid parent Loop", source: [e] });var n = e.getBody(),i = new Set(),s = e;do {if (i.has(s)) {t.push({ error: "Coedge partner list does not form a loop", source: [e] });break;}if (i.add(s), !s.getPartner()) {s !== e && t.push({ error: "Coedge has no partner", source: [e, s] });break;}if ((s = s.getPartner()).getTopologyType() !== o.TOPOLOGY_TYPES.COEDGE) {t.push({ error: "Coedge has invalid entry in partner list", source: [e, s] });break;}s.getEdge() !== e.getEdge() && t.push({ error: "Coedge partner refers to a different Edge", source: [e, s] }), s.getBody() !== n && t.push({ error: "Coedge partner is part of a different Body", source: [e, s] });} while (s !== e);var a = e.getEdge();return a ? a.getTopologyType() !== o.TOPOLOGY_TYPES.EDGE ? t.push({ error: "Coedge has invalid Edge", source: [e, a] }) : (s = a.getCoedge()) && i.has(s) || t.push({ error: "Coedge partner list does not include parent of Edge", source: [e, a] }) : t.push({ error: "Coedge has no Edge", source: [e] }), t;}function v(e) {var t = u(e),r = e.getCoedge(),s = e.getWire();s && r ? t.push({ error: "Edge has too many parents, both Wire and Coedge", source: [e] }) : s ? s.getTopologyType() !== o.TOPOLOGY_TYPES.WIRE && t.push({ error: "Edge has invalid parent Wire", source: [e] }) : r && r.getTopologyType() !== o.TOPOLOGY_TYPES.COEDGE && t.push({ error: "Edge has invalid parent Coedge", source: [e] });for (var a = e.getVertices(), c = 0; c < a.length; ++c) {var l = a[c];l && l.getTopologyType() === o.TOPOLOGY_TYPES.VERTEX ? l.isAdjacentEdge(e) || t.push({ error: "Edge is not adjacent to own Vertex", source: [e, l] }) : t.push({ error: "Edge has invalid Vertex", source: [e, l] });}var h = e.getCurve();return h ? h instanceof i.Curve ? t = t.concat(function (e, t) {var r = [],i = e.isReversed(),s = e.getRange();if (void 0 === s || 2 !== s.length || void 0 === s[0] || void 0 === s[1] || s[1] < s[0]) return r.push({ error: "Edge range is not defined", source: [e, s] }), r;var a = e.getStartVertex(),c = i ? -e.t0() : e.t0(),u = t.evaluatePosition(c),l = Math.max(o.KERNEL_TOLERANCE, a.getPrecision());n.Vector3.equals(a.getPosition(), u, l) || r.push({ error: "Edge start position not consistent with Vertex", source: [e, a, u] });var h = e.getEndVertex(),d = i ? -e.t1() : e.t1(),g = t.evaluatePosition(d),p = Math.max(o.KERNEL_TOLERANCE, h.getPrecision());return n.Vector3.equals(h.getPosition(), g, p) || r.push({ error: "Edge end position not consistent with Vertex", source: [e, h, g] }), e.isClosed() ? (a !== h && r.push({ error: "Edge is closed but has different start and end Vertices", source: [e] }), n.Vector3.equals(u, g, o.KERNEL_TOLERANCE) || r.push({ error: "Edge is closed but has different start and end positions", source: [e, u, g] }), t.isClosed() || r.push({ error: "Edge is closed but its curve is not", source: [e] })) : (a === h && r.push({ error: "Edge is open but has same start and end Vertices", source: [e] }), n.Vector3.equals(u, g, o.KERNEL_TOLERANCE) && r.push({ error: "Edge is open but has same start and end positions", source: [e, u, g] })), t.isPeriodic() ? Math.abs(d - c) > t.getPeriod() + o.PARAMETER_SPACE_TOLERANCE && r.push({ error: "Edge parameter range is longer than curve period", source: [e] }) : ((c + o.PARAMETER_SPACE_TOLERANCE < t.getRange()[0] || c - o.PARAMETER_SPACE_TOLERANCE > t.getRange()[1]) && r.push({ error: "Edge start parameter is outside of curve range", source: [e] }), (d + o.PARAMETER_SPACE_TOLERANCE < t.getRange()[0] || d - o.PARAMETER_SPACE_TOLERANCE > t.getRange()[1]) && r.push({ error: "Edge end parameter is outside of curve range", source: [e] })), r;}(e, h)) : t.push({ error: "Edge has invalid Curve geometry", source: [e, h] }) : t = t.concat(function (e) {if (e.getWire()) return [{ error: "Degenerate Edge is part of a Wire", source: [e] }];if (e.getStartVertex() !== e.getEndVertex()) return [{ error: "Degenerate Edge has different start and end vertices", source: [e] }];var t = Array.from(e.collectFaces());if (0 === t.length) return [];if (1 !== t.length) return [{ error: "Degenerate Edge is part of multiple Faces", source: [e] }];var r = e.getStartVertex().getPosition(),i = t[0].getSurface(),s = i.getGeometryType();if (s === o.GEOMETRY_TYPES.PLANE || s === o.GEOMETRY_TYPES.CYLINDER || s === o.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER || s === o.GEOMETRY_TYPES.SPHERE) return [{ error: "Degenerate Edge is on a surface with no singularities", source: [e, i] }];if (s === o.GEOMETRY_TYPES.CONE || s === o.GEOMETRY_TYPES.ELLIPTICAL_CONE) {if (!(l = i.getApexPosition())) return [{ error: "Degenerate Edge is on a surface with no singularities", source: [e, i] }];if (!n.Vector3.equals(r, l, o.KERNEL_TOLERANCE)) return [{ error: "Degenerate Edge is not at a surface singularity", source: [e, i] }];} else {if (s !== o.GEOMETRY_TYPES.TORUS) return [{ error: "Degenerate Edge is not on an analytic surface", source: [e] }];for (var a = !1, c = i.getSingularUParams(), u = 0; u < c.length; ++u) {var l = i.evaluatePosition(c[u], 0);n.Vector3.equals(r, l, o.KERNEL_TOLERANCE) && (a = !0);}if (!a) return [{ error: "Degenerate Edge is not at a surface singularity", source: [e, i] }];}return [];}(e)), t;}function _(e) {var t = u(e),r = e.getEdges();if (r.length > 0) for (var n = e.getBody(), i = 0; i < r.length; ++i) {var a = r[i];a && a.getTopologyType() === o.TOPOLOGY_TYPES.EDGE ? a.getStartVertex() !== e && a.getEndVertex() !== e ? t.push({ error: "Vertex is not an end-point of adjacent Edge", source: [e, a] }) : a.getBody() !== n && t.push({ error: "Vertex has adjacent Edge from a different body", source: [e, a] }) : t.push({ error: "Vertex has invalid entry in Edge list", source: [e, a] });} else t.push({ error: "Vertex has no adjacent Edges", source: [e] });var c = e.getPoint();return c ? c instanceof s.Point || t.push({ error: "Vertex has invalid Point geometry", source: [e, c] }) : t.push({ error: "Vertex has no Point geometry", source: [e] }), t;}function y(e) {var t = u(e),r = 0,n = 0,i = e.getWires();if (i.length > 0) {for (var s = new Set(), a = 0; a < i.length; ++a) {var c = i[a];s.add(c), c && c.getTopologyType() === o.TOPOLOGY_TYPES.WIRE ? c.getWireBody() !== e && t.push({ error: "WireBody is not the parent of child Wire", source: [e, c] }) : t.push({ error: "WireBody has invalid element in Wire array", source: [e, c] }), r += c.collectEdges().size, n += c.collectVertices().size;}s.size !== i.length && t.push({ error: "WireBody has non-unique Wires", source: [e] });} else t.push({ error: "WireBody has no Wires", source: [e] });return r !== e.collectEdges().size && t.push({ error: "WireBody has Wires which share Edges", source: [e] }), n !== e.collectVertices().size && t.push({ error: "WireBody has Wires which share Vertices", source: [e] }), t;}function m(e) {var t = u(e),r = e.getWireBody();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.WIREBODY && t.push({ error: "Wire has invalid parent WireBody", source: [e] });var n = e.getEdges();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.EDGE ? a.getWire() !== e && t.push({ error: "Wire is not the parent of child Edge", source: [e, a] }) : t.push({ error: "Wire has invalid element in Edge array", source: [e, a] });}i.size !== n.length && t.push({ error: "Wire has non-unique Edges", source: [e] });var l = (0, c.findConnectedEdges)(n);1 !== l.length ? t.push({ error: "Wire is not a connected set of Edges", source: [e] }) : l[0].length !== n.length && t.push({ error: "Wire is connected to other unknown Edges", source: [e] });} else t.push({ error: "Wire has no Edges", source: [e] });return t;}t.checkValidity = function (e) {for (var t, r, n, i = [], s = [e], a = new Set(), c = new Map(); s.length > 0;) {a.clear();var u = new Set();for (t = 0; t < s.length; ++t) {switch ((r = s[t]).getTopologyType()) {case o.TOPOLOGY_TYPES.BODY:i = i.concat(l(r)), r.getLumps().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.LUMP:i = i.concat(h(r)), r.getShells().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.SHELL:i = i.concat(d(r)), r.getFaces().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.FACE:i = i.concat(g(r)), r.getLoops().forEach(function (e) {a.add(e);}), r.getSurface() && u.add(r.getSurface());break;case o.TOPOLOGY_TYPES.LOOP:i = i.concat(p(r)), r.getCoedges().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.COEDGE:i = i.concat(f(r)), a.add(r.getEdge());break;case o.TOPOLOGY_TYPES.EDGE:i = i.concat(v(r)), r.getVertices().forEach(function (e) {e && a.add(e);}), r.getCurve() && u.add(r.getCurve());break;case o.TOPOLOGY_TYPES.VERTEX:i = i.concat(_(r)), r.getPoint() && u.add(r.getPoint());break;case o.TOPOLOGY_TYPES.WIREBODY:i = i.concat(y(r)), r.getWires().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.WIRE:i = i.concat(m(r)), r.getEdges().forEach(function (e) {a.add(e);});}n = r.getGuid(), c.has(n) ? i.push({ error: "Objects have clashing GUIDs", source: [r, c.get(n)] }) : c.set(n, r);}for (u = Array.from(u), t = 0; t < u.length; ++t) {n = (r = u[t]).getGuid(), c.has(n) ? i.push({ error: "Objects have clashing GUIDs", source: [r, c.get(n)] }) : c.set(n, r);}s = Array.from(a);}return i;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.facetPlanarFace = void 0;var n = r(1),o = r(0),i = r(108),s = r(3),a = r(109),c = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),u = r(8),l = 1e-8,h = o.KERNEL_TOLERANCE,d = function d(e, t, r) {var o,i = e[(0, s.modulus)(t - 1, e.length)],a = e[(0, s.modulus)(t + 1, e.length)],c = e[t],u = c[0] - i[0],l = c[1] - i[1],d = a[0] - c[0],g = a[1] - c[1],p = Math.sqrt(u * u + l * l),f = Math.sqrt(d * d + g * g);u * d + l * g < -.95 * p * f ? (u *= -1, l *= -1) : r ? (o = u, u = -l, l = o, o = d, d = -g, g = o) : (o = u, u = l, l = -o, o = d, d = g, g = -o);var v = .5 * (u / p + d / f),_ = .5 * (l / p + g / f),y = Math.sqrt(v * v + _ * _);e[t] = n.Vector3.clone(c), e[t][0] += h * v / y, e[t][1] += h * _ / y;},g = function g(e) {return String(e[0]) + String(e[1]);},p = function p(e) {for (var t = !1, r = {}, n = 0; n < e.length; n++) {var o = g(e[n]);void 0 === r[o] ? r[o] = [] : t = !0, r[o].push(n);}return { table: r, foundSelfIntersection: t };},f = function f(e) {var t = p(e);if (t.foundSelfIntersection) {for (var r = (0, i.isLoopCCW)(e), n = [], o = 0; o < e.length - 1; o++) {n[o] = !1;}var a = [];for (o = 0; o < e.length - 1; o++) {if (!n[o]) {var c = [],u = o;n[u] = !0, c.push(e[u]);var l = g(c[0]),h = e[(0, s.modulus)(u + 1, e.length)],f = g(h),v = [];for (t.table[l].length > 1 && v.push(0); f !== l;) {if (c.push(h), c.length > e.length) throw new Error("splitHole failure");var _ = t.table[f];if (1 === _.length) u++;else {v.push(c.length - 1);for (var y = [], m = 0; m < _.length; m++) {_[m] !== u && y.push(_[m]);}var E = Math.atan2(e[u + 1][1] - e[u][1], e[u + 1][0] - e[u][0]);E = (0, s.normalizeParameterToShiftedRange)(E - Math.PI, [-Math.PI, Math.PI]);var x = -1,R = 0;for (m = 0; m < y.length; m++) {var A = Math.atan2(e[(0, s.modulus)(y[m] + 1, e.length)][1] - e[y[m]][1], e[(0, s.modulus)(y[m] + 1, e.length)][0] - e[y[m]][0]);A < E && r ? A += s.PI2 : A > E && !r && (A -= s.PI2);var P = Math.abs(A - E);P > R && (R = P, x = y[m]);}u = x;}h = e[(0, s.modulus)(u + 1, e.length)], f = g(h), n[u] = !0;}for (m = 0; m < v.length; m++) {d(c, v[m], r);}a.push(c);}}return a;}return [e];},v = function v(e, t) {for (var r = [], n = 0; n < e.length; n++) {r[n] = { index: void 0, loop: void 0 };for (var o = e[n], i = 0; i < t.length; i++) {for (var s = t[i], a = 0; a < s.length; a++) {if (s[a][0] === o[0] && s[a][1] === o[1]) {r[n].index = a, r[n].loop = s;break;}}}}return r;};function _(e, t) {var r,n = !1,o = t.length,i = o - 1;for (r = 0; r < o; r += 2) {t[r][1] > e[1] != t[i][1] > e[1] && e[0] < (t[i][0] - t[r][0]) * (e[1] - t[r][1]) / (t[i][1] - t[r][1]) + t[r][0] && (n = !n), i = r;}return n;}function y(e, t, r) {for (var o, s, a = v(e, [t].concat(r)), c = [], h = [], d = void 0, g = void 0, p = 0; p < 4; ++p) {a[p] && void 0 !== a[p].index && (d ? g || a[p].loop === d || (g = a[p].loop) : d = a[p].loop, a[p].loop === d ? (o = d, s = c) : (o = g, s = h), (P = [a[p].index - 1, a[p].index])[0] < 0 && (P[0] = o.length - 1), s.push(P), s.push([a[p].index, (a[p].index + 1) % o.length]));}g || (g = d, h = c);var f,y,m = void 0,E = d,x = c;for (p = 0; p < 3; ++p) {for (f = 0; f < c.length; ++f) {for (y = 0; y < h.length && (c === h && y >= f || !(m = (0, i.intersectSegments)(d[c[f][0]], d[c[f][1]], g[h[y][0]], g[h[y][1]], 0)) || !m.intersection); ++y) {;}if (m && m.intersection) break;}if (m && m.intersection || d === g) break;0 === p ? (d = g, c = h) : 1 === p && (d = E, c = x, g = E, h = x);}if (void 0 !== m && m.intersection) {var R = n.Vector3.subtract(n.Vector3.createFloat64(), d[c[f][1]], d[c[f][0]]);n.Vector3.scale(R, R, m.solutions[0]);var A = n.Vector3.add(R, R, d[c[f][0]]);if (c[f][0] > c[f][1]) {var P = c[f][1];c[f][1] = c[f][0], c[f][0] = P;}if (0 === c[f][0] && 1 !== c[f][1] && (c[f][0] = c[f][1], c[f][1] = 0), h[y][0] > h[y][1] && 0 !== h[y][1] && (P = h[y][1], h[y][1] = h[y][0], h[y][0] = P), 0 === h[y][0] && 1 !== h[y][1] && (h[y][0] = h[y][1], h[y][1] = 0), d === g) {if (d.length < 4) return void console.error("REGION: Failed to fix loop tessellation! [loop too short]");console.log("REGION: Fixing self-intersection");var V = new Array(4);c[f][0] < h[y][0] ? (V[0] = c[f][0], V[1] = c[f][1], V[2] = h[y][0], V[3] = h[y][1]) : (V[0] = h[y][0], V[1] = h[y][1], V[2] = c[f][0], V[3] = c[f][1]);var T = [];for (p = 0; p <= V[0]; ++p) {T.push(d[p]);}var C = n.Vector3.subtract(n.Vector3.createFloat64(), d[V[0]], d[V[1]]);n.Vector3.normalize(C, C), n.Vector3.scale(C, C, l);var b = n.Vector3.add(n.Vector3.createFloat64(), A, C);for (T.push(b), p = V[2]; p >= V[1]; --p) {T.push(d[p]);}var L = n.Vector3.subtract(n.Vector3.createFloat64(), A, C);if (T.push(L), V[3] > V[2]) for (p = V[3]; p < d.length; ++p) {T.push(d[p]);}for (d.length = T.length, p = 0; p < T.length; ++p) {d[p] = T[p];}} else {console.log("REGION: Fixing loop-loop intersection");var O = d,S = g,M = h[y][0],w = h[y][1],N = c[f][0],F = c[f][1];(t === S || S.length > O.length && t !== O) && (O = g, S = d, M = c[f][0], w = c[f][1], N = h[y][0], F = h[y][1]);var I = 1;t !== S && t !== O && (I = -1);var D = 1;_(S[w], O) && (D = -1, P = M, M = w, w = P), n.Vector3.subtract(S[w], S[M], S[w]), n.Vector3.normalize(S[w], S[w]), n.Vector3.scale(S[w], S[w], I * l), n.Vector3.add(S[w], A, S[w]);var j,B,U = w;do {(w += D) < 0 ? w = S.length - 1 : w %= S.length;} while (w !== M && !_(S[w], O));(M = w - D) < 0 && (M = S.length - 1), F = N;do {j = O[F], B = O[F = ++F % O.length], m = (0, i.intersectSegments)(j, B, S[M], S[w], 0);} while (N !== F && !m.intersection);m.intersection && (n.Vector3.scale(R, n.Vector3.subtract(R, B, j), m.solutions[0]), n.Vector3.add(A, R, j), n.Vector3.subtract(S[M], S[w], S[M]), n.Vector3.normalize(S[M], S[M]), n.Vector3.scale(S[M], S[M], I * l), n.Vector3.add(S[M], A, S[M])), Math.min(Math.abs(U - M), Math.abs(U - M - S.length)) > 1 && console.warn("REGION: Remove loop segment! FIXME!");}} else u.DebugUtils.warn("REGION: Failed to fix loop tessellation! [no intersected segments]");}var m = function m(e, t) {var r = e;for (r < 0 ? r += t.length : r %= t.length; t[r] !== r;) {r = t[r];}return r;},E = function E(e, t, r, o) {return n.Vector3.distance(r[e], r[t]) < 1e-6 ? (o[0] = e, o[1] = e, 1) : 0;},x = function x(e, t, r, o, i) {var s = new Array(2);if (s[0] = o[e], s[1] = o[r], n.Vector3.length(n.Vector3.subtract(n.Vector3.createFloat64(), s[0], s[1])) < 1e-6) return i[0] = e, i[1] = e, i[2] = e, 2;var a = (s[0][0] - s[1][0]) * (o[t][1] - s[1][1]) - (s[0][1] - s[1][1]) * (o[t][0] - s[1][0]);return a > -l * l && a < l * l ? (i[0] = e, i[1] = e, i[2] = r, 1) : 0;},R = function R(e, t, r, n, o, s) {return (0, i.intersectSegments)(o[e], o[t], o[r], o[n]).intersection ? (s[0] = e, s[1] = t, s[2] = t, s[3] = n, 1) : (s[0] = -1, 0);},A = function A(e) {if (e.length < 4) return e;for (var t, r, n, o, i = e.length, s = new Int32Array(i), a = 0; a < i; ++a) {s[a] = a;}var c,u = new Array(3),l = new Array(3);for (l[0] = 0, l[1] = 0, l[2] = 0, a = 0; a < i; ++a) {t = m(a, s), r = m(a + 1, s), (c = E(t, r, e, u)) && (++l[0], s[t] = u[0], s[r] = u[1], t = m(a += c, s), r = m(a + 1, s)), n = m(a + 2, s), (c = x(t, r, n, e, u)) && (++l[1], s[t] = u[0], s[r] = u[1], s[n] = u[2], t = m(a += c, s), r = m(a + 1, s), n = m(a + 2, s)), o = m(a + 3, s), (c = R(t, r, n, o, e, u)) && (++l[2], s[t] = u[0], s[r] = u[1], s[n] = u[2], s[o] = u[3], a += c);}var h = [];for (a = 0; a < e.length; ++a) {s[a] === a && h.push(e[a]);}return h;},P = function P(e, t, r) {for (var n = v(e, [t].concat(r)), o = 0; o < n.length; o++) {d(n[o].loop, n[o].index, (0, i.isLoopCCW)(n[o].loop));}},V = function V(e, t) {var r = !1;!function (e) {var t = p(e);if (t.foundSelfIntersection) for (var r = (0, i.isLoopCCW)(e), n = c.default.keys(t.table), o = 0; o < n.length; o++) {if (t.table[n[o]].length > 1) for (var s = t.table[n[o]], a = 0; a < s.length; a++) {d(e, s[a], r);}}}(e);for (var n = [], o = 0; o < t.length; o++) {n.push.apply(n, f(t[o]));}var s = A(e),l = [];for (o = 0; o < n.length; o++) {l.push(A(n[o]));}var h = 8;do {r = !0;var g = (0, c.default)(s).map(function (e) {return new a.poly2tri.Point(e[0], e[1]);}),v = new a.poly2tri.SweepContext(g);for (o = 0; o < l.length; o++) {var _ = (0, c.default)(l[o]).map(function (e) {return new a.poly2tri.Point(e[0], e[1]);});v.addHole(_);}try {v.triangulate();} catch (e) {if ("poly2tri Intersecting Constraints" === e.message.substr(0, 33)) r = !1, y(e.points, s, l);else if ("poly2tri EdgeEvent: Collinear not supported" === e.message.substr(0, 43)) r = !1, P(e.points, s, l);else {if (!e.points) throw e;r = !1, y(e.points, s, l);}}} while (!r && h-- > 0);return h <= 0 && u.DebugUtils.warn("Computation of region tessellation failed, due to too many intersections."), v;};t.facetPlanarFace = function (e, t) {var r = e.getSurface(),o = (0, s.getPlaneTransforms)(r),a = new i.LoopCalculator(e, o.threeSpaceToUV).getRank0Loops();if (1 !== a.length) throw new Error("Each region should have exactly one top-loop");var c = a[0],u = (0, i.tessellateLoop)(c._loop, t);if (o.threeSpaceToUV) for (var l = 0; l < u.length; l++) {n.Vector3.transformMatrix44(u[l], u[l], o.threeSpaceToUV);}for (var h = [], d = c.getImmediatelyInsideLoops(), g = 0; g < d.length; g++) {var p = (0, i.tessellateLoop)(d[g]._loop, t);if (h.push(p), o.threeSpaceToUV) for (l = 0; l < p.length; l++) {n.Vector3.transformMatrix44(p[l], p[l], o.threeSpaceToUV);}}var f = V(u, h),v = f.getTriangles(),_ = new Uint32Array(3 * v.length),y = new Float32Array(3 * f.pointCount()),m = n.Vector3.createFloat64();for (l = 0; l < f.pointCount(); l++) {var E = f.getPoint(l);n.Vector3.set(m, E.x, E.y, 0), o.uvToThreeSpace && n.Vector3.transformMatrix44(m, m, o.uvToThreeSpace), y[3 * l] = m[0], y[3 * l + 1] = m[1], y[3 * l + 2] = m[2], E.index = l;}for (l = 0; l < v.length; l++) {var x = v[l].getPoints();for (e.isReversed() && x.reverse(), g = 0; g < x.length; g++) {var R = x[g];_[3 * l + g] = R.index;}}return { indexBuffer: _, vertexBuffer: y };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.LoopCalculator = t.intersectSegments = t.isLoopCCW = t.tessellateLoop = void 0;var n = r(1),o = r(0),i = r(3),s = function s(e, t) {this._loop = e, this._enclosureRank = 0, this._isOuterLoop = !1, this._insideLoops = [], this._isOpen = !1, this._coedges = this._loop.getCoedges();for (var r = 0; r < this._coedges.length; ++r) {this._coedges[r].generateUVCurve(t);}};s.prototype.addInsideLoop = function (e) {this._insideLoops.push(e);}, s.prototype.uvAngleSubtended = function (e) {if (!this.isClosedLoop()) throw new Error("uvAngleSubtended cannot work with open loops");for (var t = 0, r = 0; r < this._coedges.length; r++) {t += this._coedges[r].uvAngleSubtended(e);}return t;}, s.prototype.getArbitraryPointOnLoop = function () {if (1 === this._coedges.length) {var e = this._coedges[0].t0();return this._coedges[0].evaluatePosition(e);}var t = this._coedges[0].getStartVertex();if (t) return t.getPosition();}, s.prototype.isInside = function (e) {var t = this.getArbitraryPointOnLoop(),r = Math.abs(e.uvAngleSubtended(t)),n = Math.floor(r / (2 * Math.PI)),i = r - 2 * n * Math.PI;return !!(Math.abs(i) < o.KERNEL_TOLERANCE && n || Math.abs(i - 2 * Math.PI) < o.KERNEL_TOLERANCE);}, s.prototype.getEnclosureRank = function () {return this._enclosureRank;}, s.prototype.resetEnclosureRank = function () {this._enclosureRank = 0;}, s.prototype.decreaseEnclosureRank = function () {this._enclosureRank--;}, s.prototype.setIsOuterLoop = function (e) {this._isOuterLoop = e;}, s.prototype.isOuterLoop = function () {return this._isOuterLoop;}, s.prototype.isClosedLoop = function () {return !this._isOpen;}, s.prototype.addInsideLoop = function (e) {this._insideLoops.push(e);}, s.prototype.getImmediatelyInsideLoops = function () {for (var e = [], t = 0; t < this._insideLoops.length; t++) {this._insideLoops[t].getEnclosureRank() === this._enclosureRank - 1 && e.push(this._insideLoops[t]);}return e;};var a = function a(e, t) {this._face = e, this._loops = [];for (var r = 0; r < this._face.getLoops().length; ++r) {this._loops.push(new s(this._face.getLoops()[r], t));}this._calcSenses();};a.prototype._calcSenses = function () {for (var e = this._loops.length, t = 0; t < e; t++) {this._loops[t].resetEnclosureRank();}for (t = 0; t < e; t++) {if (this._loops[t].isClosedLoop()) for (var r = 0; r < e; r++) {this._loops[r].isClosedLoop() && t !== r && this._loops[t].isInside(this._loops[r]) && !this._loops[r].isInside(this._loops[t]) && (this._loops[t].decreaseEnclosureRank(), this._loops[r].addInsideLoop(this._loops[t]));}}for (t = 0; t < e; t++) {var n = 0 - this._loops[t].getEnclosureRank();this._loops[t].setIsOuterLoop(n % 2 == 0);}}, a.prototype.getRank0Loops = function () {var e = [];return this._loops.forEach(function (t) {0 === t.getEnclosureRank() && e.push(t);}), e;}, t.tessellateLoop = function (e, t) {for (var r = [], o = 0, i = e.getCoedges().length; o < i; ++o) {var s = e.getCoedges()[o],a = s.getEdge(),c = a.tessellate(void 0, t).positions;c = c.slice(1, c.length - 1), (c = [n.Vector3.clone(a.getStartVertex().getPosition())].concat(c)).push(n.Vector3.clone(a.getEndVertex().getPosition())), s.isReversed() && c.reverse(), r = r.concat(c.slice(0, c.length - 1));}return r;}, t.isLoopCCW = function (e) {for (var t = 0, r = 0; r < e.length; r++) {var n = (r + 1) % e.length;t += e[r][0] * e[n][1] - e[r][1] * e[n][0];}return t > 0;}, t.intersectSegments = function (e, t, r, o, s) {var a = [[t[0] - e[0], -(o[0] - r[0]), r[0] - e[0]], [t[1] - e[1], -(o[1] - r[1]), r[1] - e[1]]],c = (0, i.solveTwoEquationsTwoVariables)(a);if (void 0 === c) return !1;var u = n.Vector3.distance(e, t),l = n.Vector3.distance(r, o);return { intersection: -s < c[0] * u && (c[0] - 1) * u < s && -s < c[1] * l && (c[1] - 1) * l < s, solutions: c };}, t.LoopCalculator = a;}, function (e, t, r) {"use strict";var n, o;if (Object.defineProperty(t, "__esModule", { value: !0 }), void 0 === i) var i = {},s = { exports: {} };!function (a) {"object" == _typeof(i) ? s.exports = a() : void 0 === (o = "function" == typeof (n = a) ? n.call(t, r, t, e) : n) || (e.exports = o);}(function () {return function e(t, r, n) {function o(s, a) {if (!r[s]) {if (!t[s]) {if (i) return i(s, !0);throw new Error("Cannot find module '" + s + "'");}var c = r[s] = { exports: {} };t[s][0].call(c.exports, function (e) {return o(t[s][1][e] || e);}, c, c.exports, e, t, r, n);}return r[s].exports;}for (var i = !1, s = 0; s < n.length; s++) {o(n[s]);}return o;}({ 1: [function (e, t, r) {t.exports = { version: "1.3.5" };}, {}], 2: [function (e, t, r) {var n = function n(e, t) {this.head_ = e, this.tail_ = t, this.search_node_ = e;};n.prototype.head = function () {return this.head_;}, n.prototype.setHead = function (e) {this.head_ = e;}, n.prototype.tail = function () {return this.tail_;}, n.prototype.setTail = function (e) {this.tail_ = e;}, n.prototype.search = function () {return this.search_node_;}, n.prototype.setSearch = function (e) {this.search_node_ = e;}, n.prototype.findSearchNode = function () {return this.search_node_;}, n.prototype.locateNode = function (e) {var t = this.search_node_;if (e < t.value) {for (; t = t.prev;) {if (e >= t.value) return this.search_node_ = t, t;}} else for (; t = t.next;) {if (e < t.value) return this.search_node_ = t.prev, t.prev;}return null;}, n.prototype.locatePoint = function (e) {var t = e.x,r = this.findSearchNode(t),n = r.point.x;if (t === n) {if (e !== r.point) if (e === r.prev.point) r = r.prev;else {if (e !== r.next.point) throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");r = r.next;}} else if (t < n) for (; (r = r.prev) && e !== r.point;) {;} else for (; (r = r.next) && e !== r.point;) {;}return r && (this.search_node_ = r), r;}, t.exports = n, t.exports.Node = function (e, t) {this.point = e, this.triangle = t || null, this.next = null, this.prev = null, this.value = e.x;};}, {}], 3: [function (e, t, r) {t.exports = function (e, t) {if (!e) throw new Error(t || "Assert Failed");};}, {}], 4: [function (e, t, r) {var n = e("./xy"),o = function o(e, t) {this.x = +e || 0, this.y = +t || 0, this._p2t_edge_list = null;};o.prototype.toString = function () {return n.toStringBase(this);}, o.prototype.toJSON = function () {return { x: this.x, y: this.y };}, o.prototype.clone = function () {return new o(this.x, this.y);}, o.prototype.set_zero = function () {return this.x = 0, this.y = 0, this;}, o.prototype.set = function (e, t) {return this.x = +e || 0, this.y = +t || 0, this;}, o.prototype.negate = function () {return this.x = -this.x, this.y = -this.y, this;}, o.prototype.add = function (e) {return this.x += e.x, this.y += e.y, this;}, o.prototype.sub = function (e) {return this.x -= e.x, this.y -= e.y, this;}, o.prototype.mul = function (e) {return this.x *= e, this.y *= e, this;}, o.prototype.length = function () {return Math.sqrt(this.x * this.x + this.y * this.y);}, o.prototype.normalize = function () {var e = this.length();return this.x /= e, this.y /= e, e;}, o.prototype.equals = function (e) {return this.x === e.x && this.y === e.y;}, o.negate = function (e) {return new o(-e.x, -e.y);}, o.add = function (e, t) {return new o(e.x + t.x, e.y + t.y);}, o.sub = function (e, t) {return new o(e.x - t.x, e.y - t.y);}, o.mul = function (e, t) {return new o(e * t.x, e * t.y);}, o.cross = function (e, t) {return "number" == typeof e ? "number" == typeof t ? e * t : new o(-e * t.y, e * t.x) : "number" == typeof t ? new o(t * e.y, -t * e.x) : e.x * t.y - e.y * t.x;}, o.toString = n.toString, o.compare = n.compare, o.cmp = n.compare, o.equals = n.equals, o.dot = function (e, t) {return e.x * t.x + e.y * t.y;}, t.exports = o;}, { "./xy": 11 }], 5: [function (e, t, r) {var n = e("./xy"),o = function o(e, t) {this.name = "PointError", this.points = t = t || [], this.message = e || "Invalid Points!";for (var r = 0; r < t.length; r++) {this.message += " " + n.toString(t[r]);}};(o.prototype = new Error()).constructor = o, t.exports = o;}, { "./xy": 11 }], 6: [function (e, t, r) {(function (t) {var n = t.poly2tri;r.noConflict = function () {return t.poly2tri = n, r;}, r.VERSION = e("../dist/version.json").version, r.PointError = e("./pointerror"), r.Point = e("./point"), r.Triangle = e("./triangle"), r.SweepContext = e("./sweepcontext");var o = e("./sweep");r.triangulate = o.triangulate, r.sweep = { Triangulate: o.triangulate };}).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});}, { "../dist/version.json": 1, "./point": 4, "./pointerror": 5, "./sweep": 7, "./sweepcontext": 8, "./triangle": 9 }], 7: [function (e, t, r) {var n = e("./assert"),o = e("./pointerror"),i = e("./triangle"),s = e("./advancingfront").Node,a = e("./utils"),c = a.EPSILON,u = a.Orientation,l = a.orient2d,h = a.inScanArea,d = a.isAngleObtuse;function g(e, t) {var r = e.locateNode(t),o = function (e, t, r) {var n = new i(t, r.point, r.next.point);n.markNeighbor(r.triangle), e.addToMap(n);var o = new s(t);return o.next = r.next, o.prev = r, r.next.prev = o, r.next = o, y(e, n) || e.mapTriangleToNodes(n), o;}(e, t, r);return t.x <= r.point.x + c && _(e, r), function (e, t) {for (var r = t.next; r.next && !d(r.point, r.next.point, r.prev.point);) {_(e, r), r = r.next;}for (r = t.prev; r.prev && !d(r.point, r.next.point, r.prev.point);) {_(e, r), r = r.prev;}t.next && t.next.next && function (e) {var t = e.point.x - e.next.next.point.x,r = e.point.y - e.next.next.point.y;return n(r >= 0, "unordered y"), t >= 0 || Math.abs(t) < r;}(t) && function (e, t) {for (l(t.point, t.next.point, t.next.next.point) === u.CCW ? e.basin.left_node = t.next.next : e.basin.left_node = t.next, e.basin.bottom_node = e.basin.left_node; e.basin.bottom_node.next && e.basin.bottom_node.point.y >= e.basin.bottom_node.next.point.y;) {e.basin.bottom_node = e.basin.bottom_node.next;}if (e.basin.bottom_node !== e.basin.left_node) {for (e.basin.right_node = e.basin.bottom_node; e.basin.right_node.next && e.basin.right_node.point.y < e.basin.right_node.next.point.y;) {e.basin.right_node = e.basin.right_node.next;}e.basin.right_node !== e.basin.bottom_node && (e.basin.width = e.basin.right_node.point.x - e.basin.left_node.point.x, e.basin.left_highest = e.basin.left_node.point.y > e.basin.right_node.point.y, function e(t, r) {if (!function (e, t) {var r;return r = e.basin.left_highest ? e.basin.left_node.point.y - t.point.y : e.basin.right_node.point.y - t.point.y, e.basin.width > r;}(t, r) && (_(t, r), r.prev !== t.basin.left_node || r.next !== t.basin.right_node)) {if (r.prev === t.basin.left_node) {if (l(r.point, r.next.point, r.next.next.point) === u.CW) return;r = r.next;} else if (r.next === t.basin.right_node) {if (l(r.point, r.prev.point, r.prev.prev.point) === u.CCW) return;r = r.prev;} else r = r.prev.point.y < r.next.point.y ? r.prev : r.next;e(t, r);}}(e, e.basin.bottom_node));}}(e, t);}(e, o), o;}function p(e, t, r) {e.edge_event.constrained_edge = t, e.edge_event.right = t.p.x > t.q.x, v(r.triangle, t.p, t.q) || (function (e, t, r) {e.edge_event.right ? function (e, t, r) {for (; r.next.point.x < t.p.x;) {l(t.q, r.next.point, t.p) === u.CCW ? x(e, t, r) : r = r.next;}}(e, t, r) : function (e, t, r) {for (; r.prev.point.x > t.p.x;) {l(t.q, r.prev.point, t.p) === u.CW ? A(e, t, r) : r = r.prev;}}(e, t, r);}(e, t, r), f(e, t.p, t.q, r.triangle, t.q));}function f(e, t, r, n, i) {if (!v(n, t, r)) {var s = n.pointCCW(i),a = l(r, s, t);if (a === u.COLLINEAR) throw new o("poly2tri EdgeEvent: Collinear not supported!", [r, s, t]);var c = n.pointCW(i),h = l(r, c, t);if (h === u.COLLINEAR) throw new o("poly2tri EdgeEvent: Collinear not supported!", [r, c, t]);a === h ? f(e, t, r, n = a === u.CW ? n.neighborCCW(i) : n.neighborCW(i), i) : V(e, t, r, n, i);}}function v(e, t, r) {var n = e.edgeIndex(t, r);if (-1 !== n) {e.markConstrainedEdgeByIndex(n);var o = e.getNeighbor(n);return o && o.markConstrainedEdgeByPoints(t, r), !0;}return !1;}function _(e, t) {var r = new i(t.prev.point, t.point, t.next.point);r.markNeighbor(t.prev.triangle), r.markNeighbor(t.triangle), e.addToMap(r), t.prev.next = t.next, t.next.prev = t.prev, y(e, r) || e.mapTriangleToNodes(r);}function y(e, t) {for (var r = 0; r < 3; ++r) {if (!t.delaunay_edge[r]) {var n = t.getNeighbor(r);if (n) {var o = t.getPoint(r),i = n.oppositePoint(t, o),s = n.index(i);if (n.constrained_edge[s] || n.delaunay_edge[s]) {t.constrained_edge[r] = n.constrained_edge[s];continue;}if (m(o, t.pointCCW(o), t.pointCW(o), i)) {t.delaunay_edge[r] = !0, n.delaunay_edge[s] = !0, E(t, o, n, i);var a = !y(e, t);return a && e.mapTriangleToNodes(t), (a = !y(e, n)) && e.mapTriangleToNodes(n), t.delaunay_edge[r] = !1, n.delaunay_edge[s] = !1, !0;}}}}return !1;}function m(e, t, r, n) {var o = e.x - n.x,i = e.y - n.y,s = t.x - n.x,a = t.y - n.y,c = o * a - s * i;if (c <= 0) return !1;var u = r.x - n.x,l = r.y - n.y,h = u * i - o * l;return !(h <= 0) && (o * o + i * i) * (s * l - u * a) + (s * s + a * a) * h + (u * u + l * l) * c > 0;}function E(e, t, r, n) {var o, i, s, a, c, u, l, h, d, g, p, f;o = e.neighborCCW(t), i = e.neighborCW(t), s = r.neighborCCW(n), a = r.neighborCW(n), c = e.getConstrainedEdgeCCW(t), u = e.getConstrainedEdgeCW(t), l = r.getConstrainedEdgeCCW(n), h = r.getConstrainedEdgeCW(n), d = e.getDelaunayEdgeCCW(t), g = e.getDelaunayEdgeCW(t), p = r.getDelaunayEdgeCCW(n), f = r.getDelaunayEdgeCW(n), e.legalize(t, n), r.legalize(n, t), r.setDelaunayEdgeCCW(t, d), e.setDelaunayEdgeCW(t, g), e.setDelaunayEdgeCCW(n, p), r.setDelaunayEdgeCW(n, f), r.setConstrainedEdgeCCW(t, c), e.setConstrainedEdgeCW(t, u), e.setConstrainedEdgeCCW(n, l), r.setConstrainedEdgeCW(n, h), e.clearNeighbors(), r.clearNeighbors(), o && r.markNeighbor(o), i && e.markNeighbor(i), s && e.markNeighbor(s), a && r.markNeighbor(a), e.markNeighbor(r);}function x(e, t, r) {r.point.x < t.p.x && (l(r.point, r.next.point, r.next.next.point) === u.CCW ? R(e, t, r) : (function e(t, r, n) {l(n.next.point, n.next.next.point, n.next.next.next.point) === u.CCW ? R(t, r, n.next) : l(r.q, n.next.next.point, r.p) === u.CCW && e(t, r, n.next);}(e, t, r), x(e, t, r)));}function R(e, t, r) {_(e, r.next), r.next.point !== t.p && l(t.q, r.next.point, t.p) === u.CCW && l(r.point, r.next.point, r.next.next.point) === u.CCW && R(e, t, r);}function A(e, t, r) {r.point.x > t.p.x && (l(r.point, r.prev.point, r.prev.prev.point) === u.CW ? P(e, t, r) : (function e(t, r, n) {l(n.prev.point, n.prev.prev.point, n.prev.prev.prev.point) === u.CW ? P(t, r, n.prev) : l(r.q, n.prev.prev.point, r.p) === u.CW && e(t, r, n.prev);}(e, t, r), A(e, t, r)));}function P(e, t, r) {_(e, r.prev), r.prev.point !== t.p && l(t.q, r.prev.point, t.p) === u.CW && l(r.point, r.prev.point, r.prev.prev.point) === u.CW && P(e, t, r);}function V(e, t, r, i, s) {var a = i.neighborAcross(s);n(a, "FLIP failed due to missing triangle!");var c = a.oppositePoint(i, s);if (i.getConstrainedEdgeAcross(s)) {var d = i.index(s);throw new o("poly2tri Intersecting Constraints", [s, c, i.getPoint((d + 1) % 3), i.getPoint((d + 2) % 3)]);}h(s, i.pointCCW(s), i.pointCW(s), c) ? (E(i, s, a, c), e.mapTriangleToNodes(i), e.mapTriangleToNodes(a), s === r && c === t ? r === e.edge_event.constrained_edge.q && t === e.edge_event.constrained_edge.p && (i.markConstrainedEdgeByPoints(t, r), a.markConstrainedEdgeByPoints(t, r), y(e, i), y(e, a)) : V(e, t, r, i = function (e, t, r, n, o, i) {var s;return t === u.CCW ? (s = n.edgeIndex(o, i), n.delaunay_edge[s] = !0, y(e, n), n.clearDelaunayEdges(), r) : (s = r.edgeIndex(o, i), r.delaunay_edge[s] = !0, y(e, r), r.clearDelaunayEdges(), n);}(e, l(r, c, t), i, a, s, c), s)) : (function e(t, r, o, i, s, a) {var c = s.neighborAcross(a);n(c, "FLIP failed due to missing triangle");var u = c.oppositePoint(s, a);h(o, i.pointCCW(o), i.pointCW(o), u) ? V(t, o, u, c, u) : e(t, r, o, i, c, T(r, o, c, u));}(e, t, r, i, a, T(t, r, a, c)), f(e, t, r, i, s));}function T(e, t, r, n) {var i = l(t, n, e);if (i === u.CW) return r.pointCCW(n);if (i === u.CCW) return r.pointCW(n);throw new o("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [t, n, e]);}r.triangulate = function (e) {e.initTriangulation(), e.createAdvancingFront(), function (e) {var t,r = e.pointCount();for (t = 1; t < r; ++t) {for (var n = e.getPoint(t), o = g(e, n), i = n._p2t_edge_list, s = 0; i && s < i.length; ++s) {p(e, i[s], o);}}}(e), function (e) {for (var t = e.front().head().next.triangle, r = e.front().head().next.point; !t.getConstrainedEdgeCW(r);) {t = t.neighborCCW(r);}e.meshClean(t);}(e);};}, { "./advancingfront": 2, "./assert": 3, "./pointerror": 5, "./triangle": 9, "./utils": 10 }], 8: [function (e, t, r) {var n = e("./pointerror"),o = e("./point"),i = e("./triangle"),s = e("./sweep"),a = e("./advancingfront"),c = a.Node,u = function u(e, t) {if (this.p = e, this.q = t, e.y > t.y) this.q = e, this.p = t;else if (e.y === t.y) if (e.x > t.x) this.q = e, this.p = t;else if (e.x === t.x) throw new n("poly2tri Invalid Edge constructor: repeated points!", [e]);this.q._p2t_edge_list || (this.q._p2t_edge_list = []), this.q._p2t_edge_list.push(this);},l = function l() {this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;};l.prototype.clear = function () {this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;};var h = function h(e, t) {t = t || {}, this.triangles_ = [], this.map_ = [], this.points_ = t.cloneArrays ? e.slice(0) : e, this.edge_list = [], this.pmin_ = this.pmax_ = null, this.front_ = null, this.head_ = null, this.tail_ = null, this.af_head_ = null, this.af_middle_ = null, this.af_tail_ = null, this.basin = new l(), this.edge_event = new function () {this.constrained_edge = null, this.right = !1;}(), this.initEdges(this.points_);};h.prototype.addHole = function (e) {this.initEdges(e);var t,r = e.length;for (t = 0; t < r; t++) {this.points_.push(e[t]);}return this;}, h.prototype.AddHole = h.prototype.addHole, h.prototype.addHoles = function (e) {var t,r = e.length;for (t = 0; t < r; t++) {this.initEdges(e[t]);}return this.points_ = this.points_.concat.apply(this.points_, e), this;}, h.prototype.addPoint = function (e) {return this.points_.push(e), this;}, h.prototype.AddPoint = h.prototype.addPoint, h.prototype.addPoints = function (e) {return this.points_ = this.points_.concat(e), this;}, h.prototype.triangulate = function () {return s.triangulate(this), this;}, h.prototype.getBoundingBox = function () {return { min: this.pmin_, max: this.pmax_ };}, h.prototype.getTriangles = function () {return this.triangles_;}, h.prototype.GetTriangles = h.prototype.getTriangles, h.prototype.front = function () {return this.front_;}, h.prototype.pointCount = function () {return this.points_.length;}, h.prototype.head = function () {return this.head_;}, h.prototype.setHead = function (e) {this.head_ = e;}, h.prototype.tail = function () {return this.tail_;}, h.prototype.setTail = function (e) {this.tail_ = e;}, h.prototype.getMap = function () {return this.map_;}, h.prototype.initTriangulation = function () {var e,t = this.points_[0].x,r = this.points_[0].x,n = this.points_[0].y,i = this.points_[0].y,s = this.points_.length;for (e = 1; e < s; e++) {var a = this.points_[e];a.x > t && (t = a.x), a.x < r && (r = a.x), a.y > n && (n = a.y), a.y < i && (i = a.y);}this.pmin_ = new o(r, i), this.pmax_ = new o(t, n);var c = .3 * (t - r),u = .3 * (n - i);this.head_ = new o(t + c, i - u), this.tail_ = new o(r - c, i - u), this.points_.sort(o.compare);}, h.prototype.initEdges = function (e, t) {var r,n = e.length,o = t ? e.length - 1 : e.length;for (r = 0; r < o; ++r) {this.edge_list.push(new u(e[r], e[(r + 1) % n]));}}, h.prototype.getPoint = function (e) {return this.points_[e];}, h.prototype.addToMap = function (e) {this.map_.push(e);}, h.prototype.locateNode = function (e) {return this.front_.locateNode(e.x);}, h.prototype.createAdvancingFront = function () {var e,t,r,n = new i(this.points_[0], this.tail_, this.head_);this.map_.push(n), e = new c(n.getPoint(1), n), t = new c(n.getPoint(0), n), r = new c(n.getPoint(2)), this.front_ = new a(e, r), e.next = t, t.next = r, t.prev = e, r.prev = t;}, h.prototype.removeNode = function (e) {}, h.prototype.mapTriangleToNodes = function (e) {for (var t = 0; t < 3; ++t) {if (!e.getNeighbor(t)) {var r = this.front_.locatePoint(e.pointCW(e.getPoint(t)));r && (r.triangle = e);}}}, h.prototype.removeFromMap = function (e) {var t,r = this.map_,n = r.length;for (t = 0; t < n; t++) {if (r[t] === e) {r.splice(t, 1);break;}}}, h.prototype.meshClean = function (e) {for (var t, r, n = [e]; t = n.pop();) {if (!t.isInterior()) for (t.setInterior(!0), this.triangles_.push(t), r = 0; r < 3; r++) {t.constrained_edge[r] || n.push(t.getNeighbor(r));}}}, t.exports = h;}, { "./advancingfront": 2, "./point": 4, "./pointerror": 5, "./sweep": 7, "./triangle": 9 }], 9: [function (e, t, r) {var n = function n(e, t, r) {this.points_ = [e, t, r], this.neighbors_ = [null, null, null], this.interior_ = !1, this.constrained_edge = [!1, !1, !1], this.delaunay_edge = [!1, !1, !1];},o = e("./xy").toString;n.prototype.toString = function () {return "[" + o(this.points_[0]) + o(this.points_[1]) + o(this.points_[2]) + "]";}, n.prototype.getPoint = function (e) {return this.points_[e];}, n.prototype.GetPoint = n.prototype.getPoint, n.prototype.getPoints = function () {return this.points_;}, n.prototype.getNeighbor = function (e) {return this.neighbors_[e];}, n.prototype.containsPoint = function (e) {var t = this.points_;return e === t[0] || e === t[1] || e === t[2];}, n.prototype.containsEdge = function (e) {return this.containsPoint(e.p) && this.containsPoint(e.q);}, n.prototype.containsPoints = function (e, t) {return this.containsPoint(e) && this.containsPoint(t);}, n.prototype.isInterior = function () {return this.interior_;}, n.prototype.setInterior = function (e) {return this.interior_ = e, this;}, n.prototype.markNeighborPointers = function (e, t, r) {var n = this.points_;if (e === n[2] && t === n[1] || e === n[1] && t === n[2]) this.neighbors_[0] = r;else if (e === n[0] && t === n[2] || e === n[2] && t === n[0]) this.neighbors_[1] = r;else {if (!(e === n[0] && t === n[1] || e === n[1] && t === n[0])) throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");this.neighbors_[2] = r;}}, n.prototype.markNeighbor = function (e) {var t = this.points_;e.containsPoints(t[1], t[2]) ? (this.neighbors_[0] = e, e.markNeighborPointers(t[1], t[2], this)) : e.containsPoints(t[0], t[2]) ? (this.neighbors_[1] = e, e.markNeighborPointers(t[0], t[2], this)) : e.containsPoints(t[0], t[1]) && (this.neighbors_[2] = e, e.markNeighborPointers(t[0], t[1], this));}, n.prototype.clearNeighbors = function () {this.neighbors_[0] = null, this.neighbors_[1] = null, this.neighbors_[2] = null;}, n.prototype.clearDelaunayEdges = function () {this.delaunay_edge[0] = !1, this.delaunay_edge[1] = !1, this.delaunay_edge[2] = !1;}, n.prototype.pointCW = function (e) {var t = this.points_;return e === t[0] ? t[2] : e === t[1] ? t[0] : e === t[2] ? t[1] : null;}, n.prototype.pointCCW = function (e) {var t = this.points_;return e === t[0] ? t[1] : e === t[1] ? t[2] : e === t[2] ? t[0] : null;}, n.prototype.neighborCW = function (e) {return e === this.points_[0] ? this.neighbors_[1] : e === this.points_[1] ? this.neighbors_[2] : this.neighbors_[0];}, n.prototype.neighborCCW = function (e) {return e === this.points_[0] ? this.neighbors_[2] : e === this.points_[1] ? this.neighbors_[0] : this.neighbors_[1];}, n.prototype.getConstrainedEdgeCW = function (e) {return e === this.points_[0] ? this.constrained_edge[1] : e === this.points_[1] ? this.constrained_edge[2] : this.constrained_edge[0];}, n.prototype.getConstrainedEdgeCCW = function (e) {return e === this.points_[0] ? this.constrained_edge[2] : e === this.points_[1] ? this.constrained_edge[0] : this.constrained_edge[1];}, n.prototype.getConstrainedEdgeAcross = function (e) {return e === this.points_[0] ? this.constrained_edge[0] : e === this.points_[1] ? this.constrained_edge[1] : this.constrained_edge[2];}, n.prototype.setConstrainedEdgeCW = function (e, t) {e === this.points_[0] ? this.constrained_edge[1] = t : e === this.points_[1] ? this.constrained_edge[2] = t : this.constrained_edge[0] = t;}, n.prototype.setConstrainedEdgeCCW = function (e, t) {e === this.points_[0] ? this.constrained_edge[2] = t : e === this.points_[1] ? this.constrained_edge[0] = t : this.constrained_edge[1] = t;}, n.prototype.getDelaunayEdgeCW = function (e) {return e === this.points_[0] ? this.delaunay_edge[1] : e === this.points_[1] ? this.delaunay_edge[2] : this.delaunay_edge[0];}, n.prototype.getDelaunayEdgeCCW = function (e) {return e === this.points_[0] ? this.delaunay_edge[2] : e === this.points_[1] ? this.delaunay_edge[0] : this.delaunay_edge[1];}, n.prototype.setDelaunayEdgeCW = function (e, t) {e === this.points_[0] ? this.delaunay_edge[1] = t : e === this.points_[1] ? this.delaunay_edge[2] = t : this.delaunay_edge[0] = t;}, n.prototype.setDelaunayEdgeCCW = function (e, t) {e === this.points_[0] ? this.delaunay_edge[2] = t : e === this.points_[1] ? this.delaunay_edge[0] = t : this.delaunay_edge[1] = t;}, n.prototype.neighborAcross = function (e) {return e === this.points_[0] ? this.neighbors_[0] : e === this.points_[1] ? this.neighbors_[1] : this.neighbors_[2];}, n.prototype.oppositePoint = function (e, t) {var r = e.pointCW(t);return this.pointCW(r);}, n.prototype.legalize = function (e, t) {var r = this.points_;if (e === r[0]) r[1] = r[0], r[0] = r[2], r[2] = t;else if (e === r[1]) r[2] = r[1], r[1] = r[0], r[0] = t;else {if (e !== r[2]) throw new Error("poly2tri Invalid Triangle.legalize() call");r[0] = r[2], r[2] = r[1], r[1] = t;}}, n.prototype.index = function (e) {var t = this.points_;if (e === t[0]) return 0;if (e === t[1]) return 1;if (e === t[2]) return 2;throw new Error("poly2tri Invalid Triangle.index() call");}, n.prototype.edgeIndex = function (e, t) {var r = this.points_;if (e === r[0]) {if (t === r[1]) return 2;if (t === r[2]) return 1;} else if (e === r[1]) {if (t === r[2]) return 0;if (t === r[0]) return 2;} else if (e === r[2]) {if (t === r[0]) return 1;if (t === r[1]) return 0;}return -1;}, n.prototype.markConstrainedEdgeByIndex = function (e) {this.constrained_edge[e] = !0;}, n.prototype.markConstrainedEdgeByEdge = function (e) {this.markConstrainedEdgeByPoints(e.p, e.q);}, n.prototype.markConstrainedEdgeByPoints = function (e, t) {var r = this.points_;t === r[0] && e === r[1] || t === r[1] && e === r[0] ? this.constrained_edge[2] = !0 : t === r[0] && e === r[2] || t === r[2] && e === r[0] ? this.constrained_edge[1] = !0 : (t === r[1] && e === r[2] || t === r[2] && e === r[1]) && (this.constrained_edge[0] = !0);}, t.exports = n;}, { "./xy": 11 }], 10: [function (e, t, r) {var n = 1e-16;r.EPSILON = n;var o = { CW: 1, CCW: -1, COLLINEAR: 0 };r.Orientation = o, r.orient2d = function (e, t, r) {var i = (e.x - r.x) * (t.y - r.y) - (e.y - r.y) * (t.x - r.x);return i > -n && i < n ? o.COLLINEAR : i > 0 ? o.CCW : o.CW;}, r.inScanArea = function (e, t, r, o) {return !((e.x - t.x) * (o.y - t.y) - (o.x - t.x) * (e.y - t.y) >= -n || (e.x - r.x) * (o.y - r.y) - (o.x - r.x) * (e.y - r.y) <= n);}, r.isAngleObtuse = function (e, t, r) {var n = t.x - e.x,o = t.y - e.y;return n * (r.x - e.x) + o * (r.y - e.y) < 0;};}, {}], 11: [function (e, t, r) {function n(e) {return "(" + e.x + ";" + e.y + ")";}t.exports = { toString: function toString(e) {var t = e.toString();return "[object Object]" === t ? n(e) : t;}, toStringBase: n, compare: function compare(e, t) {return e.y === t.y ? e.x - t.x : e.y - t.y;}, equals: function equals(e, t) {return e.x === t.x && e.y === t.y;} };}, {}] }, {}, [6])(6);});var a = s.exports;t.poly2tri = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.CCI = void 0;var n = r(1),o = r(111),i = r(77),s = function s(e, t, r, n, i) {this._cu1 = e, this._range1 = t, this._cu2 = r, this._range2 = n, this._epsilon = i, this._tree = new o.SubCurveTree(e, t, r, n, i);};s.prototype.intersect = function () {var e = [];this._tree.build();for (var t = 0; t < this._tree._overlaps.length; ++t) {var r = this._tree._overlaps[t][0],n = this._tree._overlaps[t][1];e = e.concat(this._solve(r._range, n._range));}return this._merge(e), e;}, s.prototype._distanceSquared = function (e, t) {var r = this._cu1.evaluatePosition(e),o = this._cu2.evaluatePosition(t);return n.Vector3.squaredDistance(r, o);}, s.prototype._solve = function (e, t) {var r = [],n = [.5 * (e[0] + e[1]), .5 * (t[0] + t[1])],o = this._relaxNR(n, [e, t]),s = o === i.RelaxResult.Success;if (o === i.RelaxResult.OutOfRange) {var a = n[0] < e[0] + 1e-12 || n[0] > e[1] - 1e-12,c = n[1] < t[0] + 1e-12 || n[1] > t[1] - 1e-12;(a || c) && this._distanceSquared(n[0], n[1]) < this._epsilon * this._epsilon && (s = !0);}return s && r.push(new function (e, t) {this.cutInfo = e, this.cutByInfo = t;}({ param: n[0], atVertex: void 0 }, { param: n[1], atVertex: void 0 })), r;}, s.prototype._relaxNR = function (e, t) {var r = this,o = (0, i.newtonRaphson2D)(function (e) {var t = r._cu1.evaluatePosition(e[0]),o = r._cu2.evaluatePosition(e[1]),i = [t[0] - o[0], t[1] - o[1]],s = r._cu1.evaluateDt(e[0]),a = r._cu2.evaluateDt(e[1]);return n.Vector3.negate(a, a), { val: i, deriv1: s, deriv2: a };}, e, t);return e[0] = o.param[0], e[1] = o.param[1], o.status;}, s.prototype._merge = function (e) {e.sort(function (e, t) {return e.cutInfo.param - t.cutInfo.param;});for (var t = 0; t < e.length; t++) {if (e[t]) for (var r = e[t].cutInfo.param, n = e[t].cutByInfo.param, o = t + 1; o < e.length; o++) {if (e[o]) {var i = e[o].cutInfo.param,s = e[o].cutByInfo.param;if (i > r + 1e-11) break;if (Math.abs(s - n) <= 1e-11) {e[t] = void 0;break;}}}}for (t = 0; t < e.length; t++) {e[t] || (e.splice(t, 1), t--);}}, t.CCI = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SubCurveTree = void 0;var n = 100 * r(0).KERNEL_TOLERANCE,o = Math.PI / 180 * 10,i = function i(e, t, r) {void 0 === r && (r = 0), this._cu = e, this._range = t, this._bx = e.getBoundingBox(t).clone(), this._simple = void 0, this._split_param = void 0, this._children = [], this._depth = r;};i.prototype.isSimple = function () {if (void 0 === this._simple) {this._simple = !1;var e = [this._range[0] + 1e-8, this._range[1] - 1e-8];if (this._split_param = this._cu.suggestSplittingParam(e), void 0 === this._split_param) {this._split_param = .5 * (this._range[0] + this._range[1]);var t = this._cu.getTangentCone(this._range);(t.isDegenerate() || t.angle < o) && (this._simple = !0);}}return this._simple;}, i.prototype.canDivide = function () {return !(this._depth >= 10 || this._range[1] - this._range[0] < 2e-8 || Math.max(this._bx.getWidth(0), this._bx.getWidth(1), this._bx.getWidth(2)) < n);}, i.prototype.divide = function () {if (0 === this._children.length) {var e = [this._range[0], this._split_param],t = [this._split_param, this._range[1]];this._children = [new i(this._cu, e, this._depth + 1), new i(this._cu, t, this._depth + 1)];}}, i.prototype.fullSubdivision = function () {if (!this.isSimple() && this.canDivide()) {this.divide();for (var e = 0; e < this._children.length; ++e) {this._children[e].fullSubdivision();}}}, i.prototype.toString = function () {if (this._children.length > 0) {for (var e = "", t = 0; t < this._children.length; ++t) {e += this._children[t];}return e;}return "t=[" + this._range[0] + " " + this._range[1] + "] " + this._bx + "\n";};var s = function s(e, t, r, n, o) {this._cu1_root_node = new i(e, t), this._cu2_root_node = new i(r, n), this._epsilon = o, this._overlaps = [];};s.prototype.process = function (e, t) {if (e._bx.intersectsWithTolerance(t._bx, this._epsilon)) {var r = e.canDivide(),n = t.canDivide(),o = e.isSimple() || !r,i = t.isSimple() || !n;if (o && i) this._overlaps.push([e, t]);else if (r && n) {e.divide(), t.divide();for (var s = 0; s < e._children.length; ++s) {for (var a = 0; a < t._children.length; ++a) {this.process(e._children[s], t._children[a]);}}} else if (r) for (e.divide(), s = 0; s < e._children.length; ++s) {this.process(e._children[s], t);} else if (n) for (t.divide(), s = 0; s < t._children.length; ++s) {this.process(e, t._children[s]);}}}, s.prototype.build = function () {this.process(this._cu1_root_node, this._cu2_root_node);}, t.SubCurveTree = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.RegionTopologyFace = t.RegionTopologyEdge = t.RegionTopologyVertex = void 0;var n = r(1),o = r(16),i = r(20),s = r(15),a = r(0),c = r(2),u = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),l = function l(e) {o.Vertex.call(this, e), this._associatedVertices = [];};(l.prototype = Object.create(o.Vertex.prototype)).setAssociatedEntities = function (e) {this._associatedVertices = u.default.clone(e);}, l.prototype.getAssociatedEntities = function () {return this._associatedVertices;};var h = function h(e) {i.Edge.call(this, e), this._sourceEdge = void 0, this._associatedEdges = [], this._isDangling = !1;};(h.prototype = Object.create(i.Edge.prototype)).setAssociatedEdges = function (e) {this._associatedEdges = e;}, h.prototype.getAssociatedEntities = function () {return u.default.map(this._associatedEdges, function (e) {return e.edge;});}, h.prototype.getAssociatedEdgeInfo = function () {return this._associatedEdges;}, h.prototype.setToEdgeSegment = function (e, t) {this._sourceEdge = e, this._curve = e.getCurve(), this._reversed = e.isReversed(), this.setRange(t);}, h.prototype.setIsDangling = function (e) {this._isDangling = e;}, h.prototype.isDangling = function () {return this._isDangling;}, h.prototype.getSourceEdge = function () {return this._sourceEdge;};var d = function d(e) {s.Face.call(this, e), this._danglingEdges = [];};(d.prototype = Object.create(s.Face.prototype)).addDanglingEdge = function (e) {this._danglingEdges.push(e);}, d.prototype.isPointInsideFace = function (e) {for (var t = 0, r = 0; r < this.getLoops().length; ++r) {for (var n = this.getLoops()[r], o = 0; o < n.getCoedges().length; ++o) {var i = n.getCoedges()[o];i.getEdge().isDangling() || (t += i.uvAngleSubtended(e));}}t = Math.abs(t);var s = Math.floor(t / (2 * Math.PI)),c = t - 2 * s * Math.PI;return !!(Math.abs(c) < a.PARAMETER_SPACE_TOLERANCE && s || Math.abs(c - 2 * Math.PI) < a.PARAMETER_SPACE_TOLERANCE);}, d.prototype.getRepresentativePoint = function () {var e,t,r = n.Vector3.createFloat64(),o = this.getBoundingBox(),i = (o.max[0] - o.min[0]) / 33,s = (o.max[1] - o.min[1]) / 33;for (e = 1; e < 32; ++e) {for (t = 1; t < 32; ++t) {if (r[0] = o.min[0] + i * e, r[1] = o.min[1] + s * t, this.isPointInsideFace(r)) return r;}}return c.ConsoleUtils.assert(!1), o.getCenter();}, d.prototype.getDanglingEdges = function () {return this._danglingEdges;}, t.RegionTopologyVertex = l, t.RegionTopologyEdge = h, t.RegionTopologyFace = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.matchRegionEdgeRecipe = t.deserializeRegionEdgeRecipe = t.serializeRegionEdgeRecipe = t.createRecipeFromRegionEdge = t.matchRegionFaceRecipe = t.deserializeRegionFaceRecipe = t.serializeRegionFaceRecipe = t.createRecipeFromRegionFace = void 0;var n = r(1),o = r(3),i = r(0),s = r(114),a = r(2),c = r(8),u = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),l = function l(e, t) {var r = u.default.filter(t.regionVertices, function (t) {return u.default.contains(t.getAssociatedEntities(), e.getStartVertex());});a.ConsoleUtils.assert(1 === r.length), r = r[0];var n = [],o = [],i = new Set(),s = r,c = void 0;if (s) do {n.push(s);var l = u.default.filter(s.getEdges(), function (t) {return t !== c && u.default.contains(t.getAssociatedEntities(), e) && !i.has(t);});if (0 === l.length) {a.ConsoleUtils.assert(!e.isClosed()), a.ConsoleUtils.assert(u.default.contains(s.getAssociatedEntities(), e.getEndVertex()));break;}var h = void 0;if (l.length > 1) {l.sort(function (e, t) {return e.t0() - t.t0();});for (var d = 0; d < l.length; d++) {if (l[d].getStartVertex() === s) {h = l[d];break;}}a.ConsoleUtils.assert(h);} else h = l[0];s = h.getOtherVertex(s), a.ConsoleUtils.assert(s), c = h, i.add(c), o.push(c);} while (s !== r);return { edges: o, vertices: n };},h = function h(e, t, r) {var o = [],s = u.default.filter(t, function (t) {return t !== e;});if (0 === s.length) ;else for (var a = r.vertices, c = 0; c < a.length; c++) {for (var l = a[c], h = !1, d = l.getEdges(), g = 0; g < d.length; g++) {if (u.default.intersection(s, d[g].getAssociatedEntities()).length > 0) {h = !0;break;}}h && o.push({ vertex: l, indexInTopology: c });}if (e.isClosed() && 2 === o.length && 1 === s.length) {var p = !1;if (s[0].getCurveType() === i.GEOMETRY_TYPES.LINE) {var f = s[0],v = f.closestToPointParam(o[0].vertex.getPosition());p = f.closestToPointParam(o[1].vertex.getPosition()) < v;} else if (e.getCurveType() === i.GEOMETRY_TYPES.CIRCLE && s[0].getCurveType() === i.GEOMETRY_TYPES.CIRCLE) {var _ = e.getCurve().getCenter(),y = n.Vector3.sub([0, 0, 0], s[0].getCurve().getCenter(), _);if (n.Vector3.length(y) > 0) {n.Vector3.normalize(y, y);var m = n.Vector3.sub([0, 0, 0], o[0].vertex.getPosition(), _),E = n.Vector3.sub([0, 0, 0], o[1].vertex.getPosition(), _),x = m.x * y.y - m.y * y.x,R = E.x * y.y - E.y * y.x;x > 0 && R < 0 && (p = !0);}}if (p) {var A = o[1];o[1] = o[0], o[0] = A;}}return o;},d = function d(e, t, r, n, o) {var i,a = {};a[e.getGuid()] = { dist: 0, prev: null, prevEdge: null, vertex: e, guid: e.getGuid() };var c = new s.BinaryHeap(function (e) {return e.dist;}, function (e) {return e.guid;});for (c.push(a[e.getGuid()]); 0 !== c.size();) {var l = c.pop();if (l === t) break;i = l.vertex.getEdges();for (var h = 0; h < i.length; h++) {var d = i[h].getOtherVertex(l.vertex);if (d && !n[i[h].getGuid()] && (!r[d.getGuid()] || d === t)) {for (var g = i[h].getEndVertex() === d, p = !1, f = i[h].getAssociatedEntities(), v = 0; v < o.length; v++) {if (u.default.contains(f, o[v].edge) && o[v].orientation === g) {p = !0;break;}}var _ = a[l.guid].dist;p || (_ += 1), void 0 === a[d.getGuid()] ? (a[d.getGuid()] = { dist: _, prev: l, prevEdge: i[h], vertex: d, guid: d.getGuid() }, c.push(a[d.getGuid()])) : a[d.getGuid()].dist > _ && (a[d.getGuid()].dist = _, a[d.getGuid()].prev = l, a[d.getGuid()].prevEdge = i[h], c.updated(a[d.getGuid()]));}}}var y = a[t.getGuid()];if (y) {i = [];for (var m = [], E = y, x = t; E.prevEdge;) {var R = E.prevEdge;i.push(R), E = E.prev, m.push(R.getEndVertex() === x), x = R.getOtherVertex(x);}return { dist: y.dist, edges: i.reverse(), orientations: m.reverse(), startVertex: e, endVertex: t };}return { dist: 1 / 0, edges: [] };},g = function g(e, t, r, n, i, s, a) {for (var c = e[i], l = {}, h = 0; h < c.length; h++) {null !== c[h].endVertex && (l[c[h].endVertex.getGuid()] ? l[c[h].endVertex.getGuid()].incomingEdges.push({ edge: c[h].edge, orientation: c[h].edgeOriented }) : l[c[h].endVertex.getGuid()] = { edgeIndex: h, edgeInfo: c[h], vertex: c[h].endVertex, incomingEdges: [{ edge: c[h].edge, orientation: c[h].edgeOriented }] });}if (u.default.values(l).length > 0) {var g = s.vertices,p = s.edges,f = u.default.keys(l),v = { dist: 1 / 0 },_ = n;do {_ = (0, o.modulus)(_ - 1, e.length);for (var y = u.default.keys(a[_]), m = 0; m < y.length; m++) {var E = a[_][y[m]].vertex;if (E) for (var x = 0; x < f.length; x++) {var R = l[f[x]].vertex,A = a[_][y[m]].outgoingEdges.concat(l[f[x]].incomingEdges),P = d(E, R, g, p, A);P.dist < v.dist && ((v = P).startIndex = _);}}} while (_ !== t && v.dist === 1 / 0);if (v.dist < 1 / 0) {var V = a[v.startIndex][v.startVertex.getGuid()],T = a[i][v.endVertex.getGuid()],C = V.cost + v.dist;(!T || C < T.cost || i === t && v.endVertex.getGuid() === r.getGuid() && null === T.previousGuid) && (a[i][v.endVertex.getGuid()] = { previousGuid: v.startVertex.getGuid(), edgeSegment: null, indexRange: [], cost: V.cost + v.dist, vertex: v.endVertex, previousIndex: v.startIndex, connectionEdges: v.edges, connectionOrientation: v.orientations, outgoingEdges: [] });}}},p = function p(e, t, r, n, i) {var s = [],a = e[t][r].endVertex;s[t] = {}, s[t][a.getGuid()] = { previousGuid: null, edgeSegment: null, previousIndex: null, cost: 0, vertex: a, outgoingEdges: [] };var c = t;do {var l = (0, o.modulus)(c + 1, e.length),h = e[l];s[l] = s[l] || {};for (var d = u.default.keys(s[c]), p = 0, f = 0; f < d.length; f++) {for (var v = d[f], _ = 0; _ < h.length; _++) {if (h[_].startVertices[v]) {s[c][v].outgoingEdges.push({ edge: h[_].edge, orientation: h[_].edgeOriented });var y = h[_].endVertex;if (null !== y) {var m = s[c][v].cost;h[_].edge.isClosed() || h[_].endVertexTopologyIndex > h[_].startVertices[v].vertexIndex !== h[_].edgeOriented && (m += 1), (!s[l][y.getGuid()] || s[l][y.getGuid()].cost > m || l === t && y.getGuid() === a.getGuid() && null === s[l][y.getGuid()].previousGuid) && (s[l][y.getGuid()] = { previousGuid: v, edgeSegment: h[_], indexRange: [h[_].startVertices[v].vertexIndex, h[_].endVertexTopologyIndex], cost: m, vertex: y, previousIndex: c, outgoingEdges: [] }, p++);} else m = s[c][v].cost, (!s[l][v] || s[l][v].cost > m) && (s[l][v] = { previousGuid: v, edgeSegment: h[_], indexRange: [], cost: m, previousIndex: c, outgoingEdges: [] });}}}0 === p && g(e, t, a, c, l, n, s), c = l;} while (c !== t);null !== s[t][a.getGuid()].previousGuid && s[t][a.getGuid()].cost < i.cost && (i.cost = s[t][a.getGuid()].cost, i.state = s, i.startGuid = a.getGuid());},f = function f(e, t) {for (var r = function (e, t) {var r = {},n = {},i = {},s = t;do {var a = (0, o.modulus)(s + 1, e.length),c = e[s],u = e[a],l = i;i = {};for (var h = 0; h < u.length; h++) {var d = u[h].topologyAlongEdge.vertices,g = u[h].topologyAlongEdge.edges;u[h].startVertices = {};var p = void 0,f = void 0,v = c.length;void 0 !== l[u[h].edge.getGuid()] && v++;for (var _ = 0; _ < v; _++) {var y = void 0;if (_ === c.length) y = l[u[h].edge.getGuid()];else {if (!c[_].endVertex) continue;y = c[_].endVertex.getGuid();}for (var m = void 0, E = 0; E < d.length; E++) {if (d[E].getGuid() === y) {m = E;break;}}void 0 !== m && (u[h].startVertices[y] = { vertex: d[m], vertexIndex: m }, null !== u[h].endVertex && (u[h].edgeOriented ? (p = void 0 !== p ? Math.min(p, m) : m, f = void 0 !== f ? Math.max(f, u[h].endVertexTopologyIndex) : u[h].endVertexTopologyIndex) : (p = void 0 !== p ? Math.max(p, m) : m, f = void 0 !== f ? Math.min(f, u[h].endVertexTopologyIndex) : u[h].endVertexTopologyIndex)), void 0 === i[u[h].edge.getGuid()] && (i[u[h].edge.getGuid()] = y));}if (void 0 !== p && void 0 !== f) {if (p !== f) {var x;x = u[h].edge.isClosed() ? u[h].edgeOriented ? 1 : -1 : p < f ? 1 : -1;var R = p;do {if (r[d[R].getGuid()] = d[R], x > 0) R !== f && (n[g[R].getGuid()] = g[R]);else {var A = (0, o.modulus)(R - 1, g.length);n[g[A].getGuid()] = g[A];}R = (0, o.modulus)(R + x, d.length);} while (R !== f);}r[d[f].getGuid()] = d[f];}}s = a;} while (s !== t);return { vertices: r, edges: n };}(e, t), n = { cost: 1 / 0, state: void 0, startGuid: void 0 }, i = 0; i < e[t].length; i++) {null !== e[t][i].endVertex && p(e, t, i, r, n);}if (n.cost === 1 / 0) return { edges: void 0, edgeOrientedFlags: void 0, score: 1 / 0 };var s = function (e, t) {var r = [],n = e.startGuid,i = t;do {r.push(e.state[i][n]);var s = e.state[i][n].previousIndex;n = e.state[i][n].previousGuid, i = s;} while (i !== t);r = r.reverse();var a = [],c = [];for (i = 0; i < r.length; i++) {if (0 !== r[i].indexRange.length) {var u,l,h,d,g = r[i].edgeSegment.topologyAlongEdge;r[i].indexRange[0] < r[i].indexRange[1] ? (u = r[i].indexRange[0], l = r[i].indexRange[1], r[i].edgeSegment.edge.isClosed() && !r[i].edgeSegment.edgeOriented ? (h = -1, u = (0, o.modulus)(r[i].indexRange[0] - 1, g.edges.length), l = (0, o.modulus)(r[i].indexRange[1] - 1, g.edges.length), d = !1) : (h = 1, u = (0, o.modulus)(r[i].indexRange[0], g.edges.length), l = (0, o.modulus)(r[i].indexRange[1], g.edges.length), d = !0)) : r[i].edgeSegment.edge.isClosed() && r[i].edgeSegment.edgeOriented ? (h = 1, u = (0, o.modulus)(r[i].indexRange[0], g.edges.length), l = (0, o.modulus)(r[i].indexRange[1], g.edges.length), d = !0) : (h = -1, u = (0, o.modulus)(r[i].indexRange[0] - 1, g.edges.length), l = (0, o.modulus)(r[i].indexRange[1] - 1, g.edges.length), d = !1);var p = u;do {a.push(g.edges[p]), c.push(d), p = (0, o.modulus)(p + h, g.edges.length);} while (p !== l);} else if (r[i].connectionEdges) for (p = 0; p < r[i].connectionEdges.length; p++) {a.push(r[i].connectionEdges[p]), c.push(r[i].connectionOrientation[p]);}}return { topologyEdges: a, edgeOrientedFlags: c };}(n, t);return { edges: s.topologyEdges, edgeOrientedFlags: s.edgeOrientedFlags, score: n.cost };},v = function v(e, t) {var r,n = function (e, t) {for (var r = [], n = 0; n < e.length; n++) {for (var o = e[n], i = [], s = 0; s < o.length; s++) {var a = o[s],c = t.sketchEdges[a.edgeRef];c && i.push({ edgeRef: a.edgeRef, edgeOriented: a.edgeOriented, intersectionNumber: a.intersectionNumber, totalIntersections: a.totalIntersections, edge: c, topologyAlongEdge: l(c, t), endVertex: null, endVertexTopologyIndex: null });}r.push(i);}return r;}(e, t);if (c.DebugUtils.level("region_match") >= 2) {var o = u.default.pluck(u.default.flatten(n), "edge");for (r = 0; r < o.length; r++) {c.DebugUtils.drawEdge3D(o[r], { color: 0, render: !1 });}c.DebugUtils.render();}if (function (e) {for (var t = 0; t < e.length; t++) {for (var r = u.default.pluck(e[(t + 1) % e.length], "edge"), n = 0; n < e[t].length; n++) {var o = e[t][n],i = h(o.edge, r, o.topologyAlongEdge);if (0 === o.totalIntersections) o.endVertex = null;else if (i.length === o.totalIntersections) {var s = i[o.intersectionNumber];o.endVertexTopologyIndex = s.indexInTopology, o.endVertex = s.vertex;} else 0 === i.length || c.DebugUtils.warn("Region matching problem! Intersection counts do not match"), o.endVertex = null;}}}(n), c.DebugUtils.level("region_match") >= 2) {var i = u.default.pluck(u.default.flatten(n), "endVertex");for (r = 0; r < i.length; r++) {null !== i[r] && c.DebugUtils.drawVertex3D(i[r], { color: 65280, render: !1 });}c.DebugUtils.render();}var s = function (e) {for (var t = 1 / 0, r = void 0, n = 0; n < e.length; n++) {var o = e[n];if (0 !== o.length) {for (var i = 0, s = 0; s < o.length; s++) {null !== o[s].endVertex && i++;}var a = o.length - i;if (0 === a) return n;i > 0 && a < t && (t = a, r = n);}}return r;}(n);if (void 0 === s) {for (var a = 0; a < n[0].length; a++) {var d = n[0][a].edge;if (d.isClosed() && u.default.all(n, function (e) {for (var t = 0; t < e.length; t++) {if (e[t].edge === d) return !0;}return !1;})) {var g = n[0][a].topologyAlongEdge.edges,p = new Array(g.length);for (r = 0; r < p.length; r++) {p[r] = n[0][a].edgeOriented;}return n[0][a].edgeOriented || g.reverse(), c.DebugUtils.level("region_match") >= 2 && c.DebugUtils.drawEdge3D(d, { color: 16711680 }), { edges: g, edgeOrientedFlags: p, matchStatus: 2 };}}return { edges: void 0, edgeOrientedFlags: void 0, matchStatus: 0 };}var v,_ = f(n, s);if (c.DebugUtils.level("region_match") >= 2 && void 0 !== _.edges) {for (r = 0; r < _.edges.length; r++) {c.DebugUtils.drawEdge3D(_.edges[r], { color: 16711680, render: !1 });}c.DebugUtils.render();}return v = 0 === _.score ? 2 : _.score === 1 / 0 ? 0 : 1, { edges: _.edges, edgeOrientedFlags: _.edgeOrientedFlags, matchStatus: v };},_ = function _(e, t) {if (!e || !e.edges) return new Set();for (var r = new Set(), n = 0; n < e.edges.length; n++) {var o = e.edgeOrientedFlags[n] === t,i = e.edges[n].getCoedges();a.ConsoleUtils.assert(i.length >= 1 && i.length <= 2);for (var s = void 0, c = 0; c < i.length; c++) {if (i[c].isReversed() === o) {s = i[c].getFace();break;}}s && !r.has(s) && r.add(s);}var u = new Set(e.edges);return r.forEach(function (e) {for (var t = Array.from(e.collectEdges()), n = 0; n < t.length; n++) {var o = t[n];if (!u.has(o)) {var i = void 0,s = o.getFaces();a.ConsoleUtils.assert(s.length >= 1 && s.length <= 2), 1 === s.length ? a.ConsoleUtils.assert(s[0] === e) : 2 === s.length && (a.ConsoleUtils.assert(s[0] === e || s[1] === e), i = s[0] === e ? s[1] : s[0]), i && !r.has(i) && r.add(i);}}}), r;};t.createRecipeFromRegionFace = function (e, t) {for (var r = [], n = e.getLoops(), o = 0; o < n.length; o++) {for (var i = n[o].getCoedges(), s = [], a = 0; a < i.length; a++) {for (var c = i[a], d = c.getEdge().getAssociatedEdgeInfo(), g = c.getEndVertex(), p = i[(a + 1) % i.length].getEdge().getAssociatedEdgeInfo(), f = u.default.pluck(p, "edge"), v = [], _ = 0; _ < d.length; _++) {for (var y = l(d[_].edge, t), m = h(d[_].edge, f, y), E = 0, x = 0; x < m.length; x++) {if (m[x].vertex === g) {E = x;break;}}var R = { edgeRef: d[_].edge.getGuid(), edgeOriented: !(c.isReversed() ^ d[_].flipped), intersectionNumber: E, totalIntersections: m.length, edge: d[_].edge };v.push(R);}s.push(v);}r.push(s);}return r;}, t.serializeRegionFaceRecipe = function (e) {for (var t = [], r = 0; r < e.length; r++) {for (var n = [], o = e[r], i = 0; i < o.length; i++) {for (var s = [], a = o[i], c = 0; c < a.length; c++) {var u = a[c];s.push(u.edgeRef + "_" + (u.edgeOriented ? "t" : "f") + "_" + u.intersectionNumber + "_" + u.totalIntersections);}n.push(s.join(";"));}t.push(n.join("+"));}return t.join("/");}, t.deserializeRegionFaceRecipe = function (e) {for (var t = e.split("/"), r = 0; r < t.length; r++) {t[r] = t[r].split("+");for (var n = t[r], o = 0; o < n.length; o++) {n[o] = n[o].split(";");for (var i = n[o], s = 0; s < i.length; s++) {var a = i[s].split("_");i[s] = { edgeRef: a[0], edgeOriented: "t" === a[1], intersectionNumber: parseInt(a[2], 10), totalIntersections: parseInt(a[3], 10) };}}}return t;}, t.matchRegionFaceRecipe = function (e, t) {var r,n,o,i = 2,s = [];for (r = 0; r < e.length; r++) {var a = v(e[r], t);if (0 === a.matchStatus && 0 === r) return { regions: [], matchStatus: 0 };2 !== a.matchStatus && (i = 1), s.push(a);}if (c.DebugUtils.level("region_match") > 0) {for (c.DebugUtils.clearView(), o = u.default.values(t.sketchEdges), r = 0; r < o.length; r++) {c.DebugUtils.drawEdge3D(o[r], { color: 0, render: !1 });}for (r = 0; r < s.length; r++) {for (n = 0; n < s[r].edges.length; n++) {var l = 0 === r ? 65280 : 16711680;c.DebugUtils.drawEdge3D(s[r].edges[n], { color: l, render: !1 });}}c.DebugUtils.render();}var h = _(s[0], !1);for (n = 1; n < s.length; n++) {_(s[n], !0).forEach(function (e) {h.delete(e);});}if (h = Array.from(h), c.DebugUtils.level("region_match") > 0) {for (r = 0; r < h.length; r++) {for (o = Array.from(h[r].collectEdges()), n = 0; n < o.length; n++) {c.DebugUtils.drawEdge3D(o[n], { color: 13684736, render: !1 });}}c.DebugUtils.render();}return { regions: h, matchStatus: i };}, t.createRecipeFromRegionEdge = function (e, t) {var r,n,o = { startEdgeRefs: [], endEdgeRefs: [], edgeRef: [], edgeOriented: [], intersectionNumberStart: [], totalIntersectionsStart: [], intersectionNumberEnd: [], totalIntersectionsEnd: [] },i = e.getStartVertex(),s = [];i.getOtherEdges(e).forEach(function (e) {var t = u.default.pluck(e.getAssociatedEdgeInfo(), "edge");for (r = 0; r < t.length; r++) {s.indexOf(t[r]) < 0 && (s.push(t[r]), o.startEdgeRefs.push(t[r].getGuid()));}});var a = e.getEndVertex(),c = [];a.getOtherEdges(e).forEach(function (e) {var t = u.default.pluck(e.getAssociatedEdgeInfo(), "edge");for (r = 0; r < t.length; r++) {c.indexOf(t[r]) < 0 && (c.push(t[r]), o.endEdgeRefs.push(t[r].getGuid()));}});var d = e.getAssociatedEdgeInfo(),g = u.default.pluck(d, "edge");for (r = 0; r < d.length; r++) {var p = g[r],f = !d[r].flipped,v = l(p, t),_ = u.default.unique(s.concat(g)),y = h(p, _, v),m = 0;for (n = 0; n < y.length; n++) {if (y[n].vertex === i) {m = n;break;}}var E = u.default.unique(c.concat(g)),x = h(p, E, v),R = 0;for (n = 0; n < x.length; n++) {if (x[n].vertex === a) {R = n;break;}}o.edgeRef.push(p.getGuid()), o.edgeOriented.push(f), o.intersectionNumberStart.push(m), o.totalIntersectionsStart.push(y.length), o.intersectionNumberEnd.push(R), o.totalIntersectionsEnd.push(x.length);}return o;}, t.serializeRegionEdgeRecipe = function (e) {var t = { edge: e.edgeRef, orient: e.edgeOriented, start: e.startEdgeRefs, end: e.endEdgeRefs, sIdx: e.intersectionNumberStart, sNum: e.totalIntersectionsStart, eIdx: e.intersectionNumberEnd, eNum: e.totalIntersectionsEnd };return JSON.stringify(t);}, t.deserializeRegionEdgeRecipe = function (e) {var t = JSON.parse(e);return { edgeRef: t.edge, edgeOriented: t.orient, startEdgeRefs: t.start, endEdgeRefs: t.end, intersectionNumberStart: t.sIdx, totalIntersectionsStart: t.sNum, intersectionNumberEnd: t.eIdx, totalIntersectionsEnd: t.eNum };}, t.matchRegionEdgeRecipe = function (e, t) {var r = [],n = 0,o = [];e.startEdgeRefs.forEach(function (e) {var r = t.sketchEdges[e];r && o.push(r);});var i = [];e.endEdgeRefs.forEach(function (e) {var r = t.sketchEdges[e];r && i.push(r);}), e.edgeRef.forEach(function (e) {var r = t.sketchEdges[e];r && o.indexOf(r) < 0 && o.push(r), r && i.indexOf(r) < 0 && i.push(r);});for (var s = 0; s < e.edgeRef.length; s++) {var a = t.sketchEdges[e.edgeRef[s]];if (a) {var u = l(a, t),d = void 0,g = void 0,p = h(a, o, u);if (0 === e.totalIntersectionsStart[s]) d = u.vertices[0], g = 0;else if (p.length === e.totalIntersectionsStart[s]) {var f = p[e.intersectionNumberStart[s]];d = f.vertex, g = f.indexInTopology;}var v = void 0,_ = void 0,y = h(a, i, u);if (0 === e.totalIntersectionsEnd[s]) v = u.vertices[0], _ = u.vertices.length;else if (y.length === e.totalIntersectionsEnd[s]) {var m = y[e.intersectionNumberEnd[s]];v = m.vertex, 0 === (_ = m.indexInTopology) && a.isClosed() && (_ = u.vertices.length);}if (!e.edgeOriented[s]) {var E = d;d = v, v = E, E = g, g = _, _ = E;}if (d && v) {if (!(g >= _)) {r = u.edges.slice(g, _), n = 2;break;}c.DebugUtils.warn("Edge recipe match should find start vertex before end vertex");}}}return { edges: r, matchStatus: n };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = function n(e, t) {this.content = [], this.scoreFunction = e, this.lookupFunction = t, this.lookupFunction && (this.nodeDict = {});};n.prototype = { push: function push(e) {this.content.push(e), this.lookupFunction && (this.nodeDict[this.lookupFunction(e)] = this.content.length - 1), this.bubbleUp(this.content.length - 1);}, pop: function pop() {var e = this.content[0],t = this.content.pop();return this.content.length > 0 && (this.content[0] = t, this.lookupFunction && (this.nodeDict[this.lookupFunction(t)] = 0), this.sinkDown(0)), this.lookupFunction && delete this.nodeDict[this.lookupFunction(e)], e;}, peek: function peek() {return this.content[0];}, getNodeIndex: function getNodeIndex(e) {if (this.lookupFunction) return this.nodeDict[this.lookupFunction(e)];for (var t = this.content.length, r = 0; r < t; r++) {if (this.content[r] === e) return r;}throw new Error("Node not found.");}, updated: function updated(e) {var t = this.getNodeIndex(e),r = this.scoreFunction(e),n = Math.floor((t + 1) / 2) - 1,o = this.content[n];if (t > 0 && r < this.scoreFunction(o)) this.bubbleUp(t);else {var i = 2 * (t + 1),s = i - 1,a = this.content[s],c = this.content[i];(a && r > this.scoreFunction(a) || c && r > this.scoreFunction(c)) && this.sinkDown(t);}}, remove: function remove(e) {var t = this.content.length,r = this.getNodeIndex(e),n = this.content.pop();r !== t - 1 && (this.content[r] = n, this.scoreFunction(n) < this.scoreFunction(e) ? this.bubbleUp(r) : this.sinkDown(r));}, size: function size() {return this.content.length;}, bubbleUp: function bubbleUp(e) {for (var t = this.content[e]; e > 0;) {var r = Math.floor((e + 1) / 2) - 1,n = this.content[r];if (!(this.scoreFunction(t) < this.scoreFunction(n))) break;this.content[r] = t, this.content[e] = n, this.lookupFunction && (this.nodeDict[this.lookupFunction(t)] = r, this.nodeDict[this.lookupFunction(n)] = e), e = r;}}, sinkDown: function sinkDown(e) {for (var t = this.content.length, r = this.content[e], n = this.scoreFunction(r);;) {var o = 2 * (e + 1),i = o - 1,s = null;if (i < t) {var a = this.content[i],c = this.scoreFunction(a);c < n && (s = i);}if (o < t) {var u = this.content[o];this.scoreFunction(u) < (null === s ? n : c) && (s = o);}if (null === s) break;this.content[e] = this.content[s], this.content[s] = r, this.lookupFunction && (this.nodeDict[this.lookupFunction(this.content[e])] = e, this.nodeDict[this.lookupFunction(this.content[s])] = s), e = s;}} }, t.BinaryHeap = n;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createBlock = void 0;var n = r(28),o = r(83),i = r(0),s = r(2);t.createBlock = function (e, t) {var r = [Math.min(e[0], t[0]), Math.min(e[1], t[1]), Math.min(e[2], t[2])],a = [Math.max(e[0], t[0]), Math.max(e[1], t[1]), Math.max(e[2], t[2])];s.ConsoleUtils.assert(a[0] - r[0] > i.KERNEL_TOLERANCE, "block is degenerate in x axis"), s.ConsoleUtils.assert(a[1] - r[1] > i.KERNEL_TOLERANCE, "block is degenerate in y axis"), s.ConsoleUtils.assert(a[2] - r[2] > i.KERNEL_TOLERANCE, "block is degenerate in z axis");var c = [[r[0], r[1], r[2]], [a[0], r[1], r[2]], [a[0], a[1], r[2]], [r[0], a[1], r[2]]],u = (0, n.createFaceFromPolyline)(c),l = a[2] - r[2];return (0, o.extrudeFace)(u, l);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createCylinder = t.createCone = void 0;var n = r(1),o = r(28),i = r(0),s = r(18),a = r(51),c = r(38),u = r(39),l = r(52),h = r(13),d = r(15),g = r(26),p = r(25),f = r(24),v = r(2),_ = function _(e, t, r, _2, y, m) {var E = e,x = t,R = Math.abs(r),A = void 0 === _typeof(_2) ? R : Math.abs(_2);if (R < i.KERNEL_TOLERANCE) {E = t, x = e;var P = R;R = A, A = P;}v.ConsoleUtils.assert(R > i.KERNEL_TOLERANCE);var V = n.Vector3.createFloat64();n.Vector3.subtract(V, x, E);var T = n.Vector3.length(V);v.ConsoleUtils.assert(T > i.KERNEL_TOLERANCE), n.Vector3.scale(V, V, 1 / T);var C = A - R,b = Math.abs(C) > i.KERNEL_TOLERANCE,L = 0;b && (L = Math.atan2(C, T));var O,S = n.Vector3.createFloat64();m && n.Vector3.subtract(S, m, n.Vector3.scale(S, V, n.Vector3.dot(m, V))), (!m || n.Vector3.squaredLength(S) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE) && n.Vector3.computeOrthogonal(S, V), n.Vector3.normalize(S, S), n.Vector3.scale(S, S, R);var M = y || 1;v.ConsoleUtils.assert(M > 0 && M <= 1);var w = Math.max(R, A);Math.abs(w * (1 - M)) < i.KERNEL_TOLERANCE ? b ? (O = new a.Cone()).set(E, R, V, L, S, 1) : (O = new c.Cylinder()).set(E, R, V, S, 1) : b ? (O = new l.EllipticalCone()).set(E, S, M, V, L, 1) : (O = new u.EllipticalCylinder()).set(E, S, M, V, 1);var N = [0, T / Math.cos(L)];O.limitRangeU(N);var F = (0, o.makeConeOrCylinderVParamLoop)(O, N[0]),I = (0, o.makeConeOrCylinderVParamLoop)(O, N[1]);F.getCoedges()[0].setReversed(!0);var D = [];D[0] = new d.Face(), D[0].setSurface(O), D[0].addLoops([F, I]);var j = F.getCoedges()[0].getEdge();if (j.getCurve()) {var B = new h.Loop();B.addCoedge((0, o.createCoedgeOnEdge)(j)), (G = new d.Face()).addLoop(B);var U = new s.Plane();U.set(E, V), G.setSurface(U), G.setReversed(!0), D.push(G), v.ConsoleUtils.assert(B.getCoedges()[0].uvAngleSubtended(E) < -i.KERNEL_TOLERANCE);}var k = I.getCoedges()[0].getEdge();if (k.getCurve()) {var G,z = new h.Loop();z.addCoedge((0, o.createCoedgeOnEdge)(k)), (G = new d.Face()).addLoop(z);var Y = new s.Plane();Y.set(x, V), G.setSurface(Y), D.push(G), v.ConsoleUtils.assert(z.getCoedges()[0].uvAngleSubtended(x) < -i.KERNEL_TOLERANCE);}var K = new g.Shell();K.addFaces(D);var q = new p.Lump();q.addShell(K);var W = new f.Body();return W.addLump(q), W;};t.createCone = _, t.createCylinder = function (e, t, r, n, o) {return _(e, t, r, r, n, o);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createPolyhedron = void 0;var n = r(24),o = r(25),i = r(15),s = r(13),a = r(16),c = r(18),u = r(6),l = r(28),h = r(3),d = r(2),g = r(8);function p(e, t) {var r,n = e.getCommonEdges(t);d.ConsoleUtils.assert(n.length <= 1), r = 0 === n.length ? (0, l.createLineEdgeBetweenVertices)(e, t) : n[0];var o = (0, l.createCoedgeOnEdge)(r);return d.ConsoleUtils.assert(o.getStartVertex() === e), d.ConsoleUtils.assert(o.getEndVertex() === t), o;}function f(e, t) {var r,n = [];for (r = 0; r < t.length; ++r) {n[r] = e[t[r]];}var o = (0, h.definePlaneThroughPoints)(n);if (o) {var i = new c.Plane();return i.set(o.origin, o.normal, o.uAxis), i.limitRangeU(o.uRange), i.limitRangeV(o.vRange), i;}g.DebugUtils.warn("Face is degenerate");}t.createPolyhedron = function (e, t) {var r,c = [];for (r = 0; r < e.length; ++r) {var h = new a.Vertex(new u.Point(e[r]));c.push(h);}var g = [];for (r = 0; r < t.length; ++r) {var v = t[r];d.ConsoleUtils.assert(v.length >= 3);for (var _ = new s.Loop(), y = [], m = 0; m < v.length; ++m) {var E = v[m],x = v[(m + 1) % v.length];d.ConsoleUtils.assert(E >= 0 && E < e.length), d.ConsoleUtils.assert(x >= 0 && x < e.length);var R = p(c[E], c[x]);y.push(R);}_.addCoedges(y);var A = f(e, v),P = new i.Face(A);P.addLoop(_), g.push(P);}var V = (0, l.createShellsFromFaces)(g),T = [];for (r = 0; r < V.length; ++r) {T[r] = new o.Lump(), T[r].addShell(V[r]);}var C = new n.Body();return C.addLumps(T), C;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TopologyStitcher = void 0;var n = r(1),o = r(119),i = r(41),s = r(2),a = function a() {this._shellSet = new Set(), this._lumpSet = new Set(), this._bodySet = new Set(), this._wireSet = new Set(), this._progenitorMap = new i.ProgenitorMap();};a.prototype.initMerge = function () {this._shellSet.clear(), this._lumpSet.clear(), this._bodySet.clear(), this._wireSet.clear();}, a.prototype.getEdgeOwnerToMerge = function (e) {var t = e.getWire();if (t) this._wireSet.add(t);else {var r = function (e) {var t = e.getCoedge();if (t) {var r = t.getFace();if (r) return r.getShell();}}(e);r && this._shellSet.add(r);}}, a.prototype.getVertexOwnerToMerge = function (e) {var t = e.getEdges();t.length > 0 && this.getEdgeOwnerToMerge(t[0]);}, a.prototype.stitchVertices = function (e, t) {var r;this.initMerge();var n = void 0;for (r = 0; r < e.length; ++r) {if (!t || !t.has(e[r])) {n = e[r];break;}}s.ConsoleUtils.assert(n);var o = [];for (r = 0; r < e.length; ++r) {if (this.getVertexOwnerToMerge(e[r]), e[r] !== n) {for (var i = e[r], a = i.getEdges().slice(0), c = 0; c < a.length; ++c) {var u = a[c];u.getStartVertex() === i && u.setStartVertex(n), u.getEndVertex() === i && u.setEndVertex(n);}s.ConsoleUtils.assert(0 === i.getEdges().length), t && t.has(i) || o.push(i);}}o.length > 0 && this._progenitorMap.addEntry(n, o), this.mergeTopology();}, a.prototype.stitchEdges = function (e, t) {var r,o = e[0];for (r = 0; r < e.length; ++r) {if (!t || !t.has(e[r])) {o = e[r];break;}}var i = [],s = [];for (r = 0; r < e.length; ++r) {var a = e[r],c = !1;if (a.getStartVertex() !== o.getStartVertex() && a.getStartVertex() === o.getEndVertex()) {var u = a.evaluateDt(a.t0()),l = o.evaluateDt(o.t1());n.Vector3.dot(u, l) < 0 && (c = !0);}for (var h = a.getCoedge(); h;) {i.push(h), c && h.setReversed(!h.isReversed()), (h = h.getPartner()) === a.getCoedge() && (h = void 0);}a !== o && (a.setStartVertex(null), a.setEndVertex(null), s.push(a));}for (this.initMerge(), r = 0; r < i.length; ++r) {var d = i[r];this.getEdgeOwnerToMerge(d.getEdge()), d.setEdge(o);var g = (r + 1) % i.length;d.setPartner(i[g]);}this.mergeTopology(), this._progenitorMap.addEntry(o, s);}, a.prototype.mergeTopology = function () {if (this._shellSet.size > 1 && this.mergeShells(), this._wireSet.size > 1) throw new Error("Merging wires in TopologyStitcher is not yet supported.");}, a.prototype.mergeShells = function () {var e = new i.ProgenitorMap();if (this._shellSet.size > 1) {var t = Array.from(this._shellSet),r = t[0],n = r.getLump();n && this._lumpSet.add(n);for (var o = 1; o < t.length; ++o) {var s = t[o];r.addFaces(s.getFaces()), s.setFaces([]), (n = s.getLump()) && (n.removeShell(s), this._lumpSet.add(n));}e.addEntry(r, t.slice(1));}if (this._lumpSet.size > 1) {var a = Array.from(this._lumpSet),c = a[0],u = c.getBody();for (u && this._bodySet.add(u), o = 1; o < a.length; ++o) {var l = a[o];c.addShells(l.getShells()), l.setShells([]), (u = l.getBody()) && (u.removeLump(l), this._bodySet.add(u));}e.addEntry(c, a.slice(1));}if (this._bodySet.size > 1) {var h = Array.from(this._bodySet),d = h[0];for (o = 1; o < h.length; ++o) {for (var g = h[o], p = g.getLumps().slice(0), f = 0; f < p.length; ++f) {p[f].getShells().length > 0 && d.addLump(p[f]);}g.setLumps([]);}e.addEntry(d, h.slice(1));}e.size() > 0 && (this._progenitorMap = e.collapseMaps(this._progenitorMap, { keepIntermediates: !0, keepAllDescendants: !0 }));}, a.prototype.getProgenitorMap = function () {return this._progenitorMap;}, a.prototype.stitchTwoEdgeSets = function (e, t) {var r = new o.MatchFinder();r.setEdges(e, t), r.compute();for (var n = r.getVertexMatches(), i = r.getEdgeMatches(), s = r.getNewVertices(), a = new Set(r.getEdgeProgenitors().getAllNewTopology()), c = 0; c < n.length; ++c) {this.stitchVertices(n[c], s);}for (c = 0; c < i.length; ++c) {this.stitchEdges(i[c], a);}this._progenitorMap = this._progenitorMap.collapseMaps(r.getEdgeProgenitors(), { keepIntermediates: !1, keepAllDescendants: !0 });}, a.prototype.stitchTwoTopology = function (e, t) {s.ConsoleUtils.assert("function" == typeof e.collectEdges), s.ConsoleUtils.assert("function" == typeof t.collectEdges);var r = e.collectEdges(),n = t.collectEdges();this.stitchTwoEdgeSets(r, n);}, a.prototype.stitchEdgeSet = function (e) {this.stitchTwoEdgeSets(e, e);}, t.TopologyStitcher = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.MatchFinder = void 0;var n = r(1),o = r(0),i = r(120),s = r(82),a = r(41),c = r(2),u = function u() {this._edges1 = [], this._edges2 = [], this._verts1 = [], this._verts2 = [], this._vertexMatchMap = new Map(), this._edgeMatchMap = new Map(), this._sameEdgeLists = !1, this._newVertices = new Set(), this._edgeProgenitors = new a.ProgenitorMap();};u.prototype.addMergeToMap = function (e, t, r) {var n = r.get(e),o = r.get(t);if (n && !o) n.push(t), r.set(t, n);else if (!n && o) o.push(e), r.set(e, o);else if (n || o) {if (n && o && n !== o) for (var i = 0; i < o.length; ++i) {n.push(o[i]), r.set(o[i], n);}} else {var s = [e, t];r.set(e, s), r.set(t, s);}}, u.prototype.addVertexMerge = function (e, t) {this.addMergeToMap(e, t, this._vertexMatchMap);}, u.prototype.addEdgeMerge = function (e, t) {this.addMergeToMap(e, t, this._edgeMatchMap);}, u.prototype.verticesMatch = function (e, t) {var r = Math.max(e.getPrecision(), t.getPrecision(), o.KERNEL_TOLERANCE);return n.Vector3.squaredDistance(e.getPosition(), t.getPosition()) < r * r;}, u.prototype.findEdgeSplitParam = function (e, t) {var r = e.getStartVertex();if (r !== t) {var i = e.getEndVertex();if (i !== t) {var s = this._vertexMatchMap.get(r);if (!s || -1 === s.indexOf(t)) {var a = this._vertexMatchMap.get(i);if (!a || -1 === a.indexOf(t)) {var c = t.getPosition(),u = Math.max(t.getPrecision(), o.KERNEL_TOLERANCE),l = e.closestToPointParam(c);if (void 0 !== l) {var h = e.evaluatePosition(l);if (!(n.Vector3.squaredDistance(c, h) > u * u)) return { param: l, position: h };}}}}}}, u.prototype.matchVertices = function () {for (var e = new Set(), t = 0; t < this._edges1.length; ++t) {this._edges1[t].collectVertices(e);}this._verts1 = Array.from(e);var r = new Set();for (t = 0; t < this._edges2.length; ++t) {this._edges2[t].collectVertices(r);}this._verts2 = Array.from(r);var n = this;e.forEach(function (e) {r.forEach(function (t) {e !== t && n.verticesMatch(e, t) && n.addVertexMerge(e, t);});});}, u.prototype.findVertexOnEdgeSplits = function (e, t) {for (var r = t.length, n = 0; n < r; ++n) {for (var o = t[n], i = [], s = 0; s < e.length; ++s) {var a = e[s],c = this.findEdgeSplitParam(o, a);c && i.push({ vertex: a, param: c.param, position: c.position });}if (i.length > 0) {var u = this.splitEdgeAtParams(o, i);if (u.length > 0) {t[n] = u[0];for (var l = 1; l < u.length; ++l) {t.push(u[l]);}}}}}, u.prototype.doEdgeSplits = function () {this.findVertexOnEdgeSplits(this._verts1, this._edges2), this._sameEdgeLists || this.findVertexOnEdgeSplits(this._verts2, this._edges1);}, u.prototype.splitEdgeAtParams = function (e, t) {t.sort(function (e, t) {return e.param - t.param;});for (var r = [], s = e, a = 0; a < t.length; ++a) {var c = t[a].vertex,u = t[a].param,l = t[a].position,h = s.getStartVertex().getPosition();if (n.Vector3.squaredDistance(l, h) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) this.addVertexMerge(c, s.getStartVertex());else {0 === r.length && (s = (0, i.replaceEdge)(s), r.push(s), this._edgeProgenitors.addEntry(s, [e]));var d = (0, i.splitEdge)(s, u, l);r.push(d), this._edgeProgenitors.addEntry(d, [e]);var g = d.getStartVertex();this.addVertexMerge(c, g), this._newVertices.add(g), s = d;}}return r;}, u.prototype.edgesMatch = function (e, t) {return (0, s.edgesAreCoincident)(e, t);}, u.prototype.matchEdges = function () {for (var e = 0; e < this._edges1.length; ++e) {for (var t = this._edges1[e], r = t.getStartVertex(), n = t.getEndVertex(), o = 0; o < this._edges2.length; ++o) {var i = this._edges2[o],s = i.getStartVertex(),a = i.getEndVertex();if (!(this._sameEdgeLists && o <= e) && t !== i) {var c,u = r === s || r === a;if (!u) {var l = this._vertexMatchMap.get(r);l && (u = l === this._vertexMatchMap.get(s) || l === this._vertexMatchMap.get(a));}if (u && !(c = n === s || n === a)) {var h = this._vertexMatchMap.get(n);h && (c = h === this._vertexMatchMap.get(s) || h === this._vertexMatchMap.get(a));}u && c && this.edgesMatch(t, i) && this.addEdgeMerge(t, i);}}}}, u.prototype.setEdges = function (e, t) {e instanceof Set ? this._edges1 = Array.from(e) : e instanceof Array && (this._edges1 = e), t && t !== e ? t instanceof Set ? this._edges2 = Array.from(t) : t instanceof Array && (this._edges2 = t) : this._edges2 = this._edges1, this._sameEdgeLists = this._edges1 === this._edges2, c.ConsoleUtils.assert(this._edges1 && this._edges2);}, u.prototype.compute = function () {this.matchVertices(), this.doEdgeSplits(), this.matchEdges();}, u.prototype.getVertexMatches = function () {var e = new Set();return this._vertexMatchMap.forEach(function (t, r) {e.add(t);}), Array.from(e);}, u.prototype.getEdgeMatches = function () {var e = new Set();return this._edgeMatchMap.forEach(function (t, r) {e.add(t);}), Array.from(e);}, u.prototype.getNewVertices = function () {return this._newVertices;}, u.prototype.getEdgeProgenitors = function () {return this._edgeProgenitors;}, t.MatchFinder = u;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.replaceEdge = t.splitEdge = void 0;var n = r(16),o = r(20),i = r(27),s = r(6),a = function a(e, t) {var r = new i.Coedge();r.setEdge(t), e.getEdge().getCoedge() === e && t.setCoedge(r), r.setReversed(e.isReversed()), r.setLoop(e.getLoop());var n = e.getLoop().getCoedges(),o = n.indexOf(e);return r.isReversed() ? n.splice(o, 0, r) : n.splice((o + 1) % n.length, 0, r), r;};t.splitEdge = function (e, t, r) {var i = new n.Vertex(new s.Point(r)),c = [e.getRange()[0], e.getRange()[1]],u = e.getEndVertex();e.setRange([c[0], t]), e.setEndVertex(i);var l = new o.Edge();l.setCurve(e.getCurve()), l.setReversed(e.isReversed()), l.setRange([t, c[1]]), l.setStartVertex(i), l.setEndVertex(u), l.setPrecision(e.getPrecision()), l.setWire(e.getWire());for (var h = [], d = e.getCoedge(); d;) {h.push(a(d, l)), (d = d.getPartner()) === e.getCoedge() && (d = void 0);}for (var g = 0; g < h.length; ++g) {var p = (g + 1) % h.length;h[g].setPartner(h[p]);}if (l.getWire()) {var f = l.getWire().getEdges().slice(),v = f.indexOf(e);f.splice(v + 1, 0, l), l.getWire().setEdges(f);}return l;}, t.replaceEdge = function (e) {var t = new o.Edge();t.setCurve(e.getCurve()), t.setReversed(e.isReversed()), t.setRange([e.getRange()[0], e.getRange()[1]]), t.setStartVertex(e.getStartVertex()), t.setEndVertex(e.getEndVertex()), t.setPrecision(e.getPrecision()), t.setCoedge(e.getCoedge()), t.setWire(e.getWire()), e.setStartVertex(null), e.setEndVertex(null), e.setCoedge(void 0), e.setWire(void 0);for (var r = t.getCoedge(); r;) {r.setEdge(t), (r = r.getPartner()) === t.getCoedge() && (r = void 0);}if (t.getWire()) {var n = t.getWire().getEdges().slice();n[n.indexOf(e)] = t, t.getWire().setEdges(n);}return t;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.svgFromWire = void 0;var n = r(0),o = r(2);t.svgFromWire = function (e) {e.getTopologyType() === n.TOPOLOGY_TYPES.WIREBODY && console.warn("svgFromWire: Pass a wire, not a wire body."), o.ConsoleUtils.assert(e.getTopologyType() === n.TOPOLOGY_TYPES.WIRE, "Input topology is not a Wire");var t = e.getOrderedEdges();if (0 === t.edges.length) return "";for (var r = t.start, i = r.getPosition(), s = "M " + i[0] + " " + i[1], a = 0; a < t.edges.length; ++a) {var c = t.edges[a];i = (r = r === c.getStartVertex() ? c.getEndVertex() : c.getStartVertex()).getPosition();var u = c.getCurve();if (u) if (u.getGeometryType() === n.GEOMETRY_TYPES.LINE) s += " L " + i[0] + " " + i[1];else if (u.getGeometryType() !== n.GEOMETRY_TYPES.BCURVE || 3 !== u.getDegree() || u.isRational()) console.warn("Unhandled curve type in svgFromWire");else {for (var l = [], h = u.getBezierSegments(), d = 0; d < h.length; d++) {var g = h[d];if (g) for (var p = g.getControlPoints(), f = 0; f < p.length; f += 3) {l.push([p[f], p[f + 1]]);}}r === c.getStartVertex() !== c.isReversed() && l.reverse(), o.ConsoleUtils.assert(l.length === 4 * h.length, "Unexpected number of control points");for (var v = 0; v < h.length; ++v) {s += " C " + l[4 * v + 1][0] + " " + l[4 * v + 1][1] + " " + l[4 * v + 2][0] + " " + l[4 * v + 2][1] + " ", v === h.length - 1 ? s += i[0] + " " + i[1] : s += l[4 * v + 3][0] + " " + l[4 * v + 3][1];}}}return s;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Path2D = void 0;var n = r(1),o = r(0),i = r(54),s = r(40),a = r(33),c = r(14),u = r(23),l = r(7),h = r(28),d = r(84),g = r(2),p = r(8),f = { assert: function assert(e, t) {if (!e) throw { message: t || "assertion failed" };}, assert_arg: function assert_arg(e, t, r, n) {var o = "Invalid argument '" + t + "': " + r + "\nUsage: " + n;this.assert(e, o);}, assert_number: function assert_number(e, t, r) {this.assert_arg("number" == typeof e, t, "should be a number", r);}, assert_boolean: function assert_boolean(e, t, r) {this.assert_arg("boolean" == typeof e, t, "should be a boolean", r);}, assert_string: function assert_string(e, t, r) {this.assert_arg("string" == typeof e, t, "should be a string", r);} },v = function v() {this._wireBody = new i.WireBody(), this._curves = [], this._xy = [0, 0], this._mergeBCurves = !0, this._healPath = !1, this._tangentTol = o.KERNEL_ANGULAR_TOLERANCE;};function _(e, t, r) {var o = 3 * (t - 1),i = [e[o], e[o + 1], e[o + 2]],s = 3 * r,a = [e[s], e[s + 1], e[s + 2]],c = n.Vector3.sub([0, 0, 0], a, i);n.Vector3.scale(c, c, -.1);for (var u = 1; u <= r - t; ++u) {var l = n.Vector3.scaleAndAdd([0, 0, 0], a, c, u);e[s - 3 * u] = l[0], e[s - 3 * u + 1] = l[1], e[s - 3 * u + 2] = l[2];}}function y(e, t, r) {var o = 3 * t,i = [e[o], e[o + 1], e[o + 2]],s = 3 * (r + 1),a = [e[s], e[s + 1], e[s + 2]],c = n.Vector3.sub([0, 0, 0], a, i);n.Vector3.scale(c, c, .1);for (var u = 1; u <= r - t; ++u) {var l = n.Vector3.scaleAndAdd([0, 0, 0], i, c, u);e[o + 3 * u] = l[0], e[o + 3 * u + 1] = l[1], e[o + 3 * u + 2] = l[2];}}function m(e, t) {for (var r, o, i, s = [], a = e.getControlPoints(), c = [a[0], a[1], a[2]], u = a.length / 3, l = 1; l < u; ++l) {r = [a[3 * l], a[3 * l + 1], a[3 * l + 2]];var h = l === u - 1;n.Vector3.squaredDistance(c, r) < t ? (void 0 === o && (o = l - 1), i = l) : h = !0, h && void 0 !== o && void 0 !== i && (s.push([o, i]), h = !1, o = void 0, i = void 0), c = r;}return s;}function E(e, t) {var r = m(e, t);if (1 === r.length && r[0][1] - r[0][0] == 1) {var n = r[0];0 === n[0] ? e.addControlPointOnCurve(e.evaluatePosition(.1)) : n[1] === e.getNumControlPoints() - 1 ? e.addControlPointOnCurve(e.evaluatePosition(.9)) : (e.addControlPointOnCurve(e.evaluatePosition(.45)), e.addControlPointOnCurve(e.evaluatePosition(.55)));}return r.length > 0;}function x(e, t) {for (var r = m(e, t), n = 0; n < r.length; ++n) {var o = r[n],i = e.getControlPoints().slice();o[0] > 0 ? _(i, o[0], o[1]) : o[1] < i.length / 3 - 1 ? y(i, o[0], o[1]) : p.DebugUtils.warn("Degenerate BCurve!"), e.setControlPoints(i);}}function R(e, t) {var r = e.getControlPoints(),o = [r[0], r[1], r[2]],i = [r[3], r[4], r[5]],s = n.Vector3.distance(o, i);r[3] = o[0] + t[0] * s, r[4] = o[1] + t[1] * s, r[5] = o[2] + t[2] * s, e.setControlPoints(r);}function A(e, t) {var r = e.getControlPoints(),o = e.getControlPoints().length,i = [r[o - 6], r[o - 5], r[o - 4]],s = [r[o - 3], r[o - 2], r[o - 1]],a = n.Vector3.distance(i, s);r[o - 6] = s[0] - t[0] * a, r[o - 5] = s[1] - t[1] * a, r[o - 4] = s[2] - t[2] * a, e.setControlPoints(r);}function P(e) {var t = new a.BCurve(),r = e.getRange(),o = e.evaluatePosition(r[0]),i = e.evaluatePosition(r[1]),s = n.Vector3.lerp([0, 0, 0], o, i, 1 / 3),c = n.Vector3.lerp([0, 0, 0], o, i, 2 / 3),u = [o[0], o[1], 0, s[0], s[1], 0, c[0], c[1], 0, i[0], i[1], 0];return t.set(u, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), t;}function V(e, t) {for (var r, o = e.getRange(), i = e.evaluatePosition(o[0]), s = e.evaluatePosition(o[1]), a = n.Vector3.distance(i, s), c = 0, u = t.getControlPoints(), l = [u[0], u[1], u[2]], h = u.length / 3, d = 1; d < h; ++d) {r = [u[3 * d], u[3 * d + 1], u[3 * d + 2]], c += n.Vector3.distance(l, r), l = r;}return a < c;}function T(e, t) {var r = e.getControlPoints().concat(t.getControlPoints().slice(3)),o = e.getWeights().concat(t.getWeights().slice(1)),i = e.getKnotVector().slice(0, -1),s = e.evaluateDt(e.getRange()[1]),a = t.evaluateDt(t.getRange()[0]),c = Math.sqrt(n.Vector3.squaredLength(a) / n.Vector3.squaredLength(s)),u = i[i.length - 1] - t.getKnotVector()[0] * c,l = t.getKnotVector().slice(t.getDegree() + 1);return l = l.map(function (e) {return e * c + u;}), i = i.concat(l), e.set(r, o, 3, i), e;}function C(e, t, r, i, s) {var a = n.Vector2.subtract([], s, e),u = n.Vector2.length(a);if (!(u < o.KERNEL_TOLERANCE)) {u > 2 * t && (t = u / 2);var l = n.Vector2.scaleAndAdd([], e, a, .5);if (u < 2 * t - n.FLOAT64_TOLERANCE) {var h = Math.sqrt(t * t - u * u / 4);!0 === i != (!1 === r) && (h = -h);var d = n.Vector2.normalize([], [-a[1], a[0]]);n.Vector2.scaleAndAdd(l, l, d, h);}var g = [0, 0, i ? 1 : -1],p = new c.Circle();p.set([l[0], l[1], 0], g, [t, 0, 0]);var f = p.closestToPointParam([e[0], e[1], 0]),v = p.closestToPointParam([s[0], s[1], 0]);return v <= f && (v += 2 * Math.PI), p.limitRange([f, v]), p;}}function b(e, t) {var r = e.slice(1);r = r.replace(/([^e])-/g, "$1 -");for (var n = 0; n < 2; ++n) {r = r.replace(/\.[0-9]*\./g, function (e) {return e.slice(0, -1) + " .";});}for (var o = r.split(/[,\s]/), i = [], s = 0; s < o.length; ++s) {if (o[s].length > 0) {var a = Number(o[s]);t(!isNaN(a), "could not parse command"), i.push(a);}}return i;}v.prototype.numWires = function () {var e = this._wireBody.getWires().length;return this._curves.length > 0 && (e += 1), e;}, v.prototype.numClosed = function () {for (var e = 0, t = 0; t < this._wireBody.getWires().length; ++t) {this._wireBody.getWires()[t].isClosed() && (e += 1);}return this._areCurvesClosed() && (e += 1), e;}, v.prototype._fixCoincidentControlPoints = function () {for (var e = o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE, t = 0; t < this._curves.length; ++t) {var r = this._curves[t];r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && 3 === r.getDegree() && 4 === r.getNumControlPoints() && !1 === r.isRational() && E(r, e) && x(r, e);}}, v.prototype._snapBCurvesTangent = function () {for (var e = 0; e < this._curves.length; ++e) {var t = (e + 1) % this._curves.length;if (0 === t && !this._areCurvesClosed()) break;var r = this._curves[e],i = this._curves[t],s = r.evaluateDt(r.getRange()[1]),a = i.evaluateDt(i.getRange()[0]);n.Vector3.isParallel(s, a, 1, this._tangentTol) && (r.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE ? (n.Vector3.normalize(s, s), R(i, s)) : r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE && (n.Vector3.normalize(a, a), A(r, a)));}}, v.prototype._areCurvesClosed = function () {if (0 === this._curves.length) return !1;var e = this._curves[this._curves.length - 1],t = this._curves[0];return n.Vector3.squaredDistance(e.evaluatePosition(e.getRange()[1]), t.evaluatePosition(t.getRange()[0])) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE;}, v.prototype._mergeShortLinesWithBCurves = function () {for (var e = !1, t = 0; t < this._curves.length; ++t) {var r = (t + 1) % this._curves.length;if (0 === r && !this._areCurvesClosed()) break;var i = this._curves[t],s = this._curves[r],a = i.evaluateDt(i.getRange()[1]),c = s.evaluateDt(s.getRange()[0]);n.Vector3.isParallel(a, c, 1, o.KERNEL_ANGULAR_TOLERANCE) && (i.getGeometryType() === o.GEOMETRY_TYPES.LINE && s.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && V(i, s) ? (this._curves.splice(t, 1, T(P(i), s)), this._curves.splice(r, 1), t -= 1, e = !0) : i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && s.getGeometryType() === o.GEOMETRY_TYPES.LINE && V(s, i) && (this._curves.splice(t, 1, T(i, P(s))), this._curves.splice(r, 1), t -= 1, e = !0));}return e;}, v.prototype._mergeAdjacentBCurves = function () {for (var e = 0; e < this._curves.length; ++e) {var t = (e + 1) % this._curves.length;if (0 === t && !this._areCurvesClosed()) break;var r = this._curves[e],i = this._curves[t],s = r.evaluateDt(r.getRange()[1]),a = i.evaluateDt(i.getRange()[0]);n.Vector3.isParallel(s, a, 1, this._tangentTol) && r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && (n.Vector3.squaredLength(s) < n.Vector3.squaredLength(a) ? (n.Vector3.normalize(s, s), R(i, s)) : (n.Vector3.normalize(a, a), A(r, a)), r !== i && (T(r, i), this._curves.splice(t, 1), e -= 1));}}, v.prototype.setMergeBCurves = function (e) {this._mergeBCurves = e;}, v.prototype.setHealForASM = function (e, t) {this._healPath = e, this._tangentTol = void 0 !== t ? t : .01745240643728351;}, v.prototype._addWire = function () {if (0 !== this._curves.length) {this._healPath && (this._fixCoincidentControlPoints(), this._snapBCurvesTangent()), (this._mergeBCurves || this._healPath) && this._mergeAdjacentBCurves(), this._healPath && this._mergeShortLinesWithBCurves() && this._mergeAdjacentBCurves();var e = (0, h.createWiresFromEdges)((0, h.createEdgesFromCurves)(this._curves));g.ConsoleUtils.assert(1 === e.length), this._wireBody.addWire(e[0]), this._curves = [];}}, v.prototype._discardIfOpen = function () {if (0 !== this._curves.length) {var e = this._curves[0].evaluatePosition(this._curves[0].getRange()[0]),t = [this._xy[0], this._xy[1], 0];n.Vector3.squaredDistance(e, t) >= o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (this._curves = []);}}, v.prototype.moveTo = function (e, t) {var r = "Path2D.moveTo(x, y)";return f.assert_number(e, "x", r), f.assert_number(t, "y", r), this._addWire(), this._xy[0] = e, this._xy[1] = t, this;}, v.prototype.lineTo = function (e, t) {var r = "Path2D.lineTo(x, y)";f.assert_number(e, "x", r), f.assert_number(t, "y", r);var n = e - this._xy[0],i = t - this._xy[1];if (n * n + i * i > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) {var s = new l.Line();s.set([this._xy[0], this._xy[1], 0], [n, i, 0]), s.limitRange([0, 1]), this._curves.push(s);}return this._xy[0] = e, this._xy[1] = t, this;}, v.prototype.quadraticCurveTo = function (e, t, r, n) {var o = "Path2D.quadraticCurveTo(cpx, cpy, x, y)";f.assert_number(e, "cpx", o), f.assert_number(t, "cpy", o), f.assert_number(r, "x", o), f.assert_number(n, "y", o);var i = new a.BCurve(),s = 1 / 3 * this._xy[0] + 2 / 3 * e,c = 1 / 3 * this._xy[1] + 2 / 3 * t,u = 1 / 3 * r + 2 / 3 * e,l = 1 / 3 * n + 2 / 3 * t,h = [this._xy[0], this._xy[1], 0, s, c, 0, u, l, 0, r, n, 0];return i.set(h, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), this._curves.push(i), this._xy[0] = r, this._xy[1] = n, this;}, v.prototype.bezierCurveTo = function (e, t, r, n, o, i) {var s = "Path2D.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)";f.assert_number(e, "cp1x", s), f.assert_number(t, "cp1y", s), f.assert_number(r, "cp2x", s), f.assert_number(n, "cp2y", s), f.assert_number(o, "x", s), f.assert_number(i, "y", s);var c = new a.BCurve(),u = [this._xy[0], this._xy[1], 0, e, t, 0, r, n, 0, o, i, 0];return c.set(u, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), this._curves.push(c), this._xy[0] = o, this._xy[1] = i, this;}, v.prototype.circleArcTo = function (e, t, r, n, o) {var i = "Path2D.circleArcTo(radius, longest, anticlockwise, x, y)";f.assert_number(e, "radius", i), f.assert_arg(e > 0, "radius", "must be positive", i), f.assert_boolean(t, "longest", i), f.assert_boolean(r, "anticlockwise", i), f.assert_number(n, "x", i), f.assert_number(o, "y", i);var s = C(this._xy, e, t, r, [n, o]);return s && (this._curves.push(s), this._xy[0] = n, this._xy[1] = o), this;}, v.prototype.ellipseArcTo = function (e, t, r, o, i, s, a) {var c = "Path2D.ellipseArcTo(xRadius, yRadius, rotation, longest, anticlockwise, x, y)";if (f.assert_number(e, "xRadius", c), f.assert_arg(e > 0, "xRadius", "must be positive", c), f.assert_number(t, "yRadius", c), f.assert_arg(t > 0, "yRadius", "must be positive", c), f.assert_number(r, "rotation", c), f.assert_boolean(o, "longest", c), f.assert_boolean(i, "anticlockwise", c), f.assert_number(s, "x", c), f.assert_number(a, "y", c), e < t) {var l = e;e = t, t = l, r += Math.PI / 2;}var h = Math.cos(r),d = Math.sin(r),g = e / t,p = n.Matrix22.multiply([], [1, 0, 0, g], [h, -d, d, h]),v = C(n.Vector2.transformMatrix22([], this._xy, p), e, o, i, n.Vector2.transformMatrix22([], [s, a], p));if (v) {var _ = [v.getCenter()[0], v.getCenter()[1]];n.Matrix22.invert(p, p), n.Vector2.transformMatrix22(_, _, p), _[2] = 0;var y = v.getRadius(),m = [y * h, y * d, 0],E = new u.Ellipse();E.set(_, v.getNormal(), m, 1 / g), E.limitRange(v.getRange()), this._curves.push(E), this._xy[0] = s, this._xy[1] = a;}return this;}, v.prototype.closePath = function () {if (this._curves.length > 0) {var e = this._curves[0],t = e.evaluatePosition(e.getRange()[0]);this.lineTo(t[0], t[1]), this._addWire();}return this;}, v.prototype.addCircle = function (e, t, r) {var n = "Path2D.addCircle(x, y, radius)";f.assert_number(e, "x", n), f.assert_number(t, "y", n), f.assert_number(r, "radius", n), f.assert_arg(r > 0, "radius", "must be positive", n), this._addWire();var o = new c.Circle();return o.set([e, t, 0], [0, 0, 1], [r, 0, 0]), this._curves.push(o), this._addWire(), this;}, v.prototype.addEllipse = function (e, t, r, n, o) {o = void 0 === o ? 0 : o;var i = "Path2D.addEllipse(x, y, xRadius, yRadius, rotation)";if (f.assert_number(e, "x", i), f.assert_number(t, "y", i), f.assert_number(r, "xRadius", i), f.assert_arg(r > 0, "xRadius", "must be positive", i), f.assert_number(n, "yRadius", i), f.assert_arg(n > 0, "yRadius", "must be positive", i), f.assert_number(o, "rotation", i), this._addWire(), r < n) {var s = r;r = n, n = s, o += Math.PI / 2;}var a = new u.Ellipse(),c = Math.cos(o),l = Math.sin(o),h = n / r;return a.set([e, t, 0], [0, 0, 1], [r * c, r * l, 0], h), this._curves.push(a), this._addWire(), this;}, v.prototype.addSVGPath = function (e, t) {t = void 0 !== t && t;var r = "Path2D.addSVGPath(pathString, [includeOpen])";f.assert_string(e, "pathString", r), f.assert_boolean(t, "includeOpen", r), this._addWire(), this._xy[0] = 0, this._xy[1] = 0;var n = function (e) {for (var t = []; e.length > 0;) {var r = e.slice(1).search(/[MmZzLlHhVvCcSsQqTtAa]/) + 1;r <= 0 && (r = e.length);var n = e.slice(0, r).trim();n.length > 0 && t.push(n), e = e.slice(r).trim();}return t;}(e);f.assert_arg(n.length > 0, "pathString", "cannot be empty string", r);for (var i = [this._xy[0], this._xy[1]], s = [this._xy[0], this._xy[1]], a = 0; a < n.length; ++a) {var c,u,l,h,d,g,p,v = function v(e, t) {f.assert_arg(e, "pathString", t + ' "' + n[a] + '"', r);},_ = n[a].charAt(0).toUpperCase(),y = _ !== n[a].charAt(0),m = b(n[a], v),E = y ? this._xy : [0, 0];switch (_) {case "M":for (v(m.length >= 2, "insufficient arguments in command"), v(m.length % 2 == 0, "command requires pairs of x,y arguments"), t || this._discardIfOpen(), this.moveTo(m[0] + E[0], m[1] + E[1]), p = 2; p < m.length; p += 2) {this.lineTo(m[p] + E[0], m[p + 1] + E[1]);}break;case "Z":v(0 === m.length, "command should not have arguments"), this.closePath();break;case "L":for (v(m.length >= 2, "insufficient arguments in command"), v(m.length % 2 == 0, "command requires pairs of x,y arguments"), p = 0; p < m.length; p += 2) {this.lineTo(m[p] + E[0], m[p + 1] + E[1]);}break;case "H":for (v(m.length >= 1, "insufficient arguments in command"), p = 0; p < m.length; p += 1) {this.lineTo(m[p] + E[0], this._xy[1]);}break;case "V":for (v(m.length >= 1, "insufficient arguments in command"), p = 0; p < m.length; p += 1) {this.lineTo(this._xy[0], m[p] + E[1]);}break;case "C":for (v(m.length >= 6, "insufficient arguments in command"), v(m.length % 6 == 0, "command requires sets of 6 arguments"), p = 0; p < m.length; p += 6) {c = m[p] + E[0], u = m[p + 1] + E[1], l = m[p + 2] + E[0], h = m[p + 3] + E[1], d = m[p + 4] + E[0], g = m[p + 5] + E[1], this.bezierCurveTo(c, u, l, h, d, g), s[0] = l, s[1] = h;}break;case "S":for (v(m.length >= 4, "insufficient arguments in command"), v(m.length % 4 == 0, "command requires sets of 4 arguments"), p = 0; p < m.length; p += 4) {c = 2 * this._xy[0] - s[0], u = 2 * this._xy[1] - s[1], l = m[p] + E[0], h = m[p + 1] + E[1], d = m[p + 2] + E[0], g = m[p + 3] + E[1], this.bezierCurveTo(c, u, l, h, d, g), s[0] = l, s[1] = h;}break;case "Q":for (v(m.length >= 4, "insufficient arguments in command"), v(m.length % 4 == 0, "command requires sets of 4 arguments"), p = 0; p < m.length; p += 4) {c = m[p] + E[0], u = m[p + 1] + E[1], l = m[p + 2] + E[0], h = m[p + 3] + E[1], this.quadraticCurveTo(c, u, l, h), i[0] = c, i[1] = u;}break;case "T":for (v(m.length >= 2, "insufficient arguments in command"), v(m.length % 2 == 0, "command requires pairs of arguments"), p = 0; p < m.length; p += 2) {c = 2 * this._xy[0] - i[0], u = 2 * this._xy[1] - i[1], l = m[p] + E[0], h = m[p + 1] + E[1], this.quadraticCurveTo(c, u, l, h), i[0] = c, i[1] = u;}break;case "A":for (v(m.length >= 7, "insufficient arguments in command"), v(m.length % 7 == 0, "command requires sets of 7 arguments"), p = 0; p < m.length; p += 7) {var x = Math.abs(m[p]),R = Math.abs(m[p + 1]),A = m[p + 2] * Math.PI / 180,P = 0 !== m[p + 3],V = 0 !== m[p + 4],T = m[p + 5] + E[0],C = m[p + 6] + E[1];x < o.KERNEL_TOLERANCE || R < o.KERNEL_TOLERANCE ? this.lineTo(T, C) : this.ellipseArcTo(x, R, A, P, V, T, C);}break;default:v(!1, "unrecognised command");}"Q" !== _ && "T" !== _ && (i = [this._xy[0], this._xy[1]]), "C" !== _ && "S" !== _ && (s = [this._xy[0], this._xy[1]]);}return t || this._discardIfOpen(), this._addWire(), this;}, v.prototype.getWireBody = function () {return this._addWire(), this._wireBody;}, v.prototype.computeRegionizedWireBody = function () {this.getWireBody();for (var e = new i.WireBody(), t = (0, d.mergeSketchRegions)(this._wireBody.getWires()), r = 0; r < t.length; ++r) {for (var n = t[r].getLoops(), o = 0; o < n.length; ++o) {var a = n[o],c = new s.Wire();c.addEdges(Array.from(a.collectEdges())), e.addWire(c);}}return e;}, v.prototype.reset = function () {this._wireBody = new i.WireBody(), this._curves = [], this._xy = [0, 0];}, t.Path2D = v;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SolidDefLoader = t.getTopologyRank = void 0;var n = r(6),o = r(7),i = r(14),s = r(23),a = r(33),c = r(18),u = r(38),l = r(39),h = r(74),d = r(51),g = r(52),p = r(75),f = r(53),v = r(24),_ = r(25),y = r(26),m = r(15),E = r(13),x = r(27),R = r(20),A = r(16),P = r(54),V = r(40),T = r(79),C = r(0),b = r(85),L = r(124),O = r(125),S = r(45),M = function () {var e = {};return e[C.TOPOLOGY_TYPES.BODY] = 10, e[C.TOPOLOGY_TYPES.WIREBODY] = 9, e[C.TOPOLOGY_TYPES.LUMP] = 8, e[C.TOPOLOGY_TYPES.SHELL] = 7, e[C.TOPOLOGY_TYPES.FACE] = 6, e[C.TOPOLOGY_TYPES.WIRE] = 5, e[C.TOPOLOGY_TYPES.LOOP] = 4, e[C.TOPOLOGY_TYPES.COEDGE] = 3, e[C.TOPOLOGY_TYPES.EDGE] = 2, e[C.TOPOLOGY_TYPES.VERTEX] = 1, function (t) {var r = void 0;return "function" == typeof t.getTopologyType && (r = e[t.getTopologyType()]), r || 0;};}(),w = function w() {this._runTimeMap = new Map(), this._typeidToFuncMap = {}, this.addLoader("body", L.TopologySetters.setBodyData, v.Body), this.addLoader("wirebody", L.TopologySetters.setWireBodyData, P.WireBody), this.addLoader("wire", L.TopologySetters.setWireData, V.Wire), this.addLoader("lump", L.TopologySetters.setLumpData, _.Lump), this.addLoader("shell", L.TopologySetters.setShellData, y.Shell), this.addLoader("face", L.TopologySetters.setFaceData, m.Face), this.addLoader("loop", L.TopologySetters.setLoopData, E.Loop), this.addLoader("coedge", L.TopologySetters.setCoedgeData, x.Coedge), this.addLoader("edge", L.TopologySetters.setEdgeData, R.Edge), this.addLoader("vertex", L.TopologySetters.setVertexData, A.Vertex), this.addLoader("point", b.GeometrySetters.setPointFromProperty, n.Point), this.addLoader("line", b.GeometrySetters.setLineFromProperty, o.Line), this.addLoader("circle", b.GeometrySetters.setCircleFromProperty, i.Circle), this.addLoader("ellipse", b.GeometrySetters.setEllipseFromProperty, s.Ellipse), this.addLoader("bcurve", b.GeometrySetters.setBCurveFromProperty, a.BCurve), this.addLoader("plane", b.GeometrySetters.setPlaneFromProperty, c.Plane), this.addLoader("sphere", b.GeometrySetters.setSphereFromProperty, h.Sphere), this.addLoader("torus", b.GeometrySetters.setTorusFromProperty, p.Torus), this.addLoader("cylinder", b.GeometrySetters.setCylinderFromProperty, u.Cylinder), this.addLoader("cone", b.GeometrySetters.setConeFromProperty, d.Cone), this.addLoader("ellipticalcylinder", b.GeometrySetters.setEllipticalCylinderFromProperty, l.EllipticalCylinder), this.addLoader("ellipticalcone", b.GeometrySetters.setEllipticalConeFromProperty, g.EllipticalCone), this.addLoader("bsurface", b.GeometrySetters.setBSurfaceFromProperty, f.BSurface), this.addLoader("nmiattributestr", O.AttributeSetters.setNMIAttributeStr, T.Attribute), this.addLoader("nmiattributearr", O.AttributeSetters.setNMIAttributeArr, T.Attribute), this.addLoader("textattribute", O.AttributeSetters.setTextAttribute, T.Attribute);};w.prototype.addLoader = function (e, t, r) {this._typeidToFuncMap[e] = [t, r];}, w.prototype._reset = function () {this._runTimeMap.clear();}, w.prototype.getDataSettingFunction = function (e) {var t = this._typeidToFuncMap[e];if (t) return t[0];}, w.prototype.createRunTimeObject = function (e) {var t = this.getTypeContructor(e);if (t) return new t();}, w.prototype.getTypeContructor = function (e) {var t = this._typeidToFuncMap[e];if (t && 2 === t.length) return t[1];}, w.prototype.setObjectProperties = function (e, t, r) {var n = this.getDataSettingFunction(e, r);var o = this;"function" == typeof n && n(t, r, function (e) {if (!e) return;var t = e;return t ? o._runTimeMap.get(t) : void 0;});}, w.prototype.makeGeometryObjectsProto = function (e) {var _this2 = this;Object.keys(e).forEach(function (t) {var r = e[t],n = r[r.geometry],o = _this2.createRunTimeObject(r.geometry);o && (_this2._runTimeMap.set(t, o), _this2.setObjectProperties(r.geometry, o, n), o.setGuid(t));});}, w.prototype.makeGeometryObject = function (e) {var t = e.getTypeid(),r = this.createRunTimeObject(t);return r ? this.setObjectProperties(t, r, e) : console.error("No constructor"), r;}, w.prototype.makeTopologyObject = function (e) {var t = e.getTypeid(),r = this.createRunTimeObject(t);return r || console.error("No constructor"), r;}, w.prototype.makeAttributeObjectsProto = function (e) {var _this3 = this;Object.keys(e).forEach(function (t) {var r = e[t],n = r[r.attribute],o = new T.Attribute();_this3._runTimeMap.set(t, o), _this3.setObjectProperties(r.attribute, o, n), o.setGuid(t);});}, w.prototype.makeTopologyObjectsProto = function (e) {var _this4 = this;var t = [];Object.keys(e).forEach(function (r) {var n = e[r],o = n[n.topology],i = _this4.createRunTimeObject(n.topology);i && (_this4._runTimeMap.set(r, i), t.push({ type: n.topology, obj: i, prop: o }), i.setGuid(r));});for (var r = 0; r < t.length; ++r) {this.setObjectProperties(t[r].type, t[r].obj, t[r].prop);}}, w.prototype._collectGeometries = function (e) {this._runTimeMap.forEach(function (t) {void 0 !== t.getGeometryType && e.set(t.getGuid(), t);});}, w.prototype._collectTopologies = function (e) {this._runTimeMap.forEach(function (t) {void 0 !== t.getTopologyType && e.set(t.getGuid(), t);});}, w.prototype.loadModelPSet = function (e, t, r) {var n = e.get("geometries");if (n) {var o = e.get("attributes"),i = e.get("topologies");if (i) return this.makeGeometryObjects(n), o && this.makeAttributeObjects(o), this.makeTopologyObjects(i), this.getHighestObject(t, r);}}, w.prototype.getHighestObject = function (e, t) {var r = void 0,n = 0;return this._runTimeMap.forEach(function (e) {if (10 !== n) {var t = M(e);t > n && t > 0 && (n = t, r = e);}}), e && this._collectGeometries(e), t && this._collectTopologies(t), this._reset(), r;}, w.prototype.loadModelProtoMessage = function (e, t, r) {var n = e.geometries;if (!n) return;var o = e.attributes,i = e.topologies;return i ? (this.makeGeometryObjectsProto(n), o && this.makeAttributeObjectsProto(o), this.makeTopologyObjectsProto(i), this.getHighestObject(t, r)) : void 0;}, w.prototype.loadProtoBinary = function (e, t, r) {var n = e;n instanceof ArrayBuffer && (n = new Uint8Array(n));var o = S.Autodesk.lookupType("SolidDef.model_1_0_0").decode(n);return this.loadModelProtoMessage(o, t, r);}, t.getTopologyRank = M, t.SolidDefLoader = w;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TopologySetters = void 0;var n = r(85);var o = {},i = function i(e, t, r) {var n = t.attributes;if (n) {e.removeAllAttributes();for (var o = 0; o < n.length; ++o) {var _t9 = r(n[o]);e.addAttribute(_t9);}}};o.setBodyData = function (e, t, r) {for (var n = t.lumps, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setBody(e);}e.setLumps(o), i(e, t, r);}, o.setLumpData = function (e, t, r) {for (var n = t.shells, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setLump(e);}e.setShells(o), i(e, t, r);}, o.setShellData = function (e, t, r) {for (var n = t.faces, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setShell(e);}e.setFaces(o), i(e, t, r);}, o.setFaceData = function (e, t, r) {for (var n = t.loops, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setFace(e);}e.setLoops(o), e.setReversed(t.reversed), e.setSurface(r(t.geometry)), i(e, t, r);}, o.setLoopData = function (e, t, r) {for (var n = t.coedges, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setLoop(e);}e.setCoedges(o), i(e, t, r);}, o.setCoedgeData = function (e, t, r) {e.setEdge(r(t.edge)), e.setReversed(t.reversed), e.setPartner(r(t.partner)), e.getEdge() && !e.getEdge().getCoedge() && e.getEdge().setCoedge(e), i(e, t, r);}, o.setEdgeData = function (e, t, r) {e.setVertex(0, r(t.vertex0)), e.setVertex(1, r(t.vertex1));var o = (0, n.propertyToRange)(t, "range");e.sett0(o[0]), e.sett1(o[1]), e.setReversed(t.reversed), e.setPrecision(t.precision), e.setCurve(r(t.geometry)), i(e, t, r);}, o.setVertexData = function (e, t, r) {e.setPrecision(t.precision), e.setPoint(r(t.geometry)), i(e, t, r);}, o.setWireBodyData = function (e, t, r) {for (var n = t.wires, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setWireBody(e);}e.setWires(o), i(e, t, r);}, o.setWireData = function (e, t, r) {for (var n = t.edges, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setWire(e);}e.setEdges(o), i(e, t, r);}, t.TopologySetters = o;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = { setNMIAttributeStr: function setNMIAttributeStr(e, t) {e.typeid = "autodesk.brep:nmiattributestr-1.0.0", e.values = { primaryId: t.primaryId, secondaryId: t.secondaryId, approachId: t.approachId, operationIds: t.operationIds };}, setNMIAttributeArr: function setNMIAttributeArr(e, t) {e.typeid = "autodesk.brep:nmiattributearr-1.0.0";for (var r = t.tagInfo, n = new Array(r.length), o = 0; o < r.length; ++o) {var i = r[o];n[o] = { primaryId: i.primaryId, secondaryId: i.secondaryId, approachId: i.approachId, operationIds: i.operationIds };}e.values = { tagInfo: n };}, setTextAttribute: function setTextAttribute(e, t) {e.typeid = "autodesk.brep:textattribute-1.0.0", e.values = { text: t.text };} };t.AttributeSetters = n;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.saveToProtoBinary = t.saveToProtoMessage = t.SolidDefSaver = void 0;var n = r(45),o = function o() {};o.prototype.setVersion = function (e) {console.warn("SolidDefSaver.prototype.setVersion is deprecated,");};var i = function i(e) {var t = n.Autodesk.lookupType("SolidDef.model_1_0_0"),r = { topologies: {}, geometries: {}, attributes: {} };return e.addToModelObject(r), t.create(r);};t.SolidDefSaver = o, t.saveToProtoMessage = i, t.saveToProtoBinary = function (e) {var t = n.Autodesk.lookupType("SolidDef.model_1_0_0"),r = i(e);return t.encode(r).finish();};}]);});

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Avatar/Avatar.scss":
/*!************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Avatar/Avatar.scss ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".avatar-widget {\n  width: 0px;\n  height: 0px;\n  top: 0px;\n  left: 0px;\n  position: absolute;\n  transition: opacity 0.7s;\n  opacity: 0;\n  z-index: 1;\n  pointer-events: none;\n  will-change: transform; }\n  .avatar-widget.visible {\n    opacity: 0.7;\n    pointer-events: all; }\n\n.avatar-frustum {\n  border-left: 20px solid transparent;\n  border-right: 20px solid transparent;\n  border-top: 40px solid #3590e9;\n  border-radius: 50%;\n  opacity: 0.4;\n  width: 0px;\n  height: 0px;\n  position: absolute;\n  transform-origin: bottom center;\n  cursor: crosshair;\n  will-change: transform; }\n  .avatar-frustum.touch {\n    border-left: 40px solid transparent;\n    border-right: 40px solid transparent;\n    border-top: 80px solid #3590e9; }\n\n.avatar-position-fill {\n  width: 10px;\n  height: 10px;\n  /* Move circle center to the tip of the frustum shape */\n  left: 15px;\n  /* = (avatarFrustum.border-left - width/2)  */\n  top: 35px;\n  /* = (avatarFrustum.border-top  - height/2) */\n  position: absolute;\n  border-radius: 50%;\n  background-color: #3590e9;\n  box-shadow: 0px 0px 0px 2px #fff; }\n  .avatar-position-fill.touch {\n    /* Move circle center to the tip of the frustum shape */\n    left: 35px;\n    /* = (avatarFrustum.border-left - width/2)  */\n    top: 75px;\n    /* = (avatarFrustum.border-top  - height/2) */ }\n\n.avatar-position-hitarea {\n  position: absolute;\n  width: 15px;\n  height: 15px;\n  left: 5px;\n  /* avatar-position-fill.width/2 */\n  top: 5px;\n  /* avatar-position-fill.height/2 */\n  border-radius: 50px;\n  transform: translate(-50%, -50%);\n  cursor: grab; }\n  .avatar-position-hitarea.touch {\n    width: 50px;\n    height: 50px; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/CanvasBookmark/CanvasBookmark.css":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/CanvasBookmark/CanvasBookmark.css ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*\nhttps://stackoverflow.com/questions/27900053/css-transition-with-visibility-not-working\n\nVisibility is an animatable property according to the spec, but transitions on visibility do not work gradually, as one might expect.\nInstead transitions on visibility delay hiding an element. On the other hand making an element visible works immediately.\nThis is as it is defined by the spec (in the case of the default timing function) and as it is implemented in the browsers.\n\n    ==> transition: visibility 0.7s, opacity 0.7s;\n*/\n.canvas-bookmark.adsk-button, .clustered-canvas-bookmark.adsk-button, .declustered-canvas-bookmark.adsk-button {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  border-style: none !important;\n  /* Avoid border on button-hover */\n  color: white;\n  margin: none;\n  padding: 0px;\n  transition: visibility 0.5s, opacity 0.5s;\n  opacity: 0;\n  visibility: hidden; }\n\n.canvas-bookmark.adsk-button {\n  width: 22px;\n  height: 22px; }\n\n.clustered-canvas-bookmark.adsk-button {\n  width: 29px;\n  height: 29px; }\n\n.declustered-canvas-bookmark.adsk-button {\n  width: 29px;\n  height: 29px;\n  color: lightgrey; }\n\n.canvas-bookmark.visible {\n  opacity: 1;\n  visibility: visible; }\n\n.clustered-canvas-bookmark.visible {\n  opacity: 1;\n  visibility: visible; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/DropMe/DropMe.css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/DropMe/DropMe.css ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".camera-selector {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 100px solid #0696D7;\n  border-radius: 50%;\n  transform-origin: bottom center;\n  position: absolute;\n  opacity: 0.8;\n  pointer-events: none;\n  z-index: 1; }\n\n.camera-selector-position {\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background-color: #0696D7;\n  position: absolute;\n  opacity: 0.8;\n  pointer-events: none;\n  z-index: 1;\n  transform: scale(1, 1);\n  transition: transform 3s ease-in; }\n\n.camera-selector-position--teleporting {\n  transform: scale(0, 0); }\n\n.camera-selector-background {\n  width: 200px;\n  height: 200px;\n  background-color: #0696D7;\n  opacity: 0.2;\n  position: absolute;\n  pointer-events: none;\n  z-index: 0;\n  transform: translate(-100px, -100px);\n  border-radius: 50%; }\n\n/* mimic issues UI guidance for now as it was the only extension, featuring guidance so far */\n.dropme-guidenace-ui {\n  display: flex;\n  position: absolute;\n  left: 50%;\n  top: 20px;\n  padding: 10px 20px;\n  transform: translate(-50%, 0);\n  align-items: center;\n  border: 1px solid #9ec8f6;\n  border-radius: 4px;\n  background-color: #edf5fd;\n  color: #039be5;\n  font-size: 12px;\n  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.25);\n  opacity: 1;\n  z-index: 999;\n  overflow-y: hidden; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Minimap3D/Minimap3D.css":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Minimap3D/Minimap3D.css ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*\nhttps://stackoverflow.com/questions/27900053/css-transition-with-visibility-not-working\n\nVisibility is an animatable property according to the spec, but transitions on visibility do not work gradually, as one might expect.\nInstead transitions on visibility delay hiding an element. On the other hand making an element visible works immediately.\nThis is as it is defined by the spec (in the case of the default timing function) and as it is implemented in the browsers.\n\n    ==> transition: visibility 0.7s, opacity 0.7s;\n*/\n.minimap3D {\n  width: 0px;\n  height: 0px;\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  transition: visibility 0.7s, opacity 0.7s;\n  opacity: 0;\n  visibility: hidden;\n  background: rgba(255, 255, 255, 0.4);\n  overflow: hidden;\n  /* For side-by-side mode: Make sure that text selection highlighting is disabled on Minimap. Otherwise, fast dragging of the player will\n       color the whole map in blue */\n  user-select: none;\n  border-radius: 4px;\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.4); }\n\n.minimap3D.paddedForToolbar {\n  right: 70px; }\n\n.minimapScrollArea {\n  width: 100%;\n  height: 100%;\n  position: relative; }\n\n/* Show map left-aligned and without margin */\n.minimap3D.side-by-side {\n  box-sizing: border-box;\n  box-shadow: 0px 0px 3px rgba(0, 0, 0, 0.5);\n  z-index: 1;\n  overflow-x: hidden; }\n\n.minimap3D.side-by-side.left-2d-view {\n  border-left: none;\n  border-right: solid 2px #979797;\n  left: 0px; }\n\n.minimap3D.visible {\n  opacity: 1;\n  visibility: visible; }\n\n/* Container for floor image + floor name */\n.mapContainer {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  opacity: 1; }\n\n.mapImage {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  pointer-events: none; }\n\n/* Display floor name at top left */\n.floorNameLabel {\n  z-index: 2;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  opacity: 0.99;\n  background-color: whitesmoke;\n  box-shadow: 1px 3px 10px 0 rgba(0, 0, 0, 0.5);\n  margin: 4px;\n  border-radius: 5px; }\n\n.floorNameLabel.dark {\n  margin-top: 10px;\n  left: 50%;\n  transform: translate(-50%);\n  border-radius: 28px;\n  background-color: rgba(50, 50, 50, 0.8); }\n\n.floorNameLabel.light {\n  margin-top: 10px;\n  left: 50%;\n  transform: translate(-50%);\n  border-radius: 28px;\n  background-color: rgba(255, 255, 255, 0.85);\n  box-shadow: none; }\n\n.floorText {\n  margin: 5px 5px 5px 5px;\n  color: black;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden; }\n\n.floorText.dark {\n  padding: 0px 15px;\n  color: #FFFFFF;\n  font-family: \"Artifakt Element\", Helvetica, Arial;\n  font-size: 14px; }\n\n.floorText.light {\n  padding: 0px 15px;\n  color: #000;\n  font-family: \"Artifakt Element\", Helvetica, Arial;\n  font-size: 14px; }\n\n/* Div with text and progressbar - replaces the map image if map computation is running */\n.minimap-placeholder {\n  left: 0px;\n  top: 0px;\n  position: absolute;\n  background-color: rgba(255, 255, 255, 0.5);\n  opacity: 1; }\n\n.minimap-progressWidget {\n  transform: translate(0, -50%);\n  left: 0px;\n  top: 50%;\n  position: relative;\n  height: fit-content;\n  width: calc(100% - 60px);\n  margin-left: 30px;\n  margin-right: 30px; }\n\n.minimap-progressText {\n  color: black;\n  text-align: left;\n  position: relative; }\n\n.minimap-progress {\n  z-index: 10;\n  width: 100%; }\n\n.map-button-bar {\n  z-Index: 2;\n  right: 0px;\n  top: 0px;\n  position: absolute;\n  right: 100%;\n  /* Dock left to mapWidget */\n  display: flex;\n  flex-direction: column;\n  background-color: whitesmoke;\n  box-shadow: 1px 3px 10px 0 rgba(0, 0, 0, 0.5);\n  margin-right: 4px;\n  margin-top: 0px;\n  /* Toolbar is vertically aligned to the upper mapWidget boundary. This is okay, because the mapWidget already has some margin from the canvas boundary. */\n  border-radius: 5px; }\n\n/* In side-by-side, the upper mapWidget edge is matched with the upper canvas edge. So, we add some marigin - otherwise the toolbar would be \"glued\" to the upper canvas edge. */\n.map-button-bar.side-by-side {\n  margin-top: 4px; }\n\n.map-button-bar.side-by-side.left-2d-view {\n  right: 0px; }\n\n.sheetmap-thumbnail {\n  position: absolute;\n  overflow: hidden; }\n\n.side-by-side .minimap-header {\n  border-radius: 0; }\n\n.minimap-header {\n  background: #ffffff;\n  display: flex;\n  position: initial;\n  align-items: center;\n  justify-content: space-between;\n  border-radius: 4px 4px 0 0;\n  width: 100%;\n  z-index: 4;\n  transform-origin: top;\n  -moz-box-shadow: 0px 2px 4px -2px rgba(0, 0, 0, 0.5);\n  -webkit-box-shadow: 0px 2px 4px -2px rgba(0, 0, 0, 0.5);\n  box-shadow: 0px 2px 4px -2px rgba(0, 0, 0, 0.5); }\n\n.adsk-viewing-viewer.light-theme .minimap-header,\n.adsk-viewing-viewer.bim-theme .minimap-header,\n.adsk-viewing-viewer.acs-theme .minimap-header {\n  border-bottom: 1px solid #dcdcdc; }\n\n.minimap-title {\n  font-size: 14px;\n  text-align: left;\n  text-align-last: left;\n  margin-right: 12px;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis; }\n\n.minimap-dropdown-wrapper {\n  cursor: pointer;\n  outline: none;\n  white-space: nowrap;\n  flex-grow: 1;\n  display: flex;\n  align-items: center;\n  overflow: hidden;\n  margin-right: auto; }\n\n.minimap-dropdown-wrapper:after {\n  content: \"\";\n  border-width: 6px 5px 0 5px;\n  border-style: solid;\n  border-color: #819099 transparent; }\n\n.minimap-dropdown {\n  position: absolute;\n  top: 40px;\n  left: 5px;\n  max-height: 120px;\n  margin: 0;\n  width: 90%;\n  background: #ffffff;\n  list-style: none;\n  opacity: 0;\n  pointer-events: none;\n  overflow: scroll;\n  overflow-x: hidden;\n  border-radius: 3px;\n  z-index: 10;\n  box-shadow: 0px 1px 7px rgba(0, 0, 0, 0.3); }\n\n.minimap-dropdown li {\n  display: block;\n  color: #222222;\n  text-decoration: none;\n  border-left: 5px;\n  padding: 8px 8px 8px 20px;\n  font-size: 14px;\n  overflow: hidden;\n  text-overflow: ellipsis; }\n\n.minimap-dropdown li.active {\n  background: #eef0f2; }\n\n.minimap-dropdown li:hover {\n  background: #f8f9fa; }\n\n.minimap-dropdown.active {\n  opacity: 1;\n  pointer-events: auto;\n  padding: 0 0 10px 0; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/ui/ListPanel.css":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/ui/ListPanel.css ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".list-panel {\n  width: 260px;\n  min-width: 260px;\n  height: 260px;\n  min-height: 260px;\n  top: 180px;\n  left: 220px;\n  border-color: transparent; }\n\n.list-panel .itemList {\n  width: 100%;\n  display: flex;\n  flex-direction: column; }\n\n.list-panel .listItem {\n  display: flex;\n  justify-content: space-between;\n  text-align: left;\n  line-height: 35px;\n  background-color: rgba(0, 0, 0, 0);\n  border-style: none;\n  font-family: \"ArtifaktElement\", \"Helvetica Neue\", \"Segoe UI Semilight\", sans-serif;\n  padding: 0 10px; }\n\n.adsk-viewing-viewer.dark-theme .listItem {\n  color: #f3f7fb; }\n\n.adsk-viewing-viewer.light-theme .list-panel .listItem.hover {\n  background-color: rgba(10, 19, 28, 0.2); }\n\n.adsk-viewing-viewer.dark-theme .list-panel .listItem.hover {\n  background-color: #4a555b; }\n\n.list-panel .listItem:focus {\n  outline: none; }\n\n.list-panel .listItem.selected {\n  color: deepskyblue;\n  border-style: none; }\n\n.list-panel .listItem .textContainer {\n  -webkit-mask-image: linear-gradient(to left, transparent, black 1em);\n  mask-image: linear-gradient(to left, transparent, black 1em);\n  white-space: nowrap;\n  overflow: hidden;\n  width: 100%; }\n\n.list-panel .listItem .icon {\n  width: 24px; }\n\n.list-panel .listItem.selected .icon::before {\n  content: '\\2713';\n  margin-left: 8px; }\n\n.list-panel-item-warning {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScyNCcgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDggOCc+PHBhdGggZmlsbD0nIzZiNzg3ZicgZD0nTTMuMDkgMGMtLjA2IDAtLjEuMDQtLjEzLjA5bC0yLjk0IDYuODFjLS4wMi4wNS0uMDMuMTMtLjAzLjE5di44MWMwIC4wNS4wNC4wOS4wOS4wOWg2LjgxYy4wNSAwIC4wOS0uMDQuMDktLjA5di0uODFjMC0uMDUtLjAxLS4xNC0uMDMtLjE5bC0yLjk0LTYuODFjLS4wMi0uMDUtLjA3LS4wOS0uMTMtLjA5aC0uODF6bS0uMDkgM2gxdjJoLTF2LTJ6bTAgM2gxdjFoLTF2LTF6JyAvPjwvc3ZnPg==\");\n  width: 24px;\n  height: 24px;\n  margin-left: auto;\n  margin-top: auto;\n  margin-bottom: auto; }\n\n.list-panel .visibility {\n  right: 0;\n  top: 0;\n  width: 35px;\n  height: 35px;\n  border: none;\n  outline: none;\n  margin: 0;\n  padding: 0;\n  background-position: 6px 12px;\n  background-image: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+DQo8c3ZnIHdpZHRoPSIxN3B4IiBoZWlnaHQ9IjEwcHgiIHZpZXdCb3g9IjAgMCAxNyAxMCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4NCiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQ2LjIgKDQ0NDk2KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4NCiAgICA8dGl0bGU+R3JvdXAgMjU8L3RpdGxlPg0KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPg0KICAgIDxkZWZzPjwvZGVmcz4NCiAgICA8ZyBpZD0iU2VsZWN0LSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+DQogICAgICAgIDxnIGlkPSJNb2RlbF9Ccm93c2VyX2hvdmVyIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjYzLjAwMDAwMCwgLTE5NS4wMDAwMDApIj4NCiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjUzLjAwMDAwMCwgNzQuMDAwMDAwKSI+DQogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTE2IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCwgMzYuMDAwMDAwKSI+DQogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDcyLjAwMDAwMCkiPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Im1hcmt1cC1kaXNwbGF5LW9uIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMjIiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iZ3VpZGUiIG9wYWNpdHk9IjAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4LjAwMDAwMCwgMTguMDAwMDAwKSBzY2FsZSgxLCAtMSkgdHJhbnNsYXRlKC0xOC4wMDAwMDAsIC0xOC4wMDAwMDApICIgZmlsbD0iI0ZGOTg5OCI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTQiIHg9IjAiIHk9IjAiIHdpZHRoPSIzNiIgaGVpZ2h0PSIzNiI+PC9yZWN0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJzaG93LW1hcmtlcnMtaWNvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAuMDAwMDAwLCAxMy4wMDAwMDApIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGZpbGw9IiNGRkZGRkYiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9IkxheWVyXzEiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi40NzQsMC44MjM0NjMwNTcgQzEzLjQwOTk4ODMsMS4yMTU3ODg4NiAxNC4yODMzMDE4LDEuNzQzNDE1NzQgMTUuMDY2LDIuMzg5NDYzMDYgQzE1Ljc3NjcxMTYsMy4wMjUzOTQ1MSAxNi4zNzg2NTM3LDMuNzczMjYxOTMgMTYuODQ4LDQuNjAzNDYzMDYgQzE2LjQ5NzQ1OTEsNS41MTE5MjQ3NyAxNS45NjQ0OTk5LDYuMzM4OTMwNDMgMTUuMjgyLDcuMDMzNDYzMDYgQzE0LjUzNjE5MjEsNy43MzAyNjE3MSAxMy42NzgxNDUsOC4yOTYyMDc2OSAxMi43NDQsOC43MDc0NjMwNiBDMTEuMzYxMDM2NSw5LjI5MzUzOTU4IDkuODcxOTM1NjEsOS41ODc2ODI5NyA4LjM3LDkuNTcxNDYzMDYgQzYuODk2MjcwMjEsOS42NTA4OTU4OCA1LjQyMjc0OTI5LDkuNDExNDQ4NzMgNC4wNSw4Ljg2OTQ2MzA2IEMzLjExMzAyOTI4LDguNDg3MzIwMTcgMi4yNTMxMTg1Niw3LjkzODQ0MDk5IDEuNTEyLDcuMjQ5NDYzMDYgQzAuODQyNjYxOTQ4LDYuNTM0MTYwMTUgMC4zMjc5NTI0MTksNS42ODg1NjU5MiAwLDQuNzY1NDYzMDYgQzAuNDU1MjQyNjA0LDMuODYyMzEzMjkgMS4wNTc0NTAzMSwzLjA0MTEyMDk2IDEuNzgyLDIuMzM1NDYzMDYgQzIuNTUyMzY1MDQsMS42NTgzODQzOSAzLjQyNzgxNDI3LDEuMTExMjI4NjIgNC4zNzQsMC43MTU0NjMwNTcgQzUuNjUzNTg1NzEsMC4xNzgzNTEzOTYgNy4wMzgyOTI4MywtMC4wNjE2NjQ1MDQ1IDguNDI0LDAuMDEzNDYzMDU3MyBDOS44MTM2NzUzNCwwLjAxOTA0NzQ5MjggMTEuMTg5MDc0OSwwLjI5NDEyNzQwNiAxMi40NzQsMC44MjM0NjMwNTcgWiBNOC41MzIsOC4wNTk0NjMwNiBDOC45NjAxMDIyOSw4LjA1NTI5NTM2IDkuMzgyODA0ODMsNy45NjM0MDM1IDkuNzc0LDcuNzg5NDYzMDYgQzEwLjE1NjgyNjIsNy42MjE1NjcyNCAxMC41MDQ4MjQyLDcuMzgzNDYzMyAxMC44LDcuMDg3NDYzMDYgQzExLjQwOTE4MDYsNi40NzA2MDIwNyAxMS43NDA2NzExLDUuNjMyMTI1ODggMTEuNzE4LDQuNzY1NDYzMDYgQzExLjcyNjA1ODMsMy45MTc0MTMzNSAxMS4zOTU2NjU0LDMuMTAxMTQ4NDMgMTAuOCwyLjQ5NzQ2MzA2IEMxMC41MDQ4MjQyLDIuMjAxNDYyODIgMTAuMTU2ODI2MiwxLjk2MzM1ODg3IDkuNzc0LDEuNzk1NDYzMDYgQzguOTYzMjAwODEsMS40NTAzMjYwNyA4LjA0Njc5OTE5LDEuNDUwMzI2MDcgNy4yMzYsMS43OTU0NjMwNiBDNi44NTMxNzM4NCwxLjk2MzM1ODg3IDYuNTA1MTc1NzYsMi4yMDE0NjI4MiA2LjIxLDIuNDk3NDYzMDYgQzUuNjAwODE5NDUsMy4xMTQzMjQwNSA1LjI2OTMyODg2LDMuOTUyODAwMjQgNS4yOTIsNC44MTk0NjMwNiBDNS4yOTc2Njg2Nyw1LjI0NzM5NTM2IDUuMzg5NDk1NjMsNS42Njk3OTkzOSA1LjU2Miw2LjA2MTQ2MzA2IEM1LjcyNzU3OTMsNi40NDU1NzAxMyA1Ljk2NTk2NjY2LDYuNzkzOTgyNDQgNi4yNjQsNy4wODc0NjMwNiBDNi41NTgzNDMzMyw3LjM4NDQ2MzMxIDYuOTA2NTQzMzEsNy42MjI3MDU0IDcuMjksNy43ODk0NjMwNiBDNy42ODExOTUxNyw3Ljk2MzQwMzUgOC4xMDM4OTc3MSw4LjA1NTI5NTM2IDguNTMyLDguMDU5NDYzMDYgTDguNTMyLDguMDU5NDYzMDYgWiBNMTAuNDIyLDQuNzY1NDYzMDYgQzEwLjQxNjM1ODgsNC41MjI4NzM5MiAxMC4zNjEyMzI0LDQuMjgzOTkyNjggMTAuMjYsNC4wNjM0NjMwNiBDMTAuMTcyMzE3OCwzLjg0MzUzNDU2IDEwLjA0NDA5MzQsMy42NDIwMzg5NiA5Ljg4MiwzLjQ2OTQ2MzA2IEM5LjcxMTEwOTY4LDMuMzA1MjEyNSA5LjUwOTE2ODc2LDMuMTc2NzA0NjUgOS4yODgsMy4wOTE0NjMwNiBMOC41ODYsMi45Mjk0NjMwNiBMNy44ODQsMy4wOTE0NjMwNiBDNy40NDYzNTgyNiwzLjI3NzM3MzU0IDcuMDk3OTEwNDgsMy42MjU4MjEzMSA2LjkxMiw0LjA2MzQ2MzA2IEM2LjcxMDc1NzY2LDQuNTI4NjMwNTEgNi43MTA3NTc2Niw1LjA1NjI5NTYxIDYuOTEyLDUuNTIxNDYzMDYgQzcuMDg0OTYzNjIsNS45NDkzMjI1NiA3LjQxMjcxNDA0LDYuMjk2MzUyNDMgNy44Myw2LjQ5MzQ2MzA2IEw4LjUzMiw2LjY1NTQ2MzA2IEw5LjIzNCw2LjQ5MzQ2MzA2IEM5LjQ1NDUzMTUzLDYuNDA2OTYzMjEgOS42NTYyMzk3Miw2LjI3ODYwMzQ1IDkuODI4LDYuMTE1NDYzMDYgQzkuOTg5MTA0MjEsNS45NDIxMjA5IDEwLjExNzIwNDgsNS43NDA4MjAwMiAxMC4yMDYsNS41MjE0NjMwNiBDMTAuMzE0Njc2MSw1LjI4NDM1NTU3IDEwLjM2OTk3NzYsNS4wMjYyODIwNCAxMC4zNjgsNC43NjU0NjMwNiBMMTAuNDIyLDQuNzY1NDYzMDYgWiIgaWQ9IlNoYXBlIj48L3BhdGg+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICAgICAgICAgIDwvZz4NCiAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICA8L2c+DQogICAgICAgIDwvZz4NCiAgICA8L2c+DQo8L3N2Zz4=\");\n  background-repeat: no-repeat;\n  opacity: 0.7;\n  position: relative; }\n\n/* symbol for \"visibility toggled off\": eye with strike-through. */\n.list-panel .dim div.visibility {\n  background-position: 6px 9px;\n  background-image: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+DQo8c3ZnIHdpZHRoPSIxNnB4IiBoZWlnaHQ9IjE1cHgiIHZpZXdCb3g9IjAgMCAxNiAxNSIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4NCiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQ2ICg0NDQyMykgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+DQogICAgPHRpdGxlPm1hcmt1cF9kaXNwbGF5X3R1cm5fb2ZmPC90aXRsZT4NCiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4NCiAgICA8ZGVmcz48L2RlZnM+DQogICAgPGcgaWQ9IlBhZ2UtNiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+DQogICAgICAgIDxnIGlkPSJDYW1lcmEtSW50ZXJhY3Rpb25zLS0tSG92ZXItQ29weSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwNTcuMDAwMDAwLCAtMTIzLjAwMDAwMCkiIGZpbGw9IiNGNEY0RjQiPg0KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTE5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MTAuMDAwMDAwLCAxMTIuMDAwMDAwKSI+DQogICAgICAgICAgICAgICAgPGcgaWQ9Im1hcmt1cC1kaXNwbGF5LW9mZiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjM5LjAwMDAwMCwgMy4wMDAwMDApIj4NCiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Im1hcmt1cF9kaXNwbGF5X3R1cm5fb2ZmIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4LjAwMDAwMCwgOC4wMDAwMDApIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC4zMjIsMC41OTQgQzE0LjA1OCwwLjMzIDEzLjY2MiwwLjMzIDEzLjM5OCwwLjU5NCBMMTAuMzYyLDMuNjMgQzkuNTcsMy40MzIgOC43NzgsMy4yMzQgNy45MiwzLjIzNCBDNC4zNTYsMy4yMzQgMS4zMiw1LjQxMiAwLDguMDUyIEwwLDguMDUyIEMwLjU5NCw5LjI0IDEuNTg0LDEwLjM2MiAyLjc3MiwxMS4yMiBMMC40NjIsMTMuNTMgQzAuMTk4LDEzLjc5NCAwLjE5OCwxNC4xOSAwLjQ2MiwxNC40NTQgQzAuNzI2LDE0LjcxOCAxLjEyMiwxNC43MTggMS4zODYsMTQuNDU0IEwxNC4zMjIsMS41MTggQzE0LjU4NiwxLjI1NCAxNC41ODYsMC44NTggMTQuMzIyLDAuNTk0IEwxNC4zMjIsMC41OTQgWiBNNC43NTIsOC4wNTIgQzQuNzUyLDYuMjcgNi4yMDQsNC44ODQgNy45Miw0Ljg4NCBDOC4yNSw0Ljg4NCA4LjY0Niw0Ljk1IDguOTEsNS4wODIgTDguMDUyLDUuOTQgTDcuODU0LDUuOTQgQzYuNjY2LDUuOTQgNS42NzYsNi45MyA1LjY3Niw4LjExOCBMNS42NzYsOC4zMTYgTDQuODE4LDkuMTc0IEM0LjgxOCw4Ljc3OCA0Ljc1Miw4LjM4MiA0Ljc1Miw4LjA1MiBMNC43NTIsOC4wNTIgWiBNNy45MiwxMC4yMyBDOS4xMDgsMTAuMjMgMTAuMDk4LDkuMjQgMTAuMDk4LDguMDUyIEMxMC4wOTgsNy44NTQgMTAuMDMyLDcuNjU2IDkuOTY2LDcuMzkyIEw3LjI2LDEwLjA5OCBDNy41MjQsMTAuMTY0IDcuNzIyLDEwLjIzIDcuOTIsMTAuMjMgTDcuOTIsMTAuMjMgWiBNMTUuODQsOC4wNTIgQzE1LjE4LDYuNzMyIDE0LjA1OCw1LjU0NCAxMi43MzgsNC42ODYgTDEwLjc1OCw2LjY2NiBDMTAuOTU2LDcuMDYyIDExLjA4OCw3LjU5IDExLjA4OCw4LjA1MiBDMTEuMDg4LDkuODM0IDkuNjM2LDExLjIyIDcuOTIsMTEuMjIgQzcuMzkyLDExLjIyIDYuOTMsMTEuMDg4IDYuNTM0LDEwLjg5IEw1LjA4MiwxMi4zNDIgQzUuOTQsMTIuNjcyIDYuOTMsMTIuODcgNy45MiwxMi44NyBDMTEuNDg0LDEyLjg3IDE0LjUyLDEwLjY5MiAxNS44NCw4LjA1MiBMMTUuODQsOC4wNTIgWiIgaWQ9IlNoYXBlIj48L3BhdGg+DQogICAgICAgICAgICAgICAgICAgIDwvZz4NCiAgICAgICAgICAgICAgICA8L2c+DQogICAgICAgICAgICA8L2c+DQogICAgICAgIDwvZz4NCiAgICA8L2c+DQo8L3N2Zz4=\");\n  opacity: 0.3; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./res/locales/cs/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/cs/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"cs\",\"@@context\":\"Rozšíření Minimap3D\",\"Side by side\":\"Vedle sebe\",\"Small map\":\"Malá mapa\",\"Go to 2D\":\"Přejít do 2D\",\"Show sheet\":\"Zobrazit list\",\"Hide sheet\":\"Skrýt list\",\"Loading sheet...\":\"Načítání listu...\",\"Loading models...\":\"Načítání modelů...\"}");

/***/ }),

/***/ "./res/locales/cs/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/cs/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"cs\",\"@@context\":\"Rozšíření výřezů\",\"Level\":\"Úroveň\"}");

/***/ }),

/***/ "./res/locales/da/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/da/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"da\",\"@@context\":\"Minimap3D-udvidelse\",\"Side by side\":\"Side om side\",\"Small map\":\"Lille kort\",\"Go to 2D\":\"Gå til 2D\",\"Show sheet\":\"Vis ark\",\"Hide sheet\":\"Skjul sheet\",\"Loading sheet...\":\"Indlæser ark...\",\"Loading models...\":\"Indlæser modeller...\"}");

/***/ }),

/***/ "./res/locales/da/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/da/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"da\",\"@@context\":\"Viewports-udvidelse\",\"Level\":\"Niveau\"}");

/***/ }),

/***/ "./res/locales/de/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/de/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"de\",\"@@context\":\"Minimap3D-Erweiterung\",\"Side by side\":\"Nebeneinander\",\"Small map\":\"Kleine Karte\",\"Go to 2D\":\"Zu 2D wechseln\",\"Show sheet\":\"Plan anzeigen\",\"Hide sheet\":\"Blatt ausblenden\",\"Loading sheet...\":\"Plan wird geladen...\",\"Loading models...\":\"Modelle werden geladen...\"}");

/***/ }),

/***/ "./res/locales/de/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/de/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"de\",\"@@context\":\"Ansichtsfenstererweiterung\",\"Level\":\"Ebene\"}");

/***/ }),

/***/ "./res/locales/en-GB/nobundle-minimap3D.loc.json":
/*!*******************************************************!*\
  !*** ./res/locales/en-GB/nobundle-minimap3D.loc.json ***!
  \*******************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"Minimap3D Extension\",\"Side by side\":\"Side By Side\",\"Small map\":\"Small Map\",\"Go to 2D\":\"Go to 2D\",\"Show sheet\":\"Show Sheet\",\"Hide sheet\":\"Hide Sheet\",\"Loading sheet...\":\"Loading Sheet...\",\"Loading models...\":\"Loading Models...\"}");

/***/ }),

/***/ "./res/locales/en-GB/nobundle-viewports.loc.json":
/*!*******************************************************!*\
  !*** ./res/locales/en-GB/nobundle-viewports.loc.json ***!
  \*******************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"Viewports Extension\",\"Level\":\"Level\"}");

/***/ }),

/***/ "./res/locales/en/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/en/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"Minimap3D Extension\",\"Side by side\":\"Side by side\",\"Small map\":\"Small map\",\"Go to 2D\":\"Go to 2D\",\"Show sheet\":\"Show sheet\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Loading sheet...\",\"Loading models...\":\"Loading models...\"}");

/***/ }),

/***/ "./res/locales/en/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/en/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"Viewports Extension\",\"Level\":\"Level\"}");

/***/ }),

/***/ "./res/locales/es/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/es/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"es\",\"@@context\":\"Extensión de minimapa 3D\",\"Side by side\":\"En paralelo\",\"Small map\":\"Mapa pequeño\",\"Go to 2D\":\"Ir a 2D\",\"Show sheet\":\"Mostrar plano\",\"Hide sheet\":\"Ocultar plano\",\"Loading sheet...\":\"Cargando plano...\",\"Loading models...\":\"Cargando modelos...\"}");

/***/ }),

/***/ "./res/locales/es/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/es/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"es\",\"@@context\":\"Extensión de ventanas gráficas\",\"Level\":\"Nivel\"}");

/***/ }),

/***/ "./res/locales/fr-CA/nobundle-minimap3D.loc.json":
/*!*******************************************************!*\
  !*** ./res/locales/fr-CA/nobundle-minimap3D.loc.json ***!
  \*******************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"fr-CA\",\"@@context\":\"Extension Minimap3D\",\"Side by side\":\"Côte à côte\",\"Small map\":\"Petite carte\",\"Go to 2D\":\"Aller à la 2D\",\"Show sheet\":\"Afficher la feuille\",\"Hide sheet\":\"Masquer la feuille\",\"Loading sheet...\":\"Chargement de la feuille...\",\"Loading models...\":\"Chargement des modèles...\"}");

/***/ }),

/***/ "./res/locales/fr-CA/nobundle-viewports.loc.json":
/*!*******************************************************!*\
  !*** ./res/locales/fr-CA/nobundle-viewports.loc.json ***!
  \*******************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"fr-CA\",\"@@context\":\"Extension des fenêtres\",\"Level\":\"Niveau\"}");

/***/ }),

/***/ "./res/locales/fr/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/fr/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"fr\",\"@@context\":\"Extension Minimap3D\",\"Side by side\":\"Côte à côte\",\"Small map\":\"Petite carte\",\"Go to 2D\":\"Aller à la 2D\",\"Show sheet\":\"Afficher une feuille\",\"Hide sheet\":\"Masquer la feuille\",\"Loading sheet...\":\"Chargement de la feuille…\",\"Loading models...\":\"Chargement des modèles…\"}");

/***/ }),

/***/ "./res/locales/fr/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/fr/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"fr\",\"@@context\":\"Extension des fenêtres\",\"Level\":\"Niveau\"}");

/***/ }),

/***/ "./res/locales/it/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/it/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"it\",\"@@context\":\"Estensione Minimap3D\",\"Side by side\":\"Affiancato\",\"Small map\":\"Mappa piccola\",\"Go to 2D\":\"Vai a 2D\",\"Show sheet\":\"Mostra foglio\",\"Hide sheet\":\"Nascondi foglio\",\"Loading sheet...\":\"Caricamento foglio in corso...\",\"Loading models...\":\"Caricamento modelli in corso...\"}");

/***/ }),

/***/ "./res/locales/it/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/it/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"it\",\"@@context\":\"Estensione finestre\",\"Level\":\"Livello\"}");

/***/ }),

/***/ "./res/locales/ja/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/ja/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ja\",\"@@context\":\"Minimap3D Extension\",\"Side by side\":\"並べて表示\",\"Small map\":\"小マップ\",\"Go to 2D\":\"2D に移動\",\"Show sheet\":\"シートを表示\",\"Hide sheet\":\"シートを非表示\",\"Loading sheet...\":\"シートをロード中...\",\"Loading models...\":\"モデルをロード中...\"}");

/***/ }),

/***/ "./res/locales/ja/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/ja/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ja\",\"@@context\":\"Viewports Extension\",\"Level\":\"レベル\"}");

/***/ }),

/***/ "./res/locales/ko/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/ko/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ko\",\"@@context\":\"Minip3D 확장 프로그램\",\"Side by side\":\"나란히\",\"Small map\":\"작은 맵\",\"Go to 2D\":\"2D로 이동\",\"Show sheet\":\"시트 표시\",\"Hide sheet\":\"시트 숨기기\",\"Loading sheet...\":\"시트 로드 중...\",\"Loading models...\":\"모델 로드 중...\"}");

/***/ }),

/***/ "./res/locales/ko/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/ko/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ko\",\"@@context\":\"뷰포트 확장\",\"Level\":\"수준\"}");

/***/ }),

/***/ "./res/locales/nl/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/nl/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"nl\",\"@@context\":\"Minimap3D-extensie\",\"Side by side\":\"Naast elkaar\",\"Small map\":\"Kleine kaart\",\"Go to 2D\":\"Ga naar 2D\",\"Show sheet\":\"Blad weergeven\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Blad laden...\",\"Loading models...\":\"Modellen laden...\"}");

/***/ }),

/***/ "./res/locales/nl/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/nl/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"nl\",\"@@context\":\"Extensie viewports\",\"Level\":\"Niveau\"}");

/***/ }),

/***/ "./res/locales/no/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/no/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"no\",\"@@context\":\"Minikart-3D-utvidelse\",\"Side by side\":\"Side ved side\",\"Small map\":\"Lite kart\",\"Go to 2D\":\"Gå til 2D\",\"Show sheet\":\"Vis ark\",\"Hide sheet\":\"Skjul ark\",\"Loading sheet...\":\"Laster ark ...\",\"Loading models...\":\"Laster modeller ...\"}");

/***/ }),

/***/ "./res/locales/no/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/no/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"no\",\"@@context\":\"Viewports-utvidelse\",\"Level\":\"Nivå\"}");

/***/ }),

/***/ "./res/locales/pl/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/pl/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"pl\",\"@@context\":\"Rozszerzenie Minimap3D\",\"Side by side\":\"Równolegle\",\"Small map\":\"Mała mapa\",\"Go to 2D\":\"Przejdź do 2D\",\"Show sheet\":\"Pokaż arkusz\",\"Hide sheet\":\"Ukryj arkusz\",\"Loading sheet...\":\"Wczytywanie arkusza...\",\"Loading models...\":\"Wczytywanie modeli...\"}");

/***/ }),

/***/ "./res/locales/pl/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/pl/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"pl\",\"@@context\":\"Rozszerzenie Viewports\",\"Level\":\"Poziom\"}");

/***/ }),

/***/ "./res/locales/pt-BR/nobundle-minimap3D.loc.json":
/*!*******************************************************!*\
  !*** ./res/locales/pt-BR/nobundle-minimap3D.loc.json ***!
  \*******************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"pt\",\"@@context\":\"Extensão Minimap3D\",\"Side by side\":\"Lado a lado\",\"Small map\":\"Mapa pequeno\",\"Go to 2D\":\"Ir para 2D\",\"Show sheet\":\"Mostrar folha\",\"Hide sheet\":\"Ocultar folha\",\"Loading sheet...\":\"Carregando folha...\",\"Loading models...\":\"Carregando modelos...\"}");

/***/ }),

/***/ "./res/locales/pt-BR/nobundle-viewports.loc.json":
/*!*******************************************************!*\
  !*** ./res/locales/pt-BR/nobundle-viewports.loc.json ***!
  \*******************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ptb\",\"@@context\":\"Extensão de viewports\",\"Level\":\"Nível\"}");

/***/ }),

/***/ "./res/locales/ru/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/ru/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ru\",\"@@context\":\"Расширение Minimap3D\",\"Side by side\":\"Рядом\",\"Small map\":\"Маленькая карта\",\"Go to 2D\":\"Перейти к 2D\",\"Show sheet\":\"Показать лист\",\"Hide sheet\":\"Скрыть лист\",\"Loading sheet...\":\"Загрузка листа...\",\"Loading models...\":\"Загрузка моделей...\"}");

/***/ }),

/***/ "./res/locales/ru/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/ru/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ru\",\"@@context\":\"Расширение видовых экранов\",\"Level\":\"Уровень\"}");

/***/ }),

/***/ "./res/locales/sv/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/sv/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"sv\",\"@@context\":\"Minimap3D-tillägg\",\"Side by side\":\"Sida vid sida\",\"Small map\":\"Liten karta\",\"Go to 2D\":\"Gå till 2D\",\"Show sheet\":\"Visa blad\",\"Hide sheet\":\"Dölj blad\",\"Loading sheet...\":\"Läser in blad...\",\"Loading models...\":\"Läser in modeller...\"}");

/***/ }),

/***/ "./res/locales/sv/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/sv/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"sv\",\"@@context\":\"Tillägg för vyportar\",\"Level\":\"Våning\"}");

/***/ }),

/***/ "./res/locales/tr/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/tr/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"tr\",\"@@context\":\"Minimap3D Uzantısı\",\"Side by side\":\"Yan yana\",\"Small map\":\"Küçük harita\",\"Go to 2D\":\"2B haritaya git\",\"Show sheet\":\"Sayfayı göster\",\"Hide sheet\":\"Sayfayı gizle\",\"Loading sheet...\":\"Sayfa yükleniyor...\",\"Loading models...\":\"Model yükleniyor...\"}");

/***/ }),

/***/ "./res/locales/tr/nobundle-viewports.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/tr/nobundle-viewports.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"tr\",\"@@context\":\"Görüntü Alanları Uzantısı\",\"Level\":\"Seviye\"}");

/***/ }),

/***/ "./res/locales/zh-HANS/nobundle-minimap3D.loc.json":
/*!*********************************************************!*\
  !*** ./res/locales/zh-HANS/nobundle-minimap3D.loc.json ***!
  \*********************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-Hans\",\"@@context\":\"Minimap3D 扩展\",\"Side by side\":\"并排\",\"Small map\":\"小地图\",\"Go to 2D\":\"转至二维\",\"Show sheet\":\"显示图纸\",\"Hide sheet\":\"隐藏工作表\",\"Loading sheet...\":\"正在加载图纸...\",\"Loading models...\":\"正在加载模型...\"}");

/***/ }),

/***/ "./res/locales/zh-HANS/nobundle-viewports.loc.json":
/*!*********************************************************!*\
  !*** ./res/locales/zh-HANS/nobundle-viewports.loc.json ***!
  \*********************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-Hans\",\"@@context\":\"视口扩展\",\"Level\":\"级别\"}");

/***/ }),

/***/ "./res/locales/zh-HANT/nobundle-minimap3D.loc.json":
/*!*********************************************************!*\
  !*** ./res/locales/zh-HANT/nobundle-minimap3D.loc.json ***!
  \*********************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-Hant\",\"@@context\":\"Minimap3D 延伸\",\"Side by side\":\"並排\",\"Small map\":\"小地圖\",\"Go to 2D\":\"移至 2D\",\"Show sheet\":\"展示圖紙\",\"Hide sheet\":\"隱藏圖紙\",\"Loading sheet...\":\"正在載入圖紙...\",\"Loading models...\":\"正在載入模型...\"}");

/***/ }),

/***/ "./res/locales/zh-HANT/nobundle-viewports.loc.json":
/*!*********************************************************!*\
  !*** ./res/locales/zh-HANT/nobundle-viewports.loc.json ***!
  \*********************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-Hant\",\"@@context\":\"Viewports 延伸\",\"Level\":\"樓層\"}");

/***/ }),

/***/ "./res/locales/zh-HK/nobundle-minimap3D.loc.json":
/*!*******************************************************!*\
  !*** ./res/locales/zh-HK/nobundle-minimap3D.loc.json ***!
  \*******************************************************/
/*! exports provided: @@locale, @@context, Side by side, Small map, Go to 2D, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-hk\",\"@@context\":\"Minimap3D 擴充功能\",\"Side by side\":\"並排\",\"Small map\":\"小地圖\",\"Go to 2D\":\"移至 2D\",\"Show sheet\":\"展示圖紙\",\"Hide sheet\":\"隱藏圖紙\",\"Loading sheet...\":\"圖紙載入中…\",\"Loading models...\":\"模型載入中…\"}");

/***/ }),

/***/ "./res/locales/zh-HK/nobundle-viewports.loc.json":
/*!*******************************************************!*\
  !*** ./res/locales/zh-HK/nobundle-viewports.loc.json ***!
  \*******************************************************/
/*! exports provided: @@locale, @@context, Level, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-hk\",\"@@context\":\"檢視區擴充程式\",\"Level\":\"樓層\"}");

/***/ }),

/***/ "./thirdparty/mouse-event-polyfill/MouseEventPolyfill.js":
/*!***************************************************************!*\
  !*** ./thirdparty/mouse-event-polyfill/MouseEventPolyfill.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

try {
  new window.MouseEvent('test');
} catch (e) {
  // Polyfills DOM4 MouseEvent
  var MouseEvent = function MouseEvent(eventType, params) {
    params = params || { bubbles: false, cancelable: false };
    var mouseEvent = document.createEvent("MouseEvent");
    mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, params.screenX || 0, params.screenY || 0, params.clientX || 0, params.clientY || 0, false, false, false, false, 0, null);
    return mouseEvent;
  };

  MouseEvent.prototype = Event.prototype;

  window.MouseEvent = MouseEvent;
}

/***/ }),

/***/ "./thirdparty/resize-observer-polyfill/ResizeObserver.min.js":
/*!*******************************************************************!*\
  !*** ./thirdparty/resize-observer-polyfill/ResizeObserver.min.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ResizeObserver=e()}(this,function(){"use strict";var t=function(){if("undefined"!=typeof Map)return Map;function t(t,e){var n=-1;return t.some(function(t,i){return t[0]===e&&(n=i,!0)}),n}return function(){function e(){this.__entries__=[]}var n={size:{configurable:!0}};return n.size.get=function(){return this.__entries__.length},e.prototype.get=function(e){var n=t(this.__entries__,e),i=this.__entries__[n];return i&&i[1]},e.prototype.set=function(e,n){var i=t(this.__entries__,e);~i?this.__entries__[i][1]=n:this.__entries__.push([e,n])},e.prototype.delete=function(e){var n=this.__entries__,i=t(n,e);~i&&n.splice(i,1)},e.prototype.has=function(e){return!!~t(this.__entries__,e)},e.prototype.clear=function(){this.__entries__.splice(0)},e.prototype.forEach=function(t,e){void 0===e&&(e=null);for(var n=0,i=this.__entries__;n<i.length;n+=1){var r=i[n];t.call(e,r[1],r[0])}},Object.defineProperties(e.prototype,n),e}()}(),e="undefined"!=typeof window&&"undefined"!=typeof document&&window.document===document,n="undefined"!=typeof global&&global.Math===Math?global:"undefined"!=typeof self&&self.Math===Math?self:"undefined"!=typeof window&&window.Math===Math?window:Function("return this")(),i="function"==typeof requestAnimationFrame?requestAnimationFrame.bind(n):function(t){return setTimeout(function(){return t(Date.now())},1e3/60)},r=2,o=["top","right","bottom","left","width","height","size","weight"],s="undefined"!=typeof MutationObserver,a=function(){this.connected_=!1,this.mutationEventsAdded_=!1,this.mutationsObserver_=null,this.observers_=[],this.onTransitionEnd_=this.onTransitionEnd_.bind(this),this.refresh=function(t,e){var n=!1,o=!1,s=0;function a(){n&&(n=!1,t()),o&&h()}function c(){i(a)}function h(){var t=Date.now();if(n){if(t-s<r)return;o=!0}else n=!0,o=!1,setTimeout(c,e);s=t}return h}(this.refresh.bind(this),20)};a.prototype.addObserver=function(t){~this.observers_.indexOf(t)||this.observers_.push(t),this.connected_||this.connect_()},a.prototype.removeObserver=function(t){var e=this.observers_,n=e.indexOf(t);~n&&e.splice(n,1),!e.length&&this.connected_&&this.disconnect_()},a.prototype.refresh=function(){this.updateObservers_()&&this.refresh()},a.prototype.updateObservers_=function(){var t=this.observers_.filter(function(t){return t.gatherActive(),t.hasActive()});return t.forEach(function(t){return t.broadcastActive()}),t.length>0},a.prototype.connect_=function(){e&&!this.connected_&&(document.addEventListener("transitionend",this.onTransitionEnd_),window.addEventListener("resize",this.refresh),s?(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(document.addEventListener("DOMSubtreeModified",this.refresh),this.mutationEventsAdded_=!0),this.connected_=!0)},a.prototype.disconnect_=function(){e&&this.connected_&&(document.removeEventListener("transitionend",this.onTransitionEnd_),window.removeEventListener("resize",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationEventsAdded_&&document.removeEventListener("DOMSubtreeModified",this.refresh),this.mutationsObserver_=null,this.mutationEventsAdded_=!1,this.connected_=!1)},a.prototype.onTransitionEnd_=function(t){var e=t.propertyName;void 0===e&&(e=""),o.some(function(t){return!!~e.indexOf(t)})&&this.refresh()},a.getInstance=function(){return this.instance_||(this.instance_=new a),this.instance_},a.instance_=null;var c=function(t,e){for(var n=0,i=Object.keys(e);n<i.length;n+=1){var r=i[n];Object.defineProperty(t,r,{value:e[r],enumerable:!1,writable:!1,configurable:!0})}return t},h=function(t){return t&&t.ownerDocument&&t.ownerDocument.defaultView||n},u=_(0,0,0,0);function f(t){return parseFloat(t)||0}function d(t){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];return e.reduce(function(e,n){return e+f(t["border-"+n+"-width"])},0)}function p(t){var e=t.clientWidth,n=t.clientHeight;if(!e&&!n)return u;var i,r=h(t).getComputedStyle(t),o=function(t){for(var e={},n=0,i=["top","right","bottom","left"];n<i.length;n+=1){var r=i[n],o=t["padding-"+r];e[r]=f(o)}return e}(r),s=o.left+o.right,a=o.top+o.bottom,c=f(r.width),p=f(r.height);if("border-box"===r.boxSizing&&(Math.round(c+s)!==e&&(c-=d(r,"left","right")+s),Math.round(p+a)!==n&&(p-=d(r,"top","bottom")+a)),(i=t)!==h(i).document.documentElement){var v=Math.round(c+s)-e,l=Math.round(p+a)-n;1!==Math.abs(v)&&(c-=v),1!==Math.abs(l)&&(p-=l)}return _(o.left,o.top,c,p)}var v="undefined"!=typeof SVGGraphicsElement?function(t){return t instanceof h(t).SVGGraphicsElement}:function(t){return t instanceof h(t).SVGElement&&"function"==typeof t.getBBox};function l(t){return e?v(t)?_(0,0,(n=t.getBBox()).width,n.height):p(t):u;var n}function _(t,e,n,i){return{x:t,y:e,width:n,height:i}}var b=function(t){this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=_(0,0,0,0),this.target=t};b.prototype.isActive=function(){var t=l(this.target);return this.contentRect_=t,t.width!==this.broadcastWidth||t.height!==this.broadcastHeight},b.prototype.broadcastRect=function(){var t=this.contentRect_;return this.broadcastWidth=t.width,this.broadcastHeight=t.height,t};var m=function(t,e){var n,i,r,o,s,a,h,u=(i=(n=e).x,r=n.y,o=n.width,s=n.height,a="undefined"!=typeof DOMRectReadOnly?DOMRectReadOnly:Object,h=Object.create(a.prototype),c(h,{x:i,y:r,width:o,height:s,top:r,right:i+o,bottom:s+r,left:i}),h);c(this,{target:t,contentRect:u})},y=function(e,n,i){if(this.activeObservations_=[],this.observations_=new t,"function"!=typeof e)throw new TypeError("The callback provided as parameter 1 is not a function.");this.callback_=e,this.controller_=n,this.callbackCtx_=i};y.prototype.observe=function(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!=typeof Element&&Element instanceof Object){if(!(t instanceof h(t).Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observations_;e.has(t)||(e.set(t,new b(t)),this.controller_.addObserver(this),this.controller_.refresh())}},y.prototype.unobserve=function(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!=typeof Element&&Element instanceof Object){if(!(t instanceof h(t).Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observations_;e.has(t)&&(e.delete(t),e.size||this.controller_.removeObserver(this))}},y.prototype.disconnect=function(){this.clearActive(),this.observations_.clear(),this.controller_.removeObserver(this)},y.prototype.gatherActive=function(){var t=this;this.clearActive(),this.observations_.forEach(function(e){e.isActive()&&t.activeObservations_.push(e)})},y.prototype.broadcastActive=function(){if(this.hasActive()){var t=this.callbackCtx_,e=this.activeObservations_.map(function(t){return new m(t.target,t.broadcastRect())});this.callback_.call(t,e,t),this.clearActive()}},y.prototype.clearActive=function(){this.activeObservations_.splice(0)},y.prototype.hasActive=function(){return this.activeObservations_.length>0};var g="undefined"!=typeof WeakMap?new WeakMap:new t,w=function(t){if(!(this instanceof w))throw new TypeError("Cannot call a class as a function.");if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");var e=a.getInstance(),n=new y(t,e,this);g.set(this,n)};return["observe","unobserve","disconnect"].forEach(function(t){w.prototype[t]=function(){return(e=g.get(this))[t].apply(e,arguments);var e}}),void 0!==n.ResizeObserver?n.ResizeObserver:w});

/***/ })

/******/ });
//# sourceMappingURL=AEC.js.map