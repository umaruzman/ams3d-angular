{"version":3,"file":"Section/Section.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Section/Section.css?22a4","webpack://Autodesk.Extensions.[name]/./extensions/Section/Section.js","webpack://Autodesk.Extensions.[name]/./extensions/Section/SectionTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Section/Section.css","webpack://Autodesk.Extensions.[name]/./node_modules/css-loader/lib/css-base.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/addStyles.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/urls.js","webpack://Autodesk.Extensions.[name]/(webpack)/buildin/amd-options.js","webpack://Autodesk.Extensions.[name]/(webpack)/buildin/global.js","webpack://Autodesk.Extensions.[name]/./thirdparty/lodash/lodash.custom.js","webpack://Autodesk.Extensions.[name]/./thirdparty/three.js/TransformControls.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/Section/Section.js\");\n","\nvar content = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Section.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Section.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Section.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","import { SectionTool } from './SectionTool';\nimport './Section.css';\n\nvar avp = Autodesk.Viewing.Private;\nvar analytics = avp.analytics;\n\n/**\n                                * The SectionExtension provides ways to cut the geometry using planes or a cube.\n                                * The extension adds a toolbar button to access the feature.\n                                *\n                                * The extension id is: `Autodesk.Section`\n                                *\n                                * @param {Viewer3D} viewer - Viewer instance\n                                * @param {object} options - Configurations for the extension\n                                * @example \n                                * viewer.loadExtension('Autodesk.Section')\n                                * @memberof Autodesk.Viewing.Extensions\n                                * @alias Autodesk.Viewing.Extensions.SectionExtension\n                                * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                                * @class\n                                */\nexport var SectionExtension = function SectionExtension(viewer, options) {\n  Autodesk.Viewing.Extension.call(this, viewer, options);\n  this.viewer = viewer;\n  this.name = 'section';\n  this.modes = ['x', 'y', 'z', 'box'];\n\n  this.onViewerSetView = this.onViewerSetView.bind(this);\n  this._onCutPlanesChanged = this._onCutPlanesChanged.bind(this);\n  this._onShowAll = this._onShowAll.bind(this);\n};\n\nSectionExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nSectionExtension.prototype.constructor = SectionExtension;\n\nvar proto = SectionExtension.prototype;\n\n/**\n                                         * Registers the SectionTool, hotkeys and event handlers.\n                                         *\n                                         * @returns {boolean}\n                                         */\nproto.load = function () {var _this = this;\n  var that = this;\n  var viewer = this.viewer;\n\n  this.tool = new SectionTool(viewer, {\n    tintColor: { r: 1, g: 1, b: 0 },\n    tintIntensity: 0.2 });\n\n\n  viewer.toolController.registerTool(this.tool, this.setActive.bind(this));\n  this.sectionStyle = null;\n  this.supportedStyles = [\"X\", \"Y\", \"Z\", \"BOX\"];\n\n  this.displaySectionHatches = this.displaySectionHatches.bind(this);\n\n  this.viewer.prefs.addListeners(avp.Prefs3D.DISPLAY_SECTION_HATCHES, this.displaySectionHatches);\n\n  viewer.addEventListener(Autodesk.Viewing.SET_VIEW_EVENT, this.onViewerSetView);\n\n  // consider cutplane changes of other tools, so that cap meshes consider them too\n  viewer.addEventListener(Autodesk.Viewing.CUTPLANES_CHANGE_EVENT, this._onCutPlanesChanged);\n  viewer.addEventListener(Autodesk.Viewing.SHOW_ALL_EVENT, this._onShowAll);\n\n  this.HOTKEYS_ID = \"Autodesk.Section.Hotkeys\";\n  var hotkeys = [{\n    keycodes: [\n    Autodesk.Viewing.KeyCode.ESCAPE],\n\n    onRelease: function onRelease() {\n      if (that.viewer.getAggregateSelection().length === 0)\n      return that.deactivate();\n    } }];\n\n  viewer.getHotkeyManager().pushHotkeys(this.HOTKEYS_ID, hotkeys);\n\n  // Invoked when the context menu is about to get opened.\n  this.viewer.registerContextMenuCallback('Autodesk.Section', function (menu, status) {\n    onContextMenu(_this, menu, status);\n  });\n\n  //Load the required dependency (and return the pending load as the load completion Promise)\n  return this.viewer.loadExtension('Autodesk.CompGeom');\n};\n\n/**\n    * Unregisters the SectionTool, hotkeys and event handlers.\n    *\n    * @returns {boolean}\n    */\nproto.unload = function () {\n  var viewer = this.viewer;\n\n  viewer.unregisterContextMenuCallback('Autodesk.Section');\n\n  // remove hotkey\n  viewer.getHotkeyManager().popHotkeys(this.HOTKEYS_ID);\n\n  this.destroyUI();\n\n  viewer.removeEventListener(Autodesk.Viewing.SET_VIEW_EVENT, this.onViewerSetView);\n  viewer.removeEventListener(Autodesk.Viewing.CUTPLANES_CHANGE_EVENT, this._onCutPlanesChanged);\n  viewer.removeEventListener(Autodesk.Viewing.SHOW_ALL_EVENT, this._onShowAll);\n\n  this.viewer.prefs.removeListeners(avp.Prefs3D.DISPLAY_SECTION_HATCHES, this.displaySectionHatches);\n\n  viewer.toolController.deregisterTool(this.tool);\n  this.tool = null;\n\n  return true;\n};\n\n/**\n    * Toggles activeness of section planes.\n    *\n    * @returns {boolean} Whether the section plane is active or not.\n    * @alias Autodesk.Viewing.Extensions.SectionExtension#toggle\n    */\nproto.toggle = function () {\n  if (this.isActive()) {\n    this.enableSectionTool(false);\n  } else {\n    var style = this.sectionStyle || \"X\";\n    this.setSectionStyle(style, true);\n  }\n  return this.isActive(); // Need to check for isActive() again.\n};\n\n/**\n    * Returns the current type of plane that will cut-though the geometry.\n    *\n    * @returns {null | string} Either \"X\" or \"Y\" or \"Z\" or \"BOX\" or null.\n    * @alias Autodesk.Viewing.Extensions.SectionExtension#getSectionStyle\n    */\nproto.getSectionStyle = function () {\n  return this.sectionStyle;\n};\n\n/**\n    * Sets the Section plane style.\n    *\n    * @param {string} style - Accepted values are 'X', 'Y', 'Z' and 'BOX' (in Caps)\n    * @param {boolean} [preserveSection] - Whether sending the current style value resets the cut planes.\n    * @alias Autodesk.Viewing.Extensions.SectionExtension#setSectionStyle\n    */\nproto.setSectionStyle = function (style, preserveSection) {\n\n  if (this.supportedStyles.indexOf(style) === -1) {\n    return false;\n  }\n\n  var bActive = this.isActive();\n  var bNewStyle = this.sectionStyle !== style || !preserveSection;\n  this.sectionStyle = style;\n\n  if (bActive && bNewStyle) {\n    this.tool.setSection(style);\n  } else\n  if (!bActive) {\n    this.enableSectionTool(true);\n    if (bNewStyle) {\n      this.tool.setSection(style);\n    } else {\n      this.tool.attachControl(true);\n    }\n  }\n  return true;\n};\n\n/**\n    * Use to set the section from an externally defined plane. For showing with line pattern\n    * Tool itself will be disabled when setting the plane\n    *\n    * @param {THREE.Vector4} cutplane - send null to clear the section\n    */\nproto.setSectionFromPlane = function (cutplane) {\n  this.deactivate();\n\n  if (cutplane) {\n    this.tool.setSectionFromPlane(cutplane);\n    this.tool.attachControl(false);\n    // LMV-5299\n    if (!this.isActive()) {\n      this.tool.showPlane(false);\n    }\n  } else {\n    this.tool.clearSection();\n    var prevLock = this.viewer.toolController.setIsLocked(false);\n    this.enableSectionTool(false);\n    this.viewer.toolController.setIsLocked(prevLock);\n  }\n};\n\n/**\n    * Returns the planes belonging only to the Section tool's set*\n    */\nproto.getSectionPlanes = function () {\n  return this.tool.getSectionPlanes();\n};\n\n/**\n    *\n    * @param enable\n    * @param keepCutPlanes - keep existing cut planes when deactivating the tool.\n    * @returns {boolean}\n    * @private\n    */\nproto.enableSectionTool = function (enable) {var keepCutPlanes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var toolController = this.viewer.toolController,\n  isActive = this.tool.isActive();\n\n  if (enable && !isActive) {\n    toolController.activateTool(\"section\");\n    if (this.sectionToolButton) {\n      this.sectionToolButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);\n    }\n    return true;\n\n  } else if (!enable && isActive) {\n    var prevKeepCutPlanes = this.tool.keepCutPlanesOnDeactivate;\n    this.tool.keepCutPlanesOnDeactivate = keepCutPlanes;\n    toolController.deactivateTool(\"section\");\n    this.tool.keepCutPlanesOnDeactivate = prevKeepCutPlanes;\n\n    if (this.sectionToolButton) {\n      this.sectionToolButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);\n    }\n    return true;\n  } else if (enable) {\n    toolController.activateToolModality(\"section\");\n  }\n  return false;\n};\n\n/**\n    * Returns an object that reperesents the state of the section planes\n    * currently applied to the viewer by this extension.\n    * \n    * @param {THREE.Vector3 | object} [ignoreGlobalOffset=false]\n    * \n    * @returns {object | null}\n    */\nproto.getViewValues = function (ignoreGlobalOffset) {\n\n  var boxValues = this.tool.getSectionBoxValues(ignoreGlobalOffset);\n  if (boxValues)\n  return boxValues;\n\n  var planeValues = this.tool.getSectionPlaneValues(ignoreGlobalOffset);\n  if (planeValues)\n  return planeValues;\n\n  return null;\n};\n\n/**\n    * Gets the extension state as a plain object. Invoked automatically by viewer.getState()\n    *\n    * @param {object} viewerState - Object to inject extension values.\n    * @alias Autodesk.Viewing.Extensions.SectionExtension#getState\n    */\nproto.getState = function (viewerState) {\n  if (!this.viewer.model || this.viewer.model.is2d()) {\n    return;\n  }\n\n  viewerState.cutplanes = viewerState.cutplanes || [];\n  var planes = this.tool.getSectionPlaneSet();\n  for (var i = 0; i < planes.length; i++) {\n    viewerState.cutplanes.push(planes[i].toArray());\n  }\n};\n\n/**\n    * Restores the extension state from a given object. Invoked automatically by viewer.restoreState()\n    *\n    * @param {object} viewerState - Viewer state.\n    * @returns {boolean} True if restore operation was successful.\n    * @alias Autodesk.Viewing.Extensions.SectionExtension#restoreState\n    */\nproto.restoreState = function (viewerState) {\n  // If viewerState doesn't contain cutplanes, we should leave it as is.\n  if (!viewerState.cutplanes) {\n    return;\n  }\n  var cutplanes = this.getSectionPlanes();\n  this.setSectionFromPlane(null); // Unload any existing planes first\n  if (cutplanes.length === 1) {\n    this.setSectionFromPlane(cutplanes[0]);\n  }\n\n  return true;\n};\n\n/**\n    * @private\n    */\nproto._onCutPlanesChanged = function () /*event*/{\n  this.tool.notifyCutplanesChanged();\n};\n\n\n/**\n    * @private\n    */\nproto._onShowAll = function () /*event*/{\n  this.deactivate();\n};\n\n/**\n    * Set a section box around the passed in THREE.Box3.\n    * This method will also enable the section tool.\n    *\n    * @param {THREE.Box3} box - used to set the section box.\n    * @alias Autodesk.Viewing.Extensions.SectionExtension#setSectionBox\n    */\nproto.setSectionBox = function (box) {\n  if (!box) return;\n  this.enableSectionTool(true);\n  if (this.tool.setSectionBox(box)) {\n    this.activeStatus = true;\n    this.viewer.clearSelection();\n  } else {\n    this.enableSectionTool(false);\n  }\n};\n\n/**\n    * Place a section plane on the Intersection.\n    * This method will also enable the section tool.\n    *\n    * @param {THREE.Vector3} normal - plane normal.\n    * @param {THREE.Vector3} point - position to place the plane.\n    * @param enableRotationGizmo\n    * @alias Autodesk.Viewing.Extensions.SectionExtension#setSectionPlane\n    */\nproto.setSectionPlane = function (normal, point, enableRotationGizmo) {\n  if (!normal || !point) return;\n  this.enableSectionTool(true);\n  if (this.tool.setSectionPlane(normal, point, enableRotationGizmo)) {\n    this.activeStatus = true;\n    this.viewer.clearSelection();\n  } else {\n    this.enableSectionTool(false);\n  }\n};\n\n/**\n    * @private\n    */\nproto.onViewerSetView = function () /*event*/{\n  this.deactivate();\n};\n\n/**\n    * @param toolbar\n    */\nproto.onToolbarCreated = function (toolbar) {\n\n  var AVU = Autodesk.Viewing.UI;\n\n  this.sectionToolButton = new AVU.ComboButton(\"toolbar-sectionTool\");\n  this.sectionToolButton.setToolTip('Section analysis');\n  this.sectionToolButton.setIcon(\"adsk-icon-section-analysis\");\n  this.createSubmenu(this.sectionToolButton);\n\n  // make sure inspect tools is visible\n  var modelTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);\n\n  // place section tool before reset tool\n  if (modelTools) {\n    var resetTool = modelTools.getControl(\"toolbar-resetTool\");\n    if (resetTool) {\n      modelTools.addControl(this.sectionToolButton, { index: modelTools.indexOf(resetTool.getId()) });\n    } else {\n      modelTools.addControl(this.sectionToolButton, { index: 0 });\n    }\n  }\n};\n\n/**\n    *\n    * @param parentButton\n    * @private\n    */\nproto.createSubmenu = function (parentButton)\n{\n  var that = this;\n  var viewer = this.viewer;\n  var AVU = Autodesk.Viewing.UI;\n\n  /**\n                                  * @param button\n                                  * @param name\n                                  * @private\n                                  */\n  function createNavToggler(button, name) {\n    return function () {\n      var state = button.getState();\n      var enable = function enable() {\n        if (button instanceof AVU.ComboButton === false) {\n          that.activate(name);\n        } else {\n          that.enableSectionTool(true);\n          that.tool.attachControl(true);\n        }\n      };\n\n      var sectionType = name.toLowerCase().indexOf('box') !== -1 ? 'Box' : 'Plane';\n\n      if (state === AVU.Button.State.INACTIVE) {\n        button.setState(AVU.Button.State.ACTIVE);\n        // Long initialization may cause issues on touch enabled devices, make it async\n        if (Autodesk.Viewing.isMobileDevice()) {\n          setTimeout(enable, 1);\n        } else {\n          enable();\n        }\n        analytics.track('viewer.section', {\n          From: 'Toolbar',\n          Type: sectionType,\n          Action: 'Enable' });\n\n      } else if (state === AVU.Button.State.ACTIVE) {\n        button.setState(AVU.Button.State.INACTIVE);\n        that.deactivate();\n        analytics.track('viewer.section', {\n          From: 'Toolbar',\n          Type: sectionType,\n          Action: 'Disable' });\n\n      }\n      that.sectionStyle = name.toUpperCase();\n    };\n  }\n\n  /**\n     *\n     */\n  function updateSectionButtons() {\n    var areVectorsEqual = function () {\n      var v = new THREE.Vector3();\n      return function (a, b, sqtol) {\n        v.subVectors(a, b);\n        return v.lengthSq() < sqtol;\n      };\n    }();\n\n    var unitx = new THREE.Vector3(1, 0, 0);\n    var unity = new THREE.Vector3(0, 1, 0);\n    var unitz = new THREE.Vector3(0, 0, 1);\n    var right = viewer.autocam.getWorldRightVector();\n    var up = viewer.autocam.getWorldUpVector();\n    var front = viewer.autocam.getWorldFrontVector();\n\n    var tol = 0.0001;\n    if (areVectorsEqual(up, unitx, tol)) {\n      that.sectionYButton.setIcon(\"adsk-icon-plane-x\");\n    } else if (areVectorsEqual(up, unitz, tol)) {\n      that.sectionYButton.setIcon(\"adsk-icon-plane-z\");\n    } else {\n      that.sectionYButton.setIcon(\"adsk-icon-plane-y\");\n    }\n\n    if (areVectorsEqual(right, unity, tol)) {\n      that.sectionXButton.setIcon(\"adsk-icon-plane-y\");\n    } else if (areVectorsEqual(right, unitz, tol)) {\n      that.sectionXButton.setIcon(\"adsk-icon-plane-z\");\n    } else {\n      that.sectionXButton.setIcon(\"adsk-icon-plane-x\");\n    }\n\n    if (areVectorsEqual(front, unitx, tol)) {\n      that.sectionZButton.setIcon(\"adsk-icon-plane-x\");\n    } else if (areVectorsEqual(front, unity, tol)) {\n      that.sectionZButton.setIcon(\"adsk-icon-plane-y\");\n    } else {\n      that.sectionZButton.setIcon(\"adsk-icon-plane-z\");\n    }\n\n  }\n\n  var sectionXButton = this.sectionXButton = new AVU.Button(\"toolbar-sectionTool-x\");\n  sectionXButton.setToolTip('Add X plane');\n  sectionXButton.setIcon(\"adsk-icon-plane-x\");\n  sectionXButton.onClick = createNavToggler(sectionXButton, 'x');\n  parentButton.addControl(sectionXButton);\n\n  var sectionYButton = this.sectionYButton = new AVU.Button(\"toolbar-sectionTool-y\");\n  sectionYButton.setToolTip('Add Y plane');\n  sectionYButton.setIcon(\"adsk-icon-plane-y\");\n  sectionYButton.onClick = createNavToggler(sectionYButton, 'y');\n  parentButton.addControl(sectionYButton);\n\n  var sectionZButton = this.sectionZButton = new AVU.Button(\"toolbar-sectionTool-z\");\n  sectionZButton.setToolTip('Add Z plane');\n  sectionZButton.setIcon(\"adsk-icon-plane-z\");\n  sectionZButton.onClick = createNavToggler(sectionZButton, 'z');\n  parentButton.addControl(sectionZButton);\n\n  var sectionBoxButton = this.sectionBoxButton = new AVU.Button(\"toolbar-sectionTool-box\");\n  sectionBoxButton.setToolTip('Add box');\n  sectionBoxButton.setIcon(\"adsk-icon-box\");\n  sectionBoxButton.onClick = createNavToggler(sectionBoxButton, 'box');\n  parentButton.addControl(sectionBoxButton);\n\n  if (viewer.model) {\n    updateSectionButtons();\n  } else {\n    viewer.addEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, updateSectionButtons, { once: true });\n  }\n};\n\n/**\n    * @private\n    */\nproto.destroyUI = function () {\n\n  if (this.sectionToolButton) {\n    this.sectionToolButton.removeFromParent();\n    this.sectionToolButton = null;\n  }\n};\n\n/**\n    * Activates a section plane for user to interact with.\n    * It performs the same action as the UI button.\n    * \n    * @param {string} mode - Accepted values are 'x', 'y', 'z' and 'box' (in lowercase)\n    * @returns {boolean} - true if the activation was successful.\n    * @alias Autodesk.Viewing.Extensions.SectionExtension#activate\n    */\nproto.activate = function (mode) {\n  if (this.activeStatus && this.mode === mode) {\n    return;\n  }\n  this.enableSectionTool(true);\n  switch (mode) {\n    default:\n    case 'x':\n      this.tool.setSection('X');\n      this.mode = 'x';\n      break;\n    case 'y':\n      this.tool.setSection('Y');\n      this.mode = 'y';\n      break;\n    case 'z':\n      this.tool.setSection('Z');\n      this.mode = 'z';\n      break;\n    case 'box':\n      this.tool.setSection('BOX');\n      this.mode = 'box';\n      break;}\n\n  this.activeStatus = true;\n  return true;\n};\n\n/**\n    * Removes the section plane/box from the 3D canvas.\n    * \n    * @param keepCutPlanes - keep existing cut planes when deactivating the tool. Default is false.\n    *\n    * @alias Autodesk.Viewing.Extensions.SectionExtension#deactivate\n    * @returns {boolean} - returns true if deactivated, false otherwise.\n    */\nproto.deactivate = function (keepCutPlanes) {\n  if (this.activeStatus) {\n    this.tool.setActiveMode(\"\");\n    this.enableSectionTool(false, keepCutPlanes);\n    this.activeStatus = false;\n    return true;\n  }\n  return false;\n};\n\n/**\n    * Turns display hatches on or off.\n    * @param {boolean} value - if true all section planes will get the hatches applied, otherwise, the section planes will not have the hatches.\n    */\nproto.displaySectionHatches = function (value) {var _this2 = this;\n\n  this.tool.setDisplaySectionHatches(value);\n\n  if (this.activeStatus) {\n    var planes = this.getSectionPlanes();\n    this.tool.clearSection();\n    // update the hatches for each existing plane\n    planes.forEach(function (plane) {\n      _this2.tool.updateCapMeshes(new THREE.Plane().setComponents(plane.x, plane.y, plane.z, plane.w));\n    });\n  }\n};\n\n\n/**\n    * Invoked when the context menu is about to be created.\n    * Adds additional entries to the context menu.\n    *\n    * @param section\n    * @param menu\n    * @param status\n    * @private\n    */\nfunction onContextMenu(section, menu, status) {var _intersection$face;\n\n  if (!status.hasSelected)\n  return;\n\n  var viewer = section.viewer;\n\n  var bbox = viewer.impl.selector.getSelectionBounds();\n\n  var menuEntry = {\n    title: \"Section\",\n    target: [] };\n\n\n  menuEntry.target.push({\n    title: 'Section Box',\n    target: function target() {\n      section.setSectionBox(bbox);\n      analytics.track('viewer.section', {\n        From: 'Contextual',\n        Type: 'Box',\n        Action: 'Enable' });\n\n    } });\n\n\n  var aggregateSelection = viewer.getAggregateSelection();\n  var selected = aggregateSelection.map(function (selectionObject) {return selectionObject.selection;}).flat();\n  var modelIds = aggregateSelection.map(function (selectionObject) {return selectionObject.model.id;});\n  var intersection = viewer.impl.hitTest(status.canvasX, status.canvasY, false, selected, modelIds);\n\n  // Ensure that the selected object is the on that recieved the context click.\n  if ((intersection === null || intersection === void 0 ? void 0 : (_intersection$face = intersection.face) === null || _intersection$face === void 0 ? void 0 : _intersection$face.normal) && intersection.model && selected.indexOf(intersection.dbId) !== -1) {\n\n    var mesh = viewer.impl.getRenderProxy(intersection.model, intersection.fragId);\n    var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n    var normal = intersection.face.normal.clone().applyMatrix3(normalMatrix).normalize();\n\n    menuEntry.target.push({\n      title: 'Section Plane',\n      target: function target() {\n        section.setSectionPlane(normal, intersection.point, false);\n        analytics.track('viewer.section', {\n          From: 'Contextual',\n          Type: 'Plane',\n          Action: 'Enable' });\n\n      } });\n\n  }\n\n  menu.push(menuEntry);\n}\n\n\n// Make the extension available\nAutodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Section', SectionExtension);","\nimport { init_TransformGizmos } from '../../thirdparty/three.js/TransformControls';\nimport { debounce } from \"../../thirdparty/lodash/lodash.custom\";\n\n// Declared at the bottom, inside a function.\nvar SectionMeshClass = null;\nvar avp = Autodesk.Viewing.Private;\n\n/**\n                                     * Tool that provides visual controls for the user to change the cutplane's position and angle.\n                                     * It can (and should) be hooked to [ToolController's registerTool]{@Autodesk.Viewing.ToolController#registerTool}\n                                     *\n                                     * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer3D instance\n                                     * @param {Object} config - Configuration values\n                                     * @param {Object} options.tintColor - Object containing attributes r, g, b in the range [0..1]\n                                     * @param {Number} options.tintIntensity - Value range [0..1]\n                                     * @constructor\n                                     */\nexport var SectionTool = function SectionTool(viewer, options)\n{\n  var _viewer = viewer.impl;\n\n  var _names = [\"section\"];\n  var _active = false;\n\n  var _isDragging = false;\n  var _boxChanged = false;\n  var _isPlaneOn = true;\n  var _tintColor = options.tintColor;\n  var _tintIntensity = options.tintIntensity;\n\n  var _transRotControl;\n  var _transControl;\n  var _gizmoOffsetRight = isNaN(options.gizmoOffsetRight) ? 200 : options.gizmoOffsetRight; // 200 So the gizmo won't be covered by the View Cube.\n  var _gizmoOffsetLeft = isNaN(options.gizmoOffsetLeft) ? 80 : options.gizmoOffsetLeft;\n  var _gizmoOffsetTop = isNaN(options.gizmoOffsetTop) ? 80 : options.gizmoOffsetTop;\n  var _gizmoOffsetBottom = isNaN(options.gizmoOffsetBottom) ? 80 : options.gizmoOffsetBottom;\n  var _gizmoNewClientPos = new THREE.Vector3();\n  var _controlOffset = new THREE.Vector3();\n  var _controlNewPosition = new THREE.Vector3();\n\n  var _trcOffset;\n  var _sectionGroups = [];\n  var _sectionPlanes = [];\n  var _sectionPicker = [];\n  var _activeMode = \"\";\n  var _overlayName = \"gizmo\";\n  var _touchType = null;\n  var _initialized = false;\n  var _visibleAtFirst = true;\n  var _outlineIndices = [[0, 1], [1, 3], [3, 2], [2, 0]];\n  var _priority = 70;\n  var _selectionOpacity = 0.25;\n  var _selectionColor = 0x287EEA;\n\n  var _displaySectionHatches = true;\n\n  var sendAnalyticsDebounced = debounce(function (from, type, action) {\n    avp.analytics.track('viewer.section', {\n      from: from,\n      type: type,\n      action: action });\n\n  }, 2000);\n\n  init_TransformGizmos();\n  init_SectionMesh();\n\n  function initControl() {\n\n    if (_initialized) {\n      // Verify overlays are added.\n      _viewer.addOverlay(_overlayName, _transRotControl);\n      _viewer.addOverlay(_overlayName, _transControl);\n      return;\n    }\n\n    _transRotControl = new THREE.TransformControls(_viewer.camera, _viewer.canvas, \"transrotate\");\n    _transRotControl.addEventListener('change', updateViewer);\n    _transRotControl.setSnap(Math.PI / 2, Math.PI / 36); // snap to 90 degs within 5 degs range\n\n    _transControl = new THREE.TransformControls(_viewer.camera, _viewer.canvas, \"translate\");\n    _transControl.addEventListener('change', updateViewer);\n    _transControl.addEventListener('change', adjustGizmoToBounds);\n\n    // add to overlay scene\n    if (_viewer.overlayScenes[_overlayName] === undefined) {\n      _viewer.createOverlayScene(_overlayName);\n    }\n    _viewer.addOverlay(_overlayName, _transRotControl);\n    _viewer.addOverlay(_overlayName, _transControl);\n\n    viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, updateControls);\n    viewer.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, updateSections);\n    viewer.addEventListener(Autodesk.Viewing.HIDE_EVENT, updateSections);\n    viewer.addEventListener(Autodesk.Viewing.SHOW_EVENT, updateSections);\n    viewer.addEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, updateSections);\n\n    _initialized = true;\n  }\n\n  function deinitControl() {\n\n    if (!_initialized)\n    return;\n\n    _viewer.removeOverlay(_overlayName, _transRotControl);\n    _transRotControl.removeEventListener('change', updateViewer);\n    _transRotControl = null;\n    _viewer.removeOverlay(_overlayName, _transControl);\n    _transControl.removeEventListener('change', updateViewer);\n    _transControl.removeEventListener('change', adjustGizmoToBounds);\n    _transControl = null;\n    _viewer.removeOverlayScene(_overlayName);\n\n    viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, updateControls);\n    viewer.removeEventListener(Autodesk.Viewing.ISOLATE_EVENT, updateSections);\n    viewer.removeEventListener(Autodesk.Viewing.HIDE_EVENT, updateSections);\n    viewer.removeEventListener(Autodesk.Viewing.SHOW_EVENT, updateSections);\n    viewer.removeEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, updateSections);\n\n    _initialized = false;\n  }\n\n  function updateViewer() {\n    _viewer.invalidate(false, false, true);\n  }\n\n  function updateControls() {\n\n    adjustGizmoToBounds();\n\n    if (_transRotControl) {\n      _transRotControl.update();\n    }\n    if (_transControl) {\n      _transControl.update();\n    }\n  }\n\n  function adjustGizmoToBounds() {\n\n    if (!_transRotControl || !_transRotControl.object) {\n      return;\n    }\n\n    var client = _viewer.worldToClient(_transRotControl.position);\n    var rect = _viewer.getCanvasBoundingClientRect();\n    _gizmoNewClientPos.copy(client);\n\n    if (client.x < _gizmoOffsetLeft) {\n      _gizmoNewClientPos.x = _gizmoOffsetLeft;\n    } else if (client.x > rect.width - _gizmoOffsetRight) {\n      _gizmoNewClientPos.x = rect.width - _gizmoOffsetRight;\n    }\n\n    if (client.y < _gizmoOffsetTop) {\n      _gizmoNewClientPos.y = _gizmoOffsetTop;\n    } else if (client.y > rect.height - _gizmoOffsetBottom) {\n      _gizmoNewClientPos.y = rect.height - _gizmoOffsetBottom;\n    }\n\n    if (_gizmoNewClientPos.x !== client.x || _gizmoNewClientPos.y !== client.y) {\n      var intersection = THREE.TransformControls.intersectObjects(_gizmoNewClientPos.x, _gizmoNewClientPos.y, [_transRotControl.object], _viewer.camera, false);\n      if (intersection) {\n        // In section planes the group position is (0,0,0) and has no impact.\n        // In section box the group position is the translation of the box, and is needed for\n        // positioning the gizmo in the right place.\n        var groupPosition = _sectionGroups[0].position;\n        _controlOffset.copy(_transRotControl.object.position).add(groupPosition);\n        _controlNewPosition.copy(intersection.point).sub(_controlOffset);\n        _transRotControl.setGizmoOffset(_controlNewPosition);\n      }\n    }\n  }\n\n  function updateSections() {\n    if (_active && _sectionPlanes.length === 1) {\n      updatePlaneMeshes(true);\n      updateControls();\n      updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));\n    }\n  }\n\n  /*function mix(a, b, val) {\n        return a * (1.0 - val) + b * val;\n    }*/\n\n  function getDiffuseColor(material) {\n    return material && material.color || new THREE.Color(0xffffff);\n  }\n\n  /*function getSpecularColor(material) {\n        return (material && material.specular) || new THREE.Color(0xffffff);\n    }\n     function tintColor(c) {\n        var intensity = Autodesk.Viewing.Extensions.Section.tintIntensity;\n        var tc = _tintColor;\n        c.r = mix(c.r, tc.r, intensity);\n        c.g = mix(c.g, tc.g, intensity);\n        c.b = mix(c.b, tc.b, intensity);\n    }*/\n\n\n  // Object used to iterator all fragments in all dbids in all models in a scene\n  // _timeSlice is the time in milliseconds before the iterator will allow itself\n  // to be interrupted. _sliceDelay is the time in milliseconds the iterator delays\n  // before starting a new time slice. The default values are 15 and 0 respectively.\n  // I did some experiments and it seemed like these values worked pretty well.\n  // _sliceDelay doesn't seem to matter very much, but making _timeSlice much\n  // larger will cause highlights to look jerky.\n  function FragmentIterator(_timeSlice, _sliceDelay) {\n\n    var _capTimer = 0; // Timer used to delay time slices\n    var _callback; // Callback for each fragment\n    var _models; // Array of models in the scene\n    var _curModel; // Current model\n    var _dbIds = []; // Database ids for the current model\n    var _fragIds = []; // Fragment ids for the current database id\n    var _instanceTree; // Instance tree for current model\n    var _m; // Current index in _models\n    var _d; // Current index in _dbIds\n    var _f; // Current index in _fragIds\n\n    // Default value for _timeSlize and _sliceDelay\n    _timeSlice = _timeSlice || 15;\n    _sliceDelay = _sliceDelay || 0;\n\n    // Start the iterator\n    // models is the array of models to iterate\n    // delay is a delay to start the iteration. < 0 starts without any delay\n    // callback is the callback for each fragment:\n    //   callback(fragId, dbId, model, lastFrag)\n    // lastFrag is a boolean that is true when fragId is the last fragment for dbId.\n    this.start = function (models, delay, callback) {\n      reset(models);\n\n      _callback = callback;\n      if (callback) {\n        if (delay >= 0)\n        _capTimer = setTimeout(doIteration, delay);else\n\n        doIteration();\n      }\n    };\n\n    // Reset the iterator, this is so we can clear the manager at the end.\n    function reset(models) {\n      if (_capTimer)\n      clearTimeout(_capTimer);\n      _capTimer = 0;\n      _models = models;\n      _dbIds.length = 0;\n      _fragIds.length = 0;\n      _instanceTree = null;\n      _m = -1;\n      _d = 0;\n      _f = 0;\n    }\n\n    // Do a single time slice\n    function doIteration() {\n      _capTimer = 0;\n      var endTime = performance.now() + _timeSlice;\n      while (performance.now() < endTime) {\n        // If we are done, then return\n        if (!next()) {\n          // The cap scene is in sceneAfter, so we need to redraw the model to see the caps.\n          // LMV-2571 - clear the render, as otherwise we will draw transparent objects atop themselves.\n          _viewer.invalidate(true, true);\n          // Clear everything when we are done\n          reset(null);\n          return;\n        }\n\n        // Call the call back function\n        _callback(_fragIds[_f], _dbIds[_d], _curModel, _f + 1 >= _fragIds.length, !_models || _m >= _models.length);\n      }\n\n      // Schedule the next time slice\n      _capTimer = setTimeout(doIteration, _sliceDelay);\n    }\n\n    // Advance to the next model in _models\n    function nextModel() {\n      // Continue processing the next model in _models\n      if (_models && _m < _models.length) {\n        // Go to next model\n        while (++_m < _models.length) {\n          _instanceTree = _models[_m].getInstanceTree();\n          // Only process the model, if it has a fragment map\n          if (_instanceTree) {\n            // Get the list of dbIds.\n            _dbIds.length = 0;\n            _instanceTree.enumNodeChildren(_models[_m].getRootId(), function (dbId) {\n              _dbIds.push(dbId);\n            }, true);\n            // Only process the model if we got some ids\n            if (_dbIds.length > 0) {\n              // Set the current model and newly loaded dbIds\n              _curModel = _models[_m];\n              return _curModel;\n            }\n          }\n        }\n      }\n\n      // Done clear the current model and new loaded dbIds\n      _curModel = null;\n\n      // End of the models\n      return false;\n    }\n\n    // Advance to the next database id\n    function nextDbId() {\n      // At the end, return false\n      if (_d >= _dbIds.length)\n      return false;\n\n      // Go to next database id\n      while (++_d < _dbIds.length) {\n        var dbId = _dbIds[_d];\n        // Only process dbIds that are not hidden and not off\n        if (!_instanceTree.isNodeHidden(dbId) && !_instanceTree.isNodeOff(dbId)) {\n          //All fragments that belong to the same node make part of the\n          //same object so we have to accumulate all their intersections into one list\n          _fragIds.length = 0;\n          _instanceTree.enumNodeFragments(dbId, function (fragId) {\n            _fragIds.push(fragId);\n          }, false);\n          // Only process the database id if there are some fragments\n          if (_fragIds.length > 0)\n          return true;\n        }\n      }\n\n      // end of the database ids\n      return false;\n    }\n\n    // Advance to the next fragment\n    function next() {\n      // If we are not a the end of the fragment list, then process it\n      if (++_f < _fragIds.length)\n      return true;\n\n      // Start the fragment list at the beginning\n      _f = 0;\n      for (;;) {\n        // If we have more database ids, then process them\n        if (nextDbId())\n        return true;\n        // If we don't have another model, then we are done\n        if (!nextModel())\n        return false;\n        // restart the database ids for the new model\n        _d = -1;\n      }\n    }\n  }\n\n  // Use the same fragment iterator for all fragments\n  var _fragIterator = new FragmentIterator();\n\n  function updateCapMeshes(plane) {\n    if (!_displaySectionHatches) {\n      // LMV-5781: Do not render the section hatches if the preference is turned on. \n      return;\n    }\n    var cg = Autodesk.Viewing.Extensions.CompGeom;\n\n    //When drawing a 2D material in 3D space we will want to skip binding the G-buffer\n    //when rendering the scene that contains that material\n    _viewer.sceneAfter.skipDepthTarget = true;\n\n    _removeSections();\n\n    var section3D = new THREE.Object3D();\n    section3D.name = \"section3D\";\n    _viewer.scene.add(section3D);\n\n    var section2D = new THREE.Object3D();\n    section2D.name = \"section2D\";\n    _viewer.sceneAfter.add(section2D);\n\n    var toPlaneCoords = cg.makePlaneBasis(plane);\n    var fromPaneCoords = new THREE.Matrix4().getInverse(toPlaneCoords);\n\n    var mat2dname = _viewer.matman().create2DMaterial(null, { skipCircles: true, skipEllipticals: true, isScreenSpace: true }, false, false);\n    var mat2d = _viewer.matman().findMaterial(null, mat2dname);\n    mat2d.transparent = true;\n    mat2d.depthTest = true;\n    mat2d.polygonOffset = true;\n    mat2d.polygonOffsetFactor = -1;\n    mat2d.polygonOffsetUnits = 0.1; // 1.0 is usually way too high, see LMV-1072\n    mat2d.cutplanes = _otherCutPlanes; // make sure that cap meshes respect cutplanes from other tools\n\n    var box = new THREE.Box3();\n\n    //var worldBox = _viewer.getVisibleBounds(true);   \n\n    //some heuristic for line width of the section outline based on model size.\n    //half a percent of the model size is what we do here.\n    //var lineWidth = 0.5 * 5e-5 * worldBox.size().length();\n\n    var models = _viewer.modelQueue().getModels().filter(function (m) {return !m.getDoNotCut();});\n\n    var intersects = [];\n    var material;\n\n    function removeMesh(object, modelId, dbId, disposeMaterial) {\n      var child = object.children.find(function (mesh) {\n        return mesh.modelId == modelId && mesh.dbId == dbId;\n      });\n      if (child) {\n        object.remove(child);\n        if (child.geometry)\n        child.geometry.dispose();\n        if (disposeMaterial && child.material)\n        child.material.dispose();\n      }\n    }\n\n    // Start iterating the fragments\n    _fragIterator.start(models, 50, function (fragId, dbId, model, lastFrag) {\n\n      // Collect intersections for this fragment\n      var frags = model.getFragmentList();\n      frags.getWorldBounds(fragId, box);\n      if (cg.xBoxPlane(plane, box)) {\n        var m = frags.getVizmesh(fragId);\n\n        if (m.geometry && !m.geometry.is2d && !m.geometry.isLines && m.material.cutplanes) {\n          material = m.material;\n          cg.xMeshPlane(plane, m, intersects);\n        }\n      }\n\n      // If this is the last fragment for dbId, process the intersections\n      if (lastFrag) {\n        if (intersects.length) {\n\n          var bbox = new THREE.Box3();\n          cg.convertToPlaneCoords(toPlaneCoords, intersects, bbox);\n\n          //Create the 2D line geometry\n          var vbb = new avp.VertexBufferBuilder(false, 8 * intersects.length);\n\n          var color = getDiffuseColor(material);\n          var r = 0 | color.r * 0.25 * 255.5;\n          var g = 0 | color.g * 0.25 * 255.5;\n          var b = 0 | color.b * 0.25 * 255.5;\n\n          var c = 0xff000000 | b << 16 | g << 8 | r;\n\n\n          var eset = new cg.EdgeSet(intersects, bbox, bbox.size().length() * 1e-6);\n          eset.snapEdges();\n          eset.sanitizeEdges();\n          eset.stitchContours();\n\n          //Create the 3D mesh\n          var cset = eset.triangulate();\n\n          //Testing code path using the fancier DCEL structure for triangulation of the section edges.\n          //TODO: compare quality and performance before switching to this and retiring the EdgeSet code path\n          /*\n                              var dcel = new DCEL(bbox, bbox.size().length() * 1e-6);\n                              intersects.forEach(e => {\n                                  dcel.addDirectedEdge(e.v1.x, e.v1.y, e.v2.x, e.v2.y, true, dbId);\n                              });\n          \n                              dcel.finalize(true);\n          \n                              let cset = dcel.closedAreas[0];\n          */\n\n          if (cset) {\n            /*\n                                         if (cset.triangulationFailed)\n                                             c = 0xffffff00;\n                     */\n\n            for (var j = 0; j < cset.contours.length; j++) {\n\n              var cntr = cset.contours[j];\n\n              for (var k = 1; k < cntr.length; k++) {\n                var pt1 = cset.pts[cntr[k - 1]];\n                var pt2 = cset.pts[cntr[k]];\n                vbb.addSegment(pt1.x, pt1.y, pt2.x, pt2.y, 0, -2.0, /*isClosed ? c : rc*/c, dbId, 0);\n              }\n\n            }\n\n\n            var mdata = { mesh: vbb.toMesh() };\n\n            avp.BufferGeometryUtils.meshToGeometry(mdata);\n\n            var bg2d = mdata.geometry;\n            bg2d.streamingDraw = true;\n            bg2d.streamingIndex = true;\n\n            var mesh2d = new THREE.Mesh(bg2d, mat2d);\n\n            mesh2d.matrix.copy(fromPaneCoords);\n            mesh2d.matrixAutoUpdate = false;\n            mesh2d.frustumCulled = false;\n            mesh2d.modelId = model.id; // So we can look it up later\n            mesh2d.dbId = dbId;\n            section2D.add(mesh2d);\n\n            //Create triangulated capping polygon\n            {\n              if (!cset.triangulationFailed) {\n\n                var bg = cset.toPolygonMesh(material.packedNormals);\n\n                var mat = _viewer.matman().cloneMaterial(material, model);\n\n                mat.packedNormals = material.packedNormals;\n                mat.cutplanes = _otherCutPlanes; // make sure that cap meshes respect cutplanes from other tools\n                mat.side = THREE.FrontSide;\n                mat.depthTest = true;\n                mat.map = null;\n                mat.bumpMap = null;\n                mat.normalMap = null;\n                mat.alphaMap = null;\n                mat.specularMap = null;\n                mat.transparent = false;\n                mat.depthWrite = true;\n                mat.hatchPattern = true;\n                mat.needsUpdate = true;\n\n                var angle = (material.id + 2) * Math.PI * 0.125;\n                var tan = Math.tan(angle);\n                mat.hatchParams = new THREE.Vector2(tan, 10.0);\n                mat.hatchTintColor = _tintColor;\n                mat.hatchTintIntensity = _tintIntensity;\n\n                // If the material is prism, clear all the map definitions.\n                if (mat.prismType != null) {\n                  mat.defines = {};\n                  mat.defines[mat.prismType.toUpperCase()] = \"\";\n                  if (mat.prismType == \"PrismWood\") {\n                    mat.defines[\"NO_UVW\"] = \"\";\n                  }\n                }\n\n                var capmesh = new THREE.Mesh(bg, mat);\n                capmesh.matrix.copy(fromPaneCoords);\n                capmesh.matrixAutoUpdate = false;\n                capmesh.modelId = model.id; // So we can look it up later\n                capmesh.dbId = dbId;\n                capmesh.fragId = intersects.fragId;\n\n                section3D.add(capmesh);\n              }\n\n            }\n\n          }\n        }\n\n        // Clear intersections for the next dbId\n        intersects.length = 0;\n      } // last Fragment for dbId\n\n    }); //_fragIterator.start\n\n  }\n\n  // We use an own cut plane set to distinguish our own cut planes from others.\n  var _ownCutPlaneSet = 'Autodesk.Viewing.Extension.Section.SectionTool';\n\n  // Make sure that the viewer always uses the SectionTool's plane to adjust 2D rendering resolution.\n  _viewer.setCutPlaneSetFor2DRendering(_ownCutPlaneSet);\n\n  // Keep track of cutplanes that are not our own, because we have to apply them to our cap meshes\n  var _otherCutPlanes = [];\n\n  // Trigger update of cap mesh materials if number of cutplanes have changed by other tools\n  function updateCapMaterials() {\n\n    function update(section) {\n      // apply cutplanes to all active cap meshes\n      if (!section) {\n        return;\n      }\n\n      section.traverse(function (obj) {\n        // we only care for THREE.Mesh with material\n        if (!obj instanceof THREE.Mesh || !obj.material) {\n          return;\n        }\n        obj.material.needsUpdate = true;\n      });\n    }\n\n    update(_viewer.scene.getObjectByName(\"section3D\"));\n    update(_viewer.sceneAfter.getObjectByName(\"section2D\"));\n  }\n\n  function createPlaneMesh(plane, bbox) {\n    var quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), plane.normal);\n    var geometry;\n    var size;\n\n    if (bbox) {\n      // project bbox to set plane size\n      var ptMax = plane.projectPoint(bbox.max);\n      var ptMin = plane.projectPoint(bbox.min);\n      var invQuat = quat.clone().inverse();\n      ptMax.applyQuaternion(invQuat);\n      ptMin.applyQuaternion(invQuat);\n      size = new THREE.Vector3().subVectors(ptMax, ptMin);\n      geometry = new THREE.PlaneBufferGeometry(size.x, size.y);\n    } else {\n      // project bounding sphere\n      bbox = _viewer.getVisibleBounds();\n      size = 2.0 * bbox.getBoundingSphere().radius;\n      geometry = new THREE.PlaneBufferGeometry(size, size);\n    }\n\n    var material = new THREE.MeshBasicMaterial({\n      opacity: 0,\n      color: _selectionColor,\n      side: THREE.DoubleSide,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true });\n\n\n    var mesh = new SectionMeshClass(geometry, material, plane);\n    var pt = plane.projectPoint(bbox.center());\n    mesh.position.copy(pt);\n    mesh.quaternion.multiply(quat);\n\n    // add outlines with inverted background color\n    var presetIndex = _viewer.currentLightPreset();\n    presetIndex = Math.max(0, presetIndex);\n    var bgColor = Autodesk.Viewing.Private.LightPresets[presetIndex].bgColorGradient;\n    var color = \"rgb(\" + (255 - bgColor[0]) + \",\" + (255 - bgColor[1]) + \",\" + (255 - bgColor[2]) + \")\";\n    var lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 1, depthTest: false });\n    var pos = mesh.geometry.getAttribute('position');\n    for (var i = 0; i < _outlineIndices.length; i++) {\n      geometry = new THREE.Geometry();\n      geometry.vertices.push(new THREE.Vector3().fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize),\n      new THREE.Vector3().fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize));\n      var line = new THREE.Line(geometry, lineMaterial);\n      mesh.add(line);\n      mesh.outlines.push(line);\n    }\n\n    return mesh;\n  }\n\n  function updatePlaneMeshes(rebuild) {\n\n    traverseSections(function (child) {\n      if (child instanceof SectionMeshClass) {\n\n        var i, line, pos, pt;\n        if (child.connectivity.length > 0) {\n          // section box\n          var minv = new THREE.Matrix4().getInverse(child.matrixWorld);\n          pt = new THREE.Vector3();\n          pos = child.geometry.getAttribute('position');\n          for (i = 0; i < pos.length / pos.itemSize; i++) {\n            var connect = child.connectivity[i];\n            if (intersectPlanes(child.plane, connect[0], connect[1], pt) !== null) {\n              pt.applyMatrix4(minv);\n              pos.setXYZ(i, pt.x, pt.y, pt.z);\n            }\n          }\n          pos.needsUpdate = true;\n          child.geometry.computeBoundingBox();\n          child.geometry.computeBoundingSphere();\n\n          for (i = 0; i < child.outlines.length; i++) {\n            line = child.outlines[i];\n            line.geometry.vertices[0].fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize);\n            line.geometry.vertices[1].fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize);\n            line.geometry.verticesNeedUpdate = true;\n          }\n        } else {\n          // section plane\n          if (rebuild) {\n            var bbox = _viewer.getVisibleBounds();\n            var size = 2.0 * bbox.getBoundingSphere().radius;\n            pt = child.plane.projectPoint(bbox.center());\n            child.geometry = new THREE.PlaneBufferGeometry(size, size);\n            child.position.copy(pt);\n            pos = child.geometry.getAttribute('position');\n            for (i = 0; i < child.outlines.length; i++) {\n              line = child.outlines[i];\n              line.geometry.vertices[0].fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize);\n              line.geometry.vertices[1].fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize);\n              line.geometry.verticesNeedUpdate = true;\n            }\n          }\n        }\n      }\n    });\n  }\n\n  function traverseSections(callback) {\n    for (var i = 0; i < _sectionGroups.length; i++) {\n      _sectionGroups[i].traverse(callback);\n    }\n  }\n\n  function setSectionPlanes() {var fireEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    traverseSections(function (child) {\n      if (child instanceof SectionMeshClass) {\n        child.update();\n      }\n    });\n    if (_sectionPlanes.length === 1) {\n      updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));\n    }\n    _viewer.setCutPlaneSet(_ownCutPlaneSet, _sectionPlanes, fireEvent);\n  }\n\n  function showPlane(set) {\n    for (var i = 0; i < _sectionGroups.length; i++) {\n      _sectionGroups[i].visible = set;\n    }\n\n    if (_isPlaneOn !== set)\n    updateViewer();\n\n    _isPlaneOn = set;\n  }\n\n  function showSection(set) {\n    if (set && _sectionPlanes.length > 0) {\n      if (_sectionPlanes.length === 1) {\n        updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));\n      }\n      _viewer.setCutPlaneSet(_ownCutPlaneSet, _sectionPlanes);\n    }\n    showPlane(set);\n  }\n\n  function attachControl(control, mesh) {\n    control.attach(mesh);\n    control.setPosition(mesh.position);\n    control.visible = true;\n  }\n\n  function checkNormal(normal) {\n    // flip normal if facing inward as eye direction\n    var eyeVec = _viewer.api.navigation.getEyeVector();\n    if (eyeVec.dot(normal) > 0) {\n      normal.negate();\n    }\n\n    return normal;\n  }\n\n  function setPlane(normal, distance) {var fireEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var obbox = _viewer.getVisibleBounds();\n    var center = obbox.center();\n    var group = new THREE.Group();\n    // Calculate the plane signed distance using the dot product of the center point of the scene bounding box\n    // and the normal vector.\n    distance = distance !== undefined ? distance : -1 * center.dot(normal);\n    var plane = new THREE.Plane(normal, distance);\n    var mesh = createPlaneMesh(plane, null);\n    group.add(mesh);\n    _sectionPlanes.push(mesh.planeVec);\n    _sectionGroups.push(group);\n    _viewer.addOverlay(_overlayName, group);\n    if (_transRotControl) {\n      attachControl(_transRotControl, mesh);\n      mesh.material.opacity = 0;\n      centerPlaneArrow(mesh);\n      _transRotControl.showRotationGizmos(true);\n      _sectionPicker = _transRotControl.getPicker();\n\n    }\n    setSectionPlanes(fireEvent);\n    if (_active) {\n      updateControls();\n    }\n  }\n\n  function getCenterPoint(mesh) {\n    var middle = new THREE.Vector3();\n    var geometry = mesh.geometry;\n\n    geometry.computeBoundingBox();\n\n    middle.x = (geometry.boundingBox.max.x + geometry.boundingBox.min.x) / 2;\n    middle.y = (geometry.boundingBox.max.y + geometry.boundingBox.min.y) / 2;\n    middle.z = (geometry.boundingBox.max.z + geometry.boundingBox.min.z) / 2;\n\n    mesh.localToWorld(middle);\n    return middle;\n  }\n\n  /**\n     * Places the arrow at the center of the passed in mesh.\n     * @param {*} mesh \n     */\n  function centerPlaneArrow(mesh) {\n    if (!_transRotControl || !mesh) return false;\n    // Get the center of the plane and \n    // calculate the x,y,z offset between the plane position and the plane center\n    var centerOffset = getCenterPoint(mesh).sub(mesh.position);\n    centerOffset.sub(_trcOffset);\n    // Set the gizmo offset\n    _transRotControl.setGizmoOffset(centerOffset);\n    return true;\n  }\n\n  function setBox(planeSet) {\n    var normals = [\n    new THREE.Vector3(1, 0, 0),\n    new THREE.Vector3(0, 1, 0),\n    new THREE.Vector3(0, 0, 1),\n    new THREE.Vector3(-1, 0, 0),\n    new THREE.Vector3(0, -1, 0),\n    new THREE.Vector3(0, 0, -1)];\n\n\n    var connectivities = [\n    [[1, 2], [1, 5], [2, 4], [4, 5]], // 0\n    [[3, 5], [0, 5], [2, 3], [0, 2]], // 1\n    [[1, 3], [0, 1], [3, 4], [0, 4]], // 2\n    [[1, 5], [1, 2], [4, 5], [2, 4]], // 3\n    [[2, 3], [0, 2], [3, 5], [0, 5]], // 4\n    [[0, 1], [3, 1], [0, 4], [3, 4]] // 5\n    ];\n\n    var group = new THREE.Group();\n    var obbox = _viewer.getVisibleBounds();\n    var center = obbox.center();\n    var bbox = new THREE.Box3(obbox.min, center);\n\n    // Initialize from planeSet ONLY if it's an AABB.\n    var loadingBox = false;\n    if (planeSet && planeSet.length === 6 && planeSet[0].x === 1.0) {\n      // Assume that the order on planes is the same as in Array of normals defined above\n      bbox = new THREE.Box3(\n      new THREE.Vector3(planeSet[3].w, planeSet[4].w, planeSet[5].w),\n      new THREE.Vector3(planeSet[0].w, planeSet[1].w, planeSet[2].w));\n\n      center = bbox.max.clone();\n      loadingBox = true;\n    }\n\n    ////center = obbox.max;   // Use this to initialize the box around the model\n    ////bbox = obbox.clone(); // Use this to initialize the box around the model\n\n    var planes = [],meshes = [];\n    var i, mesh;\n    for (i = 0; i < normals.length; i++) {\n\n      if (loadingBox) {\n        var plane = new THREE.Plane(normals[i], planeSet[i].w);\n        planes.push(plane);\n      } else\n\n      {\n        var plane = new THREE.Plane(normals[i], -1 * center.dot(normals[i]));\n        planes.push(plane);\n\n        // offset plane with negative normal to form an octant\n        if (i > 2) {\n          var ptMax = plane.orthoPoint(bbox.max);\n          var ptMin = plane.orthoPoint(bbox.min);\n          var size = new THREE.Vector3().subVectors(ptMax, ptMin);\n          plane.constant -= size.length();\n        }\n      }\n\n      mesh = createPlaneMesh(plane, bbox);\n      group.add(mesh);\n      meshes.push(mesh);\n      _sectionPlanes.push(mesh.planeVec);\n    }\n\n    // build connectivity\n    for (i = 0; i < meshes.length; i++) {\n      mesh = meshes[i];\n      var connectivity = connectivities[i];\n      for (var j = 0; j < connectivity.length; j++) {\n        var nc = [];\n        var ct = connectivity[j];\n        for (var k = 0; k < ct.length; k++) {\n          nc.push(planes[ct[k]]);\n        }\n        mesh.connectivity.push(nc);\n      }\n    }\n\n    _sectionGroups.push(group);\n    _viewer.addOverlay(_overlayName, group);\n\n    setSectionPlanes();\n    updatePlaneMeshes();\n\n    var plane = _sectionGroups[0].children[0];\n    attachControl(_transRotControl, plane);\n    // Set the plane opacity\n    plane.material.opacity = _selectionOpacity;\n    centerPlaneArrow(plane);\n\n    attachControl(_transControl, _sectionGroups[0]);\n    _transRotControl.showRotationGizmos(false);\n    _sectionPicker = _transRotControl.getPicker().concat(_transControl.getPicker());\n    // Calculate the offset to the max point of the bounding box.\n    var sectionBoxPosition = _sectionGroups[0].position.clone();\n    var cornerOffset = sectionBoxPosition.sub(center.clone());\n    _transControl.setGizmoOffset(cornerOffset);\n  }\n\n  var intersectPlanes = function () {\n    var m = new THREE.Matrix3();\n    var n23 = new THREE.Vector3();\n    var n31 = new THREE.Vector3();\n    var n12 = new THREE.Vector3();\n    return function (plane1, plane2, plane3, optionalTarget) {\n      m.set(plane1.normal.x, plane1.normal.y, plane1.normal.z,\n      plane2.normal.x, plane2.normal.y, plane2.normal.z,\n      plane3.normal.x, plane3.normal.y, plane3.normal.z);\n\n      var det = m.determinant();\n      if (det === 0) return null;\n\n      n23.crossVectors(plane2.normal, plane3.normal).multiplyScalar(-plane1.constant);\n      n31.crossVectors(plane3.normal, plane1.normal).multiplyScalar(-plane2.constant);\n      n12.crossVectors(plane1.normal, plane2.normal).multiplyScalar(-plane3.constant);\n\n      var result = optionalTarget || new THREE.Vector3();\n      return result.copy(n23).add(n31).add(n12).divideScalar(det);\n    };\n  }();\n\n  var intersectObjects = function intersectObjects(pointer, objects, recursive) {\n    return THREE.TransformControls.intersectObjects(pointer.canvasX, pointer.canvasY, objects, _viewer.camera, recursive);\n  };\n\n  // public functions\n\n  /**\n   * When active, the geometry will be sectioned by the current set cut plane.\n   * @returns {boolean}\n   */\n  this.isActive = function () {\n    return _active;\n  };\n\n  /**\n      * Returns the signed distance of the sectioning plane from the origin\n      * @returns {Number} distance. Null distance is returned if there is no hit found from raycast\n      */\n  this.getSectionDistance = function (normal) {\n    // Find a target point in the direction of the camera \n    var eyeVec = _viewer.api.navigation.getEyeVector();\n    var hit = _viewer.rayIntersect(new THREE.Ray(_viewer.camera.position, eyeVec));\n    // DIstance\n    return hit && hit.intersectPoint && -1 * hit.intersectPoint.dot(normal);\n  };\n\n  /**\n      * Enables the cut planes that were created by the viewer.setCutPlanes() function.\n      * @param {boolean} [fireEvent] - if set to false the av.CUTPLANES_CHANGE_EVENT event will not be fired.\n      */\n  this.setViewerSection = function () {var fireEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.clearSection(fireEvent);\n    var normal;\n    // Attempt to initialize the tool with a plane that is already set.\n    var planeSet = _viewer.getCutPlaneSet('__set_view');\n    if (planeSet.length !== 1) return;\n\n    _transRotControl.clientScale = 1;\n    var v4 = planeSet[0];\n    var normal = new THREE.Vector3(v4.x, v4.y, v4.z);\n    var distance = v4.w;\n    setPlane(normal, distance, fireEvent);\n    _activeMode = 'SET_VIEW_PLANE';\n    // Clear sections from Viewer3D::setView\n    _viewer.setCutPlaneSet('__set_view', undefined, fireEvent);\n  };\n\n\n\n  /**\n      * Facilitates the initialization of a cut plane\n      * \n      * @param {String} name - Either 'X', 'Y', 'Z' or 'BOX'\n      */\n  this.setSection = function (name) {\n    this.clearSection();\n    _trcOffset = new THREE.Vector3();\n    var normal, distance;\n    _transRotControl.clientScale = 1;\n\n    // Attempt to initialize the tool with a plane that is already set.\n    var planeSet = _viewer.getCutPlaneSet('__set_view');\n    if (planeSet.length === 1 && name !== 'BOX' && name !== 'OBJ_SET_VIEW_PLANE') {\n      name = 'SET_VIEW_PLANE';\n    }\n\n    switch (name) {\n      case 'X':\n        normal = new THREE.Vector3(1, 0, 0);\n        distance = this.getSectionDistance(normal);\n        setPlane(checkNormal(normal), distance);\n        break;\n      case 'Y':\n        normal = new THREE.Vector3(0, 1, 0);\n        distance = this.getSectionDistance(normal);\n        setPlane(checkNormal(normal), distance);\n        break;\n      case 'Z':\n        normal = new THREE.Vector3(0, 0, 1);\n        distance = this.getSectionDistance(normal);\n        setPlane(checkNormal(normal), distance);\n        break;\n      case 'OBJ_SET_VIEW_PLANE':\n      case 'SET_VIEW_PLANE':\n        var v4 = planeSet[0];\n        normal = new THREE.Vector3(v4.x, v4.y, v4.z);\n        setPlane(normal, v4.w);\n        break;\n      case 'OBJ_BOX':\n      case 'BOX':\n        setBox(planeSet);\n        _transRotControl.clientScale = 2;\n        this.recomputePivot();\n        break;}\n\n    _activeMode = name;\n\n    // Clear sections from Viewer3D::setView\n    _viewer.setCutPlaneSet('__set_view', undefined);\n  };\n\n  /**\n      * Facilitates the initialization of a cut plane from a normal and distance\n      *\n      * @param {THREE.Vector4} normal (x,y,z) and distance (w)\n      * @param {Number} distance\n      */\n  this.setSectionFromPlane = function (cutplane) {\n    this.clearSection();\n    setPlane(new THREE.Vector3(cutplane.x, cutplane.y, cutplane.z), cutplane.w);\n    _activeMode = \"\";\n\n    // Clear sections from Viewer3D::setView\n    _viewer.setCutPlaneSet('__set_view', undefined);\n  };\n\n  /**\n      * Set the active mode\n      * @param {string} [name] - active mode name\n      * @private\n      */\n  this.setActiveMode = function (name) {\n    _activeMode = name || \"\";\n  };\n\n  /**\n      * Remove the section graphics\n      */\n  function _removeSections() {\n    var oldsection3D = _viewer.scene.getObjectByName(\"section3D\");\n    if (oldsection3D)\n    _viewer.scene.remove(oldsection3D);\n    var oldsection2D = _viewer.sceneAfter.getObjectByName(\"section2D\");\n    if (oldsection2D)\n    _viewer.sceneAfter.remove(oldsection2D);\n  }\n\n  this.setDisplaySectionHatches = function (value) {\n    _displaySectionHatches = value;\n  };\n\n  this.updateCapMeshes = function (plane) {\n    if (!plane) {\n      return;\n    }\n\n    setPlane(plane.normal, plane.constant);\n    updateCapMeshes(plane);\n  };\n\n  /**\n      * Removes any (and all) currently set cut plane(s).\n      * @param {boolean} [fireEvent] - if set to false the av.CUTPLANES_CHANGE_EVENT event will not be fired.\n      */\n  this.clearSection = function () {var fireEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    if (_transRotControl)\n    _transRotControl.detach();\n\n    if (_transControl)\n    _transControl.detach();\n\n    // remove all sections\n    while (_sectionPlanes.length > 0) {\n      _sectionPlanes.pop();\n    }\n\n    while (_sectionGroups.length > 0) {\n      var group = _sectionGroups.pop();\n      _viewer.removeOverlay(_overlayName, group);\n    }\n\n    _fragIterator.start(null); // Shutdown iterator        \n    _removeSections();\n\n    _viewer.setCutPlaneSet(_ownCutPlaneSet, null, fireEvent);\n  };\n\n  this.isPlaneOn = function () {\n    return _isPlaneOn;\n  };\n\n  this.showPlane = function (set) {\n    showPlane(set);\n  };\n\n  /**\n      * Whether translation and rotation controls are visible or not.\n      * @param {Boolean} set\n      */\n  this.attachControl = function (set) {\n    if (!_transRotControl || !_transControl) {\n      return;\n    }\n\n    if (set) {\n      attachControl(_transRotControl, _sectionGroups[0].children[0]);\n      _transRotControl.highlight();\n      if (_activeMode === 'BOX')\n      attachControl(_transControl, _sectionGroups[0]);\n    } else {\n      _transRotControl.detach();\n      _transControl.detach();\n    }\n  };\n\n  /**\n      * Invokes setSection with the last set of parameters used.\n      */\n  this.resetSection = function () {\n    this.setSection(_activeMode);\n  };\n\n  // tool interface\n\n  this.getNames = function () {\n    return _names;\n  };\n\n  this.getName = function () {\n    return _names[0];\n  };\n\n  this.register = function () {\n  };\n\n  this.deregister = function () {\n    this.clearSection();\n    deinitControl();\n  };\n\n  this.getPriority = function () {\n    return _priority;\n  };\n\n  /**\n      * [ToolInterface] Activates the tool\n      * @param {String} name - unused\n      */\n  this.activate = function () /*name*/{\n\n    initControl();\n\n    _active = true;\n    _isDragging = false;\n    _visibleAtFirst = true;\n\n    // keep only one section all the time per design\n    _sectionPlanes = _sectionPlanes || [];\n\n    showSection(true);\n  };\n\n  /**\n      * [ToolInterface] Deactivates the tool\n      * @param {String} name - unused\n      */\n  this.deactivate = function () /*name*/{\n    _active = false;\n    _isDragging = false;\n\n    if (!this.keepCutPlanesOnDeactivate) {\n      // Clean sections and gizmos when deactivating the tool.\n      _fragIterator.start(null); // Shutdown iterator        \n      _removeSections();\n\n      showSection(false);\n      _viewer.setCutPlaneSet(_ownCutPlaneSet);\n    } else {\n      // In case that keepCutPlanesOnDeactivate is set, the control gizmos will disappear, but the sections will stay.\n      _viewer.removeOverlay(_overlayName, _transRotControl);\n      _viewer.removeOverlay(_overlayName, _transControl);\n\n      for (var i = 0; i < _sectionGroups.length; i++) {\n        _viewer.removeOverlay(_overlayName, _sectionGroups[i]);\n      }\n    }\n\n    _transRotControl.detach();\n    _transControl.detach();\n  };\n\n  this.update = function () /*highResTimestamp*/{\n    return false;\n  };\n\n  this.handleSingleClick = function (event /*, button*/) {var _sectionGroups$;\n    var pointer = event;\n    var result = intersectObjects(pointer, (_sectionGroups$ = _sectionGroups[0]) === null || _sectionGroups$ === void 0 ? void 0 : _sectionGroups$.children);\n    _sectionGroups[0].children.forEach(function (child) {\n      child.material.opacity = 0;\n    });\n\n    if (result) {var _sectionGroups$2;\n      var prevObject = _transRotControl.object;\n      attachControl(_transRotControl, result.object);\n      _transRotControl.highlight();\n      result.object.material.opacity = _sectionPlanes.length > 1 ? _selectionOpacity : 0;\n      // Only in case of a section box, and only when clicking on a different plane - re-center the arrow.\n      if (((_sectionGroups$2 = _sectionGroups[0]) === null || _sectionGroups$2 === void 0 ? void 0 : _sectionGroups$2.children.length) > 1 && prevObject !== result.object) {\n        centerPlaneArrow(result.object);\n      }\n      updateViewer();\n      adjustGizmoToBounds();\n    }\n\n    return false;\n  };\n\n  this.handleDoubleClick = function () /*event, button*/{\n    return false;\n  };\n\n  this.handleSingleTap = function (event) {\n    return this.handleSingleClick(event, 0);\n  };\n\n  this.handleDoubleTap = function () /*event*/{\n    return false;\n  };\n\n  this.handleKeyDown = function () /*event, keyCode*/{\n    return false;\n  };\n\n  this.handleKeyUp = function () /*event, keyCode*/{\n    return false;\n  };\n\n  this.handleWheelInput = function () /*delta*/{\n    return false;\n  };\n\n  this.handleButtonDown = function (event /*, button*/) {\n    _isDragging = true;\n    if (_transControl.onPointerDown(event))\n    return true;\n    return _transRotControl.onPointerDown(event);\n  };\n\n  this.handleButtonUp = function (event /*, button*/) {\n    _isDragging = false;\n    if (_boxChanged) {\n      _boxChanged = false;\n      this.recomputePivot();\n    }\n    if (_transControl.onPointerUp(event))\n    return true;\n    return _transRotControl.onPointerUp(event);\n  };\n\n  this.handleMouseMove = function (event) {\n    var oldTransControlPos = _transControl.object ? new THREE.Vector3().copy(_transControl.object.position) : null;\n    // var oldMaxPoint = _transControl.object ? getMaxPoint(_transControl.object) : null;\n    if (_isDragging) {\n      if (_transControl.onPointerMove(event)) {\n        _boxChanged = true;\n        setSectionPlanes();\n        _transRotControl.update();\n        // Keep track of the section box offset\n        var boxOffset = new THREE.Vector3().copy(_transControl.object.position).sub(oldTransControlPos);\n        // Add the box offset to the section plane offset\n        _trcOffset.add(boxOffset);\n\n        sendAnalyticsDebounced('Canvas', 'Box', 'translate');\n\n        return true;\n      }\n      if (_transRotControl.onPointerMove(event)) {\n        _boxChanged = true;\n        setSectionPlanes();\n        updatePlaneMeshes();\n        // TODO: Try to position the triad to the max corner of the section box when moving the plane arrow.\n        // Currently, it is positioned at the max point of the section box.\n\n        if (_activeMode.includes('BOX'))\n        sendAnalyticsDebounced('Canvas', 'Box', 'transform');else\n        {\n          var mode = _transRotControl.axis.search(\"R\") != -1 ? \"rotate\" : \"translate\";\n          sendAnalyticsDebounced('Canvas', 'Plane', mode);\n        }\n\n        return true;\n      }\n    }\n\n    _transControl.visible = _transControl.object !== undefined;\n\n    if (event.pointerType !== 'touch') {var _sectionGroups$3;\n      var pointer = event;\n      var result = intersectObjects(pointer, (_sectionGroups$3 = _sectionGroups[0]) === null || _sectionGroups$3 === void 0 ? void 0 : _sectionGroups$3.children);\n      if (result) {\n        _visibleAtFirst = false;\n      }\n\n      // show gizmo + plane when intersecting on non-touch \n      var visible = _visibleAtFirst || result || intersectObjects(pointer, _sectionPicker, true) ? true : false;\n      _transRotControl.visible = visible;\n      _transControl.visible = _transControl.visible && visible;\n      showPlane(visible);\n    }\n\n    if (_transControl.onPointerHover(event))\n    return true;\n\n    return _transRotControl.onPointerHover(event);\n  };\n\n  this.handleGesture = function (event) {\n    switch (event.type) {\n      case \"dragstart\":\n        _touchType = \"drag\";\n        // Single touch, fake the mouse for now...\n        return this.handleButtonDown(event, 0);\n\n      case \"dragmove\":\n        return _touchType === \"drag\" ? this.handleMouseMove(event) : false;\n\n      case \"dragend\":\n        if (_touchType === \"drag\") {\n          _touchType = null;\n          return this.handleButtonUp(event, 0);\n        }\n        return false;}\n\n    return false;\n  };\n\n  this.handleBlur = function () /*event*/{\n    return false;\n  };\n\n  this.handleResize = function () {\n  };\n\n  this.handlePressHold = function () /*event*/{\n    // When this method returns true, it will not call the DefaultHandler's handlePressHold.\n    // This makes it not possible to open the context menu on mobile.\n    return false;\n  };\n\n  this.recomputePivot = function () {\n\n    var values = this.getSectionBoxValues(true);\n    if (!values) return;\n\n    var aabb = values.sectionBox;\n\n    _viewer.api.navigation.setPivotPoint(new THREE.Vector3(\n    aabb[0] + (aabb[3] - aabb[0]) * 0.5,\n    aabb[1] + (aabb[4] - aabb[1]) * 0.5,\n    aabb[2] + (aabb[5] - aabb[2]) * 0.5));\n\n  };\n\n  this.getSectionBoxValues = function (ignoreGlobalOffset) {\n\n    var group = _sectionGroups[0];\n    if (!group) {\n      return null;\n    }\n\n    var planes = group.children;\n    if (planes.length < 6) {\n      return null;\n    }\n\n    var right = planes[0].position.x;\n    var top = planes[1].position.y;\n    var front = planes[2].position.z;\n    var left = planes[3].position.x;\n    var bttm = planes[4].position.y;\n    var back = planes[5].position.z;\n\n    var off = { x: 0, y: 0, z: 0 };\n    if (!ignoreGlobalOffset) {\n      off = _viewer.model.getData().globalOffset || off;\n    }\n\n    var aabb = [\n    Math.min(left, right) + off.x,\n    Math.min(top, bttm) + off.y,\n    Math.min(front, back) + off.z,\n    Math.max(left, right) + off.x,\n    Math.max(top, bttm) + off.y,\n    Math.max(front, back) + off.z];\n\n\n    // Box doesn't support rotation at the moment.\n    // Will have to take it into account if that becomes a feature.\n    var transform = new THREE.Matrix4().identity().toArray();\n\n    return {\n      sectionBox: aabb,\n      sectionBoxTransform: transform };\n\n  };\n\n  this.getSectionPlaneValues = function (ignoreGlobalOffset) {\n\n    var group = _sectionGroups[0];\n    if (!group) {\n      return null;\n    }\n\n    var planes = group.children;\n    if (planes.length !== 1) {\n      return null;\n    }\n\n    var off = { x: 0, y: 0, z: 0 };\n    if (!ignoreGlobalOffset) {\n      off = _viewer.model.getData().globalOffset || off;\n    }\n\n    var plane = planes[0].plane;\n    var constant = plane.constant - THREE.Vector3.prototype.dot.call(off, plane.normal);\n\n    return {\n      sectionPlane: [\n      plane.normal.x,\n      plane.normal.y,\n      plane.normal.z,\n      constant] };\n\n\n  };\n\n  this.getSectionPlaneSet = function () {\n    return _viewer.getCutPlaneSet(_ownCutPlaneSet);\n  };\n\n  this.getSectionPlanes = function () {\n    // When restoring a viewer state it is put in __set_view, so return from that set\n    // However, the notifyCutplanesChanged function can call setViewerSection which would\n    // move the planes from __set_view into _ownCutPlaneSet\n    var viewSet = _viewer.getCutPlaneSet('__set_view');\n    if (viewSet.length > 0) {\n      return viewSet;\n    }\n\n    return _viewer.getCutPlaneSet(_ownCutPlaneSet);\n  };\n\n  // Called by viewer if any cutplanes are modified. It makes sure that cutplanes controlled by separate tools\n  // (with own cutplane sets) are considered by our cap meshes.\n  this.notifyCutplanesChanged = function () {\n\n    var numCutPlanesBefore = _otherCutPlanes.length;\n\n    // Collect all active cutplanes from other tools\n    //\n    // NOTE: It's essential that we don't create a new array, but just refill the same one.\n    //       Since the cap meshes are created async, the cutPlaneChange event may come in the middle of\n    //       the cap mesh generation. For consistency, we want all cap meshes to share the same cutplane array.\n    _otherCutPlanes.length = 0;\n    var cpSets = _viewer.getCutPlaneSets();\n    for (var i = 0; i < cpSets.length; i++) {\n\n      // skip our own cut planes\n      var cpName = cpSets[i];\n      if (cpName === _ownCutPlaneSet) {\n        continue;\n      }\n\n      // add cutplanes of this set\n      var cp = _viewer.getCutPlaneSet(cpName);\n      for (var j = 0; j < cp.length; j++) {\n        _otherCutPlanes.push(cp[j]);\n      }\n    }\n\n    // Set the section tool to the viewer defined cutplane.\n    if (cpSets.includes(\"__set_view\") && _activeMode !== \"\" && _activeMode.indexOf(\"OBJ_\") === -1) {\n      this.setViewerSection(false);\n    }\n\n    // If the number of cutplanes changed, this requires a shader recompile of the cap materials\n    if (numCutPlanesBefore !== _otherCutPlanes.length) {\n      updateCapMaterials();\n    }\n  };\n\n  /**\n      * Set a section box around the passed in bounding box.\n      * @param {THREE.Box3} box\n      * @returns {boolean} - true if the section box was set\n      */\n  this.setSectionBox = function (box) {\n    if (!box) return false;\n    var name = 'OBJ_BOX';\n    // Convert the bounding box to planes\n    var planes = Autodesk.Viewing.Private.SceneMath.box2CutPlanes(box, box.transform);\n    _activeMode = name;\n    _viewer.setCutPlaneSet('__set_view', planes);\n    this.setSection(name);\n    return true;\n  };\n\n  /**\n      * Set a section plane at the intersection position.\n      * @param {Three.Vector3} normal - plane normal.\n      * @param {Three.Vector3} position - position to place the plane.\n      * @returns {boolean} - true if the section plane was set\n      */\n  this.setSectionPlane = function (normal, position) {var _transRotControl2, _transRotControl3;var enableRotationGizmo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!normal || !position) return false;\n    var name = 'OBJ_SET_VIEW_PLANE';\n    var distance = -1 * position.dot(normal);\n    var plane = new THREE.Plane(normal, distance);\n    _activeMode = name;\n    var planeVecs = [new THREE.Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.constant)];\n    _viewer.setCutPlaneSet('__set_view', planeVecs);\n    this.setSection(name);\n    // RotationGizmos are turned on by default.\n    // The option to disable it, is for cases like activating the section tool from the context menu.\n    (_transRotControl2 = _transRotControl) === null || _transRotControl2 === void 0 ? void 0 : _transRotControl2.showRotationGizmos(enableRotationGizmo);\n    var pos = position.clone().sub(_sectionGroups[0].children[0].position);\n    (_transRotControl3 = _transRotControl) === null || _transRotControl3 === void 0 ? void 0 : _transRotControl3.setGizmoOffset(pos);\n\n    return true;\n  };\n};\n\nfunction init_SectionMesh() {\n\n  if (SectionMeshClass)\n  return;\n\n  SectionMeshClass = function SectionMeshClass(geometry, material, plane) {\n\n    THREE.Mesh.call(this, geometry, material, false);\n\n    this.plane = plane;\n    this.planeVec = new THREE.Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.constant);\n    this.connectivity = [];\n    this.outlines = [];\n  };\n\n  SectionMeshClass.prototype = Object.create(THREE.Mesh.prototype);\n  SectionMeshClass.prototype.constructor = SectionMeshClass;\n\n  SectionMeshClass.prototype.update = function () {\n\n    this.plane.normal.set(0, 0, 1);\n    this.plane.normal.applyQuaternion(this.quaternion);\n\n    var normal = this.plane.normal;\n    var d = -1 * this.getWorldPosition().dot(normal);\n    this.planeVec.set(normal.x, normal.y, normal.z, d);\n    this.plane.constant = d;\n  };\n\n}","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"/**\\n * Section CSS\\n **/\\n.sectionPanel {\\n  line-height: 14px;\\n  text-align: left;\\n  z-index: 10; }\\n\\n.section-horizontal-divider {\\n  height: 1px;\\n  border-top: 1px solid rgba(200, 200, 200, 0.8); }\\n\\n.section-submenu-select {\\n  display: block;\\n  position: relative;\\n  width: calc(100% - 40px);\\n  padding: 10px 20px 0px 20px;\\n  opacity: 0.3; }\\n\\n.section-panel:hover .section-submenu-select {\\n  opacity: 0.8; }\\n\\n.section-submenu-selectlabel {\\n  position: relative;\\n  display: inline-block;\\n  padding-right: 20px;\\n  padding-bottom: 4px; }\\n\\n.section-restart {\\n  margin: 10px 20px 15px 20px;\\n  padding: 6px 10px 6px 10px;\\n  width: calc(100% - 55px);\\n  cursor: pointer; }\\n\\n.docking-panel:hover .section-restart {\\n  background-color: rgba(255, 255, 255, 0.12); }\\n\\n.docking-panel .section-restart:hover {\\n  background-color: rgba(166, 194, 255, 0.7);\\n  -webkit-transition: all 0.2s ease;\\n  -moz-transition: all 0.2s ease;\\n  -ms-transition: all 0.2s ease;\\n  -o-transition: all 0.2s ease;\\n  transition: all 0.2s ease; }\\n\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);} /**\n                                                                                                                                                                                                                                                                                                                                                                                * @license\n                                                                                                                                                                                                                                                                                                                                                                                * Lodash (Custom Build) <https://lodash.com/>\n                                                                                                                                                                                                                                                                                                                                                                                * Build: `lodash include=\"debounce,throttle\" exports=\"amd\"`\n                                                                                                                                                                                                                                                                                                                                                                                * Copyright JS Foundation and other contributors <https://js.foundation/>\n                                                                                                                                                                                                                                                                                                                                                                                * Released under MIT license <https://lodash.com/license>\n                                                                                                                                                                                                                                                                                                                                                                                * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n                                                                                                                                                                                                                                                                                                                                                                                * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n                                                                                                                                                                                                                                                                                                                                                                                */\n;(function () {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.5';\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used as references for various `Number` constants. */\n  var NAN = 0 / 0;\n\n  /** `Object#toString` result references. */\n  var nullTag = '[object Null]',\n  symbolTag = '[object Symbol]',\n  undefinedTag = '[object Undefined]';\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /*--------------------------------------------------------------------------*/\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n                                                    * Used to resolve the\n                                                    * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n                                                    * of values.\n                                                    */\n  var nativeObjectToString = objectProto.toString;\n\n  /** Built-in value references. */\n  var _Symbol = root.Symbol,\n  symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax = Math.max,\n  nativeMin = Math.min;\n\n  /** Used to lookup unminified function names. */\n  var realNames = {};\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n                                                                                * Creates a `lodash` object which wraps `value` to enable implicit method\n                                                                                * chain sequences. Methods that operate on and return arrays, collections,\n                                                                                * and functions can be chained together. Methods that retrieve a single value\n                                                                                * or may return a primitive value will automatically end the chain sequence\n                                                                                * and return the unwrapped value. Otherwise, the value must be unwrapped\n                                                                                * with `_#value`.\n                                                                                *\n                                                                                * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n                                                                                * enabled using `_.chain`.\n                                                                                *\n                                                                                * The execution of chained methods is lazy, that is, it's deferred until\n                                                                                * `_#value` is implicitly or explicitly called.\n                                                                                *\n                                                                                * Lazy evaluation allows several methods to support shortcut fusion.\n                                                                                * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n                                                                                * the creation of intermediate arrays and can greatly reduce the number of\n                                                                                * iteratee executions. Sections of a chain sequence qualify for shortcut\n                                                                                * fusion if the section is applied to an array and iteratees accept only\n                                                                                * one argument. The heuristic for whether a section qualifies for shortcut\n                                                                                * fusion is subject to change.\n                                                                                *\n                                                                                * Chaining is supported in custom builds as long as the `_#value` method is\n                                                                                * directly or indirectly included in the build.\n                                                                                *\n                                                                                * In addition to lodash methods, wrappers have `Array` and `String` methods.\n                                                                                *\n                                                                                * The wrapper `Array` methods are:\n                                                                                * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n                                                                                *\n                                                                                * The wrapper `String` methods are:\n                                                                                * `replace` and `split`\n                                                                                *\n                                                                                * The wrapper methods that support shortcut fusion are:\n                                                                                * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n                                                                                * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n                                                                                * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n                                                                                *\n                                                                                * The chainable wrapper methods are:\n                                                                                * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n                                                                                * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n                                                                                * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n                                                                                * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n                                                                                * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n                                                                                * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n                                                                                * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n                                                                                * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n                                                                                * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n                                                                                * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n                                                                                * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n                                                                                * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n                                                                                * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n                                                                                * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n                                                                                * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n                                                                                * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n                                                                                * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n                                                                                * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n                                                                                * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n                                                                                * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n                                                                                * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n                                                                                * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n                                                                                * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n                                                                                * `zipObject`, `zipObjectDeep`, and `zipWith`\n                                                                                *\n                                                                                * The wrapper methods that are **not** chainable by default are:\n                                                                                * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n                                                                                * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n                                                                                * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n                                                                                * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n                                                                                * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n                                                                                * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n                                                                                * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n                                                                                * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n                                                                                * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n                                                                                * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n                                                                                * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n                                                                                * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n                                                                                * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n                                                                                * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n                                                                                * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n                                                                                * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n                                                                                * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n                                                                                * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n                                                                                * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n                                                                                * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n                                                                                * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n                                                                                * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n                                                                                * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n                                                                                * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n                                                                                * `upperFirst`, `value`, and `words`\n                                                                                *\n                                                                                * @name _\n                                                                                * @constructor\n                                                                                * @category Seq\n                                                                                * @param {*} value The value to wrap in a `lodash` instance.\n                                                                                * @returns {Object} Returns the new `lodash` wrapper instance.\n                                                                                * @example\n                                                                                *\n                                                                                * function square(n) {\n                                                                                *   return n * n;\n                                                                                * }\n                                                                                *\n                                                                                * var wrapped = _([1, 2, 3]);\n                                                                                *\n                                                                                * // Returns an unwrapped value.\n                                                                                * wrapped.reduce(_.add);\n                                                                                * // => 6\n                                                                                *\n                                                                                * // Returns a wrapped value.\n                                                                                * var squares = wrapped.map(square);\n                                                                                *\n                                                                                * _.isArray(squares);\n                                                                                * // => false\n                                                                                *\n                                                                                * _.isArray(squares.value());\n                                                                                * // => true\n                                                                                */\n  function lodash() {\n    // No operation performed.\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n                                                                                * The base implementation of `getTag` without fallbacks for buggy environments.\n                                                                                *\n                                                                                * @private\n                                                                                * @param {*} value The value to query.\n                                                                                * @returns {string} Returns the `toStringTag`.\n                                                                                */\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n    return symToStringTag && symToStringTag in Object(value) ?\n    getRawTag(value) :\n    objectToString(value);\n  }\n\n  /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag),\n    tag = value[symToStringTag];\n\n    try {\n      value[symToStringTag] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n\n    var result = nativeObjectToString.call(value);\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag] = tag;\n      } else {\n        delete value[symToStringTag];\n      }\n    }\n    return result;\n  }\n\n  /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n  function objectToString(value) {\n    return nativeObjectToString.call(value);\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n                                                                                * Gets the timestamp of the number of milliseconds that have elapsed since\n                                                                                * the Unix epoch (1 January 1970 00:00:00 UTC).\n                                                                                *\n                                                                                * @static\n                                                                                * @memberOf _\n                                                                                * @since 2.4.0\n                                                                                * @category Date\n                                                                                * @returns {number} Returns the timestamp.\n                                                                                * @example\n                                                                                *\n                                                                                * _.defer(function(stamp) {\n                                                                                *   console.log(_.now() - stamp);\n                                                                                * }, _.now());\n                                                                                * // => Logs the number of milliseconds it took for the deferred invocation.\n                                                                                */\n  var now = function now() {\n    return root.Date.now();\n  };\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n                                                                                * Creates a debounced function that delays invoking `func` until after `wait`\n                                                                                * milliseconds have elapsed since the last time the debounced function was\n                                                                                * invoked. The debounced function comes with a `cancel` method to cancel\n                                                                                * delayed `func` invocations and a `flush` method to immediately invoke them.\n                                                                                * Provide `options` to indicate whether `func` should be invoked on the\n                                                                                * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n                                                                                * with the last arguments provided to the debounced function. Subsequent\n                                                                                * calls to the debounced function return the result of the last `func`\n                                                                                * invocation.\n                                                                                *\n                                                                                * **Note:** If `leading` and `trailing` options are `true`, `func` is\n                                                                                * invoked on the trailing edge of the timeout only if the debounced function\n                                                                                * is invoked more than once during the `wait` timeout.\n                                                                                *\n                                                                                * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n                                                                                * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n                                                                                *\n                                                                                * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n                                                                                * for details over the differences between `_.debounce` and `_.throttle`.\n                                                                                *\n                                                                                * @static\n                                                                                * @memberOf _\n                                                                                * @since 0.1.0\n                                                                                * @category Function\n                                                                                * @param {Function} func The function to debounce.\n                                                                                * @param {number} [wait=0] The number of milliseconds to delay.\n                                                                                * @param {Object} [options={}] The options object.\n                                                                                * @param {boolean} [options.leading=false]\n                                                                                *  Specify invoking on the leading edge of the timeout.\n                                                                                * @param {number} [options.maxWait]\n                                                                                *  The maximum time `func` is allowed to be delayed before it's invoked.\n                                                                                * @param {boolean} [options.trailing=true]\n                                                                                *  Specify invoking on the trailing edge of the timeout.\n                                                                                * @returns {Function} Returns the new debounced function.\n                                                                                * @example\n                                                                                *\n                                                                                * // Avoid costly calculations while the window size is in flux.\n                                                                                * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n                                                                                *\n                                                                                * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n                                                                                * jQuery(element).on('click', _.debounce(sendMail, 300, {\n                                                                                *   'leading': true,\n                                                                                *   'trailing': false\n                                                                                * }));\n                                                                                *\n                                                                                * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n                                                                                * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n                                                                                * var source = new EventSource('/stream');\n                                                                                * jQuery(source).on('message', debounced);\n                                                                                *\n                                                                                * // Cancel the trailing debounced invocation.\n                                                                                * jQuery(window).on('popstate', debounced.cancel);\n                                                                                */\n  function debounce(func, wait, options) {\n    var lastArgs,\n    lastThis,\n    maxWait,\n    result,\n    timerId,\n    lastCallTime,\n    lastInvokeTime = 0,\n    leading = false,\n    maxing = false,\n    trailing = true;\n\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    wait = toNumber(wait) || 0;\n    if (isObject(options)) {\n      leading = !!options.leading;\n      maxing = 'maxWait' in options;\n      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n      trailing = 'trailing' in options ? !!options.trailing : trailing;\n    }\n\n    function invokeFunc(time) {\n      var args = lastArgs,\n      thisArg = lastThis;\n\n      lastArgs = lastThis = undefined;\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args);\n      return result;\n    }\n\n    function leadingEdge(time) {\n      // Reset any `maxWait` timer.\n      lastInvokeTime = time;\n      // Start the timer for the trailing edge.\n      timerId = setTimeout(timerExpired, wait);\n      // Invoke the leading edge.\n      return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n      var timeSinceLastCall = time - lastCallTime,\n      timeSinceLastInvoke = time - lastInvokeTime,\n      timeWaiting = wait - timeSinceLastCall;\n\n      return maxing ?\n      nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) :\n      timeWaiting;\n    }\n\n    function shouldInvoke(time) {\n      var timeSinceLastCall = time - lastCallTime,\n      timeSinceLastInvoke = time - lastInvokeTime;\n\n      // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n      return lastCallTime === undefined || timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n\n    function timerExpired() {\n      var time = now();\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // Restart the timer.\n      timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    function cancel() {\n      if (timerId !== undefined) {\n        clearTimeout(timerId);\n      }\n      lastInvokeTime = 0;\n      lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n\n    function flush() {\n      return timerId === undefined ? result : trailingEdge(now());\n    }\n\n    function debounced() {\n      var time = now(),\n      isInvoking = shouldInvoke(time);\n\n      lastArgs = arguments;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          timerId = setTimeout(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = setTimeout(timerExpired, wait);\n      }\n      return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n  }\n\n  /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n  function throttle(func, wait, options) {\n    var leading = true,\n    trailing = true;\n\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    if (isObject(options)) {\n      leading = 'leading' in options ? !!options.leading : leading;\n      trailing = 'trailing' in options ? !!options.trailing : trailing;\n    }\n    return debounce(func, wait, {\n      'leading': leading,\n      'maxWait': wait,\n      'trailing': trailing });\n\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n                                                                                * Checks if `value` is the\n                                                                                * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n                                                                                * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n                                                                                *\n                                                                                * @static\n                                                                                * @memberOf _\n                                                                                * @since 0.1.0\n                                                                                * @category Lang\n                                                                                * @param {*} value The value to check.\n                                                                                * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n                                                                                * @example\n                                                                                *\n                                                                                * _.isObject({});\n                                                                                * // => true\n                                                                                *\n                                                                                * _.isObject([1, 2, 3]);\n                                                                                * // => true\n                                                                                *\n                                                                                * _.isObject(_.noop);\n                                                                                * // => true\n                                                                                *\n                                                                                * _.isObject(null);\n                                                                                * // => false\n                                                                                */\n  function isObject(value) {\n    var type = _typeof(value);\n    return value != null && (type == 'object' || type == 'function');\n  }\n\n  /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n  function isObjectLike(value) {\n    return value != null && _typeof(value) == 'object';\n  }\n\n  /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n  function isSymbol(value) {\n    return _typeof(value) == 'symbol' ||\n    isObjectLike(value) && baseGetTag(value) == symbolTag;\n  }\n\n  /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value;\n    }\n    if (isSymbol(value)) {\n      return NAN;\n    }\n    if (isObject(value)) {\n      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n      value = isObject(other) ? other + '' : other;\n    }\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value;\n    }\n    value = value.replace(reTrim, '');\n    var isBinary = reIsBinary.test(value);\n    return isBinary || reIsOctal.test(value) ?\n    freeParseInt(value.slice(2), isBinary ? 2 : 8) :\n    reIsBadHex.test(value) ? NAN : +value;\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  // Add methods that return wrapped values in chain sequences.\n  lodash.debounce = debounce;\n  lodash.throttle = throttle;\n\n  /*------------------------------------------------------------------------*/\n\n  // Add methods that return unwrapped values in chain sequences.\n  lodash.isObject = isObject;\n  lodash.isObjectLike = isObjectLike;\n  lodash.isSymbol = isSymbol;\n  lodash.now = now;\n  lodash.toNumber = toNumber;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n                                                                                * The semantic version number.\n                                                                                *\n                                                                                * @static\n                                                                                * @memberOf _\n                                                                                * @type {string}\n                                                                                */\n  lodash.VERSION = VERSION;\n\n  /*--------------------------------------------------------------------------*/\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function () {\n      return lodash;\n    });\n  }\n}).call(this);","/**\n * @author arodic / https://github.com/arodic\n *\n * @author chiena -- Modified for Autodesk LMV web viewer\n */\n/*jshint sub:true*/\n\nexport function init_TransformGizmos() {\n\n  'use strict';\n\n  var GizmoMaterial = function GizmoMaterial(parameters) {\n\n    THREE.MeshBasicMaterial.call(this);\n\n    this.depthTest = false;\n    this.depthWrite = false;\n    this.side = THREE.FrontSide;\n    this.transparent = true;\n\n    this.setValues(parameters);\n\n    this.oldColor = this.color.clone();\n    this.oldOpacity = this.opacity;\n\n    this.highlight = function (highlighted) {\n\n      if (highlighted) {\n\n        this.color.setRGB(1, 230 / 255, 3 / 255);\n        this.opacity = 1;\n\n      } else {\n\n        this.color.copy(this.oldColor);\n        this.opacity = this.oldOpacity;\n\n      }\n\n    };\n\n  };\n\n  GizmoMaterial.prototype = Object.create(THREE.MeshBasicMaterial.prototype);\n\n  var GizmoLineMaterial = function GizmoLineMaterial(parameters) {\n\n    THREE.LineBasicMaterial.call(this);\n\n    this.depthTest = false;\n    this.depthWrite = false;\n    this.transparent = true;\n    this.linewidth = 1;\n\n    this.setValues(parameters);\n\n    this.oldColor = this.color.clone();\n    this.oldOpacity = this.opacity;\n\n    this.highlight = function (highlighted) {\n\n      if (highlighted) {\n\n        this.color.setRGB(1, 230 / 255, 3 / 255);\n        this.opacity = 1;\n\n      } else {\n\n        this.color.copy(this.oldColor);\n        this.opacity = this.oldOpacity;\n\n      }\n\n    };\n\n  };\n\n  GizmoLineMaterial.prototype = Object.create(THREE.LineBasicMaterial.prototype);\n\n  // polyfill\n  if (THREE.PolyhedronGeometry === undefined) {\n    THREE.PolyhedronGeometry = function (vertices, indices, radius, detail) {\n\n      THREE.Geometry.call(this);\n\n      this.type = 'PolyhedronGeometry';\n\n      this.parameters = {\n        vertices: vertices,\n        indices: indices,\n        radius: radius,\n        detail: detail };\n\n\n      radius = radius || 1;\n      detail = detail || 0;\n\n      var that = this;\n\n      for (var i = 0, l = vertices.length; i < l; i += 3) {\n\n        prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));\n\n      }\n\n      var midpoints = [],p = this.vertices;\n\n      var faces = [];\n\n      for (var i = 0, j = 0, l = indices.length; i < l; i += 3, j++) {\n\n        var v1 = p[indices[i]];\n        var v2 = p[indices[i + 1]];\n        var v3 = p[indices[i + 2]];\n\n        faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);\n\n      }\n\n      var centroid = new THREE.Vector3();\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n\n        subdivide(faces[i], detail);\n\n      }\n\n\n      // Handle case when face straddles the seam\n\n      for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {\n\n        var uvs = this.faceVertexUvs[0][i];\n\n        var x0 = uvs[0].x;\n        var x1 = uvs[1].x;\n        var x2 = uvs[2].x;\n\n        var max = Math.max(x0, Math.max(x1, x2));\n        var min = Math.min(x0, Math.min(x1, x2));\n\n        if (max > 0.9 && min < 0.1) {// 0.9 is somewhat arbitrary\n\n          if (x0 < 0.2) uvs[0].x += 1;\n          if (x1 < 0.2) uvs[1].x += 1;\n          if (x2 < 0.2) uvs[2].x += 1;\n\n        }\n\n      }\n\n\n      // Apply radius\n\n      for (var i = 0, l = this.vertices.length; i < l; i++) {\n\n        this.vertices[i].multiplyScalar(radius);\n\n      }\n\n\n      // Merge vertices\n\n      this.mergeVertices();\n\n      this.computeFaceNormals();\n\n      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\n\n\n      // Project vector onto sphere's surface\n\n      function prepare(vector) {\n\n        var vertex = vector.normalize().clone();\n        vertex.index = that.vertices.push(vertex) - 1;\n\n        // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n        var u = azimuth(vector) / 2 / Math.PI + 0.5;\n        var v = inclination(vector) / Math.PI + 0.5;\n        vertex.uv = new THREE.Vector2(u, 1 - v);\n\n        return vertex;\n\n      }\n\n\n      // Approximate a curved face with recursively sub-divided triangles.\n\n      function make(v1, v2, v3) {\n\n        var face = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);\n        that.faces.push(face);\n\n        centroid.copy(v1).add(v2).add(v3).divideScalar(3);\n\n        var azi = azimuth(centroid);\n\n        that.faceVertexUvs[0].push([\n        correctUV(v1.uv, v1, azi),\n        correctUV(v2.uv, v2, azi),\n        correctUV(v3.uv, v3, azi)]);\n\n\n      }\n\n\n      // Analytically subdivide a face to the required detail level.\n\n      function subdivide(face, detail) {\n\n        var cols = Math.pow(2, detail);\n        var cells = Math.pow(4, detail);\n        var a = prepare(that.vertices[face.a]);\n        var b = prepare(that.vertices[face.b]);\n        var c = prepare(that.vertices[face.c]);\n        var v = [];\n\n        // Construct all of the vertices for this subdivision.\n\n        for (var i = 0; i <= cols; i++) {\n\n          v[i] = [];\n\n          var aj = prepare(a.clone().lerp(c, i / cols));\n          var bj = prepare(b.clone().lerp(c, i / cols));\n          var rows = cols - i;\n\n          for (var j = 0; j <= rows; j++) {\n\n            if (j == 0 && i == cols) {\n\n              v[i][j] = aj;\n\n            } else {\n\n              v[i][j] = prepare(aj.clone().lerp(bj, j / rows));\n\n            }\n\n          }\n\n        }\n\n        // Construct all of the faces.\n\n        for (var i = 0; i < cols; i++) {\n\n          for (var j = 0; j < 2 * (cols - i) - 1; j++) {\n\n            var k = Math.floor(j / 2);\n\n            if (j % 2 == 0) {\n\n              make(\n              v[i][k + 1],\n              v[i + 1][k],\n              v[i][k]);\n\n\n            } else {\n\n              make(\n              v[i][k + 1],\n              v[i + 1][k + 1],\n              v[i + 1][k]);\n\n\n            }\n\n          }\n\n        }\n\n      }\n\n\n      // Angle around the Y axis, counter-clockwise when looking from above.\n\n      function azimuth(vector) {\n\n        return Math.atan2(vector.z, -vector.x);\n\n      }\n\n\n      // Angle above the XZ plane.\n\n      function inclination(vector) {\n\n        return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n\n      }\n\n\n      // Texture fixing helper. Spheres have some odd behaviours.\n\n      function correctUV(uv, vector, azimuth) {\n\n        if (azimuth < 0 && uv.x === 1) uv = new THREE.Vector2(uv.x - 1, uv.y);\n        if (vector.x === 0 && vector.z === 0) uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);\n        return uv.clone();\n\n      }\n\n    };\n\n    THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\n  }\n\n  // polyfill\n  if (THREE.OctahedronGeometry === undefined) {\n    THREE.OctahedronGeometry = function (radius, detail) {\n\n      this.parameters = {\n        radius: radius,\n        detail: detail };\n\n\n      var vertices = [\n      1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];\n\n\n      var indices = [\n      0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];\n\n\n      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);\n\n      this.type = 'OctahedronGeometry';\n\n      this.parameters = {\n        radius: radius,\n        detail: detail };\n\n    };\n\n    THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\n  }\n\n  // polyfill\n  if (THREE.TorusGeometry === undefined) {\n    THREE.TorusGeometry = function (radius, tube, radialSegments, tubularSegments, arc) {\n\n      THREE.Geometry.call(this);\n\n      this.type = 'TorusGeometry';\n\n      this.parameters = {\n        radius: radius,\n        tube: tube,\n        radialSegments: radialSegments,\n        tubularSegments: tubularSegments,\n        arc: arc };\n\n\n      radius = radius || 100;\n      tube = tube || 40;\n      radialSegments = radialSegments || 8;\n      tubularSegments = tubularSegments || 6;\n      arc = arc || Math.PI * 2;\n\n      var center = new THREE.Vector3(),uvs = [],normals = [];\n\n      for (var j = 0; j <= radialSegments; j++) {\n\n        for (var i = 0; i <= tubularSegments; i++) {\n\n          var u = i / tubularSegments * arc;\n          var v = j / radialSegments * Math.PI * 2;\n\n          center.x = radius * Math.cos(u);\n          center.y = radius * Math.sin(u);\n\n          var vertex = new THREE.Vector3();\n          vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n          vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n          vertex.z = tube * Math.sin(v);\n\n          this.vertices.push(vertex);\n\n          uvs.push(new THREE.Vector2(i / tubularSegments, j / radialSegments));\n          normals.push(vertex.clone().sub(center).normalize());\n\n        }\n\n      }\n\n      for (var j = 1; j <= radialSegments; j++) {\n\n        for (var i = 1; i <= tubularSegments; i++) {\n\n          var a = (tubularSegments + 1) * j + i - 1;\n          var b = (tubularSegments + 1) * (j - 1) + i - 1;\n          var c = (tubularSegments + 1) * (j - 1) + i;\n          var d = (tubularSegments + 1) * j + i;\n\n          var face = new THREE.Face3(a, b, d, [normals[a].clone(), normals[b].clone(), normals[d].clone()]);\n          this.faces.push(face);\n          this.faceVertexUvs[0].push([uvs[a].clone(), uvs[b].clone(), uvs[d].clone()]);\n\n          face = new THREE.Face3(b, c, d, [normals[b].clone(), normals[c].clone(), normals[d].clone()]);\n          this.faces.push(face);\n          this.faceVertexUvs[0].push([uvs[b].clone(), uvs[c].clone(), uvs[d].clone()]);\n\n        }\n\n      }\n\n      this.computeFaceNormals();\n\n    };\n\n    THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);\n  }\n\n  var createCircleGeometry = function createCircleGeometry(radius, facing, arc) {\n\n    var geometry = new THREE.Geometry();\n    arc = arc ? arc : 1;\n    for (var i = 0; i <= 64 * arc; ++i) {\n      if (facing == 'x') geometry.vertices.push(new THREE.Vector3(0, Math.cos(i / 32 * Math.PI), Math.sin(i / 32 * Math.PI)).multiplyScalar(radius));\n      if (facing == 'y') geometry.vertices.push(new THREE.Vector3(Math.cos(i / 32 * Math.PI), 0, Math.sin(i / 32 * Math.PI)).multiplyScalar(radius));\n      if (facing == 'z') geometry.vertices.push(new THREE.Vector3(Math.sin(i / 32 * Math.PI), Math.cos(i / 32 * Math.PI), 0).multiplyScalar(radius));\n    }\n\n    return geometry;\n  };\n\n  var createArrowGeometry = function createArrowGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {\n\n    var arrowGeometry = new THREE.Geometry();\n    var mesh = new THREE.Mesh(new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded));\n    mesh.position.y = 0.5;\n    mesh.updateMatrix();\n\n    arrowGeometry.merge(mesh.geometry, mesh.matrix);\n\n    return arrowGeometry;\n  };\n\n  var createLineGeometry = function createLineGeometry(axis) {\n\n    var lineGeometry = new THREE.Geometry();\n    if (axis === 'X')\n    lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0));else\n    if (axis === 'Y')\n    lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));else\n    if (axis === 'Z')\n    lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1));\n\n    return lineGeometry;\n  };\n\n  THREE.TransformGizmo = function (includeAxis) {\n\n    var scope = this;\n    var showPickers = false; //debug\n    var showActivePlane = false; //debug\n\n    this.init = function () {\n\n      THREE.Object3D.call(this);\n\n      this.handles = new THREE.Object3D();\n      this.pickers = new THREE.Object3D();\n      this.planes = new THREE.Object3D();\n      this.highlights = new THREE.Object3D();\n      this.hemiPicker = new THREE.Object3D();\n      this.subPickers = new THREE.Object3D();\n\n      this.add(this.handles);\n      this.add(this.pickers);\n      this.add(this.planes);\n      this.add(this.highlights);\n      this.add(this.hemiPicker);\n      this.add(this.subPickers);\n\n      //// PLANES\n\n      var planeGeometry = new THREE.PlaneBufferGeometry(50, 50, 2, 2);\n      var planeMaterial = new THREE.MeshBasicMaterial({ wireframe: true });\n      planeMaterial.side = THREE.DoubleSide;\n\n      var planes = {\n        \"XY\": new THREE.Mesh(planeGeometry, planeMaterial),\n        \"YZ\": new THREE.Mesh(planeGeometry, planeMaterial),\n        \"XZ\": new THREE.Mesh(planeGeometry, planeMaterial),\n        \"XYZE\": new THREE.Mesh(planeGeometry, planeMaterial) };\n\n\n      this.activePlane = planes[\"XYZE\"];\n\n      planes[\"YZ\"].rotation.set(0, Math.PI / 2, 0);\n      planes[\"XZ\"].rotation.set(-Math.PI / 2, 0, 0);\n\n      for (var i in planes) {\n        planes[i].name = i;\n        this.planes.add(planes[i]);\n        this.planes[i] = planes[i];\n        planes[i].visible = false;\n      }\n\n      this.setupGizmos();\n      this.activeMode = \"\";\n\n      // reset Transformations\n\n      this.traverse(function (child) {\n        if (child instanceof THREE.Mesh) {\n          child.updateMatrix();\n\n          var tempGeometry = new THREE.Geometry();\n          if (child.geometry instanceof THREE.BufferGeometry) {\n            child.geometry = new THREE.Geometry().fromBufferGeometry(child.geometry);\n          }\n          tempGeometry.merge(child.geometry, child.matrix);\n\n          child.geometry = tempGeometry;\n          child.position.set(0, 0, 0);\n          child.rotation.set(0, 0, 0);\n          child.scale.set(1, 1, 1);\n        }\n      });\n\n    };\n\n    this.hide = function () {\n      this.traverse(function (child) {\n        child.visible = false;\n      });\n    };\n\n    this.show = function () {\n      this.traverse(function (child) {\n        child.visible = true;\n        if (child.parent == scope.pickers || child.parent == scope.hemiPicker) child.visible = showPickers;\n        if (child.parent == scope.planes) child.visible = false;\n      });\n      this.activePlane.visible = showActivePlane;\n    };\n\n    this.highlight = function (axis) {\n      this.traverse(function (child) {\n        if (child.material && child.material.highlight) {\n          if (child.name == axis) {\n            child.material.highlight(true);\n          } else {\n            child.material.highlight(false);\n          }\n        }\n      });\n    };\n\n    this.setupGizmos = function () {\n\n      var addGizmos = function addGizmos(gizmoMap, parent) {\n\n        for (var name in gizmoMap) {\n\n          for (var i = gizmoMap[name].length; i--;) {\n\n            var object = gizmoMap[name][i][0];\n            var position = gizmoMap[name][i][1];\n            var rotation = gizmoMap[name][i][2];\n            var visble = gizmoMap[name][i][3];\n\n            object.name = name;\n\n            if (position) object.position.set(position[0], position[1], position[2]);\n            if (rotation) object.rotation.set(rotation[0], rotation[1], rotation[2]);\n            if (visble) object.visble = visble;\n\n            parent.add(object);\n\n          }\n\n        }\n\n      };\n\n      this.setHandlePickerGizmos();\n\n      if (includeAxis) {\n        var axisNames = Object.keys(this.handleGizmos);\n\n        for (var i = 0; i < axisNames.length; i++) {\n          var axisName = axisNames[i];\n\n          if (includeAxis.indexOf(axisName) === -1) {\n            delete this.handleGizmos[axisName];\n            delete this.pickerGizmos[axisName];\n            delete this.hemiPickerGizmos[axisName];\n          }\n        }\n      }\n\n      addGizmos(this.handleGizmos, this.handles);\n      addGizmos(this.pickerGizmos, this.pickers);\n      addGizmos(this.highlightGizmos, this.highlights);\n      addGizmos(this.hemiPickerGizmos, this.hemiPicker);\n      addGizmos(this.subPickerGizmos, this.subPickers);\n\n      this.hide();\n      this.show();\n\n    };\n\n  };\n\n  THREE.TransformGizmo.prototype = Object.create(THREE.Object3D.prototype);\n\n  THREE.TransformGizmo.prototype.update = function (rotation, eye) {\n\n    var vec1 = new THREE.Vector3(0, 0, 0);\n    var vec2 = new THREE.Vector3(0, 1, 0);\n    var lookAtMatrix = new THREE.Matrix4();\n\n    this.traverse(function (child) {\n      if (child.name) {\n        if (child.name.search(\"E\") != -1) {\n          child.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(eye, vec1, vec2));\n        } else if (child.name.search(\"X\") != -1 || child.name.search(\"Y\") != -1 || child.name.search(\"Z\") != -1) {\n          child.quaternion.setFromEuler(rotation);\n        }\n      }\n    });\n\n  };\n\n  THREE.TransformGizmoTranslate = function (includeAxis) {\n\n    THREE.TransformGizmo.call(this, includeAxis);\n\n    this.setHandlePickerGizmos = function () {\n\n      var arrowGeometry = createArrowGeometry(0, 0.05, 0.2, 12, 1, false);\n      var lineXGeometry = createLineGeometry('X');\n      var lineYGeometry = createLineGeometry('Y');\n      var lineZGeometry = createLineGeometry('Z');\n\n      this.handleGizmos = {\n        X: [\n        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xf12c2c })), [0.5, 0, 0], [0, 0, -Math.PI / 2]],\n        [new THREE.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xf12c2c }))]],\n\n        Y: [\n        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0bb80b })), [0, 0.5, 0]],\n        [new THREE.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x0bb80b }))]],\n\n        Z: [\n        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x2c2cf1 })), [0, 0, 0.5], [Math.PI / 2, 0, 0]],\n        [new THREE.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x2c2cf1 }))]],\n\n        XYZ: [\n        [new THREE.Mesh(new THREE.OctahedronGeometry(0.1, 0), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 })), [0, 0, 0], [0, 0, 0]]],\n\n        XY: [\n        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })), [0.15, 0.15, 0]]],\n\n        YZ: [\n        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],\n\n        XZ: [\n        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] };\n\n\n\n      this.pickerGizmos = {\n        X: [\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0xff0000, opacity: 0.25 })), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],\n\n        Y: [\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0x00ff00, opacity: 0.25 })), [0, 0.6, 0]]],\n\n        Z: [\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],\n\n        XYZ: [\n        [new THREE.Mesh(new THREE.OctahedronGeometry(0.2, 0), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))]],\n\n        XY: [\n        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })), [0.2, 0.2, 0]]],\n\n        YZ: [\n        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],\n\n        XZ: [\n        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]] };\n\n\n\n      this.hemiPickerGizmos = {\n        XYZ: [\n        [new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new GizmoMaterial({ color: 0x0000ff })), [0.5, 0.5, 0.5], null, false]] };\n\n\n\n    };\n\n    this.setActivePlane = function (axis, eye) {\n\n      var tempMatrix = new THREE.Matrix4();\n      eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes[\"XY\"].matrixWorld)));\n\n      if (axis == \"X\") {\n        this.activePlane = this.planes[\"XY\"];\n        if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes[\"XZ\"];\n      }\n\n      if (axis == \"Y\") {\n        this.activePlane = this.planes[\"XY\"];\n        if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes[\"YZ\"];\n      }\n\n      if (axis == \"Z\") {\n        this.activePlane = this.planes[\"XZ\"];\n        if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes[\"YZ\"];\n      }\n\n      if (axis == \"XYZ\") this.activePlane = this.planes[\"XYZE\"];\n\n      if (axis == \"XY\") this.activePlane = this.planes[\"XY\"];\n\n      if (axis == \"YZ\") this.activePlane = this.planes[\"YZ\"];\n\n      if (axis == \"XZ\") this.activePlane = this.planes[\"XZ\"];\n\n      this.hide();\n      this.show();\n\n    };\n\n    this.init();\n\n  };\n\n  THREE.TransformGizmoTranslate.prototype = Object.create(THREE.TransformGizmo.prototype);\n\n  THREE.TransformGizmoRotate = function (includeAxis) {\n\n    THREE.TransformGizmo.call(this, includeAxis);\n\n    this.setHandlePickerGizmos = function () {\n\n      this.handleGizmos = {\n        RX: [\n        [new THREE.Line(createCircleGeometry(1, 'x', 0.5), new GizmoLineMaterial({ color: 0xff0000 }))]],\n\n        RY: [\n        [new THREE.Line(createCircleGeometry(1, 'y', 0.5), new GizmoLineMaterial({ color: 0x00ff00 }))]],\n\n        RZ: [\n        [new THREE.Line(createCircleGeometry(1, 'z', 0.5), new GizmoLineMaterial({ color: 0x0000ff }))]],\n\n        RE: [\n        [new THREE.Line(createCircleGeometry(1.25, 'z', 1), new GizmoLineMaterial({ color: 0x00ffff }))]],\n\n        RXYZE: [\n        [new THREE.Line(createCircleGeometry(1, 'z', 1), new GizmoLineMaterial({ color: 0xff00ff }))]] };\n\n\n\n      this.pickerGizmos = {\n        RX: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 4, 12, Math.PI), new GizmoMaterial({ color: 0xff0000, opacity: 0.25 })), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],\n\n        RY: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 4, 12, Math.PI), new GizmoMaterial({ color: 0x00ff00, opacity: 0.25 })), [0, 0, 0], [Math.PI / 2, 0, 0]]],\n\n        RZ: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 4, 12, Math.PI), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0], [0, 0, -Math.PI / 2]]],\n\n        RE: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1.25, 0.12, 2, 24), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 }))]],\n\n        RXYZE: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 2, 24), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 }))]] };\n\n\n\n    };\n\n    this.setActivePlane = function (axis) {\n\n      if (axis == \"RE\") this.activePlane = this.planes[\"XYZE\"];\n\n      if (axis == \"RX\") this.activePlane = this.planes[\"YZ\"];\n\n      if (axis == \"RY\") this.activePlane = this.planes[\"XZ\"];\n\n      if (axis == \"RZ\") this.activePlane = this.planes[\"XY\"];\n\n      this.hide();\n      this.show();\n\n    };\n\n    this.update = function (rotation, eye2) {\n\n      THREE.TransformGizmo.prototype.update.apply(this, arguments);\n\n      var tempMatrix = new THREE.Matrix4();\n      var worldRotation = new THREE.Euler(0, 0, 1);\n      var tempQuaternion = new THREE.Quaternion();\n      var unitX = new THREE.Vector3(1, 0, 0);\n      var unitY = new THREE.Vector3(0, 1, 0);\n      var unitZ = new THREE.Vector3(0, 0, 1);\n      var quaternionX = new THREE.Quaternion();\n      var quaternionY = new THREE.Quaternion();\n      var quaternionZ = new THREE.Quaternion();\n      var eye = eye2.clone();\n\n      worldRotation.copy(this.planes[\"XY\"].rotation);\n      tempQuaternion.setFromEuler(worldRotation);\n\n      tempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);\n      eye.applyMatrix4(tempMatrix);\n\n      this.traverse(function (child) {\n\n        tempQuaternion.setFromEuler(worldRotation);\n\n        if (child.name == \"RX\") {\n          quaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));\n          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);\n          child.quaternion.copy(tempQuaternion);\n        }\n\n        if (child.name == \"RY\") {\n          quaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));\n          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);\n          child.quaternion.copy(tempQuaternion);\n        }\n\n        if (child.name == \"RZ\") {\n          quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));\n          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);\n          child.quaternion.copy(tempQuaternion);\n        }\n\n      });\n\n    };\n\n    this.init();\n\n  };\n\n  THREE.TransformGizmoRotate.prototype = Object.create(THREE.TransformGizmo.prototype);\n\n  THREE.TransformGizmoTranslateRotate = function (includeAxis) {\n\n    THREE.TransformGizmo.call(this, includeAxis);\n\n    var scope = this;\n\n    this.setHandlePickerGizmos = function () {\n\n      var arrowGeometry = createArrowGeometry(0, 0.05, 0.2, 12, 1, false);\n      var lineGeometry = new THREE.Geometry();\n      lineGeometry.vertices.push(new THREE.Vector3(0, 0, -0.1), new THREE.Vector3(0, 0, 0.1), new THREE.Vector3(-0.1, 0, 0), new THREE.Vector3(0.1, 0, 0));\n      var theta = 0.15;\n\n      this.handleGizmos = {\n        Z: [\n        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xffffff })), [0, 0, 0.25], [Math.PI / 2, 0, 0]],\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.6, 4, 1, false), new GizmoMaterial({ color: 0xffffff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],\n\n        RX: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.015, 12, 60, theta * 2 * Math.PI), new GizmoMaterial({ color: 0xff0000 })), [0, 0, 0], [theta * Math.PI, -Math.PI / 2, 0]],\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.015, 60, 1, false), new GizmoMaterial({ color: 0xff0000 })), [0, 0, 1], [Math.PI / 2, 0, 0]]],\n\n        RY: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.015, 12, 60, theta * 2 * Math.PI), new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0], [Math.PI / 2, 0, (0.5 - theta) * Math.PI]],\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.01, 60, 1, false), new GizmoMaterial({ color: 0x0000ff })), [0, 0, 1]]] };\n\n\n\n      this.pickerGizmos = {\n        Z: [\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.65, 4, 1, false), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],\n\n        RX: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 4, 12, theta * 2 * Math.PI), new GizmoMaterial({ color: 0xff0000, opacity: 0.25 })), [0, 0, 0], [theta * Math.PI, -Math.PI / 2, 0]]],\n\n        RY: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 4, 12, theta * 2 * Math.PI), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0], [Math.PI / 2, 0, (0.5 - theta) * Math.PI]]] };\n\n\n\n      this.subPickerGizmos = {\n        Z: [\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.65, 4, 1, false), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0.5], [Math.PI / 2, 0, 0]]] };\n\n\n\n      this.highlightGizmos = {\n        Z: [],\n\n        RX: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.02, 12, 60, 2 * Math.PI), new GizmoMaterial({ color: 0xff0000, opacity: 1 })), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2], false]],\n\n        RY: [\n        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.02, 12, 60, 2 * Math.PI), new GizmoMaterial({ color: 0x0000ff, opacity: 1 })), [0, 0, 0], [Math.PI / 2, 0, 0], false]] };\n\n\n\n      this.hemiPickerGizmos = {\n        XYZ: [\n        [new THREE.Mesh(new THREE.SphereGeometry(1.2, 8, 8, 0, Math.PI), new GizmoMaterial({ color: 0x0000ff })), null, null, false]] };\n\n\n\n    };\n\n    this.setActivePlane = function (axis, eye) {\n\n      if (this.activeMode == \"translate\") {\n\n        var tempMatrix = new THREE.Matrix4();\n        eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes[\"XY\"].matrixWorld)));\n\n        if (axis == \"X\") {\n          this.activePlane = this.planes[\"XY\"];\n          if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes[\"XZ\"];\n        }\n\n        if (axis == \"Y\") {\n          this.activePlane = this.planes[\"XY\"];\n          if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes[\"YZ\"];\n        }\n\n        if (axis == \"Z\") {\n          this.activePlane = this.planes[\"XZ\"];\n          if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes[\"YZ\"];\n        }\n\n      } else if (this.activeMode == \"rotate\") {\n\n        if (axis == \"RX\") this.activePlane = this.planes[\"YZ\"];\n\n        if (axis == \"RY\") this.activePlane = this.planes[\"XZ\"];\n\n        if (axis == \"RZ\") this.activePlane = this.planes[\"XY\"];\n\n      }\n\n      this.hide();\n      this.show();\n\n    };\n\n    this.update = function (rotation, eye2) {\n\n      if (this.activeMode == \"translate\") {\n\n        THREE.TransformGizmo.prototype.update.apply(this, arguments);\n\n      } else if (this.activeMode == \"rotate\") {\n\n        THREE.TransformGizmo.prototype.update.apply(this, arguments);\n\n        var tempMatrix = new THREE.Matrix4();\n        var worldRotation = new THREE.Euler(0, 0, 1);\n        var tempQuaternion = new THREE.Quaternion();\n        var unitX = new THREE.Vector3(1, 0, 0);\n        var unitY = new THREE.Vector3(0, 1, 0);\n        var unitZ = new THREE.Vector3(0, 0, 1);\n        var quaternionX = new THREE.Quaternion();\n        var quaternionY = new THREE.Quaternion();\n        var quaternionZ = new THREE.Quaternion();\n        var eye = eye2.clone();\n\n        worldRotation.copy(this.planes[\"XY\"].rotation);\n        tempQuaternion.setFromEuler(worldRotation);\n\n        tempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);\n        eye.applyMatrix4(tempMatrix);\n\n        this.traverse(function (child) {\n\n          tempQuaternion.setFromEuler(worldRotation);\n\n          if (child.name == \"RX\") {\n            quaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));\n            tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);\n            child.quaternion.copy(tempQuaternion);\n          }\n\n          if (child.name == \"RY\") {\n            quaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));\n            tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);\n            child.quaternion.copy(tempQuaternion);\n          }\n\n          if (child.name == \"RZ\") {\n            quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));\n            tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);\n            child.quaternion.copy(tempQuaternion);\n          }\n\n        });\n\n      }\n\n    };\n\n    this.show = function () {\n      this.traverse(function (child) {\n        if (scope.parent == null || scope.parent.useAllPickers || child.parent != scope.handles) child.visible = true;\n        if (child.material) child.material.opacity = child.material.oldOpacity;\n        if (child.parent == scope.pickers || child.parent == scope.hemiPicker || child.parent == scope.subPickers) child.visible = false;\n        if (child.parent == scope.planes || child.parent == scope.highlights) child.visible = false;\n      });\n      this.activePlane.visible = false;\n    };\n\n    this.highlight = function (axis) {\n      this.traverse(function (child) {\n        if (child.material && child.material.highlight) {\n          if (child.name == axis) {\n            if (child.parent == scope.highlights || child.parent == scope.handles) child.visible = true;\n            child.material.highlight(true);\n          } else {\n            child.material.highlight(false);\n            child.material.opacity = 0.1;\n          }\n        }\n      });\n    };\n\n    this.init();\n\n  };\n\n  THREE.TransformGizmoTranslateRotate.prototype = Object.create(THREE.TransformGizmo.prototype);\n\n  THREE.TransformGizmoScale = function (includeAxis) {\n\n    THREE.TransformGizmo.call(this, includeAxis);\n\n    this.setHandlePickerGizmos = function () {\n\n      var arrowGeometry = createArrowGeometry(0.125, 0.125, 0.125);\n      var lineXGeometry = createLineGeometry('X');\n      var lineYGeometry = createLineGeometry('Y');\n      var lineZGeometry = createLineGeometry('Z');\n\n      this.handleGizmos = {\n        X: [\n        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]],\n        [new THREE.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))]],\n\n        Y: [\n        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]],\n        [new THREE.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))]],\n\n        Z: [\n        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]],\n        [new THREE.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))]],\n\n        XYZ: [\n        [new THREE.Mesh(new THREE.BoxGeometry(0.125, 0.125, 0.125), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))]] };\n\n\n\n      this.pickerGizmos = {\n        X: [\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0xff0000, opacity: 0.25 })), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],\n\n        Y: [\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0x00ff00, opacity: 0.25 })), [0, 0.6, 0]]],\n\n        Z: [\n        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],\n\n        XYZ: [\n        [new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))]] };\n\n\n\n    };\n\n    this.setActivePlane = function (axis, eye) {\n\n      var tempMatrix = new THREE.Matrix4();\n      eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes[\"XY\"].matrixWorld)));\n\n      if (axis == \"X\") {\n        this.activePlane = this.planes[\"XY\"];\n        if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes[\"XZ\"];\n      }\n\n      if (axis == \"Y\") {\n        this.activePlane = this.planes[\"XY\"];\n        if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes[\"YZ\"];\n      }\n\n      if (axis == \"Z\") {\n        this.activePlane = this.planes[\"XZ\"];\n        if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes[\"YZ\"];\n      }\n\n      if (axis == \"XYZ\") this.activePlane = this.planes[\"XYZE\"];\n\n      this.hide();\n      this.show();\n\n    };\n\n    this.init();\n\n  };\n\n  THREE.TransformGizmoScale.prototype = Object.create(THREE.TransformGizmo.prototype);\n\n  THREE.TransformControls = function (camera, domElement, mode, includeAxis) {\n\n    // TODO: Make non-uniform scale and rotate play nice in hierarchies\n    // TODO: ADD RXYZ contol\n\n    THREE.Object3D.call(this);\n\n    domElement = domElement !== undefined ? domElement : document;\n\n    this.gizmo = {};\n    switch (mode) {\n      case \"translate\":\n        this.gizmo[mode] = new THREE.TransformGizmoTranslate(includeAxis);\n        break;\n      case \"rotate\":\n        this.gizmo[mode] = new THREE.TransformGizmoRotate(includeAxis);\n        break;\n      case \"transrotate\":\n        this.gizmo[mode] = new THREE.TransformGizmoTranslateRotate(includeAxis);\n        break;\n      case \"scale\":\n        this.gizmo[mode] = new THREE.TransformGizmoScale(includeAxis);\n        break;}\n\n\n    this.add(this.gizmo[mode]);\n    this.gizmo[mode].hide();\n\n    this.object = undefined;\n    this.snap = null;\n    this.snapDelta = 0;\n    this.space = \"world\";\n    this.size = 1;\n    this.axis = null;\n    this.useAllPickers = true;\n\n    this.unitX = new THREE.Vector3(1, 0, 0);\n    this.unitY = new THREE.Vector3(0, 1, 0);\n    this.unitZ = new THREE.Vector3(0, 0, 1);\n    this.normal = new THREE.Vector3(0, 0, 1);\n\n    if (mode === \"transrotate\") {\n      var geometry = new THREE.Geometry();\n      geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1));\n      var material = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2, depthTest: false });\n      this.startLine = new THREE.Line(geometry, material);\n      var geometry = new THREE.Geometry();\n      var material = new THREE.LineBasicMaterial({ color: 0xffe603, linewidth: 2, depthTest: false });\n      geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1));\n      this.endLine = new THREE.Line(geometry, material);\n      var geometry = new THREE.Geometry();\n      var material = new THREE.LineDashedMaterial({ color: 0x000000, linewidth: 1, depthTest: false });\n      geometry.vertices.push(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 1, 0));\n      this.centerLine = new THREE.Line(geometry, material);\n\n      var map = THREE.ImageUtils.loadTexture(Autodesk.Viewing.Private.getResourceUrl(\"res/textures/centerMarker_X.png\"));\n      map.magFilter = map.minFilter = THREE.NearestFilter;\n      var geometry = new THREE.CircleGeometry(0.1, 32);\n      var material = new THREE.MeshBasicMaterial({ opacity: 1, side: THREE.DoubleSide, transparent: true, map: map });\n      this.centerMark = new THREE.Mesh(geometry, material);\n      this.centerMark.rotation.set(Math.PI / 2, 0, 0);\n\n      this.ticks = {};\n      var map = THREE.ImageUtils.loadTexture(Autodesk.Viewing.Private.getResourceUrl(\"res/textures/cardinalPoint.png\"));\n      map.magFilter = map.minFilter = THREE.NearestFilter;\n      var material = new THREE.MeshBasicMaterial({ depthTest: false, opacity: 1, transparent: true, side: THREE.DoubleSide, map: map });\n      var w = 0.12,h = 0.25,d = 1.15;\n\n      this.ticks[\"RX\"] = new THREE.Object3D();\n      var geometry = new THREE.PlaneBufferGeometry(w, h);\n      var mesh = new THREE.Mesh(geometry, material);\n      mesh.position.set(0, 0, -d - h / 2);\n      mesh.rotation.set(Math.PI / 2, Math.PI / 2, 0);\n      this.ticks[\"RX\"].add(mesh);\n\n      mesh = mesh.clone();\n      mesh.position.set(0, d + h / 2, 0);\n      mesh.rotation.set(0, Math.PI / 2, 0);\n      this.ticks[\"RX\"].add(mesh);\n\n      mesh = mesh.clone();\n      mesh.position.set(0, 0, d + h / 2);\n      mesh.rotation.set(0, Math.PI / 2, Math.PI / 2);\n      this.ticks[\"RX\"].add(mesh);\n\n      mesh = mesh.clone();\n      mesh.position.set(0, -d - h / 2, 0);\n      mesh.rotation.set(0, Math.PI / 2, 0);\n      this.ticks[\"RX\"].add(mesh);\n\n      this.ticks[\"RY\"] = new THREE.Object3D();\n      mesh = mesh.clone();\n      mesh.position.set(0, 0, -d - h / 2);\n      mesh.rotation.set(Math.PI / 2, 0, 0);\n      this.ticks[\"RY\"].add(mesh);\n\n      mesh = mesh.clone();\n      mesh.position.set(-d - h / 2, 0, 0);\n      mesh.rotation.set(Math.PI / 2, 0, Math.PI / 2);\n      this.ticks[\"RY\"].add(mesh);\n\n      mesh = mesh.clone();\n      mesh.position.set(0, 0, d + h / 2);\n      mesh.rotation.set(Math.PI / 2, 0, 0);\n      this.ticks[\"RY\"].add(mesh);\n\n      mesh = mesh.clone();\n      mesh.position.set(d + h / 2, 0, 0);\n      mesh.rotation.set(Math.PI / 2, 0, Math.PI / 2);\n      this.ticks[\"RY\"].add(mesh);\n    }\n\n    var scope = this;\n\n    var _dragging = false;\n    var _mode = mode;\n    var _plane = \"XY\";\n\n    var changeEvent = { type: \"change\" };\n    var mouseDownEvent = { type: \"mouseDown\" };\n    var mouseUpEvent = { type: \"mouseUp\", mode: _mode };\n    var objectChangeEvent = { type: \"objectChange\" };\n\n    var ray = new THREE.Raycaster();\n    var pointerVector = new THREE.Vector3();\n    var pointerDir = new THREE.Vector3();\n\n    var point = new THREE.Vector3();\n    var offset = new THREE.Vector3();\n\n    var rotation = new THREE.Vector3();\n    var offsetRotation = new THREE.Vector3();\n    var scale = 1;\n    this.clientScale = 1;\n\n    var lookAtMatrix = new THREE.Matrix4();\n    var eye = new THREE.Vector3();\n\n    var tempMatrix = new THREE.Matrix4();\n    var tempVector = new THREE.Vector3();\n    var tempQuaternion = new THREE.Quaternion();\n    var projX = new THREE.Vector3();\n    var projY = new THREE.Vector3();\n    var projZ = new THREE.Vector3();\n\n    var quaternionXYZ = new THREE.Quaternion();\n    var quaternionX = new THREE.Quaternion();\n    var quaternionY = new THREE.Quaternion();\n    var quaternionZ = new THREE.Quaternion();\n    var quaternionE = new THREE.Quaternion();\n\n    var oldPosition = new THREE.Vector3();\n    var oldScale = new THREE.Vector3();\n    var oldRotationMatrix = new THREE.Matrix4();\n\n    var parentRotationMatrix = new THREE.Matrix4();\n    var parentScale = new THREE.Vector3();\n\n    var worldPosition = new THREE.Vector3();\n    var worldRotation = new THREE.Euler();\n    var worldRotationMatrix = new THREE.Matrix4();\n    var camPosition = new THREE.Vector3();\n    var camRotation = new THREE.Euler();\n\n    this.attach = function (object) {\n\n      scope.object = object;\n\n      this.gizmo[_mode].show();\n\n      scope.update();\n\n      scope.updateUnitVectors();\n\n    };\n\n    this.detach = function (object) {\n\n      scope.object = undefined;\n      this.axis = null;\n\n      this.gizmo[_mode].hide();\n\n    };\n\n    this.setMode = function (mode) {\n\n      _mode = mode ? mode : _mode;\n\n      if (_mode == \"scale\") scope.space = \"local\";\n\n      this.gizmo[_mode].show();\n\n      this.update();\n      scope.dispatchEvent(changeEvent);\n\n    };\n\n    this.getPicker = function () {\n\n      return scope.gizmo[_mode].hemiPicker.children;\n\n    };\n\n    this.setPosition = function (position) {\n\n      this.object.position.copy(position);\n      this.update();\n\n    };\n\n    this.setNormal = function (normal) {\n\n      tempQuaternion.setFromUnitVectors(this.normal, normal);\n      this.unitX.applyQuaternion(tempQuaternion);\n      this.unitY.applyQuaternion(tempQuaternion);\n      this.unitZ.applyQuaternion(tempQuaternion);\n      this.normal.copy(normal);\n      if (this.object) {\n        this.object.quaternion.multiply(tempQuaternion);\n      }\n      this.update();\n    };\n\n    this.setRotation = function (rotationMatrix) {\n      if (this.object) {\n        this.object.quaternion.setFromRotationMatrix(rotationMatrix);\n        this.update();\n        this.updateUnitVectors();\n      }\n    };\n\n    this.setSnap = function (snap, delta) {\n\n      scope.snap = snap;\n      scope.snapDelta = delta;\n\n    };\n\n    this.setSize = function (size) {\n\n      scope.size = size;\n      this.update();\n      scope.dispatchEvent(changeEvent);\n\n    };\n\n    this.setSpace = function (space) {\n\n      scope.space = space;\n      this.update();\n      scope.dispatchEvent(changeEvent);\n\n    };\n\n    this.update = function (highlight) {\n\n      if (scope.object === undefined) return;\n\n      scope.object.updateMatrixWorld();\n      worldPosition.setFromMatrixPosition(scope.object.matrixWorld);\n      worldRotation.setFromRotationMatrix(tempMatrix.extractRotation(scope.object.matrixWorld));\n\n      camera.updateMatrixWorld();\n      camPosition.setFromMatrixPosition(camera.matrixWorld);\n      //camRotation.setFromRotationMatrix( tempMatrix.extractRotation( camera.matrixWorld ) );\n\n      this.position.copy(worldPosition);\n\n      this.quaternion.setFromEuler(worldRotation);\n\n      this.normal.set(0, 0, 1);\n      this.normal.applyEuler(worldRotation);\n\n      // keep same screen height (100px)\n      var height;\n      if (camera.isPerspective) {\n        var dist = worldPosition.distanceTo(camPosition);\n        height = 2 * Math.tan(camera.fov * Math.PI / 360) * dist;\n      } else {\n        // orthographic, so the world height is simply top minus bottom\n        height = camera.top - camera.bottom;\n      }\n      var rect = domElement.getBoundingClientRect();\n      // multiply 100 pixels by world height for the window, divide by window height in pixels,\n      // to get world height equivalent to 100 pixels.\n      scale = this.clientScale * 100 * height / rect.height;\n      this.scale.set(scale, scale, scale);\n\n      // Set the gizmo position with the specified offset.\n      if (this.gizmoOffset) {\n        this.position.add(this.gizmoOffset);\n      }\n      this.updateMatrixWorld();\n      //eye.copy( camPosition ).sub( worldPosition ).normalize();\n\n      //if ( scope.space == \"local\" )\n      //    this.gizmo[_mode].update( worldRotation, eye );\n      //else if ( scope.space == \"world\" )\n      //    this.gizmo[_mode].update( new THREE.Euler(), eye );\n\n      if (highlight)\n      this.gizmo[_mode].highlight(scope.axis);\n\n    };\n\n    this.setGizmoOffset = function (vec) {\n      // Reset the gizmo if no vector passed in.\n      this.gizmoOffset = !vec ? new THREE.Vector3(0, 0, 0) : vec;\n      this.update();\n    };\n\n    this.updateUnitVectors = function () {\n\n      this.unitX.set(1, 0, 0);\n      this.unitY.set(0, 1, 0);\n      this.unitZ.set(0, 0, 1);\n      this.unitX.applyEuler(worldRotation);\n      this.unitY.applyEuler(worldRotation);\n      this.unitZ.applyEuler(worldRotation);\n\n    };\n\n    this.showRotationGizmos = function (set) {\n\n      var handles = this.gizmo[_mode].handles.children;\n      for (var i = 0; i < handles.length; i++) {\n        var child = handles[i];\n        child.visible = true;\n        if (child.name.search(\"R\") !== -1) child.visible = set;\n      }\n      this.useAllPickers = set;\n\n    };\n\n    this.highlight = function () {\n\n      this.gizmo[_mode].highlight(this.axis || \"Z\");\n\n    };\n\n    this.onPointerHover = function (event) {\n\n      if (scope.object === undefined || _dragging === true) return false;\n\n      var pointer = event;\n\n      var intersect = intersectObjects(pointer, scope.useAllPickers ? scope.gizmo[_mode].pickers.children : scope.gizmo[_mode].subPickers.children);\n\n      var axis = null;\n      var mode = \"\";\n\n      if (intersect) {\n\n        axis = intersect.object.name;\n        mode = axis.search(\"R\") != -1 ? \"rotate\" : \"translate\";\n\n      }\n\n      if (scope.axis !== axis) {\n\n        scope.axis = axis;\n        scope.gizmo[_mode].activeMode = mode;\n        scope.update(true);\n        scope.dispatchEvent(changeEvent);\n\n      }\n\n      if (scope.axis === null) {\n\n        scope.gizmo[_mode].show();\n\n      }\n\n      return intersect ? true : false;\n\n    };\n\n    this.isDragging = function () {\n      return _dragging;\n    };\n\n    this.onPointerDown = function (event) {\n\n      if (scope.object === undefined || _dragging === true) return false;\n\n      var pointer = event;\n\n      if (event.pointerType === 'touch') {\n\n        var intersect = intersectObjects(pointer, scope.useAllPickers ? scope.gizmo[_mode].pickers.children : scope.gizmo[_mode].subPickers.children);\n\n        var axis = null;\n        var mode = \"\";\n\n        if (intersect) {\n\n          axis = intersect.object.name;\n          mode = axis.search(\"R\") != -1 ? \"rotate\" : \"translate\";\n\n        }\n\n        if (scope.axis !== axis) {\n\n          scope.axis = axis;\n          scope.gizmo[_mode].activeMode = mode;\n        }\n      }\n\n      var intersect = null;\n\n      if (pointer.button === 0 || pointer.button === -1 || pointer.button === undefined) {\n\n        intersect = intersectObjects(pointer, scope.useAllPickers ? scope.gizmo[_mode].pickers.children : scope.gizmo[_mode].subPickers.children);\n\n        if (intersect) {\n\n          scope.dispatchEvent(mouseDownEvent);\n\n          scope.axis = intersect.object.name;\n\n          scope.update();\n\n          eye.copy(camera.position).sub(worldPosition).normalize();\n\n          scope.gizmo[_mode].setActivePlane(scope.axis, eye);\n\n          var planeIntersect = intersectObjects(pointer, [scope.gizmo[_mode].activePlane]);\n\n          if (planeIntersect)\n          offset.copy(planeIntersect.point);\n\n          oldPosition.copy(scope.object.position);\n          oldScale.copy(scope.object.scale);\n\n          oldRotationMatrix.extractRotation(scope.object.matrix);\n          worldRotationMatrix.extractRotation(scope.object.matrixWorld);\n\n          if (scope.object.parent) {\n            parentRotationMatrix.extractRotation(scope.object.parent.matrixWorld);\n            parentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.parent.matrixWorld));\n          } else {\n            parentRotationMatrix.extractRotation(scope.object.matrixWorld);\n            parentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.matrixWorld));\n          }\n\n          // show rotation start line and ticks\n          if (_mode === \"transrotate\" && scope.gizmo[_mode].activeMode === \"rotate\") {\n            scope.startLine.geometry.vertices[0].set(0, 0, 0).applyMatrix4(scope.matrixWorld);\n            scope.startLine.geometry.vertices[1].set(0, 0, 1).applyMatrix4(scope.matrixWorld);\n            scope.startLine.geometry.verticesNeedUpdate = true;\n            scope.parent.add(scope.startLine);\n\n            var pos = scope.object.geometry.getAttribute('position');\n            var pt1 = new THREE.Vector3().fromAttribute(pos, 0).applyMatrix4(scope.object.matrixWorld);\n            var pt2 = new THREE.Vector3().fromAttribute(pos, 1).applyMatrix4(scope.object.matrixWorld);\n            var pt3 = new THREE.Vector3().fromAttribute(pos, 2).applyMatrix4(scope.object.matrixWorld);\n            var pt4 = new THREE.Vector3().fromAttribute(pos, 3).applyMatrix4(scope.object.matrixWorld);\n            if (scope.axis === \"RX\") {\n              pt1.lerp(pt3, 0.5);\n              pt2.lerp(pt4, 0.5);\n              var dist = pt1.distanceTo(pt2);\n              scope.centerLine.material.dashSize = dist / 15;\n              scope.centerLine.material.gapSize = dist / 30;\n              scope.centerLine.geometry.vertices[0].copy(pt1);\n              scope.centerLine.geometry.vertices[1].copy(pt2);\n            } else {\n              pt1.lerp(pt2, 0.5);\n              pt3.lerp(pt4, 0.5);\n              var dist = pt1.distanceTo(pt3);\n              scope.centerLine.material.dashSize = dist / 15;\n              scope.centerLine.material.gapSize = dist / 30;\n              scope.centerLine.geometry.vertices[0].copy(pt1);\n              scope.centerLine.geometry.vertices[1].copy(pt3);\n            }\n            scope.centerLine.geometry.computeLineDistances();\n            scope.centerLine.geometry.verticesNeedUpdate = true;\n            scope.parent.add(scope.centerLine);\n\n            scope.ticks[scope.axis].position.copy(scope.position);\n            scope.ticks[scope.axis].quaternion.copy(scope.quaternion);\n            scope.ticks[scope.axis].scale.copy(scope.scale);\n            scope.parent.add(scope.ticks[scope.axis]);\n          }\n\n        }\n\n      }\n\n      _dragging = true;\n\n      return intersect ? true : false;\n\n    };\n\n    this.onPointerMove = function (event) {\n\n      if (scope.object === undefined || scope.axis === null || _dragging === false) return false;\n\n      var pointer = event;\n\n      var planeIntersect = intersectObjects(pointer, [scope.gizmo[_mode].activePlane]);\n\n      if (planeIntersect)\n      point.copy(planeIntersect.point);\n\n      var mode = scope.gizmo[_mode].activeMode;\n      if (mode == \"translate\") {\n\n        point.sub(offset);\n        point.multiply(parentScale);\n\n        if (scope.space == \"local\") {\n\n          point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n          if (scope.axis.search(\"X\") == -1) point.x = 0;\n          if (scope.axis.search(\"Y\") == -1) point.y = 0;\n          if (scope.axis.search(\"Z\") == -1) point.z = 0;\n\n          point.applyMatrix4(oldRotationMatrix);\n\n          scope.object.position.copy(oldPosition);\n          scope.object.position.add(point);\n\n        }\n\n        if (scope.space == \"world\" || scope.axis.search(\"XYZ\") != -1) {\n\n          projX.copy(this.unitX);\n          projY.copy(this.unitY);\n          projZ.copy(this.unitZ);\n          tempVector.set(0, 0, 0);\n          if (scope.axis.search(\"X\") != -1) {\n            projX.multiplyScalar(point.dot(this.unitX));\n            tempVector.add(projX);\n          }\n          if (scope.axis.search(\"Y\") != -1) {\n            projY.multiplyScalar(point.dot(this.unitY));\n            tempVector.add(projY);\n          }\n          if (scope.axis.search(\"Z\") != -1) {\n            projZ.multiplyScalar(point.dot(this.unitZ));\n            tempVector.add(projZ);\n          }\n          point.copy(tempVector);\n\n          point.applyMatrix4(tempMatrix.getInverse(parentRotationMatrix));\n\n          scope.object.position.copy(oldPosition);\n          scope.object.position.add(point);\n\n        }\n\n      } else if (mode == \"scale\") {\n\n        point.sub(offset);\n        point.multiply(parentScale);\n\n        if (scope.space == \"local\") {\n\n          if (scope.axis == \"XYZ\") {\n\n            scale = 1 + point.y / 50;\n\n            scope.object.scale.x = oldScale.x * scale;\n            scope.object.scale.y = oldScale.y * scale;\n            scope.object.scale.z = oldScale.z * scale;\n\n          } else {\n\n            point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n            if (scope.axis == \"X\") scope.object.scale.x = oldScale.x * (1 + point.x / 50);\n            if (scope.axis == \"Y\") scope.object.scale.y = oldScale.y * (1 + point.y / 50);\n            if (scope.axis == \"Z\") scope.object.scale.z = oldScale.z * (1 + point.z / 50);\n\n          }\n\n        }\n\n      } else if (mode == \"rotate\") {\n\n        point.sub(worldPosition);\n        point.multiply(parentScale);\n        tempVector.copy(offset).sub(worldPosition);\n        tempVector.multiply(parentScale);\n\n        if (scope.axis == \"RE\") {\n\n          point.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));\n          tempVector.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));\n\n          rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));\n          offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));\n\n          tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));\n\n          var rotz = rotation.z - offsetRotation.z;\n          if (scope.snap !== null) {\n            var rotsnap = Math.round(rotz / scope.snap) * scope.snap;\n            if (Math.abs(rotsnap - rotz) < scope.snapDelta) {\n              rotz = rotsnap;\n            }\n          }\n          quaternionE.setFromAxisAngle(eye, rotz);\n          quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);\n\n          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionE);\n          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);\n\n          scope.object.quaternion.copy(tempQuaternion);\n\n        } else if (scope.axis == \"RXYZE\") {\n\n          var tempAxis = point.clone().cross(tempVector).normalize(); // rotation axis\n\n          tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));\n\n          var rot = -point.clone().angleTo(tempVector);\n          if (scope.snap !== null) {\n            var rotsnap = Math.round(rot / scope.snap) * scope.snap;\n            if (Math.abs(rotsnap - rot) < scope.snapDelta) {\n              rot = rotsnap;\n            }\n          }\n          quaternionX.setFromAxisAngle(tempAxis, rot);\n          quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);\n\n          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);\n          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);\n\n          scope.object.quaternion.copy(tempQuaternion);\n\n        } else if (scope.space == \"local\") {\n\n          point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n          tempVector.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n          var projx = point.dot(this.unitX),projy = point.dot(this.unitY),projz = point.dot(this.unitZ);\n          var tempx = tempVector.dot(this.unitX),tempy = tempVector.dot(this.unitY),tempz = tempVector.dot(this.unitZ);\n          rotation.set(Math.atan2(projz, projy), Math.atan2(projx, projz), Math.atan2(projy, projx));\n          offsetRotation.set(Math.atan2(tempz, tempy), Math.atan2(tempx, tempz), Math.atan2(tempy, tempx));\n\n          var rotx = rotation.x - offsetRotation.x;\n          var roty = rotation.y - offsetRotation.y;\n          var rotz = rotation.z - offsetRotation.z;\n          if (scope.snap !== null) {\n            if (scope.axis.search(\"X\") != -1) {\n              var rotsnap = Math.round(rotx / scope.snap) * scope.snap;\n              if (Math.abs(rotsnap - rotx) < scope.snapDelta) {\n                rotx = rotsnap;\n              }\n            }\n            if (scope.axis.search(\"Y\") != -1) {\n              var rotsnap = Math.round(roty / scope.snap) * scope.snap;\n              if (Math.abs(rotsnap - roty) < scope.snapDelta) {\n                roty = rotsnap;\n              }\n            }\n            if (scope.axis.search(\"Z\") != -1) {\n              var rotsnap = Math.round(rotz / scope.snap) * scope.snap;\n              if (Math.abs(rotsnap - rotz) < scope.snapDelta) {\n                rotz = rotsnap;\n              }\n            }\n          }\n          quaternionX.setFromAxisAngle(this.unitX, rotx);\n          quaternionY.setFromAxisAngle(this.unitY, roty);\n          quaternionZ.setFromAxisAngle(this.unitZ, rotz);\n          quaternionXYZ.setFromRotationMatrix(oldRotationMatrix);\n\n          if (scope.axis == \"RX\") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionX);\n          if (scope.axis == \"RY\") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionY);\n          if (scope.axis == \"RZ\") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionZ);\n\n          scope.object.quaternion.copy(quaternionXYZ);\n\n        } else if (scope.space == \"world\") {\n\n          var projx = point.dot(this.unitX),projy = point.dot(this.unitY),projz = point.dot(this.unitZ);\n          var tempx = tempVector.dot(this.unitX),tempy = tempVector.dot(this.unitY),tempz = tempVector.dot(this.unitZ);\n          rotation.set(Math.atan2(projz, projy), Math.atan2(projx, projz), Math.atan2(projy, projx));\n          offsetRotation.set(Math.atan2(tempz, tempy), Math.atan2(tempx, tempz), Math.atan2(tempy, tempx));\n\n          tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));\n\n          var rotx = rotation.x - offsetRotation.x;\n          var roty = rotation.y - offsetRotation.y;\n          var rotz = rotation.z - offsetRotation.z;\n          if (scope.snap !== null) {\n            if (scope.axis.search(\"X\") != -1) {\n              var rotsnap = Math.round(rotx / scope.snap) * scope.snap;\n              if (Math.abs(rotsnap - rotx) < scope.snapDelta) {\n                rotx = rotsnap;\n              }\n            }\n            if (scope.axis.search(\"Y\") != -1) {\n              var rotsnap = Math.round(roty / scope.snap) * scope.snap;\n              if (Math.abs(rotsnap - roty) < scope.snapDelta) {\n                roty = rotsnap;\n              }\n            }\n            if (scope.axis.search(\"Z\") != -1) {\n              var rotsnap = Math.round(rotz / scope.snap) * scope.snap;\n              if (Math.abs(rotsnap - rotz) < scope.snapDelta) {\n                rotz = rotsnap;\n              }\n            }\n          }\n          quaternionX.setFromAxisAngle(this.unitX, rotx);\n          quaternionY.setFromAxisAngle(this.unitY, roty);\n          quaternionZ.setFromAxisAngle(this.unitZ, rotz);\n          quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);\n\n          if (scope.axis == \"RX\") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);\n          if (scope.axis == \"RY\") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);\n          if (scope.axis == \"RZ\") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);\n\n          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);\n\n          scope.object.quaternion.copy(tempQuaternion);\n\n        }\n\n        // show rotation end line\n        if (_mode === \"transrotate\") {\n          scope.add(scope.endLine);\n          scope.add(scope.centerMark);\n        }\n\n      }\n\n      // update matrix\n      scope.object.matrixAutoUpdate = true;\n\n      scope.update(true);\n      scope.dispatchEvent(changeEvent);\n      scope.dispatchEvent(objectChangeEvent);\n\n      return planeIntersect ? true : false;\n\n    };\n\n    this.onPointerUp = function (event) {\n\n      if (_dragging && scope.axis !== null) {\n        mouseUpEvent.mode = _mode;\n        scope.dispatchEvent(mouseUpEvent);\n      }\n      _dragging = false;\n\n      this.gizmo[_mode].show();\n\n      this.updateUnitVectors();\n\n      // remove rotation start/end lines\n      if (_mode === \"transrotate\" && this.gizmo[_mode].activeMode === \"rotate\") {\n        this.remove(this.endLine);\n        this.remove(this.centerMark);\n        this.parent.remove(this.centerLine);\n        this.parent.remove(this.startLine);\n        this.parent.remove(this.ticks[this.axis]);\n      }\n\n      return false;\n\n    };\n\n    function intersectObjects(pointer, objects) {\n      return THREE.TransformControls.intersectObjects(pointer.canvasX, pointer.canvasY, objects, camera, true);\n    }\n  };\n\n  THREE.TransformControls.intersectObjects = function () {\n\n    var pointerVector = new THREE.Vector3();\n    var pointerDir = new THREE.Vector3();\n    var ray = new THREE.Raycaster();\n\n    return function (clientX, clientY, objects, camera, recursive) {\n\n      // Convert client to viewport coords (in [-1,1]^2)\n      var x = clientX / camera.clientWidth * 2 - 1;\n      var y = -(clientY / camera.clientHeight) * 2 + 1; // y-direction flips between canvas and viewport coords\n\n      if (camera.isPerspective) {\n        pointerVector.set(x, y, 0.5);\n        pointerVector.unproject(camera);\n        ray.set(camera.position, pointerVector.sub(camera.position).normalize());\n      } else {\n        pointerVector.set(x, y, -1);\n        pointerVector.unproject(camera);\n        pointerDir.set(0, 0, -1);\n        ray.set(pointerVector, pointerDir.transformDirection(camera.matrixWorld));\n      }\n\n      var intersections = ray.intersectObjects(objects, recursive);\n      return intersections[0] ? intersections[0] : null;\n    };\n  }();\n\n  THREE.TransformControls.prototype = Object.create(THREE.Object3D.prototype);\n\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5jDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxFA;AACA;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;AC3qBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}