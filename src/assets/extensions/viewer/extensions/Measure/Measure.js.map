{"version":3,"file":"Measure/Measure.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Measure/Calibration.css?c2b7","webpack://Autodesk.Extensions.[name]/./extensions/Measure/CalibrationPanels.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/CalibrationTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/CalibrationToolIndicator.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/Indicator.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/MagnifyingGlass.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/Measure.css?7049","webpack://Autodesk.Extensions.[name]/./extensions/Measure/Measure.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/MeasureTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/MeasureToolIndicator.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/MeasureToolbar.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/MeasurementsManager.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/PolygonCentroid.js","webpack://Autodesk.Extensions.[name]/./extensions/Measure/res/icon-spinner-sm.svg","webpack://Autodesk.Extensions.[name]/./extensions/Measure/Calibration.css","webpack://Autodesk.Extensions.[name]/./extensions/Measure/Measure.css","webpack://Autodesk.Extensions.[name]/./node_modules/css-loader/lib/css-base.js","webpack://Autodesk.Extensions.[name]/./node_modules/css-loader/lib/url/escape.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/addStyles.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/urls.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/Measure/Measure.js\");\n","\nvar content = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Calibration.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Calibration.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Calibration.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","\n\n\"use strict\";function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\nvar av = Autodesk.Viewing,\nave = Autodesk.Viewing.Extensions,\navp = Autodesk.Viewing.Private,\navu = Autodesk.Viewing.UI,\nMeasureCommon = Autodesk.Viewing.MeasureCommon;\n\n// This strange code is there because we \n// don't want DockingPanel, which is used as a base class later\n// to be undefined during headless mode.\n// Simply deriving from undefined will cause an exception (from babel env preset) \n// even if the class is never instantiated\nvar DockingPanel = avu && avu.DockingPanel || /*#__PURE__*/function () {function _class() {_classCallCheck(this, _class);}return _class;}();\n// et ViewerPanelMixin to a no-op in headless mode\nvar ViewerPanelMixin = ave && ave.ViewerPanelMixin || function () {};\n\nvar _gWindow = av.getGlobal();\nvar _gDocument = _gWindow.document;\n\n//\n// /** @constructor */\n//\n//\nexport var CalibrationPanel = function CalibrationPanel(calibrationTool, viewer, id, title, options)\n{\n  var self = this;\n\n  options = options || {};\n  options.addFooter = false;\n\n  DockingPanel.call(this, viewer.container, id, title, options);\n\n  this.viewer = viewer;\n  this.calibrationTool = calibrationTool;\n  this.parentContainer = viewer.container;\n  this.container.style.left = '0px';\n  this.container.style.top = '0px';\n  this.container.style.resize = 'none';\n\n  this.container.classList.add('calibration-panel');\n\n  this.setGlobalManager && this.setGlobalManager(viewer.globalManager);\n\n  this.addEventListener(this.closer, \"click\", function (e) {\n    self.setVisible(false);\n    self.calibrationTool.clearSize();\n    self.calibrationTool.showAddCalibrationLabel();\n  });\n\n  if (!options.heightAdjustment)\n  options.heightAdjustment = 40;\n  if (!options.marginTop)\n  options.marginTop = 0;\n  options.left = false;\n\n  this.createScrollContainer(options);\n\n  var _document = this.getDocument && this.getDocument() || _gDocument;\n\n  this.calibrationMenu = _document.createElement(\"div\");\n\n  this.scrollContainer.appendChild(this.calibrationMenu);\n\n  // Table\n  this.table = _document.createElement(\"table\");\n  this.table.className = \"adsk-lmv-tftable calibration-table\";\n  this.tbody = _document.createElement(\"tbody\");\n  this.table.appendChild(this.tbody);\n  this.calibrationMenu.appendChild(this.table);\n\n  // Define Size Row\n  this.row = this.tbody.insertRow(0);\n  this.requestedSizeTextbox = _document.createElement('input');\n  this.requestedSizeTextbox.className = 'docking-panel-textbox';\n  this.requestedSizeTextbox.type = 'text';\n  this.requestedSizeTextbox.autofocus = 'true';\n\n  this.addEventListener(this.requestedSizeTextbox, \"keyup\", function (e) {\n    var value = self.requestedSizeTextbox.value;\n    if (value !== \"\" && value.split(\".\")[0] === \"\") {\n      self.requestedSizeTextbox.value = \"0\" + value;\n    }\n    self.updateLabel();\n  });\n\n\n  this.addEventListener(this.requestedSizeTextbox, \"keypress\", function (e) {\n    var key = e.key || String.fromCharCode(e.keyCode);\n    // Handling backspace and arrows for firefox\n    if (key == \"Backspace\" || key == \"ArrowLeft\" || key == \"ArrowRight\") {\n      return;\n    }\n\n    // Escape (For IE11)\n    if (e.keyCode == av.KeyCode.ESCAPE) {\n      self.setVisible(false);\n      self.calibrationTool.clearSize();\n      self.calibrationTool.showAddCalibrationLabel();\n      return;\n    }\n\n    var requestedSize = self.requestedSizeTextbox.value;\n    var cursorIndex = self.requestedSizeTextbox.selectionStart;\n    requestedSize = [requestedSize.slice(0, cursorIndex), key, requestedSize.slice(cursorIndex)].join('');\n\n    if (requestedSize == \".\") {\n      return;\n    }\n\n    var isSimple = self.units[self.unitList.selectedIndex].simpleInput;\n\n    if (!isPositiveNumber(requestedSize) || isSimple && (!isSimpleDecimal(requestedSize) || Autodesk.Viewing.Private.calculatePrecision(requestedSize) > self.calibrationTool.getMaxPrecision())) {\n      e.preventDefault();\n    }\n  });\n\n  var caption = \"Define Size\";\n  var cell = this.row.insertCell(0);\n  this.caption = _document.createElement(\"div\");\n  this.caption.setAttribute(\"data-i18n\", caption);\n  this.caption.textContent = av.i18n.translate(caption);\n  cell.appendChild(this.caption);\n\n  cell = this.row.insertCell(1);\n  cell.appendChild(this.requestedSizeTextbox);\n\n  // Unit Type Row\n  this.units = [\n  { name: 'Feet and fractional inches', units: 'ft-and-fractional-in', matches: ['ft-and-fractional-in', 'fractional-in'], simpleInput: false },\n  { name: 'Feet and decimal inches', units: 'ft-and-decimal-in', matches: ['ft', 'decimal-ft', 'in', 'decimal-in', 'ft-and-decimal-in'], simpleInput: false },\n  { name: 'Meters', units: 'm', matches: ['m', 'm-and-cm'], simpleInput: true },\n  { name: 'Centimeters', units: 'cm', matches: ['cm'], simpleInput: true },\n  { name: 'Millimeters', units: 'mm', matches: ['mm'], simpleInput: true }];\n\n\n  var unitNames = [];\n  for (var i = 0; i < this.units.length; ++i) {\n    unitNames.push(this.units[i].name);\n  }\n  this.unitList = new avp.OptionDropDown(\"Unit type\", this.tbody, unitNames, 0, null, { paddingLeft: 0, paddingRight: 15 });\n  this.unitList.setGlobalManager(this.globalManager);\n  this.addEventListener(this.unitList, \"change\", function (e) {\n    self.updateLabel();\n  });\n\n  // Set Calibration button\n  var setCalibration = _document.createElement('div');\n  setCalibration.classList.add('docking-panel-primary-button');\n  setCalibration.classList.add('calibration-button');\n\n  setCalibration.setAttribute(\"data-i18n\", \"Set Calibration\");\n  setCalibration.textContent = av.i18n.translate(\"Set Calibration\");\n\n  setCalibration.addEventListener('click', function () {\n    var index = self.unitList.selectedIndex;\n    var requestedUnits = self.units[index].units;\n    self.calibrationTool.calibrate(requestedUnits, self.requestedSizeTextbox.value);\n  }, false);\n\n  this.calibrationMenu.appendChild(setCalibration);\n\n\n}; // end constructor\n\nvar isPositiveNumber = function isPositiveNumber(n) {\n  // The first character of the string has to be a digit.\n  return n.match(/^(\\d+)/);\n};\n\nvar isSimpleDecimal = function isSimpleDecimal(n) {\n  // Add \"0\" to the end of the string, to check if there are trailing spaces.\n  n += '0';\n  return !isNaN(parseFloat(n)) && !isNaN(+n) && parseFloat(n) >= 0;\n};\n\nCalibrationPanel.prototype = Object.create(DockingPanel.prototype);\nViewerPanelMixin.call(CalibrationPanel.prototype);\n\n\nCalibrationPanel.prototype.uninitialize = function uninitialize() {\n  this.viewer = null;\n  DockingPanel.prototype.uninitialize.call(this);\n};\n\nCalibrationPanel.prototype.findUnits = function findUnits() {\n  var i,\n  j,\n  selectedUnits = this.calibrationTool.getCurrentUnits();\n  for (i = 0; i < this.units.length; ++i) {\n    var matches = this.units[i].matches;\n    if (matches) {\n      for (j = 0; j < matches.length; ++j) {\n        if (matches[j] === selectedUnits) {\n          return i;\n        }\n      }\n    }\n  }\n  return 0;\n};\n\nCalibrationPanel.prototype.setPanelValue = function (size) {\n  this.updateUnits();\n  this.requestedSizeTextbox.value = size;\n};\n\nCalibrationPanel.prototype.updateUnits = function () {\n  this.unitList.setSelectedIndex(this.findUnits());\n};\n\nCalibrationPanel.prototype.updateLabel = function () {\n  var index = this.unitList.selectedIndex;\n  var requestedUnits = this.units[index].units;\n  var size = this.requestedSizeTextbox.value;\n  var parsedNumber = Autodesk.Viewing.Private.UnitParser.parsePositiveNumber(size, requestedUnits);\n  var text = Autodesk.Viewing.Private.formatValueWithUnits(parsedNumber, requestedUnits, 3, Autodesk.Viewing.Private.calculatePrecision(size));\n\n  if (size === \"\") {\n    this.calibrationTool.updateLabelValue(null);\n  } else if (!isNaN(parsedNumber)) {\n    this.calibrationTool.updateLabelValue(text);\n  }\n};\n\nCalibrationPanel.prototype.updatePanelPosition = function (labelPosition, p1, p2, labelOffset) {\n\n  var width = parseInt(this.container.getBoundingClientRect().width);\n  var height = parseInt(this.container.getBoundingClientRect().height);\n\n  var cornerX;\n  var cornerY;\n\n  if (!labelPosition || !p1 || !p2) {\n    cornerX = Math.floor((this.viewer.canvas.clientWidth - width) / 2);\n    cornerY = Math.floor((this.viewer.canvas.clientHeight - height) / 2);\n  } else\n  {\n    p1 = MeasureCommon.project(p1, this.viewer);\n    p2 = MeasureCommon.project(p2, this.viewer);\n    var rubberbandDirection = new THREE.Vector2().copy(p1).sub(p2).normalize();\n\n    var normal;\n    if (p1.x < p2.x) {\n      normal = new THREE.Vector2(rubberbandDirection.y, -rubberbandDirection.x);\n    } else {\n      normal = new THREE.Vector2(-rubberbandDirection.y, rubberbandDirection.x);\n    }\n\n    var offset = labelOffset + Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) / 2;\n\n    normal = normal.multiplyScalar(offset);\n    var pos = labelPosition.sub(normal);\n\n    cornerX = pos.x - Math.floor(width / 2);\n    cornerY = pos.y - Math.floor(height / 2);\n\n    // if panel exceeds screen bounds, just put the panel in the center of the screen.\n    if (cornerX < 0 || cornerX + width > this.viewer.canvas.clientWidth || cornerY < 0 || cornerY + height > this.viewer.canvas.clientHeight) {\n      cornerX = Math.floor((this.viewer.canvas.clientWidth - width) / 2);\n      cornerY = Math.floor((this.viewer.canvas.clientHeight - height) / 2);\n    }\n  }\n\n  this.container.style.left = cornerX + 'px';\n  this.container.style.top = cornerY + 'px';\n};\n\n//\n// /** @constructor */\n//\n//\nexport var CalibrationRequiredDialog = function CalibrationRequiredDialog(measureExt, viewer, id, title, options)\n{\n  var self = this;\n\n  options = options || {};\n  options.addFooter = false;\n\n  DockingPanel.call(this, viewer.container, id, title, options);\n\n  this.viewer = viewer;\n  this.measureExt = measureExt;\n  this.parentContainer = viewer.container;\n  this.container.classList.add('calibration-panel');\n  this.container.style.width = \"380px\";\n  this.container.style.height = \"190px\";\n\n  this.setGlobalManager && this.setGlobalManager(viewer.globalManager);\n\n  if (!options.heightAdjustment)\n  options.heightAdjustment = 70;\n  if (!options.marginTop)\n  options.marginTop = 0;\n  options.left = false;\n\n  var _document = this.getDocument && this.getDocument() || _gDocument;\n\n  this.createScrollContainer(options);\n  this.dialogBox = _document.createElement(\"div\");\n  this.scrollContainer.appendChild(this.dialogBox);\n\n  // text\n  var calibrateNow = _document.createElement('div');\n  calibrateNow.className = 'calibration-text';\n  var text = \"Calibration Message\";\n  calibrateNow.setAttribute(\"data-i18n\", text);\n  calibrateNow.textContent = av.i18n.translate(text);\n  this.dialogBox.appendChild(calibrateNow);\n\n  var buttonsWrapper = _document.createElement('div');\n  buttonsWrapper.className = 'calibration-buttons-wrapper';\n  this.dialogBox.appendChild(buttonsWrapper);\n\n  // Cancel button\n  var cancel = _document.createElement('div');\n  cancel.classList.add('docking-panel-secondary-button');\n  cancel.classList.add('calibration-button-left');\n  cancel.setAttribute(\"data-i18n\", \"Cancel\");\n  cancel.textContent = av.i18n.translate(\"Cancel\");\n  cancel.addEventListener('click', function () {\n    self.setVisible(false);\n  }, false);\n  buttonsWrapper.appendChild(cancel);\n\n  // Calibrate-Now button\n  var calibrateNowButton = _document.createElement('div');\n  calibrateNowButton.classList.add('docking-panel-primary-button');\n  calibrateNowButton.classList.add('calibration-button-right');\n  calibrateNowButton.setAttribute(\"data-i18n\", \"Calibrate Now\");\n  calibrateNowButton.textContent = av.i18n.translate(\"Calibrate Now\");\n  calibrateNowButton.addEventListener('click', function () {\n    self.measureExt.enableCalibrationTool(true);\n    self.setVisible(false);\n  }, false);\n  buttonsWrapper.appendChild(calibrateNowButton);\n\n\n}; // end constructor\n\nCalibrationRequiredDialog.prototype = Object.create(DockingPanel.prototype);\nViewerPanelMixin.call(CalibrationRequiredDialog.prototype);\n\n\nCalibrationRequiredDialog.prototype.uninitialize = function uninitialize() {\n  this.viewer = null;\n  DockingPanel.prototype.uninitialize.call(this);\n};","import { CalibrationToolIndicator } from './CalibrationToolIndicator';\nimport { CalibrationPanel } from './CalibrationPanels';\n\nvar av = Autodesk.Viewing;\n\n//\n// /** @constructor */\n//\n//\nexport var CalibrationTool = function CalibrationTool(viewer, options, sharedMeasureConfig, snapper)\n{\n  var av = Autodesk.Viewing;\n  var avem = Autodesk.Viewing.Extensions.Measure;\n  var MeasureCommon = Autodesk.Viewing.MeasureCommon;\n\n  var _names = [\"calibration\"];\n  var _priority = 50;\n  var _viewer = viewer;\n  var _measurement = new MeasureCommon.Measurement(MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE);\n  var _options = options || {};\n\n  this.setGlobalManager(viewer.globalManager);\n\n  // Shared State with MeasureTool and Indicator\n  var _sharedMeasureConfig = sharedMeasureConfig;\n\n  var _maxPrecision = options.maxPrecision || 5;\n  var _isCalibrated = sharedMeasureConfig.calibrationFactor != null; // True when the user set the calibration, or used a Previous calibration factor.\n\n  var _snapper = snapper;\n\n  var _active = false;\n  var _isDragging = false;\n  var _isPressing = false;\n\n  var _distance = null; // The length of the current measurement.\n  var _calibrationTaken = false; // True when the user selected two valid points and set the calibration.\n  var _selectedSize = null;\n  var _selectedUnits = null;\n  var _selectedP1 = null;\n  var _selectedP2 = null;\n  var _waitingForInput = false; // True when the user selected two valid points.\n  var _picksBackup = [];\n  var _cursorPosition = null;\n\n  var _activePoint = 0;\n\n  var _endpointMoved = false;\n\n  var _consumeSingleClick = false;\n  var _singleClickHandled = false;\n  var _downX = null;\n  var _downY = null;\n\n  // GUI.\n  var _calibrationPanel = null;\n  var _cursor = \"url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAYCAYAAAD+vg1LAAAAAXNSR0IArs4c6QAAAwZJREFUSA2tVEtLW0EUvjGJefoqSY0x0WBSiY+oNWiUINkU6ioLaaAlG1eudNVFoT+grgopiCkEIbUK1o0lusmurRSEWmmKG6MNtNhNosWqyU2CZPpN8cr15nFD7YHDzHnON2fOGYZhmHkw4XEW+wD4xkT4lMvl6CE0+Y2ohh+dz+cZn89HVS/5+n/d/wVMkXq9Xor2v5SBgsmymQwZHx+vOqlKpXKDXWI3eU6Tg+kqSjSh3W4/s9lsvzUajaNcAK3xY7Dyci3nd6WXSCS60dHRvMfjSRcKBfWV4SYbrVarB8p0PB5nY7HYmdVq/aDX67WlckpKKcvpOjs7X09OTvoPDw8z2Wy2Bu+imJqa+npycnJXGHOt3YRGoSyVSvvMZrNkYWFBs7GxkaoBAXFJcDJhcCW5rq5ur62trQ/EOhyOBhDT2Nj4qVKMqA31ve1yub7Rfufo/PycDA4OxpuamhqECaouhVqtfuD3+1tqa2uZQCCQDoVCWTwknVQDDvIKE1clI1ja09Ozg0cjx8fHpL+/P+50OhMU8f7+Punt7f2I5NdqXRXi9fV1z9jYWCuIWV5eziSTyWAqlXq1urqaw6AwOMiCG4lOYtEturu732xubhK0FQHSvfr6+lsog4HWPIPvIBqNErRiqCiwkkKpVFowZd8xZSQYDLImk+kJ52+xWJ4tLS3hU8yTkZGRBD2Ms4mu6Nun4XA4f3p6SoaGhuJ0+rgg/Bsmt9udYFmWzM3NZdDT05ztWsE5JV0R1AqUCfTt0fb2tjESiRRmZmaOUOcI3w9DY5mdnb03PDzMoDQ/MZFRzM20lO/E38vl8vt46UdAq0WNJWixlEwmu8B1bXioOxwjpgXJ0hMTE1og1qysrDghf+HnKtoD7c7u7i5ZXFzMGY3GF7iFuRR3dHTMr62tXWxtbZH29vZ3RYmECozu54ODAzpdP2hphHZOVigUVjChvgMDA+85fdm1q6vrrU6n+4WR9Zd1ujQ0Nzc/NBgMScSExXwZ2j5oL5Wo46UD/ZvxUemo+AdW1zJzUYr16wAAAABJRU5ErkJggg==), auto\";\n  var _hasUI = Autodesk.Viewing.GuiViewer3D && viewer instanceof Autodesk.Viewing.GuiViewer3D;\n\n  var MeasureCommon = Autodesk.Viewing.MeasureCommon;\n\n  function getActivePick()\n  {\n    switch (_activePoint) {\n      case 0:\n        return null;\n      case 1:\n      case 2:\n        return _measurement.getPick(_activePoint);\n      case 3:\n        return _measurement.getPick(_measurement.countPicks());}\n\n  }\n\n  function getPreviousPick()\n  {\n    switch (_activePoint) {\n      case 0:\n        return null;\n      case 1:\n        return _measurement.getPick(_measurement.countPicks());\n      case 2:\n      case 3:\n        return _measurement.getPick(1);}\n\n  }\n\n  function hasPreviousPick()\n  {\n    switch (_activePoint) {\n      case 0:\n        return false;\n      case 1:\n        return _measurement.hasPick(_measurement.countPicks());\n      case 2:\n      case 3:\n        return _measurement.hasPick(1);}\n\n  }\n\n  function noPicksSet() {\n    _activePoint = 0;\n  }\n\n  function allPicksSet() {\n    _activePoint = 3;\n    _measurement.indicator.changeAllEndpointsEditableStyle(true);\n  }\n\n  function isNoPicksSet() {\n    return _activePoint === 0;\n  }\n\n  function areAllPicksSet() {\n    return _activePoint === 3;\n  }\n\n  this.register = function ()\n  {\n    if (_hasUI && !_calibrationPanel) {\n      _calibrationPanel = new CalibrationPanel(this, _viewer, \"calibration-panel\", \"Calibration\", _options);\n      _viewer.addPanel(_calibrationPanel);\n    }\n\n    this.onCameraChangeBinded = this.onCameraChange.bind(this);\n    this.screenSizeChangedBinded = this.screenSizeChanged.bind(this);\n  };\n\n  this.deregister = function ()\n  {\n    this.deactivate();\n\n    if (_calibrationPanel) {\n      _viewer.removePanel(_calibrationPanel);\n      _calibrationPanel.uninitialize();\n      _calibrationPanel = null;\n    }\n  };\n\n  this.isActive = function ()\n  {\n    return _active;\n  };\n\n  this.getNames = function ()\n  {\n    return _names;\n  };\n\n  this.getName = function ()\n  {\n    return _names[0];\n  };\n\n  this.getPriority = function ()\n  {\n    return _priority;\n  };\n\n  this.getCursor = function () {\n    return _isDragging ? null : _cursor;\n  };\n\n  this.activate = function ()\n  {\n    _active = true;\n    _isDragging = false;\n    this.isEditingEndpoint = false;\n    this.editByDrag = false;\n    noPicksSet();\n\n    _viewer.toolController.activateTool(_snapper.getName());\n    _viewer.toolController.activateTool(\"magnifyingGlass\");\n\n\n    if (!_measurement.indicator) {\n      _measurement.attachIndicator(_viewer, this, CalibrationToolIndicator);\n    }\n\n    _measurement.indicator.clear();\n\n    if (_calibrationTaken && _selectedP1 && _selectedP2) {\n      _measurement.setPick(1, _selectedP1.clone());\n      _measurement.setPick(2, _selectedP2.clone());\n\n      allPicksSet();\n\n      var parsedRequestedSize = Autodesk.Viewing.Private.UnitParser.parsePositiveNumber(_selectedSize, _selectedUnits);\n      _measurement.indicator.updateLabelValue(Autodesk.Viewing.Private.formatValueWithUnits(parsedRequestedSize, _selectedUnits, 3, _sharedMeasureConfig.precision));\n      _distance = _measurement.distanceXYZ;\n      _measurement.indicator.changeLabelClickableMode(false);\n      _waitingForInput = true;\n      var valid = this.render();\n      _measurement.indicator.changeAllEndpointsEditableStyle(true);\n\n      if (valid) {\n        if (_calibrationPanel) {\n          _calibrationPanel.setPanelValue(_selectedSize);\n        }\n\n        this.showPanel();\n      }\n    }\n\n    _viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n    _viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.screenSizeChangedBinded);\n  };\n\n  this.deactivate = function ()\n  {\n    if (!_active)\n    return;\n\n    _active = false;\n\n    this.hidePanel();\n    this.updateViewportId(true);\n    _waitingForInput = false;\n    _measurement.clearAllPicks();\n\n    if (_snapper && _snapper.isActive()) {\n      _viewer.toolController.deactivateTool(_snapper.getName());\n    }\n\n    _viewer.toolController.deactivateTool(\"magnifyingGlass\");\n\n    if (_measurement.indicator) {\n      _measurement.indicator.clear();\n      _measurement.indicator.destroy();\n      _measurement.indicator = null;\n    }\n\n    _viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n    _viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.screenSizeChangedBinded);\n  };\n\n  this.getActivePointIndex = function () {\n    return _activePoint;\n  };\n\n  this.setCalibrationFactor = function (calibrationFactor) {\n    _sharedMeasureConfig.calibrationFactor = calibrationFactor;\n  };\n\n  this.getCalibrationFactor = function () {\n    return _sharedMeasureConfig.calibrationFactor;\n  };\n\n  this.updateLabelValue = function (value) {\n    _measurement.indicator.updateLabelValue(value);\n  };\n\n  this.isCalibrationValid = function (requestedUnits, requestedSize) {\n    var parsedRequestedSize = Autodesk.Viewing.Private.UnitParser.parsePositiveNumber(requestedSize, requestedUnits);\n    return !isNaN(parsedRequestedSize);\n  };\n\n  this.calibrate = function (requestedUnits, requestedSize)\n  {\n\n    var calibrationFactor = null;\n\n    var parsedRequestedSize = Autodesk.Viewing.Private.UnitParser.parsePositiveNumber(requestedSize, requestedUnits);\n\n    if (!isNaN(parsedRequestedSize)) {\n      var currentSize = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), requestedUnits, 1, _distance);\n      if (currentSize !== 0 && !isNaN(currentSize)) {\n        calibrationFactor = parsedRequestedSize / currentSize;\n        _sharedMeasureConfig.calibrationFactor = calibrationFactor;\n        _sharedMeasureConfig.units = requestedUnits;\n        var defualtPrecision = _viewer.model.is2d() ? 3 : 1;\n        var requestedPrecision = Autodesk.Viewing.Private.calculatePrecision(requestedSize);\n        _sharedMeasureConfig.precision = Math.max(_sharedMeasureConfig.precision ? _sharedMeasureConfig.precision : defualtPrecision, requestedPrecision);\n        _selectedSize = requestedSize;\n        _selectedUnits = requestedUnits;\n        _isCalibrated = true;\n        _calibrationTaken = true;\n        _selectedP1 = _measurement.getPick(1).clone();\n        _selectedP2 = _measurement.getPick(2).clone();\n      }\n    }\n\n    if (calibrationFactor) {\n      _viewer.getExtension('Autodesk.Measure').enableCalibrationTool(false);\n      _viewer.dispatchEvent({ type: MeasureCommon.Events.FINISHED_CALIBRATION, units: requestedUnits, scaleFactor: calibrationFactor, size: requestedSize });\n    }\n  };\n\n  this.calibrateByScale = function (requestedUnits, requestedScale) {\n    _sharedMeasureConfig.calibrationFactor = requestedScale;\n\n    if (_sharedMeasureConfig.units !== requestedUnits) {\n      _sharedMeasureConfig.units = requestedUnits;\n      _selectedUnits = requestedUnits;\n    }\n\n    _isCalibrated = true;\n  };\n\n  this.getCurrentUnits = function () {\n    return _sharedMeasureConfig.units;\n  };\n\n  this.hidePanel = function () {\n    if (_calibrationPanel) {\n      _calibrationPanel.setVisible(false);\n    } else\n    {\n      _viewer.dispatchEvent({ type: MeasureCommon.Events.CLOSE_CALIBRATION_PANEL_EVENT });\n    }\n  };\n\n  this.showPanel = function () {\n\n    var self = this;\n    var _window = this.getWindow();\n\n    if (_calibrationPanel) {\n      _window.setTimeout(function () {_calibrationPanel.requestedSizeTextbox.focus();}, 0);\n      _calibrationPanel.setVisible(true);\n      _calibrationPanel.updatePanelPosition(_measurement.indicator.labelPosition, _measurement.indicator.p1, _measurement.indicator.p2, _measurement.indicator.calibrationLabel.clientHeight);\n      _calibrationPanel.updateUnits();\n      self.addWindowEventListener(\"keyup\", function onKeyUp(e) {\n        var key = e.key || String.fromCharCode(e.keyCode);\n        if (key == \"Escape\" && self.isActive()) {\n          self.hidePanel();\n          self.clearSize();\n          self.showAddCalibrationLabel();\n\n          self.removeWindowEventListener(\"keyup\", onKeyUp);\n        }\n      });\n    } else\n    {\n      _viewer.dispatchEvent({ type: MeasureCommon.Events.OPEN_CALIBRATION_PANEL_EVENT, data: { size: _selectedSize, units: _selectedUnits } });\n    }\n  };\n\n  this.updateCalibrationPanel = function () {\n    _calibrationPanel && _calibrationPanel.updateUnits();\n  };\n\n  this.showAddCalibrationLabel = function () {\n    _measurement.indicator.showAddCalibrationLabel();\n  };\n\n  this.isCalibrated = function () {\n    return _isCalibrated;\n  };\n\n  this.clearSize = function () {\n    _measurement.indicator.updateLabelValue(null);\n\n    if (_calibrationPanel) {\n      _calibrationPanel.requestedSizeTextbox.value = \"\";\n    } else\n    {\n      _viewer.dispatchEvent({ type: MeasureCommon.Events.CLEAR_CALIBRATION_SIZE_EVENT });\n    }\n  };\n\n  this.getMaxPrecision = function () {\n    return _maxPrecision;\n  };\n\n  this.clearMeasurement = function () {\n\n    noPicksSet();\n\n    this.clearPick(1);\n    this.clearPick(2);\n\n    _measurement.indicator.clear();\n\n    this.updateViewportId(true);\n    this.hidePanel();\n\n    _waitingForInput = false;\n  };\n\n  this.clearPick = function (pickNumber) {\n    if (_measurement.hasPick(pickNumber)) {\n      _measurement.clearPick(pickNumber);\n      _measurement.indicator.hideClick(pickNumber);\n    }\n  };\n\n  this.repickEndpoint = function (pickNumber) {\n    this.clearPick(pickNumber);\n    this.editEndpoint(null, pickNumber);\n  };\n\n  this.getSnapper = function () {\n    return _snapper;\n  };\n\n  this._handleMouseEvent = function (event) {\n\n    var valid = false;\n\n    if (_snapper.isSnapped()) {\n\n      // User picked a new point after two points where already set (or none) - Start a new measurement.\n      if (areAllPicksSet() || isNoPicksSet()) {\n        this.clearMeasurement();\n        _activePoint = 1;\n      }\n\n      _snapper.copyResults(getActivePick());\n\n      valid = true;\n\n    } else\n    {\n      // In order to draw rubber-band, set the cursor position, so the indicator will use it as active point.\n      if (event && _viewer.model.is2d()) {\n        var viewport = _viewer.container.getBoundingClientRect();\n        var x = event.canvasX || event.clientX - viewport.left;\n        var y = event.canvasY || event.clientY - viewport.top;\n\n        if (x && y) {\n          _cursorPosition = MeasureCommon.inverseProject({ x: x, y: y }, _viewer);\n        }\n      }\n\n      // In case a measurement is set, and the user clicks on a blank spot - don't do nothing.\n      if (_consumeSingleClick && _measurement && !this.isEditingEndpoint) {\n        if (_activePoint === _measurement.getMaxNumberOfPicks() + 1) {\n          return true;\n        }\n      }\n\n      var lastPick = getActivePick();\n      if (lastPick) {\n        lastPick.clear();\n      }\n    }\n\n    this.correctPickPosition();\n\n    if (_consumeSingleClick) {\n      this._doConsumeSingleClick(valid);\n    }\n\n    if (!isNoPicksSet()) {\n      var renderSucceeded = this.render();\n\n      // If it's the first pick, we don't expect the render of the rubberband to be succeeded.\n      // So enter here only if it's not the first pick.\n      if (_measurement.hasPick(2)) {\n        valid &= renderSucceeded;\n      }\n    }\n\n    if (_consumeSingleClick) {\n      if (_measurement.isComplete() && valid) {\n        _distance = _measurement.distanceXYZ;\n        this.clearSize();\n        this.showPanel();\n        _waitingForInput = true;\n      } else\n      {\n        this.hidePanel();\n        _measurement.indicator.updateLabelValue(null);\n        _waitingForInput = false;\n      }\n    }\n\n    // If valid is false, the last pick is not revelant, and will clear it in case of a click.\n    return valid;\n  };\n\n  this.updateViewportId = function (clear) {\n    if (_viewer.model && _viewer.model.is2d()) {\n      if (clear || isNoPicksSet()) {\n        viewer.impl.updateViewportId(0);\n        _snapper.setViewportId(null);\n      } else\n      if (!_isPressing) {\n        var viewport = getPreviousPick().viewportIndex2d || getActivePick().viewportIndex2d;\n\n        // Pass viewport Id to LineShader to make all other geometries with different viewport transparent\n        viewer.impl.updateViewportId(viewport);\n        if (_snapper)\n        _snapper.setViewportId(viewport);\n\n      }\n    }\n  };\n\n  this._doConsumeSingleClick = function (valid) {\n\n    this.updateViewportId(_measurement.isComplete());\n\n    _measurement.indicator.clear();\n  };\n\n\n  this.handleButtonDown = function (event, button) {\n    if (av.isMobileDevice())\n    return false;\n\n    _isDragging = true;\n    if (button === 0 && !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {\n      _consumeSingleClick = true;\n      _downX = event.canvasX;\n      _downY = event.canvasY;\n    }\n    return false;\n  };\n\n  this.handleMouseMove = function (event) {\n    if (av.isMobileDevice())\n    return false;\n\n    if (event.canvasX !== _downX || event.canvasY !== _downY) {\n      _consumeSingleClick = false;\n    }\n\n    _endpointMoved = this.isEditingEndpoint;\n\n    if (!isNoPicksSet() && !areAllPicksSet()) {\n      this.clearPick(_activePoint);\n      this._handleMouseEvent(event);\n    }\n\n    _snapper.indicator.render();\n\n    return false;\n  };\n\n  this.restoreMouseListeners = function () {\n\n    // When a press event has happend, the default behavior of firefly.js is to disable other mouse events,\n    // So they won't be triggered as well.\n    // The solution is to enable them after the end of the pressing.\n\n    _viewer.toolController.getTool(\"gestures\").controller.enableMouseButtons(true);\n  };\n\n  this.handlePressHold = function (event) {\n    _consumeSingleClick = false;\n\n    if (av.isTouchDevice()) {\n      switch (event.type) {\n\n        case \"press\":\n          _isPressing = true;\n          if (areAllPicksSet()) {\n            this.clearMeasurement();\n          } else {\n            this.clearPick(_activePoint);\n          }\n          this._handleMouseEvent(event);\n          _snapper.indicator.render();\n\n          return true;\n\n        case \"pressup\":\n          _consumeSingleClick = true;\n          this.restoreMouseListeners();\n          _singleClickHandled = !_singleClickHandled;\n          this.handleSingleClick(event);\n          _isPressing = false;\n          return true;}\n\n    }\n    return false;\n\n  };\n\n  this.correctPickPosition = function () {\n\n    var active = getActivePick();\n\n    if (active && !active.getGeometry() && _cursorPosition) {\n      active.geomType = MeasureCommon.SnapType.SNAP_VERTEX;\n      active.geomVertex = _cursorPosition;\n      active.intersectPoint = _cursorPosition;\n    }\n\n    if (hasPreviousPick()) {\n      var passive = getPreviousPick();\n      MeasureCommon.correctPerpendicularPicks(passive, active, viewer, _snapper);\n    }\n  };\n\n  this.render = function () {\n\n    var hasResult = _measurement.computeResult(_measurement.picks, _viewer, _snapper);\n    _measurement.indicator.render(_measurement.picks, _consumeSingleClick || _waitingForInput);\n\n    return hasResult;\n  };\n\n  this.editEndpoint = function (event, endpointNumber) {\n    if (_activePoint === endpointNumber) {\n      _measurement.indicator.changeEndpointOnEditStyle(endpointNumber, false);\n      this.undoEditEndpoint();\n      return;\n    }\n\n    _activePoint = endpointNumber;\n    this.isEditingEndpoint = true;\n\n    _measurement.indicator.changeEndpointOnEditStyle(endpointNumber, true);\n    _measurement.indicator.changeAllEndpointsEditableStyle(false);\n\n    for (var key in _measurement.picks) {\n      if (_measurement.picks.hasOwnProperty(key)) {\n        _picksBackup[key] = _measurement.getPick(key).clone();\n      }\n    }\n\n    this.updateViewportId();\n\n    this.hidePanel();\n    _measurement.indicator.updateLabelValue(null);\n    _waitingForInput = false;\n\n    if (!av.isMobileDevice()) {\n      this._handleMouseEvent(event);\n    }\n  };\n\n  this.undoEditEndpoint = function () {\n    _measurement.indicator.clear();\n\n    for (var key in _measurement.picks) {\n      if (_measurement.picks.hasOwnProperty(key)) {\n        _measurement.setPick(key, _picksBackup[key].clone());\n      }\n    }\n\n    this.updateViewportId(true);\n    this.isEditingEndpoint = false;\n    _waitingForInput = true;\n\n    allPicksSet();\n    var valid = this.render();\n\n    if (valid) {\n      this.showPanel();\n    }\n  };\n\n  this.handleGesture = function (event)\n  {\n    if (av.isTouchDevice()) {\n\n      _consumeSingleClick = false;\n\n      if (_isPressing) {\n\n        this.clearPick(_activePoint);\n\n        switch (event.type) {\n\n          case \"dragstart\":\n            this._handleMouseEvent(event);\n            _snapper.indicator.render();\n\n            return true;\n\n          case \"dragmove\":\n            this._handleMouseEvent(event);\n            _snapper.indicator.render();\n\n            return true;\n\n          case \"dragend\":\n            _isPressing = false;\n            _consumeSingleClick = true;\n\n            if (!this.editByDrag) {\n              _singleClickHandled = !_singleClickHandled;\n              this.handleSingleClick(event);\n            }\n\n            this.editByDrag = false;\n            this.restoreMouseListeners();\n            return true;\n\n          case \"pinchend\":\n            _consumeSingleClick = true;\n            _singleClickHandled = !_singleClickHandled;\n            this.handleSingleClick(event);\n            this.restoreMouseListeners();\n            return true;}\n\n      }\n    }\n\n    return false;\n  };\n\n  this.handleButtonUp = function (event) {\n    _isDragging = false;\n    _downX = null;\n    _downY = null;\n\n    if (_endpointMoved) {\n      _consumeSingleClick = true;\n      _singleClickHandled = !_singleClickHandled;\n      this.handleSingleClick(event);\n      _endpointMoved = false;\n    }\n\n    return false;\n  };\n\n  this.handleSingleClick = function (event) {\n    if (_consumeSingleClick) {\n\n      _snapper.indicator.clearOverlays();\n\n      _measurement.indicator.changeEndpointOnEditStyle(_activePoint, false);\n\n      if (this._handleMouseEvent(event)) {\n        _measurement.indicator.showEndpoints();\n        _measurement.indicator.updateLabelsPosition();\n        _activePoint++;\n      } else\n      {\n        if (this.isEditingEndpoint) {\n          this.undoEditEndpoint();\n        } else\n        {\n          this.clearMeasurement();\n        }\n      }\n\n      if (_measurement.isComplete()) {\n        allPicksSet();\n      }\n\n      _consumeSingleClick = false;\n      _singleClickHandled = !_singleClickHandled;\n      this.isEditingEndpoint = false;\n\n      _snapper.clearSnapped();\n    }\n    return true;\n  };\n\n  this.handleDoubleClick = function () {\n    return true;\n  };\n\n  this.handleSingleTap = function (event) {\n    if (!_singleClickHandled) {\n      _consumeSingleClick = true;\n      _snapper.onMouseDown({ x: event.canvasX, y: event.canvasY });\n      this.handleSingleClick(event);\n    }\n    _singleClickHandled = !_singleClickHandled;\n\n    return true;\n  };\n\n  this.handleDoubleTap = function () {\n    return true;\n  };\n\n  this.handleResize = function () {\n    if (_measurement.indicator) {\n      _measurement.indicator.handleResize();\n    }\n  };\n\n  this.onCameraChange = function () {\n    if (_snapper.indicator) {\n      _snapper.indicator.onCameraChange();\n    }\n  };\n\n  this.screenSizeChanged = function (event) {\n    this.onCameraChange();\n  };\n};\n\nav.GlobalManagerMixin.call(CalibrationTool.prototype);","import { Indicator } from './Indicator';\n\nvar av = Autodesk.Viewing;\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon;\n\n// /** @constructor */\nexport function CalibrationToolIndicator(viewer, measurement, calibrationTool)\n{\n  Indicator.call(this, viewer, measurement, calibrationTool);\n  this.calibrationTool = calibrationTool;\n  this.calibrationLabel = null;\n  this.endpoints = null;\n  this.tmpVector = new THREE.Vector3();\n  this.p1 = null;\n  this.p2 = null;\n\n  this.rubberbandDefaultMaterial = new THREE.MeshBasicMaterial({\n    color: 0xe8b22c,\n    opacity: 1,\n    transparent: false,\n    depthTest: false,\n    depthWrite: false,\n    side: THREE.DoubleSide });\n\n\n  this.rubberbandSnappedMaterial = new THREE.MeshBasicMaterial({\n    color: 0x005BCE,\n    opacity: 1,\n    transparent: false,\n    depthTest: false,\n    depthWrite: false,\n    side: THREE.DoubleSide });\n\n\n  this.rubberbandTipMaterial = new THREE.MeshBasicMaterial({\n    color: 0x000000,\n    opacity: 1,\n    transparent: false,\n    depthTest: false,\n    depthWrite: false,\n    side: THREE.DoubleSide });\n\n\n}\n\nCalibrationToolIndicator.prototype = Object.create(Indicator.prototype);\nCalibrationToolIndicator.prototype.constructor = CalibrationToolIndicator;\nvar proto = CalibrationToolIndicator.prototype;\n\nvar kEndpointOffset = 15;\n\nvar kCrossWidth = 1.5;\nvar kTipXWidth = 2;\nvar kLineWidth = 3;\n\nvar kTipXLength = 3;\nvar kCrossLength = 5;\n\nvar kDashSize = 2;\nvar kGapSize = 1;\n\nproto.createEndpoint = function (name) {\n  this.endpoints[name] = {};\n  this.endpoints[name].position = null;\n\n  var _document = this.getDocument();\n  var label = this.endpoints[name].label = _document.createElement('div');\n  label.className = 'calibration-endpoint';\n\n  this.viewer.container.appendChild(label);\n\n  var text = _document.createElement('div');\n  text.className = 'calibration-endpoint-text';\n  text.textContent = name.toString();\n  label.appendChild(text);\n\n  if (av.isTouchDevice()) {\n    this.initLabelMobileGestures(label, name, this.calibrationTool);\n  }\n  // Disable hover for mobile devices\n  if (!av.isMobileDevice()) {\n    MeasureCommon.safeToggle(label, 'enable-hover', true);\n\n    this.initMouseEvent(label, name);\n\n    label.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n\n  }\n};\n\nproto.init = function () {\n\n  MeasureCommon.createCommonOverlay(this.viewer, this.overlayName);\n\n  if (!this.calibrationLabel) {\n    var _document = this.getDocument();\n    this.calibrationLabel = _document.createElement('div');\n    this.calibrationLabel.className = 'calibration-label';\n    this.hideLabel(this.calibrationLabel);\n    this.viewer.container.appendChild(this.calibrationLabel);\n    this.calibrationLabel.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n\n    var text = _document.createElement('div');\n    text.className = 'calibration-label-text';\n    this.calibrationLabel.appendChild(text);\n  }\n\n  this.endpoints = [];\n\n  this.handleButtonUpBinded = this.calibrationTool.handleButtonUp.bind(this.calibrationTool);\n  this.addWindowEventListener('mouseup', this.handleButtonUpBinded);\n\n  this.onCameraChangeBinded = this.onCameraChange.bind(this);\n  this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n};\n\nproto.destroy = function () {\n  this.clear();\n\n  Indicator.prototype.destroy.call(this);\n\n  if (this.calibrationLabel) {\n    this.calibrationLabel.removeEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    this.viewer.container.removeChild(this.calibrationLabel);\n    this.calibrationLabel = null;\n  }\n\n\n  this.viewer.impl.clearOverlay(this.overlayName);\n  this.viewer.impl.removeOverlayScene(this.overlayName);\n\n  this.removeWindowEventListener('mouseup', this.handleButtonUpBinded);\n  this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n};\n\nproto.clearRubberband = function () {\n  this.viewer.impl.clearOverlay(this.overlayName);\n};\n\nproto.clear = function () {\n\n  this.clearRubberband();\n\n  this.hideLabel(this.calibrationLabel);\n\n  for (var name in this.endpoints) {\n    if (this.endpoints.hasOwnProperty(name)) {\n      this.hideClick(name);\n      this.endpoints[name].position = null;\n    }\n  }\n};\n\nproto.updateLabelValue = function (text) {\n  if (!text || text === \"\") {\n    this.calibrationLabel.childNodes[0].textContent = null;\n    this.hideLabel(this.calibrationLabel);\n  } else\n  {\n    this.calibrationLabel.childNodes[0].setAttribute(\"data-i18n\", text);\n    this.calibrationLabel.childNodes[0].textContent = av.i18n.translate(text);\n    this.showLabel(this.calibrationLabel);\n    this.calibrationTool.render();\n  }\n};\n\nproto.changeLabelClickableMode = function (clickable) {\n  if (clickable) {\n    this.calibrationLabel.childNodes[0].style.pointerEvents = 'all';\n  } else\n  {\n    this.calibrationLabel.childNodes[0].style.pointerEvents = 'none';\n  }\n};\n\nproto.showAddCalibrationLabel = function () {\n  var self = this;\n  this.updateLabelValue(\"Add Calibration\");\n  this.changeLabelClickableMode(true);\n  this.calibrationTool.render();\n\n  this.calibrationLabel.addEventListener(\"click\", function onClick() {\n    self.calibrationLabel.childNodes[0].style.pointerEvents = 'none';\n    self.calibrationTool.render();\n    self.updateLabelValue(null);\n    self.calibrationTool.showPanel();\n    self.calibrationLabel.removeEventListener(\"click\", onClick);\n  });\n};\n\nproto.updateLabelsPosition = function () {\n  for (var i = 1; i <= Object.keys(this.endpoints).length; i++) {\n    if (this.endpoints[i].position) {\n      var label = this.endpoints[i].label;\n      var pos = MeasureCommon.project(this.endpoints[i].position, this.viewer, kEndpointOffset);\n      label.style.left = pos.x - parseInt(label.clientWidth) / 2 + 'px';\n      label.style.top = pos.y - parseInt(label.clientHeight) / 2 + 'px';\n      label.point = this.endpoints[i].position;\n\n      // Detect and move in case of overlapping.\n      this.labelsOverlapDetection(this.endpoints[i].label, this.endpoints);\n    }\n  }\n\n  this.hideLabelsOutsideOfView();\n};\n\nfunction isLeftIntersect(current, other) {\n  return current.right >= other.left && current.right <= other.right;\n}\n\nfunction isRightIntersect(current, other) {\n  return current.left >= other.left && current.left <= other.right;\n}\n\nfunction isMiddleIntersect(current, other) {\n  return current.left <= other.left && current.right >= other.right;\n}\n\nfunction isVerticalIntersect(current, other) {\n  return current.top < other.bottom && current.bottom > other.top;\n}\n\nfunction moveLeft(currentLabel, currentRect, otherRect) {\n  currentLabel.style.left = parseInt(currentLabel.style.left, 10) - (currentRect.right - otherRect.left) + 'px';\n}\n\nfunction moveRight(currentLabel, currentRect, otherRect) {\n  currentLabel.style.left = parseInt(currentLabel.style.left, 10) + (otherRect.right - currentRect.left) + 'px';\n}\n\nfunction moveDown(currentLabel, currentRect, otherRect) {\n  currentLabel.style.top = parseInt(currentLabel.style.top, 10) + (otherRect.bottom - currentRect.top) + 'px';\n}\n\n\nproto.labelsOverlapDetection = function (staticLabel, labelsList) {\n\n  for (var i = 1; i <= Object.keys(labelsList).length; i++) {\n\n    var dynamicLabel = labelsList[i].label;\n\n    if (staticLabel !== dynamicLabel) {\n      var staticRect = staticLabel.getBoundingClientRect();\n      var dynamicRect = dynamicLabel.getBoundingClientRect();\n\n      if (isVerticalIntersect(dynamicRect, staticRect)) {\n\n        if (isLeftIntersect(dynamicRect, staticRect)) {\n          moveLeft(dynamicLabel, dynamicRect, staticRect);\n        } else\n        if (isRightIntersect(dynamicRect, staticRect)) {\n          moveRight(dynamicLabel, dynamicRect, staticRect);\n        } else\n        if (isMiddleIntersect(dynamicRect, staticRect)) {\n          moveDown(dynamicLabel, dynamicRect, staticRect);\n        }\n      }\n    }\n  }\n};\n\nproto.renderCalibrationLabel = function () {\n\n  if (this.showMeasureResult && this.calibrationLabel && this.p1 && this.p2) {\n\n    var point = { x: (this.p1.x + this.p2.x) / 2, y: (this.p1.y + this.p2.y) / 2, z: (this.p1.z + this.p2.z) / 2 };\n    var mid = MeasureCommon.project(point, this.viewer);\n\n    this.labelPosition = new THREE.Vector2(mid.x, mid.y);\n\n    if (this.calibrationLabel.childNodes[0].textContent) {\n      this.showLabel(this.calibrationLabel);\n    }\n\n    this.calibrationLabel.style.top = this.labelPosition.y - Math.floor(this.calibrationLabel.clientHeight / 2) + 'px';\n    this.calibrationLabel.style.left = this.labelPosition.x - Math.floor(this.calibrationLabel.clientWidth / 2) + 'px';\n    this.calibrationLabel.point = point;\n\n    if (this.viewer.model.is2d()) {\n      this.alignLabelWithLine(this.calibrationLabel, this.p1, this.p2, this.calibrationLabel.clientHeight, this.viewer);\n    }\n  }\n};\n\nproto.drawMeasurementLineTip = function (point, direction, normal, flip) {\n\n  var tmpVec = new THREE.Vector3();\n  var geometry = new THREE.Geometry();\n  var p1Scale = this.setScale(point);\n\n  flip = flip ? -1 : 1;\n\n  var tipMaterial = this.snapper.isSnapped() && !this.showMeasureResult ? this.rubberbandSnappedMaterial : this.rubberbandTipMaterial;\n\n  // black tip\n  tmpVec.addVectors(point, normal.clone().multiplyScalar(kCrossLength * p1Scale));\n  geometry.vertices[0] = tmpVec.clone();\n  tmpVec.subVectors(point, normal.clone().multiplyScalar(kCrossLength * p1Scale));\n  geometry.vertices[1] = tmpVec.clone();\n  this.drawLineAsCylinder(geometry, tipMaterial, kCrossWidth, this.overlayName);\n\n  geometry.vertices[0] = point;\n  tmpVec.subVectors(point, direction.clone().multiplyScalar(kCrossLength * p1Scale * flip));\n  geometry.vertices[1] = tmpVec.clone();\n  this.drawLineAsCylinder(geometry, tipMaterial, kCrossWidth, this.overlayName);\n\n  // yellow tip\n  tmpVec.addVectors(point, normal.clone().multiplyScalar(kTipXLength * p1Scale));\n  geometry.vertices[0] = tmpVec.clone();\n  tmpVec.subVectors(point, normal.clone().multiplyScalar(kTipXLength * p1Scale));\n  geometry.vertices[1] = tmpVec.clone();\n  this.drawLineAsCylinder(geometry, this.rubberbandDefaultMaterial, kTipXWidth, this.overlayName);\n\n  tmpVec.addVectors(point, normal.clone().multiplyScalar(kTipXLength * p1Scale));\n  tmpVec.addVectors(tmpVec, direction.clone().multiplyScalar(kTipXLength * p1Scale));\n  geometry.vertices[0] = tmpVec.clone();\n  tmpVec.subVectors(point, normal.clone().multiplyScalar(kTipXLength * p1Scale));\n  tmpVec.subVectors(tmpVec, direction.clone().multiplyScalar(kTipXLength * p1Scale));\n  geometry.vertices[1] = tmpVec.clone();\n  this.drawLineAsCylinder(geometry, this.rubberbandDefaultMaterial, kTipXWidth, this.overlayName);\n};\n\nproto.renderDistanceMeasurement = function (p1, p2) {\n\n  this.viewer.impl.clearOverlay(this.overlayName);\n\n  if (!p1 || !p2)\n  return;\n\n  var geometry = new THREE.Geometry();\n  var lineDirection = new THREE.Vector3().subVectors(p2, p1).normalize();\n  var lineNormal = lineDirection.clone().cross(this.viewer.navigation.getEyeVector()).normalize();\n  var p1Scale = this.setScale(p1);\n\n  var dashSize = kDashSize * p1Scale;\n  var gapSize = kGapSize * p1Scale;\n\n  // Main line\n\n  var lineMaterial = (Math.abs(p1.x - p2.x) <= 0.1 || Math.abs(p1.y - p2.y) <= 0.1 ||\n  this.snapper.getSnapResult().isPerpendicular) && !this.showMeasureResult ?\n  this.rubberbandSnappedMaterial : this.rubberbandDefaultMaterial;\n\n  if (this.showMeasureResult) {\n    // Single solid line.\n    geometry.vertices[0] = p1;\n    geometry.vertices[1] = p2;\n    this.drawLineAsCylinder(geometry, lineMaterial, kLineWidth, this.overlayName);\n  } else\n  {\n    this.drawDashedLine(p1, p2, dashSize, gapSize, lineMaterial, kLineWidth, this.overlayName);\n  }\n\n  this.drawMeasurementLineTip(p1, lineDirection, lineNormal, false);\n\n  if (this.showMeasureResult) {\n    this.drawMeasurementLineTip(p2, lineDirection, lineNormal, true);\n  }\n\n  this.p1 = p1;\n  this.p2 = p2;\n\n  this.renderCalibrationLabel();\n};\n\nproto.onCameraChange = function () {\n  if (this.measurement.isComplete()) {\n    this.renderDistanceMeasurement(this.p1, this.p2);\n  }\n  this.updateLabelsPosition();\n};","\nvar av = Autodesk.Viewing;\nvar MeasureCommon = av.MeasureCommon;\n\n/**\n                                       * Base class for an indicator.\n                                       */\n\nexport var Indicator = function Indicator(viewer, measurement, tool)\n{\n  this.viewer = viewer;\n  this.setGlobalManager(viewer.globalManager);\n  this.measurement = measurement;\n  this.tool = tool;\n  this.snapper = tool.getSnapper();\n  this.materialExtensionLine = null;\n  this.materialExtensionFace = null;\n  this.extensionLines = [];\n  this.extensionFaces = [];\n  this.grayOutPlane = [];\n  this.materialPoint = null;\n  this.materialLine = null;\n  this.materialAngle = null;\n  this.materialAngleOutline = null;\n  this.materialGreyOutPlane = null;\n  this.materialFace = null;\n  this.angleArc = null;\n  this.angleOutline = [];\n  this.arcOutline = [];\n  this.arcTip = [];\n  this.showMeasureResult = false;\n  this.visibleLabels = [];\n  this.overlayName = 'measure-indicator-overlay-' + (measurement.id || '');\n  this.xAxis = this.viewer.autocam.getWorldRightVector();\n  this.yAxis = this.viewer.autocam.getWorldUpVector();\n  this.zAxis = this.viewer.autocam.getWorldFrontVector();\n};\n\n\n\nvar proto = Indicator.prototype;\nav.GlobalManagerMixin.call(proto);\n\nproto.init = function () {\n  return false;\n};\n\nproto.updateDistance = function () {\n  return false;\n};\n\nproto.updateAngle = function () {\n  return false;\n};\n\nproto.clear = function () {\n  return false;\n};\n\nproto.updateLabelsPosition = function () {\n  return false;\n};\n\nproto.renderFromPoints = function (pointData, showMeasureResult) {\n  this.showMeasureResult = showMeasureResult;\n\n  this.clear();\n\n  for (var i = 1; i <= Object.keys(pointData).length; i++) {\n    var p = pointData[i].intersection;\n\n    if (!this.endpoints[i]) {\n      this.createEndpoint(i);\n    }\n\n    this.endpoints[i].position = new THREE.Vector3(p.x, p.y, p.z);\n    this.showClick(i);\n  }\n\n  this.renderRubberbandFromPoints(pointData);\n\n  this.updateLabelsPosition();\n};\n\n// Renders the measurement and the labels.\nproto.render = function (picks, showMeasureResult) {\n\n  this.showMeasureResult = showMeasureResult;\n\n  this.clear();\n\n  for (var i = 1; i <= Object.keys(picks).length; i++) {\n    if (this.measurement.hasPick(i)) {\n      this.renderPick(i);\n    }\n  }\n\n  this.renderRubberband(picks);\n\n  this.updateLabelsPosition();\n};\n\nproto.changeEndpointOnEditStyle = function (endpointNumber, isEditing) {\n  return false;\n};\n\nproto.handleResize = function () {\n  return false;\n};\n\nproto.setNoTopology = function () {\n  return false;\n};\n\nproto.setFetchingTopology = function () {\n  return false;\n};\n\nproto.setTopologyAvailable = function () {\n  return false;\n};\n\nproto.clientToCanvasCoords = function (event) {\n  var rect = this.viewer.impl.getCanvasBoundingClientRect();\n  var res = {};\n  if (event.hasOwnProperty(\"center\"))\n  {\n    event.canvasX = res.x = event.center.x - rect.left;\n    event.canvasY = res.y = event.center.y - rect.top;\n  } else\n\n  {\n    event.canvasX = res.x = event.pointers[0].clientX - rect.left;\n    event.canvasY = res.y = event.pointers[0].clientY - rect.top;\n  }\n\n  return res;\n};\n\nproto.initLabelMobileGestures = function (label, pointNumber) {\n  var magnifyingGlass = this.viewer.toolController.getTool(\"magnifyingGlass\");\n\n  this.hammer = new av.Hammer.Manager(label, {\n    recognizers: [\n    av.GestureRecognizers.drag,\n    av.GestureRecognizers.singletap],\n\n    handlePointerEventMouse: false,\n    inputClass: av.isIE11 ? av.Hammer.PointerEventInput : av.Hammer.TouchInput });\n\n\n  this.onSingleTapBinded = function (event) {\n    var pos = this.clientToCanvasCoords(event);\n    this.snapper.onMouseDown(pos);\n    this.tool.editEndpoint(event, pointNumber, this.measurement.id);\n  }.bind(this);\n\n  this.onDragStartBinded = function (event) {\n    var pos = this.clientToCanvasCoords(event);\n    this.snapper.onMouseDown(pos);\n    this.tool.editEndpoint(event, pointNumber, this.measurement.id);\n    this.tool.editByDrag = true;\n\n    // Activate Magnifying Glass and tool by faking press event.\n    event.type = \"press\";\n    magnifyingGlass.handlePressHold(event);\n    this.tool.handlePressHold(event);\n    event.type = \"dragstart\";\n    magnifyingGlass.handleGesture(event);\n    this.tool.handleGesture(event);\n  }.bind(this);\n\n  this.onDragMoveBinded = function (event) {\n    var pos = this.clientToCanvasCoords(event);\n    this.snapper.onMouseDown(pos);\n\n    magnifyingGlass.handleGesture(event);\n    this.tool.handleGesture(event);\n  }.bind(this);\n\n  this.onDragEndBinded = function (event) {\n    var pos = this.clientToCanvasCoords(event);\n    this.snapper.onMouseDown(pos);\n\n    // Deactivate Magnifying Glass and tool by faking pressup event.\n    magnifyingGlass.handleGesture(event);\n    this.tool.handleGesture(event);\n    event.type = \"pressup\";\n    magnifyingGlass.handlePressHold(event);\n    this.tool.handlePressHold(event);\n\n    this.tool.handleButtonUp(event);\n  }.bind(this);\n\n  this.hammer.on(\"singletap\", this.onSingleTapBinded);\n  this.hammer.on(\"dragstart\", this.onDragStartBinded);\n  this.hammer.on(\"dragmove\", this.onDragMoveBinded);\n  this.hammer.on(\"dragend\", this.onDragEndBinded);\n};\n\nproto.clearLabelMobileGestures = function () {\n  if (this.hammer) {\n    this.hammer.off(\"singletap\", this.onSingleTapBinded);\n    this.hammer.off(\"dragstart\", this.onDragStartBinded);\n    this.hammer.off(\"dragmove\", this.onDragMoveBinded);\n    this.hammer.off(\"dragend\", this.onDragEndBinded);\n    this.hammer = null;\n  }\n};\n\nproto.updateVisibleLabelsArray = function (label, isVisible) {\n  if (isVisible) {\n    if (!(this.visibleLabels.indexOf(label) > -1)) {\n      this.visibleLabels.push(label);\n    }\n  } else {\n    // remove from array\n    var index = this.visibleLabels.indexOf(label);\n    if (index > -1) {\n      this.visibleLabels.splice(index, 1);\n    }\n  }\n};\n\nproto.hideEndpoints = function () {\n  for (var name in this.endpoints) {\n    if (this.endpoints.hasOwnProperty(name)) {\n      var endpoint = this.endpoints[name];\n      if (endpoint.label) {\n        this.hideLabel(endpoint.label);\n      }\n    }\n  }\n};\n\nproto.showEndpoints = function () {\n  for (var name in this.endpoints) {\n    if (this.endpoints.hasOwnProperty(name)) {\n      var endpoint = this.endpoints[name];\n      if (this.measurement.hasPick(name) && endpoint.label) {\n        this.showLabel(endpoint.label);\n      }\n    }\n  }\n};\n\nproto.hideLabel = function (label) {\n  if (label) {\n    MeasureCommon.safeToggle(label, 'visible', false);\n    this.updateVisibleLabelsArray(label, false);\n  }\n};\n\nproto.showLabel = function (label) {\n  if (label) {\n    MeasureCommon.safeToggle(label, 'visible', true);\n    this.updateVisibleLabelsArray(label, true);\n  }\n};\n\nproto.changeEndpointOnEditStyle = function (endpointNumber, isEditing) {\n  if (this.endpoints[endpointNumber] && this.endpoints[endpointNumber].label) {\n    MeasureCommon.safeToggle(this.endpoints[endpointNumber].label, 'on-edit', isEditing);\n  }\n};\n\nproto.changeEndpointEditableStyle = function (endpointNumber, isEditable) {\n  if (this.endpoints[endpointNumber] && this.endpoints[endpointNumber].label) {\n    MeasureCommon.safeToggle(this.endpoints[endpointNumber].label, 'editable', isEditable);\n  }\n};\n\nproto.changeAllEndpointsEditableStyle = function (isEditable) {\n  for (var name in this.endpoints) {\n    if (this.endpoints.hasOwnProperty(name)) {\n      this.changeEndpointEditableStyle(name, isEditable);\n    }\n  }\n};\n\nproto.changeAllEndpointsOnEditStyle = function (isEditing) {\n  for (var name in this.endpoints) {\n    if (this.endpoints.hasOwnProperty(name)) {\n      this.changeEndpointOnEditStyle(name, isEditing);\n    }\n  }\n};\n\nproto.hideLabelsOutsideOfView = function () {\n  // For each label, check if it's inside the camera viewport.\n  if (this.viewer.model && !this.viewer.model.is2d()) {\n    this.visibleLabels.forEach(function (label) {\n\n      // Ignore labels if position is not computed yet. This may temporarily happen, because label positions are not\n      // always immediately assigned. (see MeasureToolIndicator.js)\n      // Note that we must not set them to invisible here, because this may cause a hen-and-egg-problem: \n      // Some code sections in MeasureToolIndicator.updatePositions() don't set the label position for invisible labels.\n      if (!label.point) {\n        return;\n      }\n\n      var show = this.viewer.navigation.isPointVisible(label.point);\n\n      if (label.classList.contains('visible') && !show || !label.classList.contains('visible') && show) {\n        label.classList.toggle('visible', show);\n      }\n\n    }.bind(this));\n  }\n};\n\nproto.showClick = function (pickNumber) {\n  if (this.tool.getActivePointIndex() !== pickNumber) {\n    this.showLabel(this.endpoints[pickNumber].label);\n  }\n};\n\nproto.hideClick = function (pickNumber) {\n\n  if (this.endpoints[pickNumber]) {\n    this.hideLabel(this.endpoints[pickNumber].label);\n  }\n};\n\nproto.renderPick = function (pickNumber) {\n  if (!this.endpoints[pickNumber]) {\n    this.createEndpoint(pickNumber);\n  }\n\n  this.renderEndpointGeometry(pickNumber);\n  this.showClick(pickNumber);\n};\n\nproto.renderEndpointGeometry = function (pickNumber) {\n  var geometry = MeasureCommon.getSnapResultPosition(this.measurement.getPick(pickNumber), this.viewer);\n\n  if (geometry !== null) {\n    this.endpoints[pickNumber].position = geometry.clone();\n  }\n};\n\n\n// This is a workaround to deal with the limitation on linewidth on Windows due to the ANGLE library\nproto.drawEdgeAsCylinder = function (geom, material, linewidth, type, cylinderGeometry) {\n\n  // The array for all cylinders\n  var edge = [];\n  var cylinder;\n\n  if (type == 1) {// LinePieces\n    for (var i = 0; i < geom.vertices.length; i += 2) {\n      cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, linewidth, cylinderGeometry);\n      this.setCylinderScale(cylinder, geom.vertices[i], geom.vertices[i + 1]);\n      edge.push(cylinder);\n    }\n  } else\n  {// LineStrip\n    for (var i = 0; i < geom.vertices.length - 1; i++) {\n      cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, linewidth, cylinderGeometry);\n      this.setCylinderScale(cylinder, geom.vertices[i], geom.vertices[i + 1]);\n      edge.push(cylinder);\n    }\n  }\n\n\n  return edge;\n};\n\nproto.drawDashedLine = function (p1, p2, dashSize, gapSize, material, width, overlayName) {\n\n  var geometry = new THREE.Geometry();\n  var line = new THREE.Vector3().subVectors(p2, p1);\n  var lineLength = line.length() - gapSize;\n  var lineDirection = line.normalize();\n\n  var i = 0;\n  var pos = p1.clone();\n  var currLength = 0;\n\n  while (currLength < lineLength) {\n    var isPointVisible = this.viewer.navigation.isPointVisible(pos);\n\n    if (isPointVisible) {\n      geometry.vertices[i] = pos.clone();\n      i++;\n    }\n\n    pos.addVectors(pos, lineDirection.clone().multiplyScalar(dashSize));\n\n    if (isPointVisible) {\n      geometry.vertices[i] = pos.clone();\n      i++;\n    }\n\n    pos.addVectors(pos, lineDirection.clone().multiplyScalar(gapSize));\n\n    currLength += dashSize + gapSize;\n  }\n\n  line = this.drawEdgeAsCylinder(geometry, material, width, 1, this.getNewCylinderGeometry());\n  this.viewer.impl.addMultipleOverlays(overlayName, line);\n\n  return line;\n};\n\n// This is a workaround to deal with the limitation on linewidth on Windows due to the ANGLE library\nproto.drawLineAsCylinder = function (geom, material, linewidth, overlayName) {\n\n  var line;\n\n  if (geom.vertices.length == 2) {\n    line = this.cylinderMesh(geom.vertices[0], geom.vertices[1], material, linewidth, this.getNewCylinderGeometry());\n    this.setCylinderScale(line, geom.vertices[0], geom.vertices[1]);\n    this.viewer.impl.addOverlay(overlayName, line);\n  }\n\n  return line;\n};\n\nproto.getNewCylinderGeometry = function () {\n  return new THREE.CylinderGeometry(0.1, 0.1, 1, 8, 1, true);\n};\n\n\nproto.cylinderMesh = function (pointX, pointY, material, linewidth, cylinderGeometry) {\n\n  var direction = new THREE.Vector3().subVectors(pointY, pointX);\n  var orientation = new THREE.Matrix4();\n  orientation.lookAt(pointX, pointY, new THREE.Object3D().up);\n  orientation.multiply(new THREE.Matrix4().set(linewidth, 0, 0, 0,\n  0, 0, linewidth, 0,\n  0, -direction.length(), 0, 0,\n  0, 0, 0, 1));\n\n  var edge = new THREE.Mesh(cylinderGeometry, material);\n  edge.applyMatrix(orientation);\n  edge.lmv_line_width = linewidth;\n  edge.position.x = (pointY.x + pointX.x) / 2;\n  edge.position.y = (pointY.y + pointX.y) / 2;\n  edge.position.z = (pointY.z + pointX.z) / 2;\n\n  return edge;\n};\n\n// Set scale for cylinder\nproto.setCylinderScale = function (cylinderMesh, p1, p2) {\n  var scale;\n\n  if (p1 && p2) {\n    var point = MeasureCommon.nearestPointInPointToSegment(this.viewer.navigation.getPosition(), p1, p2);\n    scale = this.setScale(point);\n  } else {\n    scale = this.setScale(cylinderMesh.position);\n  }\n\n  if (cylinderMesh.hasOwnProperty(\"lmv_line_width\"))\n  scale *= cylinderMesh.lmv_line_width;\n  cylinderMesh.scale.x = scale;\n  cylinderMesh.scale.z = scale;\n};\n\n\n// Set scale for vertex and extension dashed line\nproto.setScale = function (point) {\n\n  var pixelSize = 5;\n\n  var navapi = this.viewer.navigation;\n  var camera = navapi.getCamera();\n  var position = navapi.getPosition();\n\n  var p = point.clone();\n\n  var distance = camera.isPerspective ? p.sub(position).length() :\n  navapi.getEyeVector().length();\n\n  var fov = navapi.getVerticalFov();\n  var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n  var viewport = navapi.getScreenViewport();\n  var scale = pixelSize * worldHeight / viewport.height;\n\n  return scale;\n};\n\nproto.alignLabelWithLine = function (label, p1, p2, offset, viewer) {\n  var camUpVector = viewer.navigation.getCameraUpVector();\n  var worldUpVec = new THREE.Vector3(0, 1, 0);\n  var cameraAngle = worldUpVec.angleTo(camUpVector) * 180 / Math.PI;\n\n  cameraAngle = camUpVector.x >= 0 ? cameraAngle : -cameraAngle;\n\n  var angle = null;\n\n  var deltaX = p1.x - p2.x;\n  var deltaY = p1.y - p2.y;\n\n  if (p1.x < p2.x) {\n    angle = Math.atan2(-deltaY, -deltaX) * 180 / Math.PI;\n  } else\n  {\n    angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;\n  }\n\n  angle = -(angle + cameraAngle);\n\n  if (Math.abs(angle) > 90) {\n    angle = angle + 180;\n  }\n\n  label.style.transform = 'rotate(' + angle + 'deg) translate(0px, ' + offset + 'px)';\n};\n\nproto.destroy = function () {\n  this.materialPoint = null;\n  this.materialFace = null;\n  this.materialLine = null;\n  this.materialAngle = null;\n\n  if (av.isTouchDevice()) {\n    this.clearLabelMobileGestures();\n  }\n\n  for (var name in this.endpoints) {\n    if (this.endpoints.hasOwnProperty(name)) {\n      var endPoint = this.endpoints[name];\n\n      if (endPoint.label) {\n        endPoint.label.removeEventListener(av.isSafari() ? 'mousedown' : 'pointerdown', this.onMouseClickBinded);\n        endPoint.label.removeEventListener('mousewheel', this.viewer.toolController.mousewheel);\n        endPoint.label.parentNode.removeChild(endPoint.label);\n        endPoint.label = null;\n      }\n    }\n  }\n\n  this.visibleLabels = [];\n};\n\nproto.renderRubberbandFromPoints = function (pointData) {\n  var keys = Object.keys(pointData);\n  var intersectionPoints = [];\n  for (var i = 0; i < keys.length; i++) {\n    intersectionPoints.push(pointData[keys[i]].intersection);\n  }\n  switch (this.measurement.measurementType) {\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE:\n      var start = pointData[1].intersection;\n      var end = pointData[2].intersection;\n      if (start && end) {\n        this.renderDistanceMeasurementFromPoints(start, end);\n      }\n      break;\n\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_ANGLE:\n      this.renderAngleMeasurementFromPoints(intersectionPoints);\n      break;\n\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_AREA:\n      this.renderAreaMeasurementFromPoints(intersectionPoints);\n      break;\n\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_ARC:\n      var p1 = pointData[1].intersection;\n      var p2 = pointData[2].intersection;\n      var center = pointData[1].circularArcCenter;\n      var radius = pointData[1].circularArcRadius;\n      // Render the arc measurement from the intersection points, center and radius.\n      this.renderArcMeasurementFromPoints(p1, p2, center, radius);\n      break;\n\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_LOCATION:\n      this.renderLocationMeasurementFromPoints(intersectionPoints);\n      break;\n\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_CALLOUT:\n      this.renderCalloutMeasurementFromPoints(intersectionPoints);\n      break;}\n\n\n};\n\nproto.renderRubberband = function (picks) {\n\n  switch (this.measurement.measurementType) {\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE:\n      var previewsPick = picks[1];\n      var activePick = picks[2];\n      var start = MeasureCommon.getSnapResultPosition(previewsPick, this.viewer);\n      var end = MeasureCommon.getSnapResultPosition(activePick, this.viewer);\n\n      if (start && end) {\n        this.renderDistanceMeasurement(start, end);\n      }\n      break;\n\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_ANGLE:\n      this.renderAngleMeasurement(picks);\n      break;\n\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_AREA:\n      this.renderAreaMeasurement(picks);\n      break;\n\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_ARC:\n      var previewsPick = picks[1];\n      var activePick = picks[2];\n\n      if (previewsPick && activePick) {\n        this.renderArcMeasurement(previewsPick, activePick);\n      }\n      break;\n\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_LOCATION:\n      this.renderLocationMeasurement(picks);\n      break;\n\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_CALLOUT:\n      this.renderCalloutMeasurement(picks);\n      break;}\n\n};\n\nproto.initMouseEvent = function (label, pointNumber) {\n\n  var isSafari = av.isSafari();\n  this.onMouseClickBinded = function (event) {\n    if (isSafari || event.pointerType === 'mouse') {\n      event.canvasX = event.clientX;\n      event.canvasY = event.clientY;\n      this.tool.editEndpoint(event, pointNumber, this.measurement.id);\n    }\n  }.bind(this);\n  label.addEventListener(isSafari ? 'mousedown' : 'pointerdown', this.onMouseClickBinded);\n};","\nvar av = Autodesk.Viewing;\n\nexport var MagnifyingGlass = function MagnifyingGlass(viewer) {\n\n  var _viewer = viewer;\n  var _active = false;\n  var _names = [\"magnifyingGlass\"];\n  var _priority = 70;\n  var _isPressing = false;\n  var _radius = 60;\n  var _zoom = 2;\n  var _offset = 15;\n  var _magnifyingGlassCanvas = null;\n  var _imageData = null;\n  var _imageBuffer = null;\n  var _clientX = null;\n  var _clientY = null;\n  var _needsClear = false;\n  var av = Autodesk.Viewing;\n\n  this.setGlobalManager(viewer.globalManager);\n\n  this.register = function () {\n    this.updateMagnifyingGlassBinded = this.updateMagnifyingGlass.bind(this);\n  };\n\n  this.isActive = function () {\n    return _active;\n  };\n\n  this.activate = function () {\n    _active = true;\n  };\n\n  this.updateMagnifyingGlass = function () {\n    var _window = this.getWindow();\n    var _document = this.getDocument();\n    if (_needsClear) {\n      _magnifyingGlassCanvas && _magnifyingGlassCanvas.classList.remove('visible');\n      _needsClear = false;\n    } else\n    {\n      var pixelRatio = _window.devicePixelRatio;\n      var diameter = 2 * _radius;\n      var normlizedDiameter = diameter * pixelRatio;\n      var x = pixelRatio * (_clientX - _radius / _zoom);\n      var y = pixelRatio * (_clientY - _radius / _zoom);\n\n      if (!_magnifyingGlassCanvas) {\n        _magnifyingGlassCanvas = _document.createElement(\"canvas\");\n        _magnifyingGlassCanvas.className = 'magnifying-glass';\n        _magnifyingGlassCanvas.width = normlizedDiameter;\n        _magnifyingGlassCanvas.height = normlizedDiameter;\n        _magnifyingGlassCanvas.style.width = diameter + 'px';\n        _magnifyingGlassCanvas.style.height = diameter + 'px';\n\n        // Swap canvas\n        _magnifyingGlassCanvas.getContext(\"2d\").translate(0, normlizedDiameter);\n        _magnifyingGlassCanvas.getContext(\"2d\").scale(1, -1);\n\n        _viewer.container.appendChild(_magnifyingGlassCanvas);\n        _imageData = _magnifyingGlassCanvas.getContext(\"2d\").createImageData(Math.ceil(normlizedDiameter / _zoom), Math.ceil(normlizedDiameter / _zoom));\n        _imageBuffer = new Uint8Array(_imageData.data.buffer);\n      }\n\n      var ctx = _magnifyingGlassCanvas.getContext(\"2d\");\n\n      // Read the pixels from the frame buffer\n      var gl = _viewer.impl.glrenderer().getContext();\n      gl.readPixels(x, _viewer.canvas.height - y - _imageData.height, _imageData.width, _imageData.height, gl.RGBA, gl.UNSIGNED_BYTE, _imageBuffer);\n      // Put the pixel into the magnifying context.\n      ctx.putImageData(_imageData, 0, 0);\n      // Scale the image\n      ctx.drawImage(_magnifyingGlassCanvas, 0, 0, _imageData.width, _imageData.height, 0, 0, normlizedDiameter, normlizedDiameter);\n      this.setGlassPosition(_magnifyingGlassCanvas, _clientX, _clientY, diameter, _offset);\n\n      _magnifyingGlassCanvas.classList.toggle('visible', true);\n    }\n  };\n\n  this.deactivate = function () {\n    this.clearMagnifyingGlass();\n    _active = false;\n  };\n\n  this.getNames = function () {\n\n    return _names;\n  };\n\n  this.getName = function () {\n\n    return _names[0];\n  };\n\n  this.getPriority = function () {\n    return _priority;\n  };\n\n  this.setGlassPosition = function (canvas, x, y, diameter, offset) {\n\n    // check the left border of canvas\n    canvas.style.left = x - diameter / 2 + 'px';\n\n    // check the top border of canvas\n    if (y - diameter - offset > 0) {\n      canvas.style.top = y - diameter - offset + 'px';\n    } else\n    {\n      canvas.style.top = y + offset + 'px';\n    }\n  };\n\n  this.requestUpdate = function () {\n    if (!_viewer.hasEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.updateMagnifyingGlassBinded)) {\n      _viewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.updateMagnifyingGlassBinded, { once: true });\n    }\n  };\n\n  this.drawMagnifyingGlass = function (clientX, clientY) {\n    _needsClear = false;\n    _clientX = clientX;\n    _clientY = clientY;\n    _viewer.impl.invalidate(false, false, true);\n    this.requestUpdate();\n  };\n\n  this.clearMagnifyingGlass = function () {\n    _needsClear = true;\n    this.requestUpdate();\n  };\n\n  this.handlePressHold = function (event) {\n\n    if (av.isTouchDevice()) {\n      switch (event.type) {\n\n        case \"press\":\n          _isPressing = true;\n          this.drawMagnifyingGlass(event.canvasX, event.canvasY);\n          break;\n\n        case \"pressup\":\n          this.clearMagnifyingGlass();\n          _isPressing = false;\n          break;}\n\n    }\n    return false;\n\n  };\n\n  this.handleGesture = function (event) {\n\n    if (_isPressing && av.isTouchDevice()) {\n      switch (event.type) {\n\n        case \"dragstart\":\n          this.drawMagnifyingGlass(event.canvasX, event.canvasY);\n          break;\n\n        case \"dragmove\":\n          this.drawMagnifyingGlass(event.canvasX, event.canvasY);\n          break;\n\n        case \"dragend\":\n          this.clearMagnifyingGlass();\n          _isPressing = false;\n          break;\n\n        case \"pinchstart\":\n          this.drawMagnifyingGlass(event.canvasX, event.canvasY);\n          break;\n\n        case \"pinchmove\":\n          this.drawMagnifyingGlass(event.canvasX, event.canvasY);\n          break;\n\n        case \"pinchend\":\n          this.clearMagnifyingGlass();\n          break;}\n\n    }\n\n    return false;\n  };\n\n  this.handleMouseMove = function (event) {\n    return false;\n  };\n\n  this.handleWheelInput = function (delta) {\n    return false;\n  };\n\n  this.handleButtonUp = function (event, button) {\n    return false;\n  };\n\n};\n\nav.GlobalManagerMixin.call(MagnifyingGlass.prototype);","\nvar content = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Measure.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Measure.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Measure.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}import { MeasureTool } from './MeasureTool';\nimport { CalibrationTool } from './CalibrationTool';\nimport { MagnifyingGlass } from './MagnifyingGlass';\nimport { CalibrationRequiredDialog } from './CalibrationPanels';\nimport { MeasureToolbar } from './MeasureToolbar';\n\n\nimport './Measure.css'; // IMPORTANT!!\nimport './Calibration.css'; // IMPORTANT!!\n\n'use strict';\n\nvar avem = AutodeskNamespace('Autodesk.Viewing.Extensions.Measure'),\nav = Autodesk.Viewing,\navp = Autodesk.Viewing.Private,\navu = av.UI;\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon; // Comes form main viewer bundle.\n\nvar NONE = 0;\nvar MEASURE_TOOL = 1;\nvar CALIBRATION_TOOL = 2;\n\nvar DEFAULT_MEASUREMENT_TYPE = MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE;\n\n/**\n                                                                                     * Provides UI controls to perform distance and angle measurements for 2D and 3D models.\n                                                                                     *\n                                                                                     * The extension id is: `Autodesk.Measure`\n                                                                                     *\n                                                                                     * @param {Viewer3D} viewer - Viewer instance\n                                                                                     * @param {object} options - Configurations for the extension\n                                                                                     * @example \n                                                                                     * viewer.loadExtension('Autodesk.Measure')\n                                                                                     * @memberof Autodesk.Viewing.Extensions\n                                                                                     * @alias Autodesk.Viewing.Extensions.MeasureExtension\n                                                                                     * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                                                                                     * @class\n                                                                                     */\nexport var MeasureExtension = function MeasureExtension(viewer, options) {\n  Autodesk.Viewing.Extension.call(this, viewer, options);\n  this.modes = ['distance', 'angle', 'area', 'arc', 'calibrate'];\n  this.name = 'measure';\n  this._onModelLoaded = this._onModelLoaded.bind(this);\n  this._onDisplayUnitsPrefChanged = this._onDisplayUnitsPrefChanged.bind(this);\n  this._onPrecisionPrefChanged = this._onPrecisionPrefChanged.bind(this);\n};\n\nMeasureExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nMeasureExtension.prototype.constructor = MeasureExtension;\n\n\n/**\n                                                            * Load the measure extension.\n                                                            *\n                                                            * @returns {boolean} True if measure extension is loaded successfully.\n                                                            * \n                                                            * @alias Autodesk.Viewing.Extensions.MeasureExtension#load\n                                                            */\nMeasureExtension.prototype.load = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this = this;var self, viewer, measureToolOptions, onToolChangedCb;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n\n            this.viewer.loadExtension('Autodesk.Snapping'));case 2:\n\n          self = this;\n          viewer = this.viewer;\n          this.hasUI = Autodesk.Viewing.GuiViewer3D && viewer instanceof Autodesk.Viewing.GuiViewer3D;\n\n          this.escapeHotkeyId = 'Autodesk.Measure.Hotkeys.Escape';\n\n          // Register the Measure tool\n          if (viewer.toolController) {_context.next = 8;break;}return _context.abrupt(\"return\",\n          false);case 8:\n\n\n          this.options = this.options || {};\n          measureToolOptions = {};\n\n          measureToolOptions.onCloseCallback = function () {\n            self.enableMeasureTool(false);\n          };\n\n          // Shared State with measureTool & calibrationTool.\n          // Gets populated when a model is received.\n          this.sharedMeasureConfig = {\n            units: null,\n            precision: null,\n            calibrationFactor: null };\n\n\n          measureToolOptions.snapperOptions = this.options.snapperOptions;\n\n          this.forceCalibrate = this.options.forceCalibrate;\n\n          this.snapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer, {\n            renderSnappedTopology: true });\n\n          viewer.toolController.registerTool(this.snapper);\n\n          onToolChangedCb = function onToolChangedCb(enable) {\n            _this.setActive(enable);\n            if (!enable) {\n              _this.deactivate();\n            }\n          };\n\n          this.measureTool = new MeasureTool(viewer, measureToolOptions, this.sharedMeasureConfig, this.snapper);\n          viewer.toolController.registerTool(this.measureTool, onToolChangedCb);\n\n          this.calibrationTool = new CalibrationTool(viewer, this.options, this.sharedMeasureConfig, this.snapper);\n          viewer.toolController.registerTool(this.calibrationTool, onToolChangedCb);\n\n          this.magnifyingGlass = new MagnifyingGlass(viewer);\n          viewer.toolController.registerTool(this.magnifyingGlass);\n\n          this.calibration = {};\n          this.onFinishedCalibration = function (event) {\n            if (self.measureToolbar) {\n              self.measureToolbar.updateSettingsPanel();\n            }\n\n            self.activateInitiator && self.activateInitiator();\n\n            // Set the calibration values\n            self.calibration.units = event.units;\n            self.calibration.scaleFactor = event.scaleFactor;\n            self.calibration.size = event.size;\n            self.calibration.precision = self.sharedMeasureConfig.precision;\n          };\n\n          viewer.addEventListener('finished-calibration', this.onFinishedCalibration);\n\n          this.onMeasurementChanged = function (event) {\n            var type = event.data.type;\n            self.changeMeasurementType(type);\n          };\n\n          viewer.addEventListener(MeasureCommon.Events.MEASUREMENT_CHANGED_EVENT, this.onMeasurementChanged);\n\n          if (viewer.model) {\n            this._onModelLoaded({ model: viewer.model });\n          } else {\n            viewer.addEventListener(av.MODEL_ROOT_LOADED_EVENT, this._onModelLoaded, { once: true });\n          }\n\n          // If there is no model anymore, interrupt any ongoing interaction.\n          // We need at least one model to derive things like is2d() and model units.\n          this.onModelRemoved = function () {\n            // If UI was not created yet or destroyed, we don't have to disable anything\n            if (!self.measurementToolbarButton) {\n              return;\n            }\n\n            if (!self.viewer.model) {\n              self.measurementToolbarButton.setState(Autodesk.Viewing.UI.Button.State.DISABLED);\n              self.exitMeasurementMode();\n            }\n          };\n          this.onModelAdded = function () {\n\n            // If UI was not created yet or destroyed, the button will be enabled in next createUI() call\n            if (!self.measurementToolbarButton) {\n              return;\n            }\n\n            // On first model-add, re-enable measure toolbar again\n            var modelCount = self.viewer.getVisibleModels().length;\n            if (modelCount === 1 && self.measurementToolbarButton) {\n              self.measurementToolbarButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);\n            }\n          };\n          viewer.addEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);\n          viewer.addEventListener(av.MODEL_REMOVED_EVENT, this.onModelRemoved);\n\n          this.viewer.prefs.addListeners(avp.Prefs.DISPLAY_UNITS, this._onDisplayUnitsPrefChanged, this._onDisplayUnitsPrefChanged);\n          this.viewer.prefs.addListeners(avp.Prefs.DISPLAY_UNITS_PRECISION, this._onPrecisionPrefChanged, this._onPrecisionPrefChanged);case 35:case \"end\":return _context.stop();}}}, _callee, this);}));\n\n\n/**\n                                                                                                                                                                                                            * @param {string} value - unit\n                                                                                                                                                                                                            * @private\n                                                                                                                                                                                                            */\nMeasureExtension.prototype._onDisplayUnitsPrefChanged = function (value) {\n  if (value !== '') {\n    this.setUnits(value);\n    this.measureToolbar.updateSettingsPanel();\n    // Also update the units in calibration panel\n    this.calibrationTool.updateCalibrationPanel();\n  }\n};\n\n/**\n    * @param {string} value precision\n    * @private\n    */\nMeasureExtension.prototype._onPrecisionPrefChanged = function (value) {\n  if (typeof value === 'number') {\n    this.setPrecision(value);\n    this.measureToolbar.updateSettingsPanel();\n  }\n};\n\nMeasureExtension.prototype._onModelLoaded = function (event) {\n  var model = event.model;\n\n  var setPdfUnits = !!model.isPdf(true) && !this.viewer.prefs.get(avp.Prefs2D.FORCE_PDF_CALIBRATION);\n  var setLeafletUnits = !!model.isLeaflet() && !this.viewer.prefs.get(avp.Prefs2D.FORCE_LEAFLET_CALIBRATION);\n\n  this.sharedMeasureConfig.units = this.options.calibrationUnits || this.viewer.prefs.get(avp.Prefs.DISPLAY_UNITS) || model.getDisplayUnit();\n\n  // Set the units to points only for pdf and leaflet models that do not contain model units in the metadata.\n  if ((setPdfUnits || setLeafletUnits) && !model.getMetadata('page_dimensions', 'model_units', null)) {\n    this.sharedMeasureConfig.units = 'pt';\n  }\n\n  var precisionPreference = this.viewer.prefs.get(avp.Prefs.DISPLAY_UNITS_PRECISION);\n  if (typeof precisionPreference === 'number') {\n    this.sharedMeasureConfig.precision = precisionPreference;\n  } else {\n    this.sharedMeasureConfig.precision = model.is2d() ? 3 : 1;\n  }\n\n  if (this.options.calibrationUnits && !isNaN(this.options.calibrationFactor)) {\n    this.calibrationTool.calibrateByScale(this.options.calibrationUnits, this.options.calibrationFactor);\n  }\n};\n\n/**\n    * Unload the measure extension.\n    *\n    * @returns {boolean} True if measure extension is unloaded successfully.\n    * \n    * @alias Autodesk.Viewing.Extensions.MeasureExtension#unload\n    */\nMeasureExtension.prototype.unload = function () {\n  var viewer = this.viewer;\n\n  // Remove the ui from the viewer.\n  this.destroyUI();\n\n  viewer.removeEventListener('finished-calibration', this.onFinishedCalibration);\n  viewer.removeEventListener(MeasureCommon.Events.MEASUREMENT_CHANGED_EVENT, this.onMeasurementChanged);\n  viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.onModelAdded);\n  viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.onModelRemoved);\n  viewer.removeEventListener(av.MODEL_ROOT_LOADED_EVENT, this._onModelLoaded);\n\n  viewer.toolController.deregisterTool(this.snapper);\n  this.snapper = null;\n\n  viewer.toolController.deregisterTool(this.measureTool);\n  this.measureTool = null;\n\n  viewer.toolController.deregisterTool(this.calibrationTool);\n  this.calibrationTool = null;\n\n  viewer.toolController.deregisterTool(this.magnifyingGlass);\n  this.magnifyingGlass = null;\n\n  this.unloaded = true;\n\n  viewer.prefs.removeListeners(avp.Prefs.DISPLAY_UNITS, this._onDisplayUnitsPrefChanged, this._onDisplayUnitsPrefChanged);\n  viewer.prefs.removeListeners(avp.Prefs.DISPLAY_UNITS_PRECISION, this._onPrecisionPrefChanged, this._onPrecisionPrefChanged);\n\n  return true;\n};\n\n/**\n    * Enable/disable the measure tool.\n    * It does not update the toolbar UI.\n    * \n    * @param {boolean} active - True to activate, false to deactivate.\n    * @returns {boolean} True if a change in activeness occurred.\n    */\nMeasureExtension.prototype.setActive = function (active) {\n  return this.enableMeasureTool(active);\n};\n\n/**\n    * Toggles activeness of the measure tool.\n    * It does not update the toolbar UI.\n    * \n    * @returns {boolean} Whether the tool is active.\n    */\nMeasureExtension.prototype.toggle = function () {\n  if (this.isActive()) {\n    this.enableMeasureTool(false);\n  } else {\n    this.enableMeasureTool(true);\n  }\n  return this.isActive();\n};\n\n/**\n    * Get the current measurement in the measure tool.\n    *\n    * @param {string} [unitType] - Either: \"decimal-ft\", \"ft\", \"ft-and-decimal-in\", \"decimal-in\", \"fractional-in\", \"m\", \"cm\", \"mm\" or \"m-and-cm\".\n    * @param {number} [precision] - precision index (0: 0, 1: 0.1, 2: 0.01, 3: 0.001, 4: 0.0001, 5: 0.00001).\n    * When units type is \"ft\", \"in\" or \"fractional-in\", then the precisions are 0: 1, 1: 1/2, 2: 1/4, 3: 1/8, 4: 1/16, 5: 1/32, 6: 1/64.\n    * @returns {object|null} Object with properties of the current measurement, or null.\n    * @alias Autodesk.Viewing.Extensions.MeasureExtension#getMeasurement\n    */\nMeasureExtension.prototype.getMeasurement = function (unitType, precision) {\n  var measurement = null;\n  if (this.measureTool.isActive()) {\n    measurement = this.measureTool.getMeasurement(unitType, precision);\n  }\n  return measurement;\n};\n\n/**\n    * Get a list of all the measurements that are currently on the screen.\n    *\n    * @param {string} [unitType] - Either: \"decimal-ft\", \"ft\", \"ft-and-decimal-in\", \"decimal-in\", \"fractional-in\", \"m\", \"cm\", \"mm\" or \"m-and-cm\".\n    * @param {number} [precision] - precision index (0: 0, 1: 0.1, 2: 0.01, 3: 0.001, 4: 0.0001, 5: 0.00001).\n    * When units type is \"ft\", \"in\" or \"fractional-in\", then the precisions are 0: 1, 1: 1/2, 2: 1/4, 3: 1/8, 4: 1/16, 5: 1/32, 6: 1/64.\n    * @returns {Array.<object>} An array of measurement objects with properties of the measurement.\n    * @alias Autodesk.Viewing.Extensions.MeasureExtension#getMeasurementList\n    */\n\nMeasureExtension.prototype.getMeasurementList = function (unitType, precision) {\n  var measurementList = [];\n  if (this.measureTool.isActive()) {\n    measurementList = this.measureTool.getMeasurementList(unitType, precision);\n  }\n  return measurementList;\n};\n\n/**\n    * Restores existing measurements. The `measurements` object should be generated by either the {@link Autodesk.Viewing.Extensions.MeasureExtension#getMeasurementList|getMeasurementList} or the {@link Autodesk.Viewing.Extensions.MeasureExtension#getMeasurement|getMeasurement} methods.\n    *\n    * @param {object[] | object} measurements - An array of measurement objects\n    * @alias Autodesk.Viewing.Extensions.MeasureExtension#setMeasurements\n    */\nMeasureExtension.prototype.setMeasurements = function (measurements) {\n  if (this.measureTool.isActive()) {\n    this.measureTool.setMeasurements(measurements);\n  }\n};\n\n\n/**\n    * Get all available units in measure tool.\n    *\n    * @returns {object[]} Array of all available units.\n    */\nMeasureExtension.prototype.getUnitOptions = function () {\n  var units = [\n  { name: 'Unknown', type: '' },\n  { name: 'Decimal feet', type: 'decimal-ft' },\n  { name: 'Feet and fractional inches', type: 'ft' },\n  { name: 'Feet and decimal inches', type: 'ft-and-decimal-in' },\n  { name: 'Decimal inches', type: 'decimal-in' },\n  { name: 'Fractional inches', type: 'fractional-in' },\n  { name: 'Meters', type: 'm' },\n  { name: 'Centimeters', type: 'cm' },\n  { name: 'Millimeters', type: 'mm' },\n  { name: 'Meters and centimeters', type: 'm-and-cm' },\n  { name: 'Points', type: 'pt' }];\n\n\n  return units;\n};\n\n/**\n    * Get all available precisions in measure tool.\n    *\n    * @param {boolean} isFractional - Set true to get fractional precisions.\n    * @returns {string[]} List of all available precisions.\n    */\nMeasureExtension.prototype.getPrecisionOptions = function (isFractional) {\n\n  var precisions;\n\n  if (isFractional)\n  precisions = ['1', '1/2', '1/4', '1/8', '1/16', '1/32', '1/64'];else\n\n  precisions = ['0', '0.1', '0.01', '0.001', '0.0001', '0.00001'];\n\n  return precisions;\n};\n\n/**\n    * Get the default measure unit in measure tool.\n    *\n    * @returns {string} The default measure unit.\n    */\nMeasureExtension.prototype.getDefaultUnit = function () {\n  var unit = this.viewer.model.getDisplayUnit();\n\n  return unit;\n};\n\nMeasureExtension.prototype.openCalibrationRequiredDialog = function (initiator) {\n  if (this.hasUI) {\n    if (!this.CalibrationRequiredDialog) {\n      this.CalibrationRequiredDialog = new CalibrationRequiredDialog(this, this.viewer, \"calibration-required\", \"Calibration Required\", this.options);\n    }\n\n    this.CalibrationRequiredDialog.setVisible(true);\n  } else\n  {\n    this.viewer.dispatchEvent({ type: MeasureCommon.Events.CALIBRATION_REQUIRED_EVENT });\n  }\n\n  if (initiator === 'measure') {\n    this.activateInitiator = function () {\n      this.enableMeasureTool(true, DEFAULT_MEASUREMENT_TYPE);\n      this.activateInitiator = null;\n    };\n  } else if (initiator === 'dimension') {\n    this.activateInitiator = function () {\n      this.viewer.dispatchEvent({ type: MeasureCommon.Events.FINISHED_CALIBRATION_FOR_DIMENSION_EVENT });\n      this.activateInitiator = null;\n    };\n  }\n};\n\n/**\n    * Get the calibration size, unit type and the calibration Factor of the model\n    *\n    * @returns {object}\n    */\nMeasureExtension.prototype.getCalibration = function () {\n  return this.calibration;\n};\n\n\n/**\n    * @param mode Measurement Mode\n    * @returns {boolean}\n    */\n\n/**\n        * Activates the tool and UI to start measuring.\n        * \n        * @param {string} [mode] - Either 'distance', 'angle', 'area' (2D only), 'arc' (2D only) or 'calibrate'. Default is 'distance'.\n        * \n        * @alias Autodesk.Viewing.Extensions.MeasureExtension#activate\n        */\nMeasureExtension.prototype.activate = function (mode) {\n  if (this.activeStatus && this.mode === mode) {\n    return true;\n  }\n\n  this.enterMeasurementMode();\n\n  var success;\n\n  switch (mode) {\n    default:\n      mode = 'distance';\n    // falls through\n    case 'distance':\n      success = this.enableMeasureTool(true, MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE);\n      break;\n    case 'angle':\n      success = this.enableMeasureTool(true, MeasureCommon.MeasurementTypes.MEASUREMENT_ANGLE);\n      break;\n    case 'area':\n      if (!this.viewer.model.is2d()) {\n        console.warn('Area mode is applicable on 2D models only');\n      } else {\n        success = this.enableMeasureTool(true, MeasureCommon.MeasurementTypes.MEASUREMENT_AREA);\n      }\n      break;\n    case 'arc':\n      if (!this.viewer.model.is2d() || this.viewer.model.isPdf()) {\n        console.warn('Arc mode is applicable on 2D models only');\n      } else {\n        success = this.enableMeasureTool(true, MeasureCommon.MeasurementTypes.MEASUREMENT_ARC);\n      }\n      break;\n    case 'calibrate':\n      success = this.enableCalibrationTool(true);\n      break;}\n\n\n\n  this.mode = success ? mode : '';\n  this.activeStatus = true;\n  return true;\n};\n\n/**\n    * Deactivates measuring tool and UI.\n    * \n    * @returns {boolean}\n    * \n    * @alias Autodesk.Viewing.Extensions.MeasureExtension#deactivate\n    */\nMeasureExtension.prototype.deactivate = function () {\n  if (this.activeStatus) {\n    this.exitMeasurementMode();\n    this.enableMeasureTool(false);\n    this.activeStatus = false;\n  }\n  return true;\n};\n\n/**\n    * Force the calibration panel for pdf models\n    *\n    * @param {boolean} enable - true to force the calibration panel\n    */\nMeasureExtension.prototype.setForcePDFCalibrate = function (enable) {\n  this.viewer.prefs.set(avp.Prefs2D.FORCE_PDF_CALIBRATION, enable);\n};\n\n/**\n    * Force the calibration panel for leaflet models\n    *\n    * @param {boolean} enable - true to force the calibration panel\n    */\nMeasureExtension.prototype.setForceLeafletCalibrate = function (enable) {\n  this.viewer.prefs.set(avp.Prefs2D.FORCE_LEAFLET_CALIBRATION, enable);\n};\n\n/**\n    * Restore session measurements when enabling the measure tool.\n    *\n    * @param {boolean} enable - true to restore session measurements. \n    */\nMeasureExtension.prototype.setRestoreSessionMeasurements = function (enable) {\n  this.viewer.prefs.set(avp.Prefs.RESTORE_SESSION_MEASUREMENTS, enable);\n};\n\n/**\n    * Enable/disable the measure tool.\n    *\n    * @param {boolean} enable - True to enable, false to disable.\n    * @param measurementType\n    * @returns {boolean} True if the tool state was changed.\n    * @private\n    */\nMeasureExtension.prototype.enableMeasureTool = function (enable, measurementType) {var _this$viewer$model;\n  if (measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_AREA && this.viewer.model && !this.viewer.model.is2d()) {\n    return false;\n  }\n\n  // arc measurement is not supported for 3D models\n  if (measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_ARC && this.viewer.model && !this.viewer.model.is2d()) {\n    return false;\n  }\n\n  var snapToArc = measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_ARC && ((_this$viewer$model = this.viewer.model) === null || _this$viewer$model === void 0 ? void 0 : _this$viewer$model.is2d());\n  this.snapper.setSnapToArc(snapToArc);\n\n  var toolController = this.viewer.toolController,\n  isActive = this.selectedTool === MEASURE_TOOL;\n\n  if (!this.viewer.model || !enable && isActive) {\n    if (this.measureTool.isActive()) {\n      toolController.deactivateTool(\"measure\");\n\n      if (this.measureToolbar) {\n        this.measureToolbar.deactivateAllButtons();\n      }\n\n      // No tool is active anymore. Only do this if measureTool was really the active one before.\n      // If not, changing selectedTool would produce an inconsistent state, e.g., CalibrationTool \n      // may still be active, but enableCalibrationTool(false) would not properly close it.\n      this.selectedTool = NONE;\n    }\n\n    return true;\n  }\n\n  var is2d = this.viewer.impl.is2d;\n  var forcePDFCalibration = is2d && this.viewer.model.isPdf(true) && this.viewer.prefs.get(avp.Prefs2D.FORCE_PDF_CALIBRATION);\n  var forceLeafletCalibration = is2d && this.viewer.model.isLeaflet() && this.viewer.prefs.get(avp.Prefs2D.FORCE_LEAFLET_CALIBRATION);\n\n  this.forceCalibrate |= forceLeafletCalibration || forcePDFCalibration;\n\n  if (!measurementType) {\n    measurementType = DEFAULT_MEASUREMENT_TYPE;\n  }\n\n  if (enable && !isActive) {\n    // Fetch topology when opening Measure tool for the first time.\n    this.checkAndFetchTopology(toolController.getTool('measure'));\n\n    if (!this.forceCalibrate || this.forceCalibrate && this.calibrationTool.isCalibrated() || measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_ANGLE) {\n      if (this.calibrationTool.isActive()) {\n        toolController.deactivateTool(\"calibration\");\n      }\n\n      if (this.measureToolbar) {\n        this.measureToolbar.updateSettingsPanel();\n      }\n\n      toolController.activateTool(\"measure\");\n\n      this.selectedTool = MEASURE_TOOL;\n\n\n\n      this.changeMeasurementType(measurementType);\n      return true;\n    } else\n    {\n      this.viewer.addEventListener(avem.OPEN_TOOL_AFTER_CALIBRAION, function () {\n        this.enableMeasureTool(true);\n      }.bind(this), { once: true });\n\n      this.openCalibrationRequiredDialog('measure');\n      return false;\n    }\n\n  } else if (enable && isActive) {\n    if (!this.forceCalibrate || this.forceCalibrate && this.calibrationTool.isCalibrated() || measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_ANGLE) {\n      this.changeMeasurementType(measurementType);\n      return true;\n    } else\n    {\n      this.openCalibrationRequiredDialog('measure');\n      return false;\n    }\n  }\n\n  return false;\n};\n\nMeasureExtension.prototype.changeMeasurementType = function (measurementType) {\n  this.measureTool.changeMeasurementType(measurementType);\n  if (this.measureToolbar) {\n    this.measureToolbar.deactivateAllButtons();\n    this.measureToolbar.activateButtonByType(measurementType);\n  }\n\n  switch (measurementType) {\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE:\n      this.mode = 'distance';\n      break;\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_ANGLE:\n      this.mode = 'angle';\n      break;\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_AREA:\n      this.mode = 'area';\n      break;\n    case MeasureCommon.MeasurementTypes.MEASUREMENT_ARC:\n      this.mode = 'arc';\n      break;\n    default:\n      this.mode = '';}\n\n};\n\n/**\n    * When enabled, the Viewer will only render model parts that are included in\n    * measurements.\n    *\n    * @param {boolean} enable - true to render only nodes being measured.\n    * \n    * @alias Autodesk.Viewing.Extensions.MeasureExtension#setIsolateMeasure\n    */\nMeasureExtension.prototype.setIsolateMeasure = function (enable) {\n  this.measureTool.setIsolateMeasure(enable);\n  if (enable) {\n    this.measureTool.isolateMeasurement();\n  } else {\n    this.measureTool.clearIsolate();\n  }\n};\n\n/**\n    * Enable/disable the measure tool.\n    *\n    * @param {boolean} enable - True to enable, false to disable.\n    * @returns {boolean} True if the tool state was changed.\n    * @private\n    */\nMeasureExtension.prototype.enableCalibrationTool = function (enable) {\n  var toolController = this.viewer.toolController,\n  isActive = this.selectedTool == CALIBRATION_TOOL;\n\n  if (enable && !isActive) {\n    if (this.measureTool.isActive()) {\n      toolController.deactivateTool(\"measure\");\n    }\n\n    toolController.activateTool(\"calibration\");\n    this.viewer.dispatchEvent({ type: MeasureCommon.Events.UNITS_CALIBRATION_STARTS_EVENT });\n\n    if (this.measureToolbar) {\n      this.measureToolbar.deactivateAllButtons();\n      this.measureToolbar.activateButtonByType(MeasureCommon.MeasurementTypes.CALIBRATION);\n    }\n\n    this.selectedTool = CALIBRATION_TOOL;\n    return true;\n\n  } else if (!enable && isActive) {\n    if (this.calibrationTool.isActive()) {\n      this.mode = '';\n      toolController.deactivateTool(\"calibration\");\n      if (this.measureToolbar) {\n        this.measureToolbar.deactivateAllButtons();\n      }\n    }\n\n    this.selectedTool = NONE;\n    return true;\n  }\n  return false;\n};\n\n/**\n    * @private\n    */\nMeasureExtension.prototype.enterMeasurementMode = function () {\n\n  if (this._measurementMode) return;\n  this._measurementMode = true;\n\n  this.viewer.dispatchEvent({ type: MeasureCommon.Events.MEASUREMENT_MODE_ENTER });\n\n  if (!this.viewer.getToolbar) {\n    return; // Adds support for Viewer3D instance\n  }\n\n  var toolbar = this.viewer.getToolbar();\n  var viewerToolbarContainer = toolbar.container;\n  var viewerContainerChildrenCount = viewerToolbarContainer.children.length;\n  for (var i = 0; i < viewerContainerChildrenCount; ++i) {\n    viewerToolbarContainer.children[i].style.display = \"none\";\n  }\n\n  this.navigationControls = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);\n  this.navigationControls.setVisible(true);\n  this.navigationControls.container.style.display = '';\n\n  this.measureControls = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MEASURETOOLSID);\n  this.measureControls.setVisible(true);\n  this.measureControls.container.style.display = '';\n\n  var measureButtonId = this.measurementToolbarButton.getId();\n  this.measurementToolbarButton.index = this.measurementToolbarButton.parent.indexOf(measureButtonId);\n  this.measurementToolbarButton.parent.removeControl(measureButtonId);\n\n  this.measureToolbar.toggleVisible();\n\n  if (this.viewer.centerToolBar) {\n    this.viewer.centerToolBar();\n  }\n\n  this.enableMeasureTool(true, DEFAULT_MEASUREMENT_TYPE);\n};\n\n/**\n    * @private\n    */\nMeasureExtension.prototype.exitMeasurementMode = function () {\n  if (!this._measurementMode) return;\n\n  this.viewer.dispatchEvent({ type: MeasureCommon.Events.MEASUREMENT_MODE_LEAVE });\n\n  this.measureToolbar && this.measureToolbar.closeToolbar();\n  if (this.CalibrationRequiredDialog && this.CalibrationRequiredDialog.isVisible()) {\n    this.CalibrationRequiredDialog.setVisible(false);\n  }\n  this._measurementMode = false;\n};\n\n/**\n    * Create measure button in toolbar.\n    *\n    * @param toolbar\n    * @private\n    */\nMeasureExtension.prototype.onToolbarCreated = function (toolbar)\n{\n  if (this.measureToolbar) {\n    return;\n  }\n\n  var self = this;\n  var viewer = this.viewer;\n\n  // Add Measure button to toolbar\n  var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);\n  this.measurementToolbarButton = new avu.Button('toolbar-measurementSubmenuTool');\n  this.measurementToolbarButton.setToolTip('Measure');\n  this.measurementToolbarButton.setIcon(\"adsk-icon-measure\");\n  modelTools.measurementToolbarButton = this.measurementToolbarButton;\n  modelTools.addControl(this.measurementToolbarButton, { index: 0 });\n\n  // Set button enabled if and only if there is >=1 visible model. Otherwise, it will remain disabled until next model-add event.\n  var state = this.viewer.model ? Autodesk.Viewing.UI.Button.State.INACTIVE : Autodesk.Viewing.UI.Button.State.DISABLED;\n  this.measurementToolbarButton.setState(state);\n\n  this.measureToolbar = new MeasureToolbar(this);\n  this.measureToolbar.init();\n\n  this.measurementToolbarButton.onClick = this.activate.bind(this);\n\n  // Escape hotkey to exit tool.\n  //\n  var hotkeys = [{\n    keycodes: [\n    Autodesk.Viewing.KeyCode.ESCAPE],\n\n    onRelease: function onRelease() {\n      if (self._measurementMode) {\n        self.exitMeasurementMode();\n        return true;\n      }\n    } }];\n\n  viewer.getHotkeyManager().pushHotkeys(this.escapeHotkeyId, hotkeys);\n};\n\n\n/**\n    * @param tool\n    * @private\n    */\nMeasureExtension.prototype.checkAndFetchTopology = function (tool) {\n\n  if (this._checkedTopology) {\n    return;\n  }\n\n  this._checkedTopology = true;\n  if (!this.viewer.model.is3d()) {\n    tool && tool.setNoTopology();\n    return;\n  }\n\n  if (this.viewer.modelHasTopology()) {\n    tool && tool.setTopologyAvailable();\n    return;\n  }\n\n  // Fetch topology from backend.\n  tool && tool.setFetchingTopology();\n  this.viewer.model.fetchTopology().\n  then(function () {\n    tool && tool.setTopologyAvailable();\n  }).\n  catch(function (err) {\n    avp.logger.log(err); // No topology\n    tool && tool.setNoTopology();\n  });\n};\n\n/**\n    * Destroy measure button in toolbar.\n    *\n    * @private\n    */\nMeasureExtension.prototype.destroyUI = function ()\n{\n  var viewer = this.viewer;\n\n  if (this.measureToolbar) {\n    this.measureToolbar.destroy();\n    this.measureToolbar = null;\n  }\n\n  if (this.measurementToolbarButton) {\n    this.measurementToolbarButton.removeFromParent();\n    this.measurementToolbarButton = null;\n  }\n\n  viewer.getHotkeyManager().popHotkeys(this.escapeHotkeyId);\n};\n\nMeasureExtension.prototype.setUnits = function (units) {\n  this.measureTool.setUnits(units);\n};\n\nMeasureExtension.prototype.getUnits = function () {\n  return this.measureTool.getUnits();\n};\n\nMeasureExtension.prototype.setPrecision = function (precision) {\n  this.measureTool.setPrecision(precision);\n};\n\nMeasureExtension.prototype.getPrecision = function () {\n  return this.measureTool.getPrecision();\n};\n\nMeasureExtension.prototype.calibrate = function (requestedUnits, requestedSize) {\n  this.calibrationTool.calibrate(requestedUnits, requestedSize);\n};\n\nMeasureExtension.prototype.calibrateByScale = function (requestedUnits, requestedScale) {\n  this.calibrationTool.calibrateByScale(requestedUnits, requestedScale);\n};\n\nMeasureExtension.prototype.isCalibrationValid = function (requestedUnits, requestedSize) {\n  return this.calibrationTool.isCalibrationValid(requestedUnits, requestedSize);\n};\n\nMeasureExtension.prototype.getCalibrationFactor = function () {\n  return this.calibrationTool.getCalibrationFactor();\n};\n\nMeasureExtension.prototype.showAddCalibrationLabel = function () {\n  this.calibrationTool.showAddCalibrationLabel();\n};\n\n/**\n    * Delete all measurements.\n    * \n    * @alias Autodesk.Viewing.Extensions.MeasureExtension#deleteAllMeasurements\n    */\nMeasureExtension.prototype.deleteMeasurements = function () {\n  this.measureTool.deleteMeasurements();\n};\n\n/**\n    * Deletes the selected measurement.\n    * \n    * @alias Autodesk.Viewing.Extensions.MeasureExtension#deleteCurrentMeasurement\n    */\nMeasureExtension.prototype.deleteCurrentMeasurement = function () {\n  this.measureTool.deleteCurrentMeasurement();\n};\n\nMeasureExtension.prototype.selectMeasurementById = function (id) {\n  this.measureTool.selectMeasurementById(id);\n};\n\n/**\n    * Enable measuring on non snapped locations.\n    *\n    * @alias Autodesk.Viewing.Extensions.MeasureExtension#setFreeMeasureMode\n    * @param {boolean} allow - true to allow measuring on non snapped locations, otherwise false;\n    * @param {boolean} useLastViewport - override the free measurement's viewport with a previously created measurement's viewport.\n    */\nMeasureExtension.prototype.setFreeMeasureMode = function (allow, useLastViewport) {\n  this.snapper.setSnapToPixel(allow);\n  this.measureTool.setUseLastViewport(!!useLastViewport);\n};\n\n/**\n    * Checks whether measuring can be performed from non snapped locations.\n    *\n    * @alias Autodesk.Viewing.Extensions.MeasureExtension#isFreeMeasureMode\n    *\n    * @returns {boolean} true is users can measure from any location.\n    */\nMeasureExtension.prototype.isFreeMeasureMode = function () {\n  return this.snapper.getSnapToPixel();\n};\n\nav.theExtensionManager.registerExtension('Autodesk.Measure', MeasureExtension);","import { MeasurementsManager } from './MeasurementsManager';\nimport { MeasureToolIndicator } from './MeasureToolIndicator';\n\nvar av = Autodesk.Viewing;\n\n//\n// /** @constructor */\n//\n//\nexport function MeasureTool(viewer, options, sharedMeasureConfig, snapper)\n{\n  var _viewer = viewer;\n  var _options = options || {};\n  var _names = [\"measure\"];\n  var _priority = 50;\n\n  this.setGlobalManager(viewer.globalManager);\n\n  // Shared State with CalibrationTool and Indicator\n  var _sharedMeasureConfig = sharedMeasureConfig;\n\n  var av = Autodesk.Viewing;\n  var avem = Autodesk.Viewing.Extensions.Measure;\n  var MeasureCommon = Autodesk.Viewing.MeasureCommon;\n\n  // Not shared with Indicator.js\n  var _active = false;\n  var _isDragging = false;\n  var _endpointMoved = false;\n  var _activePoint = 0;\n  var _consumeSingleClick = false;\n  var _singleClickHandled = false;\n  var _downX = null;\n  var _downY = null;\n  var _isolateMeasure = false;\n\n  var _measurementsManager = new MeasurementsManager(_viewer);\n  var _currentMeasurement = null;\n  var _onIndicatorCreatedCB = null;\n  var _fetchingMeasurements = [];\n  var _prevMeasurement = null;\n  var _useLastViewport = false;\n\n  var _cursor = \"url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAKZJREFUeNrclLEKwzAQQ9+FgH/Nk7d8ViFT+6cG36IsNXgIdMg5kAoOIw8WSDoDvAEN04BdEhFjgCTR4e6klFxSIgDLSNydbdsAPgRCktRaUylFkfZ0Z2qtVTlnAfugGibwAur3JFrAxoBnYGEy1pGYmQCLLNB6Uqmw182M9eRS0yzqGo+y6D9rytSQR8vM7DKfbtHy4x+/xG8J+d4W9WAi8fxFOwYA8W0ypu2ZfcsAAAAASUVORK5CYII=), auto\";\n\n  // Snapper\n  var _snapper = snapper;\n\n  var _isPressing = false;\n\n  var _picksBackup = [];\n  var _cursorPosition = null;\n\n  var _closeAreaSnapRange = 25;\n  var _preMeasureState = null;\n\n  var _measurementType = MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE;\n\n  var _sessionMeasurements = null;\n\n  function getActivePick()\n  {\n    if (!_currentMeasurement)\n    return null;\n\n    var index;\n\n    if (_activePoint === 0) {\n      return null;\n    } else if (_activePoint === _currentMeasurement.getMaxNumberOfPicks() + 1) {\n      index = _currentMeasurement.countPicks();\n    } else {\n      index = _activePoint;\n    }\n\n    return _currentMeasurement.getPick(index);\n  }\n\n  function getPreviousPick()\n  {\n    if (!_currentMeasurement)\n    return null;\n\n    var index;\n\n    if (_activePoint === 0) {\n      return null;\n    } else if (_activePoint === 1) {\n      index = _currentMeasurement.countPicks();\n    } else if (_activePoint === _currentMeasurement.getMaxNumberOfPicks() + 1) {\n      index = _currentMeasurement.countPicks() - 1;\n    } else {\n      index = _activePoint - 1;\n    }\n\n    return _currentMeasurement.getPick(index);\n  }\n\n  function hasPreviousPick()\n  {\n    if (!_currentMeasurement)\n    return false;\n\n    var index;\n\n    if (_activePoint === 0) {\n      return false;\n    } else if (_activePoint === 1) {\n      index = _currentMeasurement.countPicks();\n    } else if (_activePoint === _currentMeasurement.getMaxNumberOfPicks() + 1) {\n      index = _currentMeasurement.countPicks() - 1;\n    } else {\n      index = _activePoint - 1;\n    }\n\n    return _currentMeasurement.hasPick(index);\n  }\n\n  function noPicksSet() {\n    _activePoint = 0;\n  }\n\n  function allPicksSet() {\n    _activePoint = _currentMeasurement.countPicks() + 1;\n    enableMeasurementsTouchEvents(true);\n    _currentMeasurement.indicator.enableSelectionAreas(true);\n\n    // Keep track of the previous measurement\n    _prevMeasurement = _currentMeasurement.clone();\n    _viewer.dispatchEvent({\n      type: MeasureCommon.Events.MEASUREMENT_COMPLETED_EVENT,\n      data: { type: _currentMeasurement.measurementType, id: _currentMeasurement.id } });\n\n  }\n\n  function isNoPicksSet() {\n    return _activePoint === 0 || !_currentMeasurement;\n  }\n\n  this.areAllPicksSet = function () {\n    return _currentMeasurement && _activePoint === _currentMeasurement.getMaxNumberOfPicks() + 1;\n  };\n\n  this.setSessionMeasurements = function (measurementList) {\n    // Store the clone of the measurementList\n    _sessionMeasurements = JSON.parse(JSON.stringify(measurementList));\n  };\n\n  this.getSessionMeasurements = function () {\n    return JSON.parse(JSON.stringify(_sessionMeasurements));\n  };\n\n  this.register = function ()\n  {\n\n  };\n\n  this.deregister = function ()\n  {\n    this.deactivate();\n  };\n\n  this.isActive = function ()\n  {\n    return _active;\n  };\n\n  this.getNames = function ()\n  {\n    return _names;\n  };\n\n  this.getName = function ()\n  {\n    return _names[0];\n  };\n\n  this.getPriority = function ()\n  {\n    return _priority;\n  };\n\n  this.getCursor = function () {\n    return _isDragging ? null : _cursor;\n  };\n\n  this.getCurrentMeasurementRaw = function () {\n    return _currentMeasurement;\n  };\n\n  this.getActivePointIndex = function () {\n    return _activePoint;\n  };\n\n  this.getMeasurementsManager = function () {\n    return _measurementsManager;\n  };\n\n\n  this.startNewMeasurement = function () {\n    _currentMeasurement = _measurementsManager.createMeasurement(_measurementType);\n    _currentMeasurement.attachIndicator(_viewer, this, MeasureToolIndicator);\n\n    if (_onIndicatorCreatedCB instanceof Function) {\n      _onIndicatorCreatedCB();\n      _onIndicatorCreatedCB = null;\n    }\n\n    enableMeasurementsTouchEvents(false);\n  };\n\n  this.changeMeasurementType = function (type) {\n    _measurementType = type;\n  };\n\n  this.getCurrentMeasureType = function () {\n    return _measurementType;\n  };\n\n  this.activate = function ()\n  {\n    _active = true;\n    _measurementsManager.init();\n\n    noPicksSet();\n    _isDragging = false;\n    this.isEditingEndpoint = false;\n    this.editByDrag = false;\n\n    _viewer.impl.pauseHighlight(true);\n\n    _viewer.clearSelection();\n    _preMeasureState = _viewer.getState({ objectSet: true });\n\n    _viewer.toolController.activateTool(\"snapper\");\n    _viewer.toolController.activateTool(\"magnifyingGlass\");\n\n    this.onMeasurementChangedBinded = this.onMeasurementChanged.bind(this);\n    _viewer.addEventListener(MeasureCommon.Events.MEASUREMENT_CHANGED_EVENT, this.onMeasurementChangedBinded);\n    _viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.onCameraChange);\n    _viewer.addEventListener(av.SHOW_ALL_EVENT, this.onShowAllEvent);\n\n    // Set the stored session measurements only if the preference is enabled\n    var restoreSessionMeasurements = _viewer.prefs.get(av.Private.Prefs.RESTORE_SESSION_MEASUREMENTS);\n    if (restoreSessionMeasurements) {\n      var sessionMeasurements = this.getSessionMeasurements();\n      this.setMeasurements(sessionMeasurements);\n      this.isolateMeasurement();\n    }\n  };\n\n  this.deactivate = function ()\n  {\n    if (!_active)\n    return;\n\n    // Store the session measurements only if the preference is enabled\n    var restoreSessionMeasurements = _viewer.prefs.get(av.Private.Prefs.RESTORE_SESSION_MEASUREMENTS);\n    if (restoreSessionMeasurements) {\n      this.clearIncompleteMeasurement();\n      var measurementList = this.getMeasurementList();\n      this.setSessionMeasurements(measurementList);\n    }\n\n    _active = false;\n\n    this.clearIsolate(); // restore initial isolation\n    _preMeasureState = null;\n\n    _prevMeasurement = null;\n    _useLastViewport = false;\n\n    while (Object.keys(_measurementsManager.measurementsList).length > 0) {\n      _currentMeasurement = _measurementsManager.measurementsList[Object.keys(_measurementsManager.measurementsList)[0]];\n      _measurementsManager.changeCurrentMeasurement(_currentMeasurement);\n      this.clearCurrentMeasurement();\n      _currentMeasurement = null;\n    }\n\n    if (_snapper && _snapper.isActive()) {\n      _viewer.toolController.deactivateTool(\"snapper\");\n    }\n\n    _viewer.toolController.deactivateTool(\"magnifyingGlass\");\n\n    _viewer.impl.pauseHighlight(false);\n\n    _measurementsManager.destroy();\n    _viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.onCameraChange);\n    _viewer.removeEventListener(MeasureCommon.Events.MEASUREMENT_CHANGED_EVENT, this.onMeasurementChangedBinded);\n    _viewer.removeEventListener(av.SHOW_ALL_EVENT, this.onShowAllEvent);\n  };\n\n  this.clearIncompleteMeasurement = function () {\n    if (!this.areAllPicksSet()) {\n      if (this.isEditingEndpoint) {\n        this.undoEditEndpoint();\n      } else {\n        this.clearCurrentMeasurement();\n      }\n    }\n  };\n\n  this.update = function ()\n  {\n    return false;\n  };\n\n  this.getUnits = function () {\n    return _sharedMeasureConfig.units;\n  };\n\n  this.setUnits = function (units)\n  {\n    if (_sharedMeasureConfig.units !== units) {\n      _sharedMeasureConfig.units = units;\n      _viewer.dispatchEvent({ type: MeasureCommon.Events.DISPLAY_UNITS_CHANGED, units: units });\n\n      for (var key in _measurementsManager.measurementsList) {\n        if (_measurementsManager.measurementsList.hasOwnProperty(key)) {\n          // Update UI\n          var measurement = _measurementsManager.measurementsList[key];\n          if (measurement.indicator) {\n            measurement.indicator.updateResults();\n          }\n        }\n      }\n    }\n  };\n\n  this.getPrecision = function () {\n    return _sharedMeasureConfig.precision;\n  };\n\n  this.setPrecision = function (precision) {\n\n    if (_sharedMeasureConfig.precision !== precision) {\n      _sharedMeasureConfig.precision = precision;\n      _viewer.dispatchEvent({ type: MeasureCommon.Events.PRECISION_CHANGED, precision: precision });\n\n      for (var key in _measurementsManager.measurementsList) {\n        if (_measurementsManager.measurementsList.hasOwnProperty(key)) {\n          // Update UI\n          var measurement = _measurementsManager.measurementsList[key];\n          if (measurement.indicator) {\n            measurement.indicator.updateResults();\n          }\n        }\n      }\n    }\n  };\n\n  /**\n      * Prepare the measurement snap result information into a serializable object.\n      * @param {*} measurement \n      */\n  function getPickData(measurement) {\n    measurement = measurement || _currentMeasurement;\n    var picks = measurement.clonePicks();\n    var picksData = [];\n    for (var i = 0; i < picks.length; i++) {\n      var pick = picks[i];\n\n      var pickPoint = MeasureCommon.getSnapResultPosition(pick, _viewer);\n      var model = pick.hasOwnProperty('modelId') && pick.modelId ? _viewer.impl.findModel(pick.modelId) : _viewer.model;\n      if (model) {\n        var modelData = model.getData();\n        pickPoint = modelData && modelData.hasOwnProperty('globalOffset') ? pickPoint.clone().add(modelData.globalOffset) : pickPoint.clone();\n      }\n\n      var pickData = {\n        intersection: JSON.parse(JSON.stringify(pickPoint)),\n        modelId: pick.modelId,\n        viewportIndex2d: pick.viewportIndex2d,\n        snapNode: pick.snapNode };\n\n\n      // Add the arc center and arc radius for the measurement\n      if (measurement.arc) {\n        pickData.circularArcCenter = pick.circularArcCenter;\n        pickData.circularArcRadius = pick.circularArcRadius;\n      }\n\n      picksData.push(pickData);\n    }\n\n    return picksData;\n  };\n\n  this.getDistanceXYZ = function (measurement) {\n    if (!measurement) {\n      measurement = _currentMeasurement;\n    }\n    return this.getDistanceAux(measurement.distanceXYZ);\n  };\n  this.getDistanceX = function (measurement) {\n    if (!measurement) {\n      measurement = _currentMeasurement;\n    }\n    return this.getDistanceAux(measurement.distanceX);\n  };\n  this.getDistanceY = function (measurement) {\n    if (!measurement) {\n      measurement = _currentMeasurement;\n    }\n    return this.getDistanceAux(measurement.distanceY);\n  };\n  this.getDistanceZ = function (measurement) {\n    if (!measurement) {\n      measurement = _currentMeasurement;\n    }\n    return this.getDistanceAux(measurement.distanceZ);\n  };\n\n  /**\n      * @private\n      */\n  this.getDistanceAux = function (measurementDistance) {\n\n    if (_viewer.model) {\n      var d = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _sharedMeasureConfig.units, _sharedMeasureConfig.calibrationFactor, measurementDistance || 0);\n      return Autodesk.Viewing.Private.formatValueWithUnits(d, _sharedMeasureConfig.units, 3, _sharedMeasureConfig.precision);\n    }\n  };\n\n  this.getAngle = function (measurement) {\n\n    if (!measurement) {\n      measurement = _currentMeasurement;\n    }\n    var angle = measurement.angle;\n    return Autodesk.Viewing.Private.formatValueWithUnits(angle, String.fromCharCode(0xb0), 3, _sharedMeasureConfig.precision);\n  };\n\n  this.getArc = function (measurement) {\n\n    if (!measurement) {\n      measurement = _currentMeasurement;\n    }\n    var arc = measurement.arc;\n    return Autodesk.Viewing.Private.formatValueWithUnits(arc, _sharedMeasureConfig.units, 3, _sharedMeasureConfig.precision);\n  };\n\n\n  this.getLocation = function (measurement) {\n\n    if (!measurement) {\n      measurement = _currentMeasurement;\n    }\n    var location = measurement.location || { x: 0, y: 0, z: 0 };\n    return 'X: ' + this.getDistanceAux(location.x) +\n    '\\nY: ' + this.getDistanceAux(location.y) +\n    '\\nZ: ' + this.getDistanceAux(location.z);\n  };\n\n  this.getCallout = function (measurement) {\n\n    if (!measurement) {\n      measurement = _currentMeasurement;\n    }\n    return measurement.text || \"\";\n  };\n\n  this.getArea = function (measurement) {\n\n    if (_viewer.model) {\n\n      if (!measurement) {\n        measurement = _currentMeasurement;\n      }\n\n      var area = Autodesk.Viewing.Private.convertUnits(viewer.model.getUnitString(), _sharedMeasureConfig.units, _sharedMeasureConfig.calibrationFactor, measurement.area, 'square');\n\n      if (_sharedMeasureConfig.units) {\n        return Autodesk.Viewing.Private.formatValueWithUnits(area, _sharedMeasureConfig.units + '^2', 3, _sharedMeasureConfig.precision);\n      } else\n      {\n        return Autodesk.Viewing.Private.formatValueWithUnits(area, null, 3, _sharedMeasureConfig.precision);\n      }\n    }\n  };\n\n  function snapToFirstPick(currentPick, forceSnap) {\n    if (_currentMeasurement.hasPick(1) && _activePoint > 3 && !_currentMeasurement.closedArea) {\n      var firstPick = _currentMeasurement.getPick(1);\n      var firstPickPoint = MeasureCommon.getSnapResultPosition(firstPick, _viewer);\n      var firstPickPosition = MeasureCommon.project(firstPickPoint, viewer);\n      var currentPickPoint = MeasureCommon.getSnapResultPosition(currentPick, _viewer);\n      var currentPickPosition = MeasureCommon.project(currentPickPoint, viewer);\n\n      if (forceSnap || currentPickPosition.distanceTo(firstPickPosition) < _closeAreaSnapRange) {\n        _snapper.onMouseMove(firstPickPosition);\n        firstPick.copyTo(currentPick);\n      }\n    }\n  }\n\n  function checkSnapperIndicatorForArc() {var _currentMeasurement2;\n    if (!_currentMeasurement) {\n      _snapper.setArc(true);\n    }\n\n    if (((_currentMeasurement2 = _currentMeasurement) === null || _currentMeasurement2 === void 0 ? void 0 : _currentMeasurement2.measurementType) === MeasureCommon.MeasurementTypes.MEASUREMENT_ARC && viewer.model.is2d()) {\n      var firstPick = _currentMeasurement && _currentMeasurement.getPick(1);\n      var secondPick = _currentMeasurement && _currentMeasurement.hasPick(2) && _currentMeasurement.getPick(2);\n      var isArc = !firstPick || _currentMeasurement.countPicks().length > 2 || MeasureCommon.isEqualVectors(firstPick.circularArcCenter, secondPick.circularArcCenter, 0) && firstPick.circularArcRadius === secondPick.circularArcRadius;\n      _snapper.setArc(isArc);\n    }\n  }\n\n  /**\n     * Overrides each pick's viewportIndex2d in the current measurement with the passed in viewportIndex.\n     * This function only overrides the viewport index if the current measurement's picks do not have the viewportIndex2d set.\n     */\n  function setMeasurePicksViewport(viewportIndex) {\n    var picks = _currentMeasurement.picks;\n    for (var key in picks) {\n      if (picks.hasOwnProperty(key)) {\n        // If the current measurement has a viewport index do not override the its picks viewport id with the previous measurement's.\n        if (picks[key].viewportIndex2d) return;\n        picks[key].viewportIndex2d = viewportIndex;\n      }\n    }\n  }\n\n  function render(showResult) {\n    // LMV-5498: Set the current measurement's picks viewport to the previous measurement's pciks viewport.\n    if (_useLastViewport && _prevMeasurement && _prevMeasurement.picks.length > 0) {\n      setMeasurePicksViewport(_prevMeasurement.picks[0].viewportIndex2d);\n    }\n\n    var hasResult = _currentMeasurement.computeResult(_currentMeasurement.picks, _viewer, _snapper);\n    _currentMeasurement.indicator.render(_currentMeasurement.picks, _consumeSingleClick || !!showResult);\n\n    return hasResult;\n  }\n\n  this.setUseLastViewport = function (value) {\n    _useLastViewport = value;\n  };\n\n  this.getUseLastViewport = function () {\n    return _useLastViewport;\n  };\n\n  /**\n      * Sets existing measurements from the passed in measurement list. Reference getMeasurementList.\n      * \n      * @param {Object[]} measurementList - measurements to set.\n      */\n  this.setMeasurements = function (measurementList) {var _this = this;\n    if (!measurementList) return; // Only set the a measurementList is passed in.\n    measurementList = !Array.isArray(measurementList) ? [measurementList] : measurementList;\n\n    if (measurementList.length === 0) return;\n\n    function getMeasureType(measureData) {\n      var measurementType;\n      switch (measureData.type) {\n        case 'Distance':\n          measurementType = MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE;\n          break;\n        case 'Angle':\n          measurementType = MeasureCommon.MeasurementTypes.MEASUREMENT_ANGLE;\n          break;\n        case 'Area':\n          measurementType = MeasureCommon.MeasurementTypes.MEASUREMENT_AREA;\n          break;\n        case 'Arc':\n          measurementType = MeasureCommon.MeasurementTypes.MEASUREMENT_ARC;\n          break;\n        case 'Location':\n          measurementType = MeasureCommon.MeasurementTypes.MEASUREMENT_LOCATION;\n          break;\n        case 'Callout':\n          measurementType = MeasureCommon.MeasurementTypes.MEASUREMENT_CALLOUT;\n          break;\n        default:\n          return;}\n\n      return measurementType;\n    }\n\n    // Restore the supplied measurementList.\n    for (var i = 0; i < measurementList.length; i++) {\n      var measureData = measurementList[i];\n      var measurementType = getMeasureType(measureData);\n      if (!measurementType) continue;\n\n      var attachIndicatorCb = function attachIndicatorCb(measurement) {\n        _currentMeasurement = measurement; // _currentMeasurement needs to be set for the onMeasurementChanged to work\n        measurement.attachIndicator(_viewer, _this, MeasureToolIndicator);\n\n        if (_onIndicatorCreatedCB instanceof Function) {\n          _onIndicatorCreatedCB();\n          _onIndicatorCreatedCB = null;\n        }\n\n        enableMeasurementsTouchEvents(false);\n      };\n\n      var initPicksCb = function initPicksCb() {\n        var restoredMeasurements = _measurementsManager.getRestoredMeasurementData();\n        var points = restoredMeasurements[_currentMeasurement.id];\n        _activePoint = points.length;\n      };\n\n      _measurementsManager.createMeasurementFromData(\n      measureData,\n      measurementType,\n      attachIndicatorCb,\n      initPicksCb);\n\n    }\n\n    this.deselectAllMeasurements();\n  };\n\n  function getMeasurementType(measurement) {\n    measurement = measurement || _currentMeasurement;\n    var types = MeasureCommon.MeasurementTypes;\n    var type = measurement.measurementType;\n    switch (type) {\n      case types.MEASUREMENT_DISTANCE:\n        return 'Distance';\n      case types.MEASUREMENT_ANGLE:\n        return 'Angle';\n      case types.MEASUREMENT_AREA:\n        return 'Area';\n      case types.CALIBRATION:\n        return 'Calibration';\n      case types.MEASUREMENT_ARC:\n        return 'Arc';\n      case types.MEASUREMENT_LOCATION:\n        return 'Location';\n      case types.MEASUREMENT_CALLOUT:\n        return 'Callout';\n      default:\n        return;}\n\n  }\n\n  /**\n     * TODO: We need to flesh out the return value here.\n     *\n     * @param unitType\n     * @param precision\n     * @returns {Object}\n     */\n  this.getMeasurement = function (unitType, precision) {\n\n    _sharedMeasureConfig.units = unitType || _sharedMeasureConfig.units;\n    _sharedMeasureConfig.precision = precision || _sharedMeasureConfig.precision;\n\n    var geomTypes = ['Vertex', 'Edge', 'Face', 'Circular Arc', 'Curved Edge', 'Curved Face'];\n    var picks = getPickData();\n    var type = getMeasurementType();\n    var measurement = {\n      from: geomTypes[_currentMeasurement.getGeometry(1).type],\n      to: geomTypes[_currentMeasurement.getGeometry(2).type],\n      distance: this.getDistanceXYZ(),\n      deltaX: this.getDistanceX(),\n      deltaY: this.getDistanceY(),\n      deltaZ: this.getDistanceZ(),\n      angle: this.getAngle(),\n      area: this.getArea(),\n      arc: this.getArc(),\n      location: this.getLocation(),\n      text: this.getCallout(),\n      unitType: _sharedMeasureConfig.units,\n      precision: _sharedMeasureConfig.precision,\n      picks: picks,\n      type: type };\n\n\n    return measurement;\n  };\n\n  /**\n      * @returns {SnapResult[]} list of points for the selected measurement.\n      */\n  this.getMeasurementPoints = function () {\n\n    return _currentMeasurement.clonePicks();\n  };\n\n  /**\n      * @param unitType\n      * @param precision\n      * @returns {Array.<Object>}\n      */\n\n  this.getMeasurementList = function (unitType, precision) {\n    var list = [];\n    var measurement = null;\n    // TODO: These need to match the measurement SnapTypes\n    var geomTypes = ['Vertex', 'Edge', 'Face', 'Circular Arc', 'Curved Edge', 'Curved Face'];\n    var measurementList = Object.keys(_measurementsManager.measurementsList);\n\n    for (var i = 0; i < measurementList.length; i++) {\n      measurement = _measurementsManager.measurementsList[measurementList[i]];\n      var picks = getPickData(measurement);\n      var type = getMeasurementType(measurement);\n      var result = {\n        from: geomTypes[measurement.getGeometry(1).type],\n        to: geomTypes[measurement.getGeometry(2).type],\n        distance: this.getDistanceXYZ(measurement),\n        deltaX: this.getDistanceX(measurement),\n        deltaY: this.getDistanceY(measurement),\n        deltaZ: this.getDistanceZ(measurement),\n        angle: this.getAngle(measurement),\n        area: this.getArea(measurement),\n        arc: this.getArc(measurement),\n        location: this.getLocation(measurement),\n        text: this.getCallout(measurement),\n        unitType: unitType || _sharedMeasureConfig.units,\n        precision: precision || _sharedMeasureConfig.precision,\n        picks: picks,\n        type: type };\n\n      if (measurement.options) {(function () {\n          var options = result.options = JSON.parse(JSON.stringify(measurement.options));\n          if (!options.modelId && picks[0] && picks[0].modelId)\n          options.modelId = picks[0].modelId;\n          var model = options.modelId ? _viewer.impl.findModel(options.modelId) : _viewer.model;\n          var globalOffset = model && model.getData().globalOffset;\n          if (globalOffset && (globalOffset.x !== 0 || globalOffset.y !== 0 || globalOffset.z !== 0)) {\n            var cvtPts = function cvtPts(points) {\n              if (points) {\n                for (var _i = 0; _i < points.length; ++_i) {\n                  // Tricky way to use Vector3 add on plain objects\n                  THREE.Vector3.prototype.add.call(points[_i], globalOffset);\n                }\n              }\n            };\n            cvtPts(options.dimensionOffset);\n            cvtPts(options.dashedLeader);\n            cvtPts(options.arc);\n          }})();\n      }\n      list.push(result);\n    }\n    return list;\n  };\n\n  this.clearCurrentMeasurement = function () {\n    if (_currentMeasurement) {\n      noPicksSet();\n\n      for (var key in _currentMeasurement.picks) {\n        if (_currentMeasurement.picks.hasOwnProperty(key)) {\n          this.clearPick(key);\n        }\n      }\n\n      this.updateViewportId(true);\n\n      if (_isolateMeasure) {\n        this.clearIsolate();\n      }\n\n      _currentMeasurement.indicator.clear();\n      _currentMeasurement.indicator.destroy();\n      _currentMeasurement = _measurementsManager.removeCurrentMeasurement();\n      _currentMeasurement = null;\n    }\n\n    enableMeasurementsTouchEvents(true);\n  };\n\n  this.clearPick = function (pickNumber) {\n    if (_currentMeasurement && _currentMeasurement.hasPick(pickNumber)) {\n      _currentMeasurement.clearPick(pickNumber);\n      _currentMeasurement.indicator.hideClick(pickNumber);\n    }\n  };\n\n  this.setIsolateMeasure = function (enable) {\n    _isolateMeasure = enable;\n  };\n\n  this.getIsolateMeasure = function () {\n    return _isolateMeasure;\n  };\n\n  this.isolateMeasurement = function () {\n\n    if (!_active || !_isolateMeasure) {\n      return;\n    }\n\n    var defaultModelId = _viewer.model.id;\n    var isolationGroups = {};\n\n    for (var key in _measurementsManager.measurementsList) {\n      if (_measurementsManager.measurementsList.hasOwnProperty(key)) {\n\n        var measurement = _measurementsManager.measurementsList[key];\n        for (var key in measurement.picks) {\n          if (measurement.picks.hasOwnProperty(key)) {\n            var pick = measurement.getPick(key);\n\n            var modelId = pick.modelId || defaultModelId;\n            if (!Array.isArray(isolationGroups[modelId])) {\n              isolationGroups[modelId] = [];\n            }\n            if (isolationGroups[modelId].indexOf(pick.snapNode) == -1) {\n              isolationGroups[modelId].push(pick.snapNode);\n            }\n          }\n        }\n\n      }\n    }\n\n\n    // convert to expected format\n    var isolationSet = [];\n    for (var modelId in isolationGroups) {\n      if (isolationGroups.hasOwnProperty(modelId)) {\n\n        var modelInstance = _viewer.impl.findModel(parseInt(modelId));\n        isolationSet.push({\n          model: modelInstance,\n          ids: isolationGroups[modelId] });\n\n      }\n    }\n\n    if (isolationSet.length) {\n      _viewer.impl.visibilityManager.aggregateIsolate(isolationSet);\n    }\n  };\n\n  // It actually restores the isolation state to the one just before\n  // the measure tool was enabled...\n  this.clearIsolate = function () {\n    if (_preMeasureState) {\n      _viewer.restoreState(_preMeasureState, undefined, true);\n    }\n  };\n\n  this.onShowAllEvent = function (event) {\n    _preMeasureState = null;\n  };\n\n  this.deselectAllMeasurements = function () {\n    if (_currentMeasurement && !this.areAllPicksSet()) {\n      if (this.isEditingEndpoint) {\n        this.undoEditEndpoint();\n      } else\n      {\n        this.clearCurrentMeasurement();\n      }\n    }\n\n    for (var key in _measurementsManager.measurementsList) {\n      if (_measurementsManager.measurementsList.hasOwnProperty(key)) {\n        var measurement = _measurementsManager.measurementsList[key];\n        if (measurement.indicator) {\n          measurement.indicator.setSimple(true);\n          measurement.indicator.hideEndpoints();\n          measurement.indicator.unfocusLabels();\n        }\n      }\n    }\n\n    _currentMeasurement = null;\n  };\n\n  this.onMeasurementChanged = function () {\n\n    this.deselectAllMeasurements();\n\n    _currentMeasurement = _measurementsManager.getCurrentMeasurement();\n\n    if (_currentMeasurement.isComplete()) {\n      _currentMeasurement.indicator.setSimple(false);\n      allPicksSet();\n      render(true);\n      this.updateResults();\n    }\n  };\n\n  this.selectMeasurementById = function (measurementId) {\n    if (!_currentMeasurement) {\n      _currentMeasurement = _measurementsManager.selectMeasurementById(measurementId);\n    }\n\n    if (_currentMeasurement.id !== measurementId) {\n      this.clearIncompleteMeasurement();\n\n      _currentMeasurement = _measurementsManager.selectMeasurementById(measurementId);\n    }\n  };\n\n  function enableMeasurementsTouchEvents(enable) {\n    for (var key in _measurementsManager.measurementsList) {\n      if (_measurementsManager.measurementsList.hasOwnProperty(key)) {\n        var measurement = _measurementsManager.measurementsList[key];\n        measurement.indicator.changeAllEndpointsEditableStyle(enable);\n        measurement.indicator.enableSelectionAreas(enable);\n        measurement.indicator.enableLabelsTouchEvents(enable);\n      }\n    }\n  }\n\n  this.editEndpoint = function (event, endpointNumber, measurementId) {\n    if (_currentMeasurement.id === measurementId && _activePoint === endpointNumber) {\n      _currentMeasurement.indicator.changeEndpointOnEditStyle(endpointNumber, false);\n      this.undoEditEndpoint();\n      return;\n    }\n\n    this.selectMeasurementById(measurementId);\n\n    _activePoint = endpointNumber;\n    this.isEditingEndpoint = true;\n\n    _currentMeasurement.indicator.changeEndpointOnEditStyle(endpointNumber, true);\n    enableMeasurementsTouchEvents(false);\n\n    for (var key in _currentMeasurement.picks) {\n      if (_currentMeasurement.picks.hasOwnProperty(key)) {\n        _picksBackup[key] = _currentMeasurement.getPick(key).clone();\n      }\n    }\n\n    this.updateViewportId();\n\n    if (_isolateMeasure) {\n      this.clearIsolate();\n    }\n\n    if (_currentMeasurement.isRestored) {\n      // populate the existing picks with the new snap result from the snapper\n      _snapper.onMouseMove({ x: event.canvasX, y: event.canvasY });\n      var snapResult = _snapper.getSnapResult().clone();\n      var pick = _currentMeasurement.getPick(_activePoint);\n      snapResult.copyTo(pick);\n\n      // Keep track of the pick that was updated.\n      pick.isValid = true;\n\n      // Set isRestored flag back to false if all of the picks have been validated\n      _currentMeasurement.isRestored = !function () {\n        var picks = _currentMeasurement.picks;\n        for (var key in picks) {\n          if (picks.hasOwnProperty(key)) {\n            var _pick = picks[key];\n            if (!_pick.isValid) {\n              return false;\n            }\n          }\n        }\n        return true;\n      }();\n    }\n\n    if (!av.isMobileDevice()) {\n      this._handleMouseEvent(event);\n    }\n  };\n\n  function canCloseArea() {\n    return _currentMeasurement.countPicks() > 3;\n  }\n\n  this.undoEditEndpoint = function () {\n    _currentMeasurement.indicator.clear();\n\n    for (var key in _currentMeasurement.picks) {\n      if (_currentMeasurement.picks.hasOwnProperty(key)) {\n        _currentMeasurement.setPick(key, _picksBackup[key].clone());\n      }\n    }\n\n    _currentMeasurement.indicator.changeEndpointOnEditStyle(_activePoint, false);\n\n    this.isEditingEndpoint = false;\n    this.updateViewportId(true);\n    allPicksSet();\n    render(true);\n  };\n\n  this.updateResults = function () {\n\n    _currentMeasurement.indicator.updateResults();\n    _currentMeasurement.indicator.showEndpoints();\n    _currentMeasurement.indicator.focusLabels();\n\n    if (_currentMeasurement.isComplete()) {\n      this.isolateMeasurement();\n    }\n  };\n\n  /**\n      * Delete all measurements.\n      */\n  this.deleteMeasurements = function () {\n    var measurements = _measurementsManager.measurementsList;\n    var keys = Object.keys(measurements);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      _measurementsManager.currentMeasurement = measurements[key];\n      _currentMeasurement = _measurementsManager.getCurrentMeasurement();\n      this.deleteCurrentMeasurement();\n    }\n  };\n\n  this.deleteCurrentMeasurement = function () {\n    // Keeping a copy of current measurement so send info in event.\n    var _deletedMeasurement = _currentMeasurement ? _currentMeasurement.clone() : null;\n    this.clearCurrentMeasurement();\n    this.isEditingEndpoint = false;\n    this.editByDrag = false;\n    _isDragging = false;\n    this.isolateMeasurement();\n    if (_deletedMeasurement) {\n      _viewer.dispatchEvent({\n        type: MeasureCommon.Events.DELETE_MEASUREMENT,\n        data: { type: _deletedMeasurement.measurementType, id: _deletedMeasurement.id } });\n\n    }\n    _deletedMeasurement = null;\n  };\n\n  this.deleteCurrentPick = function () {\n\n    var pick = getActivePick();\n    var id = pick.id;\n\n    while (_currentMeasurement.hasPick(id + 1)) {\n      _currentMeasurement.setPick(id, _currentMeasurement.getPick(id + 1));\n      id++;\n    }\n\n    delete _currentMeasurement.picks[id];\n\n\n\n    var count = _currentMeasurement.countPicks();\n\n    _activePoint--;\n\n    if (_activePoint <= 0) {\n      _activePoint = count;\n    }\n\n    if (this.isEditingEndpoint) {\n      if (count == 2) {\n        this.deleteCurrentMeasurement();\n        return;\n      }\n\n      _currentMeasurement.indicator.changeAllEndpointsOnEditStyle(false);\n      this.isEditingEndpoint = false;\n      this.updateViewportId(true);\n      allPicksSet();\n      render();\n    } else {\n      this._handleMouseEvent();\n    }\n  };\n\n  this.updateViewportId = function (clear) {\n    if (_viewer.model && _viewer.model.is2d()) {\n      if (clear || isNoPicksSet()) {\n        _viewer.impl.updateViewportId(0);\n        _snapper.setViewportId(null);\n      } else\n      if (!_isPressing) {\n        var viewport = getPreviousPick().viewportIndex2d || getActivePick().viewportIndex2d;\n\n        // Pass viewport Id to LineShader to make all other geometries with different viewport transparent\n        _viewer.impl.updateViewportId(viewport);\n        if (_snapper)\n        _snapper.setViewportId(viewport);\n\n      }\n    }\n  };\n\n  // Setting session measurements before activating measure needed\n  // some special handling for the topology state. The problem was\n  // that the indicators were set to 'fetching', and were cleared from\n  // _currentMeasurement before the the topology fetch could finish.\n  // I changed the logic to track all of the measurements that were\n  // marked as fetching and clear them when the fetch is finished.\n\n  // Clear fetching state in all measurements that were created\n  // while we were fetching topology. The stateSetter is the name\n  // of the method that sets the correct state.\n  function changeFetchingState(stateSetter) {\n    // call setter for all measurements in the list\n    for (var i = 0; i < _fetchingMeasurements.length; ++i) {\n      var measurement = _fetchingMeasurements[i];\n      measurement.indicator[stateSetter]();\n    }\n    // Clear list\n    _fetchingMeasurements.length = 0;\n  }\n\n  this.setNoTopology = function () {\n    // Change existing indicators\n    changeFetchingState(\"setNoTopology\");\n    // Set state for future measurements\n    _onIndicatorCreatedCB = function _onIndicatorCreatedCB() {_currentMeasurement.indicator.setNoTopology();};\n  };\n  this.setFetchingTopology = function () {\n    // Set state for future measurements\n    _onIndicatorCreatedCB = function _onIndicatorCreatedCB() {\n      _fetchingMeasurements.push(_currentMeasurement);\n      _currentMeasurement.indicator.setFetchingTopology();\n    };\n    // Change existing indicator\n    if (_currentMeasurement && _currentMeasurement.indicator)\n    _onIndicatorCreatedCB();\n  };\n  this.setTopologyAvailable = function () {\n    // Change existing indicators\n    changeFetchingState(\"setTopologyAvailable\");\n    // Set state for future measurements\n    _onIndicatorCreatedCB = function _onIndicatorCreatedCB() {_currentMeasurement.indicator.setTopologyAvailable();};\n  };\n\n  this.getSnapper = function () {\n    return _snapper;\n  };\n\n  this.correctPickPosition = function () {\n\n    var active = getActivePick();\n\n    if (active && !active.getGeometry() && _cursorPosition) {\n      active.geomType = MeasureCommon.SnapType.SNAP_VERTEX;\n      active.geomVertex = _cursorPosition;\n      active.intersectPoint = _cursorPosition;\n    }\n\n    if (hasPreviousPick()) {\n      var passive = getPreviousPick();\n      var corrected = MeasureCommon.correctPerpendicularPicks(passive, active, viewer, _snapper);\n      if (!corrected) {\n\n        // get next pick in case of closed loop measurement.\n        var id = (active.id + 1) % (_currentMeasurement.countPicks() + 1);\n\n        if (id === 0)\n        id = 1;\n\n        if (id !== active.id && _currentMeasurement.hasPick(id)) {\n          var nextPick = _currentMeasurement.getPick(id);\n          MeasureCommon.correctPerpendicularPicks(nextPick, active, viewer, _snapper);\n        }\n      }\n\n      if (_currentMeasurement.measurementType == MeasureCommon.MeasurementTypes.MEASUREMENT_AREA) {\n        snapToFirstPick(active);\n      }\n    }\n  };\n\n  this._handleMouseEvent = function (event) {\n\n    var valid = false;\n\n    if (_snapper.isSnapped()) {var _currentMeasurement3;\n\n      // User picked a new point after two points where already set (or none) - Start a new measurement.\n      if (this.areAllPicksSet() || isNoPicksSet()) {\n        this.startNewMeasurement();\n\n        _activePoint = 1;\n      }\n\n      _snapper.copyResults(getActivePick());\n\n\n      // When user is in the arc measurement mode and the user clicks on a different circle than the first point, then don't do anything\n      if (_consumeSingleClick && ((_currentMeasurement3 = _currentMeasurement) === null || _currentMeasurement3 === void 0 ? void 0 : _currentMeasurement3.measurementType) === MeasureCommon.MeasurementTypes.MEASUREMENT_ARC) {\n        if (!_currentMeasurement.getPick(1).circularArcCenter ||\n        _currentMeasurement.hasPick(2) && !(MeasureCommon.isEqualVectors(_currentMeasurement.getPick(1).circularArcCenter, _currentMeasurement.getPick(2).circularArcCenter, 0) &&\n        _currentMeasurement.getPick(1).circularArcRadius === _currentMeasurement.getPick(2).circularArcRadius)) {\n          return false;\n        }\n      }\n\n      valid = true;\n\n    } else\n    {\n      // In order to draw rubber-band, set the cursor position, so the indicator will use it as active point.\n      if (event && _viewer.model) {\n        var viewport = _viewer.container.getBoundingClientRect();\n        var x = event.canvasX || event.clientX - viewport.left;\n        var y = event.canvasY || event.clientY - viewport.top;\n\n        if (x && y) {\n          var canDrawRubberBand;\n          if (_viewer.impl.is2d) {\n            canDrawRubberBand = true;\n          } else {\n            var renderer = _viewer.impl.renderer();\n            var res = [];\n            renderer.idAtPixel(x, y, res);\n            var modelId = res[1];\n            if (modelId > 0) {\n              var model = _viewer.impl.modelQueue().findModel(modelId);\n              canDrawRubberBand = model === null || model === void 0 ? void 0 : model.is2d();\n            }\n          }\n\n          _cursorPosition = canDrawRubberBand ? MeasureCommon.inverseProject({ x: x, y: y }, _viewer) : null;\n        }\n      }\n\n      // In case a measurement is set, and the user clicks on a blank spot - don't do nothing.\n      if (_consumeSingleClick && _currentMeasurement && !this.isEditingEndpoint) {\n        if (_activePoint === _currentMeasurement.getMaxNumberOfPicks() + 1) {\n          return true;\n        }\n      }\n\n      var lastPick = getActivePick();\n      if (lastPick) {\n        lastPick.clear();\n      }\n    }\n\n    if (_currentMeasurement) {\n      this.correctPickPosition();\n\n      if (_consumeSingleClick) {\n        this._doConsumeSingleClick();\n      }\n\n      if (!isNoPicksSet()) {\n        var renderSucceeded = render();\n\n        // If it's the first pick, we don't expect the render of the rubberband to be succeeded.\n        // So enter here only if it's not the first pick.\n        if (_currentMeasurement.hasPick(2)) {\n          valid &= renderSucceeded;\n        }\n      }\n    }\n\n    // If valid is false, the last pick is not revelant, and will clear it in case of a click.\n    return valid;\n  };\n\n  this._doConsumeSingleClick = function () {\n    // In case the measurement is a closed loop, eliminate the last pick.\n    if (_currentMeasurement.measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_AREA && !_currentMeasurement.closedArea) {\n      var length = _currentMeasurement.countPicks();\n      var firstPick = _currentMeasurement.getPick(1);\n      var lastPick = _currentMeasurement.getPick(length);\n\n      if (length >= 3 && _currentMeasurement.hasEqualPicks(firstPick, lastPick)) {\n        lastPick.clear();\n        delete _currentMeasurement.picks[length];\n        _currentMeasurement.closedArea = true;\n      }\n    }\n\n    this.updateResults();\n\n    var measurementComplete = _currentMeasurement.isComplete();\n    this.updateViewportId(measurementComplete);\n  };\n\n\n  this.handleButtonDown = function (event, button) {\n    if (av.isMobileDevice())\n    return false;\n\n    _isDragging = true;\n    if (button === 0 && !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {\n      _consumeSingleClick = true;\n      _downX = event.canvasX;\n      _downY = event.canvasY;\n    }\n    return false;\n  };\n\n  this.handleMouseMove = function (event) {\n\n    if (av.isMobileDevice())\n    return false;\n\n    if (event.canvasX !== _downX || event.canvasY !== _downY) {\n      _consumeSingleClick = false;\n    }\n\n    _endpointMoved = this.isEditingEndpoint;\n\n    if (!isNoPicksSet() && !this.areAllPicksSet()) {\n      this.clearPick(_activePoint);\n      this._handleMouseEvent(event);\n    }\n\n    checkSnapperIndicatorForArc();\n\n    _snapper.indicator.render();\n\n    return false;\n  };\n\n  this.restoreMouseListeners = function () {\n\n    // When a press event has happend, the default behavior of firefly.js is to disable other mouse events,\n    // So they won't be triggered as well.\n    // The solution is to enable them after the end of the pressing.\n\n    _viewer.toolController.getTool(\"gestures\").controller.enableMouseButtons(true);\n  };\n\n  this.handlePressHold = function (event) {\n    _consumeSingleClick = false;\n\n    if (av.isTouchDevice()) {\n      switch (event.type) {\n\n        case \"press\":\n          _isPressing = true;\n\n          if (this.areAllPicksSet() || isNoPicksSet()) {\n            this.startNewMeasurement();\n\n            if (_isolateMeasure) {\n              this.clearIsolate();\n            }\n\n            _activePoint = 1;\n          }\n\n          this._handleMouseEvent(event);\n          _snapper.indicator.render();\n\n          return true;\n\n        case \"pressup\":\n          _consumeSingleClick = true;\n          this.restoreMouseListeners();\n          _singleClickHandled = !_singleClickHandled;\n          this.handleSingleClick(event);\n          _isPressing = false;\n          return true;}\n\n    }\n    return false;\n\n  };\n\n\n\n  this.handleGesture = function (event)\n  {\n    if (av.isTouchDevice()) {\n\n      _consumeSingleClick = false;\n\n      if (_isPressing) {\n\n        this.clearPick(_activePoint);\n\n        switch (event.type) {\n\n          case \"dragstart\":\n            this._handleMouseEvent(event);\n            _snapper.indicator.render();\n\n            return true;\n\n          case \"dragmove\":\n            this._handleMouseEvent(event);\n            _snapper.indicator.render();\n\n            return true;\n\n          case \"dragend\":\n            _isPressing = false;\n            _consumeSingleClick = true;\n\n            if (!this.editByDrag) {\n              _singleClickHandled = !_singleClickHandled;\n              this.handleSingleClick(event);\n            }\n\n            this.editByDrag = false;\n            this.restoreMouseListeners();\n            return true;\n\n          case \"pinchstart\":\n            this._handleMouseEvent(event);\n            _snapper.indicator.render();\n\n            break;\n\n          case \"pinchmove\":\n            this._handleMouseEvent(event);\n            _snapper.indicator.render();\n\n            break;\n\n          case \"pinchend\":\n            _consumeSingleClick = true;\n            _singleClickHandled = !_singleClickHandled;\n            this.handleSingleClick(event);\n            this.restoreMouseListeners();\n            return true;}\n\n      }\n\n      if (event.type.indexOf('pinch') !== -1) {\n        for (var key in _measurementsManager.measurementsList) {\n          if (_measurementsManager.measurementsList.hasOwnProperty(key)) {\n            var measurement = _measurementsManager.measurementsList[key];\n            measurement.indicator.updateScale();\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  this.handleButtonUp = function (event, button) {\n    _isDragging = false;\n    _downX = null;\n    _downY = null;\n\n    if (_endpointMoved) {\n      _consumeSingleClick = true;\n      _singleClickHandled = !_singleClickHandled;\n      this.handleSingleClick(event);\n      _endpointMoved = false;\n    }\n\n    return false;\n  };\n\n  this.handleSingleClick = function (event, button) {\n    if (_consumeSingleClick) {\n\n      _snapper.indicator.clearOverlays();\n\n      if (_currentMeasurement) {\n        _currentMeasurement.indicator.changeEndpointOnEditStyle(_activePoint, false);\n      }\n\n      if (this._handleMouseEvent(event)) {\n        this.updateResults();\n        _activePoint++;\n      } else\n      {\n        if (this.isEditingEndpoint) {\n          this.undoEditEndpoint();\n        } else\n        {\n          if (_currentMeasurement && _currentMeasurement.measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_AREA && canCloseArea()) {\n            snapToFirstPick(getActivePick(), true);\n            this._handleMouseEvent();\n          } else {\n            this.clearCurrentMeasurement();\n          }\n        }\n      }\n\n      if (_currentMeasurement && _currentMeasurement.isComplete()) {\n        allPicksSet();\n      }\n\n      _consumeSingleClick = false;\n      _singleClickHandled = !_singleClickHandled;\n      this.isEditingEndpoint = false;\n\n      _snapper.clearSnapped();\n    }\n    return true;\n  };\n\n  this.handleDoubleClick = function (event) {\n    return true;\n  };\n\n  this.onCameraChange = function () {\n    for (var key in _measurementsManager.measurementsList) {\n      if (_measurementsManager.measurementsList.hasOwnProperty(key)) {\n        var measurement = _measurementsManager.measurementsList[key];\n        measurement.indicator.updateScale();\n      }\n    }\n\n    _snapper.indicator.onCameraChange();\n  };\n\n  this.handleSingleTap = function (event) {\n    if (!_singleClickHandled) {\n      _consumeSingleClick = true;\n      _snapper.onMouseDown({ x: event.canvasX, y: event.canvasY });\n      this.handleSingleClick(event);\n    }\n    _singleClickHandled = !_singleClickHandled;\n\n    return true;\n  };\n\n  this.handleDoubleTap = function (event) {\n    if (_currentMeasurement && _currentMeasurement.measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_AREA && _currentMeasurement.countPicks() > 2) {\n      // fake single click over the first handle, to close the area.\n      var firstPick = _currentMeasurement.getPick(1);\n      var firstPickPoint = MeasureCommon.getSnapResultPosition(firstPick, _viewer);\n      var firstPickPosition = MeasureCommon.project(firstPickPoint, viewer);\n      event.canvasX = firstPickPosition.x;\n      event.canvasY = firstPickPosition.y;\n      _consumeSingleClick = true;\n      _snapper.onMouseDown(firstPickPosition);\n      this.handleSingleClick(event);\n      _singleClickHandled = !_singleClickHandled;\n    }\n\n    return true;\n  };\n\n  this.handleResize = function () {\n    for (var key in _measurementsManager.measurementsList) {\n      if (_measurementsManager.measurementsList.hasOwnProperty(key)) {\n        var measurement = _measurementsManager.measurementsList[key];\n        if (measurement.indicator) {\n          measurement.indicator.handleResize();\n        }\n      }\n    }\n  };\n\n  this.handleKeyDown = function (event, keyCode) {\n    switch (keyCode) {\n      case Autodesk.Viewing.KeyCode.BACKSPACE:\n      case Autodesk.Viewing.KeyCode.DELETE:\n        if (_currentMeasurement && _currentMeasurement.measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_AREA && !this.areAllPicksSet()) {\n          if (_currentMeasurement.countPicks() > 2) {\n            this.deleteCurrentPick();\n          } else {\n            this.deleteCurrentMeasurement();\n          }\n        } else {\n          this.deleteCurrentMeasurement();\n        }\n\n        return true;}\n\n\n    return false;\n  };\n};\n\nav.GlobalManagerMixin.call(MeasureTool.prototype);","import { Indicator } from './Indicator';\nimport { getPolygonVisualCenter } from \"./PolygonCentroid\";\n\nvar av = Autodesk.Viewing;\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon;\n\n/** Color values should match Measure.css **/\nvar DEFAULT_LINE_COLOR = '009bea';\nvar X_AXIS_COLOR = \"F12C2C\";\nvar Y_AXIS_COLOR = \"0BB80B\";\nvar Z_AXIS_COLOR = \"2C2CF1\";\n/*******************************************/\n\nvar tmpColor = new THREE.Color();\nfunction numToColor(num) {\n  return tmpColor.set(num >>> 8).getHexString();\n}\n\n// /** @constructor */\nexport function MeasureToolIndicator(viewer, measurement, measureTool)\n{\n  Indicator.call(this, viewer, measurement, measureTool);\n  this.measureTool = measureTool;\n  this.endpoints = [];\n  this.lines = {\n    xyz: { axis: false, material: this._createLineMaterial(DEFAULT_LINE_COLOR), className: 'adsk-icon-axis-delta' + '-xyz measure-label-axis-delta' + ' measure-label-axis-xyz' },\n    x: { axis: true, material: this._createLineMaterial(X_AXIS_COLOR), className: 'adsk-icon-axis-delta' + '-x measure-label-axis-delta' + ' measure-label-axis-x', iconText: 'X' },\n    y: { axis: true, material: this._createLineMaterial(Y_AXIS_COLOR), className: 'adsk-icon-axis-delta' + '-y measure-label-axis-delta' + ' measure-label-axis-y', iconText: 'Y' },\n    z: { axis: true, material: this._createLineMaterial(Z_AXIS_COLOR), className: 'adsk-icon-axis-delta' + '-z measure-label-axis-delta' + ' measure-label-axis-z', iconText: 'Z' } };\n\n  this.applyLineColor(this.lines.xyz.material);\n  this.segments = [];\n  this.dashedLines = [];\n  this.simple = false;\n  this.angleLabel = {};\n  this.areaLabel = {};\n  this.arcLabel = {};\n  this.locationLabel = {};\n  this.calloutLabel = {};\n  this.labels = [];\n  this.isLeaflet = false;\n  this.topologyStatus = TOPOLOGY_NOT_AVAILABLE;\n  this.tmpVector = new THREE.Vector3();\n  this.surfaceColor = new THREE.MeshBasicMaterial({\n    color: parseInt(DEFAULT_LINE_COLOR, 16),\n    opacity: 0.15,\n    transparent: true,\n    depthTest: false,\n    depthWrite: false,\n    side: THREE.DoubleSide });\n\n  this.applyLineColor(this.surfaceColor);\n}\n\nMeasureToolIndicator.prototype = Object.create(Indicator.prototype);\nMeasureToolIndicator.prototype.constructor = MeasureToolIndicator;\nvar proto = MeasureToolIndicator.prototype;\n\nvar _labelsSpace = 4;\nvar _angleLabelOffset = 5;\nvar TOPOLOGY_NOT_AVAILABLE = 0;\nvar TOPOLOGY_FETCHING = 1;\nvar TOPOLOGY_AVAILABLE = 2;\nvar _selectorAreaSize = 15;\n\nvar _tipHeight = 2;\nvar _tipWidth = 3;\nvar _segmentWidth = 4;\nvar _dashedSegmentWidth = 3;\nvar _axisLineWidth = 2;\nvar _dashSize = 2;\nvar _gapSize = 1;\n\nvar _angleArcWidth = 2;\n\nfunction isVisible(label) {\n  return label.classList.contains('visible');\n}\n\nproto.init = function () {\n  this.isLeaflet = this.viewer.model.isLeaflet();\n  // Create HTML Labels\n  var currLabel;\n\n  this.onSelectionAreaClickedBinded = this.onSelectionAreaClicked.bind(this);\n\n  // Line\n  if (!this.lines.xyz.label) {\n    currLabel = this.lines.xyz.label = this.createMeasurementLabel(); // Measurement result\n    currLabel.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    currLabel.addEventListener('click', this.onSelectionAreaClickedBinded);\n    this.viewer.container.appendChild(currLabel);\n  }\n  switch (this.topologyStatus) {\n    case TOPOLOGY_FETCHING:\n      this.setFetchingTopology();\n      break;\n    case TOPOLOGY_AVAILABLE:\n      this.setTopologyAvailable();\n      break;\n    case TOPOLOGY_NOT_AVAILABLE:\n      this.setNoTopology();\n      break;}\n\n\n  this.showMeasureResult = false;\n\n  this.onCameraChangeBinded = this.onCameraChange.bind(this);\n  this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n\n  this.handleButtonUpBinded = this.measureTool.handleButtonUp.bind(this.measureTool);\n  this.addWindowEventListener('mouseup', this.handleButtonUpBinded);\n};\n\nproto._hexToCorrectedColor = function (color) {\n  tmpColor.set(parseInt(color, 16));\n\n  // In case of a 3D viewer, manually apply gamma correction to the materials.\n  // It is needed because we are using THREE.js materials that don't get LMV's shaders.\n  // So GAMMA_INPUT & GAMMA_OUTPUT are missing in their shaders.\n  if (!this.viewer.impl.is2d) {\n    tmpColor.multiply(tmpColor);\n  }\n\n  return tmpColor;\n};\n\nproto._createLineMaterial = function (color) {\n  var correctedColor = this._hexToCorrectedColor(color);\n\n  var material = new THREE.MeshBasicMaterial({\n    color: correctedColor.getHex(),\n    depthTest: false,\n    depthWrite: false,\n    side: THREE.DoubleSide });\n\n\n  return material;\n};\n\nproto.createEndpoint = function (index) {\n  this.endpoints[index] = {};\n\n  // Don't render endpoints that are under the labels.\n  if (index === 2 && (\n  this.measurement.measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_LOCATION ||\n  this.measurement.measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_CALLOUT)) {\n    return;\n  }\n\n  var currLabel = this.endpoints[index].label = this.createSnapResultLabel(index);\n  this.viewer.container.appendChild(currLabel);\n};\n\nproto.applyLineColor = function (material) {\n  if (!material)\n  return;\n\n  var hasColor = this.measurement.options && this.measurement.options.format &&\n  this.measurement.options.format.TEXTCOLOR && this.measurement.options.format.TEXTCOLOR.Enabled === 'true' &&\n  this.measurement.options.format.FILLCOLOR && this.measurement.options.format.FILLCOLOR.Enabled === 'true' &&\n  this.measurement.options.format.LINECOLOR && this.measurement.options.format.LINECOLOR.Enabled === 'true';\n  var lineColor = hasColor ? numToColor(this.measurement.options.format.LINECOLOR.UIntValue) : DEFAULT_LINE_COLOR;\n  var correctedColor = this._hexToCorrectedColor(lineColor);\n\n  material.color.set(correctedColor);\n};\n\nproto.applyLabelColors = function (label) {\n  if (!label)\n  return;\n\n  var hasColor = this.measurement.options && this.measurement.options.format &&\n  this.measurement.options.format.TEXTCOLOR && this.measurement.options.format.TEXTCOLOR.Enabled === 'true' &&\n  this.measurement.options.format.FILLCOLOR && this.measurement.options.format.FILLCOLOR.Enabled === 'true' &&\n  this.measurement.options.format.LINECOLOR && this.measurement.options.format.LINECOLOR.Enabled === 'true';\n  var color = hasColor ? \"#\".concat(numToColor(this.measurement.options.format.TEXTCOLOR.UIntValue)) : \"#\".concat(DEFAULT_LINE_COLOR);\n  var bg = hasColor ? \"#\".concat(numToColor(this.measurement.options.format.FILLCOLOR.UIntValue)) : '#f4f4f4';\n  label.style.color = color;\n  label.style.backgroundColor = bg;\n};\n\nproto.updateLabelsPosition = function () {var _this = this;\n\n  var point,\n  xy,\n  label,\n  key;\n\n  var placeLabel = function placeLabel(xOff, yOff) {\n    xy = MeasureCommon.project(point, _this.viewer);\n\n    label.style.top = xy.y - yOff + 'px';\n    label.style.left = xy.x - xOff + 'px';\n    label.point = point;\n    _this.applyLabelColors(label);\n    _this.labels.push(label);\n  };\n\n  for (key in this.endpoints) {\n    if (this.endpoints.hasOwnProperty(key)) {\n      label = this.endpoints[key].label;\n      point = this.endpoints[key].position;\n\n      if (label && point && isVisible(label)) {\n        xy = MeasureCommon.project(point, this.viewer);\n\n        placeLabel(label.getBoundingClientRect().width / 2,\n        label.getBoundingClientRect().height / 2);\n      }\n    }\n  }\n\n  for (var name in this.lines) {\n    if (this.lines.hasOwnProperty(name)) {\n      var item = this.lines[name];\n      label = item.label;\n\n      if (label && item.p1 && item.p2 && isVisible(label)) {\n\n        item.line.visible = item.visible;\n\n        point = { x: (item.p1.x + item.p2.x) / 2, y: (item.p1.y + item.p2.y) / 2, z: (item.p1.z + item.p2.z) / 2 };\n\n        xy = MeasureCommon.project(point, this.viewer);\n        label.style.top = xy.y - Math.floor(label.clientHeight / 2) + 'px';\n        label.style.left = xy.x - Math.floor(label.clientWidth / 2) + 'px';\n\n        if (this.viewer.model && this.viewer.model.is2d()) {\n          var offset = item === this.lines.xyz ? 0 : label.clientHeight;\n\n          var p1Projected = MeasureCommon.project(item.p1, this.viewer);\n          var p2Projected = MeasureCommon.project(item.p2, this.viewer);\n\n          if (label.clientWidth >= p1Projected.distanceTo(p2Projected) - this.endpoints[1].label.clientWidth) {\n            if (item === this.lines.xyz) {\n              offset = label.clientHeight;\n            } else {\n              // Hide all axis labels and quit the loop\n\n              this.lines.x.line.visible = false;\n              this.lines.y.line.visible = false;\n\n              this.viewer.impl.invalidate(false, false, /*overlayDirty=*/true);\n\n              for (name in this.lines) {\n                if (this.lines.hasOwnProperty(name)) {\n                  if (this.lines[name] !== this.lines.xyz) {\n                    var currLabel = this.lines[name].label;\n                    if (currLabel) {\n                      currLabel.style.opacity = 0;\n                    }\n                  }\n                }\n              }\n\n              break;\n\n            }\n          }\n\n          if (item !== this.lines.xyz) {\n            var xyzDirection = new THREE.Vector3();\n            var itemDirection = new THREE.Vector3();\n            xyzDirection.subVectors(this.lines.xyz.p1, this.lines.xyz.p2).normalize();\n            itemDirection.subVectors(item.p1, item.p2).normalize();\n            var normal = xyzDirection.cross(this.viewer.navigation.getEyeVector()).normalize();\n            var angle = normal.dot(itemDirection);\n\n            if (angle < 0) {\n              offset = -offset;\n            }\n          }\n\n          this.alignLabelWithLine(label, item.p1, item.p2, offset, this.viewer);\n        }\n\n        label.style.opacity = 1;\n        label.point = point;\n        this.applyLabelColors(label);\n        this.labels.push(label);\n      }\n    }\n  }\n\n  if (this.angleLabel) {\n\n    label = this.angleLabel.label;\n\n    if (label && this.angleLabel.p1 && this.angleLabel.p2 && isVisible(label)) {\n      point = { x: (this.angleLabel.p1.x + this.angleLabel.p2.x) / 2, y: (this.angleLabel.p1.y + this.angleLabel.p2.y) / 2, z: (this.angleLabel.p1.z + this.angleLabel.p2.z) / 2 };\n      xy = MeasureCommon.project(point, this.viewer, _angleLabelOffset);\n      placeLabel(Math.floor(label.clientWidth / 2), Math.floor(label.clientHeight / 2));\n    }\n  }\n\n  if (this.arcLabel) {\n    label = this.arcLabel.label;\n    offset = 0;\n\n    if (label && this.arcLabel.p1 && this.arcLabel.p2 && isVisible(label)) {\n      point = { x: (this.arcLabel.p1.x + this.arcLabel.p2.x) / 2, y: (this.arcLabel.p1.y + this.arcLabel.p2.y) / 2, z: (this.arcLabel.p1.z + this.arcLabel.p2.z) / 2 };\n      xy = MeasureCommon.project(point, this.viewer, label.clientHeight);\n      placeLabel(Math.floor(label.clientWidth / 2), Math.floor(label.clientHeight / 2));\n\n      // Rotate the label\n      var p1Projected = MeasureCommon.project(this.arcLabel.point1Relative, this.viewer);\n      var p2Projected = MeasureCommon.project(this.arcLabel.point2Relative, this.viewer);\n\n      if (label.clientWidth >= p1Projected.distanceTo(p2Projected) - this.endpoints[1].label.clientWidth) {\n\n        // you need to project midpoint and the circle center here because the offset direction logic occurs in screen coordinates\n        var midPointProjected = MeasureCommon.project(this.arcLabel.midPointRelative, this.viewer);\n        var centerProjected = MeasureCommon.project(new THREE.Vector3(), this.viewer);\n\n        // Check if the midpoint position is above or below the center of the circle\n        // Based on this, offset the label up or down to ensure it is always outside the arc\n        if (midPointProjected.y > centerProjected.y) {\n          offset = label.clientHeight; // offset down\n        } else {\n          offset = -label.clientHeight; // offset up\n        }\n\n      }\n      this.alignLabelWithLine(label, this.arcLabel.point1Relative, this.arcLabel.point2Relative, offset, this.viewer);\n    }\n  }\n\n  if (this.locationLabel) {\n\n    label = this.locationLabel.label;\n\n    if (label && this.locationLabel.p && isVisible(label)) {\n      xy = MeasureCommon.project(this.locationLabel.p, this.viewer);\n      placeLabel(Math.floor(label.clientWidth / 2), Math.floor(label.clientHeight / 2));\n    }\n  }\n\n  if (this.calloutLabel) {\n\n    label = this.calloutLabel.label;\n\n    if (label && this.calloutLabel.p && isVisible(label)) {\n      xy = MeasureCommon.project(this.calloutLabel.p, this.viewer);\n      placeLabel(Math.floor(label.clientWidth / 2), Math.floor(label.clientHeight / 2));\n    }\n  }\n\n  if (this.areaLabel) {\n\n    label = this.areaLabel.label;\n\n    if (label && this.areaLabel.p1 && this.areaLabel.p2 && isVisible(label)) {\n      point = { x: (this.areaLabel.p1.x + this.areaLabel.p2.x) / 2, y: (this.areaLabel.p1.y + this.areaLabel.p2.y) / 2, z: (this.areaLabel.p1.z + this.areaLabel.p2.z) / 2 };\n      xy = MeasureCommon.project(point, this.viewer);\n      placeLabel(Math.floor(label.clientWidth / 2), Math.floor(label.clientHeight / 2));\n    }\n  }\n\n  if (this.viewer.model && !this.viewer.model.is2d()) {\n\n    var needToStackLabels = false;\n    this.labelsStacked = false;\n    var currentLabel, i;\n\n    // Backup lable's positions in case of the need of stacking them later\n    var backupPositions = [];\n    for (i = 0; i < this.labels.length; i++) {\n      backupPositions.push({ left: this.labels[i].style.left, top: this.labels[i].style.top });\n    }\n\n    // Detect and move in case of overlapping.\n    for (i = 0; i < this.labels.length && !needToStackLabels; i++) {\n      currentLabel = this.labels[i];\n      needToStackLabels = this.labelsOverlapDetection(currentLabel, this.labels);\n    }\n\n    // If we found out that the labels need to be stacked, restore their positions from the backup first, and then start again.\n    if (needToStackLabels) {\n\n      for (i = 0; i < this.labels.length; i++) {\n        this.labels[i].style.left = backupPositions[i].left;\n        this.labels[i].style.top = backupPositions[i].top;\n      }\n\n      this.stackLabels(this.labels);\n\n      for (i = 0; i < this.labels.length; i++) {\n        currentLabel = this.labels[i];\n        this.labelsOverlapDetection(currentLabel, this.labels);\n      }\n    }\n  }\n\n  this.labels = [];\n\n};\n\nfunction isLeftIntersect(current, other) {\n  return current.right >= other.left && current.right <= other.right;\n}\n\nfunction isRightIntersect(current, other) {\n  return current.left >= other.left && current.left <= other.right;\n}\n\nfunction isMiddleIntersect(current, other) {\n  return current.left <= other.left && current.right >= other.right;\n}\n\nfunction isVerticalIntersect(current, other) {\n  return current.top < other.bottom && current.bottom > other.top;\n}\n\nfunction moveLeft(currentLabel, currentRect, otherRect) {\n  currentLabel.style.left = parseInt(currentLabel.style.left, 10) - (currentRect.right - otherRect.left) + 'px';\n}\n\nfunction moveRight(currentLabel, currentRect, otherRect) {\n  currentLabel.style.left = parseInt(currentLabel.style.left, 10) + (otherRect.right - currentRect.left) + 'px';\n}\n\nfunction moveDown(currentLabel, currentRect, otherRect) {\n  currentLabel.style.top = parseInt(currentLabel.style.top, 10) + (otherRect.bottom - currentRect.top) + 'px';\n}\n\n\nproto.labelsOverlapDetection = function (staticLabel, labelsList) {\n\n  var needToStackLabels = false;\n\n  for (var i = 0; i < labelsList.length; i++) {\n\n    var dynamicLabel = labelsList[i];\n    var moved = false;\n\n    if (staticLabel !== dynamicLabel) {\n      var staticRect = staticLabel.getBoundingClientRect();\n      var dynamicRect = dynamicLabel.getBoundingClientRect();\n\n      if (isVerticalIntersect(dynamicRect, staticRect)) {\n\n        if (isLeftIntersect(dynamicRect, staticRect)) {\n          moveLeft(dynamicLabel, dynamicRect, staticRect);\n          moved = true;\n        } else\n        if (isRightIntersect(dynamicRect, staticRect)) {\n          moveRight(dynamicLabel, dynamicRect, staticRect);\n          moved = true;\n        } else\n        if (isMiddleIntersect(dynamicRect, staticRect)) {\n          moveDown(dynamicLabel, dynamicRect, staticRect);\n          moved = true;\n        }\n\n        if (moved) {\n          var newList = labelsList.slice(0);\n          newList.splice(newList.indexOf(staticLabel), 1);\n          this.labelsOverlapDetection(dynamicLabel, newList);\n\n          if (dynamicLabel.causeStacking && staticLabel.causeStacking) {\n            needToStackLabels = true;\n          }\n\n          // We don't want that after the labels have been stacked, only one of them will move alone.\n          if (dynamicLabel.causeStacking && this.labelsStacked) {\n            this.stackLabels(this.labels);\n          }\n        }\n      }\n    }\n  }\n\n  return needToStackLabels;\n};\n\nproto.stackLabels = function (labels) {\n  var topLabel = this.lines.xyz.label;\n\n  for (var i = 1; i < labels.length; i++) {\n    if (labels[i].causeStacking) {\n      labels[i].style.left = topLabel.style.left;\n\n      var rect = labels[i - 1].getBoundingClientRect();\n      var space = labels[i - 1] == topLabel ? _labelsSpace : 0;\n      var top = labels[i] === topLabel ? topLabel.style.top : labels[i - 1].style.top;\n      labels[i].style.top = parseInt(top, 10) + rect.height + space + 'px';\n    }\n    labels[i].style.transform = '';\n  }\n\n  this.labelsStacked = true;\n};\n\nproto.drawXYZLine = function (item) {\n  var self = this;\n\n  var p1 = item.p1;\n  var p2 = item.p2;\n\n  if (!p1 || !p2)\n  return;\n\n  item.line = this.drawLineSegment(p1, p2, _segmentWidth, item.material);\n\n  var tmpVec = new THREE.Vector3();\n  var geometry = item.geometry = new THREE.Geometry();\n  var point = MeasureCommon.nearestPointInPointToSegment(self.viewer.navigation.getPosition(), p1, p2);\n  var scale = self.setScale(point);\n\n  var direction;\n  var dimensionOffset = this.measurement.options && this.measurement.options.dimensionOffset;\n  if (dimensionOffset) {\n    var d1 = new THREE.Vector3(dimensionOffset[0].x, dimensionOffset[0].y, dimensionOffset[0].z);\n    var d2 = new THREE.Vector3(dimensionOffset[1].x, dimensionOffset[1].y, dimensionOffset[1].z);\n    direction = new THREE.Vector3().subVectors(p1, d1);\n    this.segments.push({ line: this.drawLineSegment(d1, p1, _segmentWidth, item.material), p1: d1, p2: p1 });\n    this.segments.push({ line: this.drawLineSegment(p2, d2, _segmentWidth, item.material), p1: p2, p2: d2 });\n    p1 = d1;\n    p2 = d2;\n  } else {\n    direction = new THREE.Vector3().subVectors(p2, p1);\n  }\n  var normal = direction.cross(self.viewer.navigation.getEyeVector()).normalize();\n  item.visible = true;\n\n  this.segments.push(item);\n\n  var dashedLeader = this.measurement.options && this.measurement.options.dashedLeader;\n  if (dashedLeader) {\n    var l1 = new THREE.Vector3(dashedLeader[0].x, dashedLeader[0].y, dashedLeader[0].z);\n    var l2 = new THREE.Vector3(dashedLeader[1].x, dashedLeader[1].y, dashedLeader[1].z);\n    this.drawLineSegment(l1, l2, _segmentWidth, item.material, true);\n  }\n\n  function drawTip(p) {\n    geometry.vertices = [];\n\n    // Edge\n    tmpVec.addVectors(p, normal.clone().multiplyScalar(_tipHeight * scale));\n    geometry.vertices[0] = tmpVec.clone();\n    tmpVec.subVectors(p, normal.clone().multiplyScalar(_tipHeight * scale));\n    geometry.vertices[1] = tmpVec.clone();\n    var line = self.drawLineAsCylinder(geometry, item.material, _tipWidth, self.overlayName);\n    self.setCylinderScale(line, p1, p2);\n    line.visible = true;\n    item.tips.push(line);\n  }\n\n  if (self.showMeasureResult) {\n    item.tips = [];\n\n    drawTip(p1);\n    drawTip(p2);\n  }\n};\n\nproto.redrawDashedLine = function (dashedLine) {\n  if (!dashedLine.p1 || !dashedLine.p2)\n  return;\n\n  this.viewer.impl.removeMultipleOverlays(this.overlayName, dashedLine.line);\n\n  var p1Scale = this.setScale(dashedLine.p2);\n  var dashSize = _dashSize * p1Scale;\n  var gapSize = _gapSize * p1Scale;\n  dashedLine.line = this.drawDashedLine(dashedLine.p2, dashedLine.p1, dashSize, gapSize, this.lines.xyz.material, _dashedSegmentWidth, this.overlayName);\n\n  return dashedLine.line;\n};\n\nproto.redrawDashedLines = function () {\n  this.dashedLines.forEach(this.redrawDashedLine.bind(this));\n};\n\nproto.drawLineSegment = function (p1, p2, width, material, isDashedLine) {\n  var line;\n\n  if (isDashedLine) {\n    var dashedLine = {};\n    dashedLine.p1 = p1;\n    dashedLine.p2 = p2;\n    this.dashedLines.push(dashedLine);\n    line = this.redrawDashedLine(dashedLine);\n  } else {\n    var geometry = new THREE.Geometry();\n    geometry.vertices.push(p1);\n    geometry.vertices.push(p2);\n    line = this.drawLineAsCylinder(geometry, material, width, this.overlayName);\n    this.setCylinderScale(line, p1, p2);\n  }\n\n  line.visible = true;\n\n  return line;\n};\n\nproto.drawSurface = function (points) {\n\n  var cg = Autodesk.Viewing.Extensions.CompGeom;\n\n  var cset = new cg.ContourSet();\n\n  cset.addContour(points);\n\n  cset.triangulate();\n\n  if (cset.triangulationFailed)\n  return false;\n\n  var bufferGeometry = cset.toPolygonMesh();\n\n  var face = new THREE.Mesh(bufferGeometry, this.surfaceColor);\n  this.applyLineColor(this.surfaceColor);\n\n  this.viewer.impl.addOverlay(this.overlayName, face);\n\n  return true;\n};\n\nproto.drawSegmentAndPush = function (p1, p2, isDashedLine) {\n  if (!p1 || !p2) {\n    return;\n  }\n\n  var line = this.drawLineSegment(p1, p2, _segmentWidth, this.lines.xyz.material, isDashedLine);\n\n  if (!isDashedLine) {\n    var item = { line: line, p1: p1, p2: p2 };\n    this.segments.push(item);\n  }\n};\n\n\nproto.renderAreaMeasurementFromPoints = function (pickPositions) {\n  var p1, p2;\n  var firstPoint;\n\n  var points = [];\n  this.applyLineColor(this.lines.xyz.material);\n  this.applyLineColor(this.surfaceColor);\n\n  var keys = Object.keys(pickPositions);\n\n  for (var i = 0; i < keys.length - 1; i++) {\n    var key = parseFloat(keys[i]);\n    var position1 = pickPositions[key];\n    var position2 = pickPositions[key + 1];\n\n    if (i === 0) {\n      firstPoint = new THREE.Vector3(position1.x, position1.y, position1.z);\n    }\n\n    p1 = new THREE.Vector3(position1.x, position1.y, position1.z);\n    p2 = new THREE.Vector3(position2.x, position2.y, position2.z);\n\n    this.drawSegmentAndPush(p1, p2);\n    points.push(p1);\n  }\n\n  if (keys.length > 2) {\n    // Draw last line\n    this.drawSegmentAndPush(firstPoint, p2, !this.measurement.closedArea);\n\n    if (!MeasureCommon.isEqualVectors(firstPoint, p2, MeasureCommon.EPSILON)) {\n      points.push(p2);\n    }\n\n    if (this.measurement.area !== 0) {\n      //Draw surface will return false if it failed to triangulate the polygon (e.g. it has self-intersections)\n      if (this.drawSurface(points)) {\n        this.showAreaLabel(getPolygonVisualCenter(points));\n        this.updateArea();\n      }\n    }\n  }\n};\n\nproto.renderAreaMeasurement = function (picks) {\n\n  var count = this.measurement.countPicks();\n  var p1, p2;\n\n  var points = [];\n\n  for (var i = 1; i < count; i++) {\n    p1 = MeasureCommon.getSnapResultPosition(picks[i], this.viewer);\n    p2 = MeasureCommon.getSnapResultPosition(picks[i + 1], this.viewer);\n\n    this.drawSegmentAndPush(p1, p2);\n    points.push(p1);\n  }\n\n  if (count > 2) {\n    // Draw last line\n    p1 = MeasureCommon.getSnapResultPosition(picks[1], this.viewer);\n    this.drawSegmentAndPush(p1, p2, !this.measurement.closedArea);\n\n    if (!MeasureCommon.isEqualVectors(p1, p2, MeasureCommon.EPSILON)) {\n      points.push(p2);\n    }\n\n    if (this.measurement.area !== 0) {\n      //Draw surface will return false if it failed to triangulate the polygon (e.g. it has self-intersections)\n      if (this.drawSurface(points)) {\n        this.showAreaLabel(getPolygonVisualCenter(points));\n        this.updateArea();\n      }\n    }\n  }\n};\n\nproto.clearAngleMeshes = function () {\n  if (this.angleArc) {\n    this.viewer.impl.removeOverlay(this.overlayName, this.angleArc);\n    this.angleArc = null;\n  }\n  if (this.angleOutline.length > 0) {\n    this.viewer.impl.removeMultipleOverlays(this.overlayName, this.angleOutline);\n    this.angleOutline.length = 0;\n  }\n};\n\nproto.drawAngle = function (p, ep1, ep2, n, angle, midPoint, _radius) {\n\n  var smallNum = 0.001;\n\n  if (!this.materialAngle) {\n\n    this.materialAngle = new THREE.MeshPhongMaterial({\n      color: 0x999999,\n      ambient: 0x999999,\n      opacity: 0.5,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      side: THREE.DoubleSide });\n\n\n\n    this.materialAngleOutline = new THREE.MeshBasicMaterial({\n      color: 0xFF9900,\n      depthTest: false,\n      depthWrite: false });\n\n\n  }\n\n  this.applyLineColor(this.lines.xyz.material);\n  this.applyLineColor(this.surfaceColor);\n\n  MeasureCommon.createCommonOverlay(this.viewer, this.overlayName);\n  this.clearAngleMeshes();\n\n  // draw arc of angle\n  var radius = _radius || Math.min(p.distanceTo(ep1), p.distanceTo(ep2)) / 4;\n  var segments = 100;\n  //angle = angle * Math.PI / 180;\n\n  var circleGeometry = new THREE.CircleGeometry(radius, segments, 0, angle * Math.PI / 180);\n  var arc = new THREE.Mesh(circleGeometry, this.surfaceColor);\n  this.applyLineColor(this.surfaceColor);\n\n  var center = arc.geometry.vertices[0].clone();\n  arc.geometry.vertices.push(center);\n\n\n  // Translate and rotate the arc to the plane where it should lie in\n  arc.position.set(p.x, p.y, p.z);\n  var V = arc.position.clone();\n  V.add(n);\n  arc.lookAt(V);\n  arc.updateMatrixWorld();\n\n\n  // Rotate the arc in the plane to the right place\n  var vA = arc.geometry.vertices[1].clone();\n  var vB = arc.geometry.vertices[arc.geometry.vertices.length - 2].clone();\n  vA.applyMatrix4(arc.matrixWorld);\n  vB.applyMatrix4(arc.matrixWorld);\n\n  var v1 = new THREE.Vector3();\n  var v2 = new THREE.Vector3();\n  var v3 = new THREE.Vector3();\n  var v4 = new THREE.Vector3();\n  v1.subVectors(vA, p);\n  v2.subVectors(vB, p);\n  v3.subVectors(ep1, p);\n  v4.subVectors(ep2, p);\n\n  var a13 = v1.angleTo(v3);\n  var a14 = v1.angleTo(v4);\n  var a23 = v2.angleTo(v3);\n  var a24 = v2.angleTo(v4);\n\n  //console.log(a13 * 180 / Math.PI + \" \" + a14 * 180 / Math.PI + \" \" + a23 * 180 / Math.PI + \" \" + a24 * 180 / Math.PI);\n\n  var ra;\n  // The arc is in the right place\n  if ((a13 <= smallNum && a13 >= -smallNum || a14 <= smallNum && a14 >= -smallNum) && (\n  a23 <= smallNum && a23 >= -smallNum || a24 <= smallNum && a24 >= -smallNum)) {\n\n    ra = 0;\n  }\n  // The arc needs to be rotated 180 degree to the right place\n  else if ((a13 <= Math.PI + smallNum && a13 >= Math.PI - smallNum || a14 <= Math.PI + smallNum && a14 >= Math.PI - smallNum) && (\n    a23 <= Math.PI + smallNum && a23 >= Math.PI - smallNum || a24 <= Math.PI + smallNum && a24 >= Math.PI - smallNum)) {\n\n      ra = Math.PI;\n    }\n    // The arc needs to be rotated a13 radian\n    else if (a13 <= a23 + smallNum && a13 >= a23 - smallNum || a13 <= a24 + smallNum && a13 >= a24 - smallNum) {\n\n        ra = a13;\n      }\n      // The arc needs to be rotated a14 radian\n      else {\n\n          ra = a14;\n        }\n\n  var rotWorldMatrix = new THREE.Matrix4();\n  rotWorldMatrix.makeRotationAxis(n, ra);\n  //arc.matrix.multiply(rotWorldMatrix);\n  rotWorldMatrix.multiply(arc.matrix);\n  arc.matrix = rotWorldMatrix;\n  arc.rotation.setFromRotationMatrix(arc.matrix);\n\n  // Check if rotate to the wrong direction, if so, rotate back twice of the degree\n  arc.updateMatrixWorld();\n  vA = arc.geometry.vertices[1].clone();\n  vB = arc.geometry.vertices[arc.geometry.vertices.length - 2].clone();\n  vA.applyMatrix4(arc.matrixWorld);\n  vB.applyMatrix4(arc.matrixWorld);\n\n  v1.subVectors(vA, p);\n  v2.subVectors(vB, p);\n\n  a13 = v1.angleTo(v3);\n  a14 = v1.angleTo(v4);\n  a23 = v2.angleTo(v3);\n  a24 = v2.angleTo(v4);\n\n  //console.log(a13 * 180 / Math.PI + \" \" + a14 * 180 / Math.PI + \" \" + a23 * 180 / Math.PI + \" \" + a24 * 180 / Math.PI);\n\n  if (a13 >= smallNum && a14 >= smallNum) {\n\n    rotWorldMatrix = new THREE.Matrix4();\n    rotWorldMatrix.makeRotationAxis(n, -ra * 2);\n    //arc.matrix.multiply(rotWorldMatrix);\n    rotWorldMatrix.multiply(arc.matrix);\n    arc.matrix = rotWorldMatrix;\n    arc.rotation.setFromRotationMatrix(arc.matrix);\n  }\n\n  // draw outline of the arc\n  var outlineGeometry = new THREE.CircleGeometry(radius, segments, 0, angle * Math.PI / 180);\n  outlineGeometry.vertices.splice(0, 1);\n  arc.updateMatrixWorld();\n  outlineGeometry.applyMatrix(arc.matrixWorld);\n  this.angleOutline = this.drawEdgeAsCylinder(outlineGeometry, this.lines.xyz.material, _angleArcWidth, 0, this.getNewCylinderGeometry());\n\n  this.angleArc = arc;\n  this.viewer.impl.addOverlay(this.overlayName, this.angleArc);\n  this.viewer.impl.addMultipleOverlays(this.overlayName, this.angleOutline);\n\n  // This is used for angle label's position\n  midPoint.copy(arc.geometry.vertices[Math.round(arc.geometry.vertices.length / 2) - 1]);\n  midPoint.applyMatrix4(arc.matrixWorld);\n  if (!_radius) {\n    var dir = new THREE.Vector3();\n    dir.subVectors(midPoint, p).normalize();\n    dir.multiplyScalar(radius / 2);\n    midPoint.add(dir);\n  }\n};\n\nproto.createArcLabel = function () {\n  var label = this.createMeasurementLabel();\n  this.viewer.container.appendChild(label);\n  label.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n  label.addEventListener('click', this.onSelectionAreaClickedBinded);\n\n  return label;\n};\n\nproto.clearArcMeshes = function () {\n  if (this.arcOutline && this.arcOutline.length > 0) {\n    this.viewer.impl.removeMultipleOverlays(this.overlayName, this.arcOutline);\n    this.arcOutline.length = 0;\n  }\n};\n\nproto.drawCircularArc = function (point1, point2, center, radius) {var drawTips = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var segments = 100;\n  var edgeGeomtry = new THREE.Geometry();\n  var tmpVec = new THREE.Vector3();\n  var nearPoint = MeasureCommon.nearestPointInPointToSegment(this.viewer.navigation.getPosition(), point1, point2);\n  var scale = this.setScale(nearPoint);\n\n  var point1Relative = new THREE.Vector3();\n  point1Relative.subVectors(point1, center);\n  var startAngle = Math.atan2(point1Relative.y, point1Relative.x);\n\n  var point2Relative = new THREE.Vector3();\n  point2Relative.subVectors(point2, center);\n  var endAngle = Math.atan2(point2Relative.y, point2Relative.x);\n\n  // Set this.lines with the points to rotabte the label\n  this.arcLabel.point1Relative = point1Relative.clone();\n  this.arcLabel.point2Relative = point2Relative.clone().normalize().multiplyScalar(radius);\n\n  var arcAngle = endAngle - startAngle;\n  if (arcAngle > Math.PI) {\n    arcAngle -= 2 * Math.PI;\n  } else if (arcAngle < -Math.PI) {\n    arcAngle += 2 * Math.PI;\n  }\n\n  var circleGeometry = new THREE.CircleGeometry(radius, segments, startAngle, arcAngle);\n  var arc = new THREE.Mesh(circleGeometry, this.lines.xyz.material);\n\n  // Translate and rotate the arc to the plane where it should lie in\n  arc.position.set(center.x, center.y, center.z);\n  circleGeometry.vertices.splice(0, 1);\n\n  arc.updateMatrixWorld();\n  circleGeometry.applyMatrix(arc.matrixWorld);\n\n  MeasureCommon.createCommonOverlay(this.viewer, this.overlayName);\n  this.clearArcMeshes();\n  this.arcOutline = this.drawEdgeAsCylinder(circleGeometry, this.lines.xyz.material, _segmentWidth, 0, this.getNewCylinderGeometry());\n\n  this.viewer.impl.addMultipleOverlays(this.overlayName, this.arcOutline);\n\n  function drawArcTip(p, normal) {\n    edgeGeomtry.vertices = [];\n\n    tmpVec.addVectors(p, normal.clone().multiplyScalar(_tipHeight * scale));\n    edgeGeomtry.vertices[0] = tmpVec.clone();\n\n    tmpVec.subVectors(p, normal.clone().multiplyScalar(_tipHeight * scale));\n    edgeGeomtry.vertices[1] = tmpVec.clone();\n\n    var line = this.drawLineAsCylinder(edgeGeomtry, this.lines.xyz.material, _tipWidth, this.overlayName);\n    this.arcTip.push(line);\n  }\n\n  // Draw arc's tip lines\n  if (drawTips) {\n    drawArcTip.call(this, point1, point1Relative.normalize());\n    drawArcTip.call(this, point2, point2Relative.normalize());\n  }\n\n  var midPoint = new THREE.Vector3();\n\n  // Calculate midpoint position\n  var midAngle = startAngle + arcAngle * 0.5;\n  midPoint.x = Math.cos(midAngle) * radius;\n  midPoint.y = Math.sin(midAngle) * radius;\n  this.arcLabel.midPointRelative = midPoint.clone();\n  midPoint.applyMatrix4(arc.matrixWorld);\n\n  this.showArcLabel(midPoint);\n};\n\nproto.renderAngleMeasurementFromPoints = function (pickPositions) {\n  var points = [];\n\n  var keys = Object.keys(pickPositions);\n  for (var i = 0; i < keys.length; i++) {\n    var key = parseFloat(keys[i]);\n    var position = pickPositions[key];\n\n    points.push(new THREE.Vector3(position.x, position.y, position.z));\n  }\n\n  if (points.length === 3) {\n    var arcRadius;\n    var options = this.measurement.options;\n    if (options && options.offset) {\n      var o0 = new THREE.Vector3(options.offset.x, options.offset.y, options.offset.z);\n      var o1 = o0.clone().add(points[1]);\n      o0.add(points[0]);\n      this.drawSegmentAndPush(o0, o1);\n      this.drawSegmentAndPush(points[1], points[2]);\n      this.drawSegmentAndPush(points[0], o0, true);\n      this.drawSegmentAndPush(points[1], o1, true);\n      arcRadius = o1.clone().sub(o0).length();\n    } else {\n      this.drawSegmentAndPush(points[0], points[1]);\n      this.drawSegmentAndPush(points[1], points[2]);\n    }\n\n    if (this.measurement.angle) {\n      var n = new THREE.Vector3();\n      var v1 = new THREE.Vector3();\n      var v2 = new THREE.Vector3();\n      v1.subVectors(points[0], points[1]);\n      v2.subVectors(points[1], points[2]);\n      n.crossVectors(v1, v2);\n      n.normalize();\n\n      var midPoint = new THREE.Vector3();\n      this.drawAngle(points[1], points[0], points[2], n, this.measurement.angle, midPoint, arcRadius);\n      this.showAngleLabel(midPoint);\n      this.updateAngle();\n    }\n  }\n};\n\nproto.renderAngleMeasurement = function (picks) {\n\n  var count = this.measurement.countPicks();\n  var p1, p2;\n\n  var points = [];\n  this.applyLineColor(this.lines.xyz.material);\n  this.applyLineColor(this.surfaceColor);\n\n  for (var i = 1; i < count; i++) {\n    p1 = MeasureCommon.getSnapResultPosition(picks[i], this.viewer);\n    p2 = MeasureCommon.getSnapResultPosition(picks[i + 1], this.viewer);\n\n    this.drawSegmentAndPush(p1, p2);\n\n    if (p1) {\n      points.push(p1);\n    }\n  }\n\n  if (p2) {\n    points.push(p2);\n  }\n\n  if (points.length === 3 && this.measurement.angle) {\n    var n = new THREE.Vector3();\n    var v1 = new THREE.Vector3();\n    var v2 = new THREE.Vector3();\n    v1.subVectors(points[0], points[1]);\n    v2.subVectors(points[1], points[2]);\n    n.crossVectors(v1, v2);\n    n.normalize();\n\n    var midPoint = new THREE.Vector3();\n    this.drawAngle(points[1], points[0], points[2], n, this.measurement.angle, midPoint);\n    this.showAngleLabel(midPoint);\n    this.updateAngle();\n  }\n};\n\nproto.renderArcMeasurementFromPoints = function (p1, p2, center, radius) {\n  if (!p1 || !p2 || !center || !radius) {\n    return;\n  }\n  this.drawCircularArc(p1, p2, center, radius);\n  this.updateArcLength();\n};\n\nproto.renderArcMeasurement = function (p1, p2) {\n\n  if (!p1 || !p2 || !p1.circularArcCenter || !p1.circularArcRadius) {\n    return;\n  }\n\n  var radius = p1.circularArcRadius;\n  var center = p1.circularArcCenter;\n\n  var point1 = MeasureCommon.getSnapResultPosition(p1);\n  var point2 = MeasureCommon.getSnapResultPosition(p2);\n\n  var drawTips =\n  this.showMeasureResult &&\n  MeasureCommon.isEqualVectors(p1.circularArcCenter, p2.circularArcCenter, 0) &&\n  p1.circularArcRadius === p2.circularArcRadius;\n\n  this.drawCircularArc(point1, point2, center, radius, drawTips);\n  this.updateArcLength();\n\n};\n\nproto.renderLocationMeasurementFromPoints = function (pickPositions) {\n  var p1 = pickPositions[1];\n  var p2 = pickPositions[2];\n  if (!p1 || !p2)\n  return;\n\n  this.applyLineColor(this.lines.xyz.material);\n  this.drawSegmentAndPush(p1, p2);\n\n  this.showLocationLabel(p2);\n  this.updateLocation();\n};\n\nproto.renderLocationMeasurement = function (picks) {\n  var p1 = picks[1] && picks[1].intersection;\n  var p2 = picks[2] && picks[2].intersection;\n  if (!p1 || !p2)\n  return;\n\n  this.applyLineColor(this.lines.xyz.material);\n  this.drawSegmentAndPush(p1, p2);\n\n  this.showLocationLabel(p2);\n  this.updateLocation();\n};\n\nproto.renderCalloutMeasurementFromPoints = function (pickPositions) {\n  var p1 = pickPositions[1];\n  var p2 = pickPositions[2];\n  if (!p1 || !p2)\n  return;\n\n  this.applyLineColor(this.lines.xyz.material);\n  this.drawSegmentAndPush(p1, p2);\n\n  this.showCalloutLabel(p2);\n  this.updateCallout();\n};\n\nproto.renderCalloutMeasurement = function (picks) {\n  var p1 = picks[1] && picks[1].intersection;\n  var p2 = picks[2] && picks[2].intersection;\n  if (!p1 || !p2)\n  return;\n\n  this.applyLineColor(this.lines.xyz.material);\n  this.drawSegmentAndPush(p1, p2);\n\n  this.showCalloutLabel(p2);\n  this.updateCallout();\n};\n\nproto.createDistanceLabel = function (item) {\n  var label = item.label = this.createMeasurementLabel();\n\n  setVisibilityMeasurementLabelText(label, item === this.lines.xyz);\n\n  var _document = this.getDocument();\n  // Override main label when displaying only an axis label (X, Y or Z)\n  if (item.axis) {\n    label.className = item.className;\n    var axisIcon = _document.createElement('div');\n    axisIcon.className = 'measure-label-axis-icon ' + item.iconText;\n    axisIcon.innerText = item.iconText;\n    label.insertBefore(axisIcon, label.firstChild);\n\n    if (!av.isMobileDevice()) {\n      MeasureCommon.safeToggle(label, 'enableTransition', true);\n    }\n  }\n\n  this.viewer.container.appendChild(label);\n\n  return label;\n};\n\nproto.updateLine = function (item, x1, y1, z1, x2, y2, z2, showAxis) {\n  this.applyLineColor(this.lines.xyz.material);\n\n  var line = item.line,\n  label = item.label,\n  p1 = new THREE.Vector3(x1, y1, z1),\n  p2 = new THREE.Vector3(x2, y2, z2);\n\n  // Swap points if needed to have consistent axis directions.\n  var tmpVec;\n  if (item === this.lines.x && p2.x > p1.x) {\n    tmpVec = p1.clone();\n    p1 = p2.clone();\n    p2 = tmpVec.clone();\n  } else\n  if (item === this.lines.y && p2.y > p1.y) {\n    tmpVec = p1.clone();\n    p1 = p2.clone();\n    p2 = tmpVec.clone();\n  } else\n  if (item === this.lines.z && p2.z > p1.z) {\n    tmpVec = p1.clone();\n    p1 = p2.clone();\n    p2 = tmpVec.clone();\n  }\n\n  item.line = null;\n\n  if (!label) {\n    label = this.createDistanceLabel(item);\n  } else\n  {\n    this.hideLabel(label);\n  }\n\n  if ((this.isLeaflet && item !== this.lines.z || p1.distanceTo(p2) >= MeasureCommon.EPSILON) && showAxis) {\n\n    item.p1 = p1;\n    item.p2 = p2;\n\n    if (item === this.lines.xyz) {\n      this.drawXYZLine(item);\n      this.showLabel(label);\n      this.updateDistance();\n    } else\n    {\n      line = item.line = this.drawLineSegment(p1, p2, _axisLineWidth, item.material);\n      var show = !this.simple && this.showMeasureResult;\n\n      line.visible = show;\n      item.visible = show;\n\n      if (show) {\n        this.showLabel(label);\n      } else\n      {\n        this.hideLabel(label);\n      }\n    }\n  }\n};\n\n// Draw distance measurement\nproto.renderDistanceMeasurementFromPoints = function (p1, p2) {\n\n  this.updateLine(this.lines.xyz, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, true);\n\n  var up = this.viewer.navigation.getAlignedUpVector(),\n  x = Math.abs(up.x),\n  y = Math.abs(up.y),\n  z = Math.abs(up.z);\n\n  var showAxis = false;\n\n  if (z > x && z > y) {// z up\n    this.updateLine(this.lines.x, p1.x, p1.y, p1.z, p2.x, p1.y, p1.z, showAxis);\n    this.updateLine(this.lines.y, p2.x, p1.y, p1.z, p2.x, p2.y, p1.z, showAxis);\n    this.updateLine(this.lines.z, p2.x, p2.y, p1.z, p2.x, p2.y, p2.z, showAxis);\n\n  } else if (y > x && y > z) {// y up\n    this.updateLine(this.lines.x, p1.x, p1.y, p1.z, p2.x, p1.y, p1.z, showAxis);\n    this.updateLine(this.lines.z, p2.x, p1.y, p1.z, p2.x, p1.y, p2.z, showAxis);\n    this.updateLine(this.lines.y, p2.x, p1.y, p2.z, p2.x, p2.y, p2.z, showAxis);\n\n  } else {// x up - do we ever see this?\n    this.updateLine(this.lines.y, p1.x, p1.y, p1.z, p1.x, p2.y, p1.z, showAxis);\n    this.updateLine(this.lines.z, p1.x, p2.y, p1.z, p1.x, p2.y, p2.z, showAxis);\n    this.updateLine(this.lines.x, p1.x, p2.y, p2.z, p2.x, p2.y, p2.z, showAxis);\n  }\n\n};\n\n// Draw distance measurement\nproto.renderDistanceMeasurement = function (p1, p2)\n{\n  var self = this;\n\n  // If the line aligns with one of axis, then don't show axis\n  function displayAxis(p1, p2) {\n    self.tmpVector.subVectors(p1, p2);\n    self.tmpVector.normalize();\n\n    return !MeasureCommon.isParallel(self.tmpVector, self.xAxis) && !MeasureCommon.isParallel(self.tmpVector, self.yAxis) && !MeasureCommon.isParallel(self.tmpVector, self.zAxis);\n  }\n\n  this.updateLine(this.lines.xyz, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, true);\n\n  var up = this.viewer.navigation.getAlignedUpVector(),\n  x = Math.abs(up.x),\n  y = Math.abs(up.y),\n  z = Math.abs(up.z);\n\n  var showAxis = displayAxis(p1, p2);\n\n  if (z > x && z > y) {// z up\n    this.updateLine(this.lines.x, p1.x, p1.y, p1.z, p2.x, p1.y, p1.z, showAxis);\n    this.updateLine(this.lines.y, p2.x, p1.y, p1.z, p2.x, p2.y, p1.z, showAxis);\n    this.updateLine(this.lines.z, p2.x, p2.y, p1.z, p2.x, p2.y, p2.z, showAxis);\n\n  } else if (y > x && y > z) {// y up\n    this.updateLine(this.lines.x, p1.x, p1.y, p1.z, p2.x, p1.y, p1.z, showAxis);\n    this.updateLine(this.lines.z, p2.x, p1.y, p1.z, p2.x, p1.y, p2.z, showAxis);\n    this.updateLine(this.lines.y, p2.x, p1.y, p2.z, p2.x, p2.y, p2.z, showAxis);\n\n  } else {// x up - do we ever see this?\n    this.updateLine(this.lines.y, p1.x, p1.y, p1.z, p1.x, p2.y, p1.z, showAxis);\n    this.updateLine(this.lines.z, p1.x, p2.y, p1.z, p1.x, p2.y, p2.z, showAxis);\n    this.updateLine(this.lines.x, p1.x, p2.y, p2.z, p2.x, p2.y, p2.z, showAxis);\n  }\n\n};\n\nproto.updateResults = function () {\n  this.updateDistance();\n  this.updateAngle();\n  this.updateArea();\n  this.updateArcLength();\n\n  setTimeout(function () {\n    // This can get called after the viewer is unloaded\n    if (this.viewer.impl)\n    this.updateLabelsPosition();\n  }.bind(this), 0);\n};\n\n// Update distance measurement label\nproto.updateDistance = function () {\n\n  function setWidth(label, value) {\n    if (!label) return;\n    label.style.width = value;\n  }\n\n  function getWidth(label) {\n    return label ? label.clientWidth : 0;\n  }\n\n  Object.keys(this.lines).forEach(function (name) {\n    setWidth(this.lines[name].label, '');\n  }.bind(this));\n\n  setDeltaMeasurementLabelText(this.lines.x.label, \"~ \" + this.measureTool.getDistanceX(this.measurement));\n  setDeltaMeasurementLabelText(this.lines.y.label, \"~ \" + this.measureTool.getDistanceY(this.measurement));\n  setDeltaMeasurementLabelText(this.lines.z.label, \"~ \" + this.measureTool.getDistanceZ(this.measurement));\n  setValueMeasurementLabelText(this.lines.xyz.label, \"~ \" + this.measureTool.getDistanceXYZ(this.measurement));\n\n  if (this.viewer.model && this.viewer.model.is3d()) {\n    setTimeout(function () {\n      var maxWidth = Math.max(getWidth(this.lines.x.label), getWidth(this.lines.y.label), getWidth(this.lines.z.label), getWidth(this.lines.xyz.label));\n      Object.keys(this.lines).forEach(function (name) {\n        setWidth(this.lines[name].label, maxWidth + 'px');\n      }.bind(this));\n    }.bind(this), 0);\n  }\n};\n\n// Update angle measurement label\nproto.updateAngle = function () {\n  setValueMeasurementLabelText(this.angleLabel.label, \"~ \" + this.measureTool.getAngle(this.measurement));\n};\n\n// Update location measurement label\nproto.updateLocation = function () {\n  setValueMeasurementLabelText(this.locationLabel.label,\n  (\"~ \" + this.measureTool.getLocation(this.measurement)).split('\\n').join('\\n~ '));\n};\n\n// Update callout measurement label\nproto.updateCallout = function () {\n  setValueMeasurementLabelCallout(this.calloutLabel.label, this.measureTool.getCallout(this.measurement));\n};\n\n// Update area measurement label\nproto.updateArea = function () {\n  setValueMeasurementLabelText(this.areaLabel.label, \"~ \" + this.measureTool.getArea(this.measurement));\n};\n\n// Update arc measurement label\nproto.updateArcLength = function () {\n  setValueMeasurementLabelText(this.arcLabel.label, \"~ \" + this.measureTool.getArc(this.measurement));\n};\n\n// Set if collapse or expand the xyz delta distance\nproto.setSimple = function (simple) {\n  if (this.simple != simple) {\n    this.simple = simple;\n\n    var isVisible = !simple;\n    this.setLineVisible(this.lines.x, isVisible);\n    this.setLineVisible(this.lines.y, isVisible);\n    this.setLineVisible(this.lines.z, isVisible);\n\n    this.updateLabelsPosition();\n\n    this.viewer.impl.invalidate(false, false, /*overlayDirty=*/true);\n  }\n};\n\nproto.setLineVisible = function (item, isVisible) {\n  if (item.line) {\n    item.line.visible = isVisible;\n    item.visible = isVisible;\n\n    if (item.label) {\n      if (isVisible) {\n        this.showLabel(item.label);\n      } else\n      {\n        this.hideLabel(item.label);\n        item.label.style.opacity = 0;\n      }\n    }\n  }\n};\n\nproto.enableLabelsTouchEvents = function (enable) {\n  var value = enable ? 'all' : 'none';\n\n  if (this.lines.xyz.label) {\n    this.lines.xyz.label.style.pointerEvents = value;\n  }\n\n  if (this.angleLabel.label) {\n    this.angleLabel.label.style.pointerEvents = value;\n  }\n\n  if (this.areaLabel.label) {\n    this.areaLabel.label.style.pointerEvents = value;\n  }\n\n  if (this.arcLabel.label) {\n    this.arcLabel.label.style.pointerEvents = value;\n  }\n};\n\nproto.setLabelsZIndex = function (zIndex) {\n  for (var name in this.lines) {\n    if (this.lines.hasOwnProperty(name)) {\n      var item = this.lines[name];\n      if (item.label) {\n        item.label.style.zIndex = zIndex;\n      }\n    }\n  }\n\n  if (this.angleLabel && this.angleLabel.label) {\n    this.angleLabel.label.style.zIndex = zIndex;\n  }\n\n  if (this.locationLabel && this.locationLabel.label) {\n    this.locationLabel.label.style.zIndex = zIndex;\n  }\n\n  if (this.calloutLabel && this.calloutLabel.label) {\n    this.calloutLabel.label.style.zIndex = zIndex;\n  }\n\n  if (this.areaLabel && this.areaLabel.label) {\n    this.areaLabel.label.style.zIndex = zIndex;\n  }\n\n  if (this.arcLabel && this.arcLabel.label) {\n    this.arcLabel.label.style.zIndex = zIndex;\n  }\n\n  for (name in this.endpoints) {\n    if (this.endpoints.hasOwnProperty(name)) {\n      var endpoint = this.endpoints[name];\n      if (endpoint.label) {\n        endpoint.label.style.zIndex = zIndex - 1;\n      }\n    }\n  }\n};\n\nproto.focusLabels = function () {\n  this.setLabelsZIndex(3);\n};\n\nproto.unfocusLabels = function () {\n  this.setLabelsZIndex(2);\n};\n\nproto.clear = function () {\n  var name;\n\n  for (name in this.endpoints) {\n    if (this.endpoints.hasOwnProperty(name)) {\n      var endpoint = this.endpoints[name];\n      if (endpoint.label) {\n        this.hideLabel(endpoint.label);\n      }\n    }\n  }\n\n  for (name in this.lines) {\n    if (this.lines.hasOwnProperty(name)) {\n      var item = this.lines[name];\n      if (item.line) {\n        item.line.visible = false;\n        item.visible = false;\n\n        item.tips && item.tips.forEach(function (tip) {\n          tip.visible = false;\n        });\n      }\n      if (item.label) {\n        this.hideLabel(item.label);\n        item.label.style.opacity = 0;\n        item.label.style.zIndex = 2;\n      }\n    }\n  }\n\n  if (this.angleLabel && this.angleLabel.label) {\n    this.hideLabel(this.angleLabel.label);\n  }\n\n  if (this.locationLabel && this.locationLabel.label) {\n    this.hideLabel(this.locationLabel.label);\n  }\n\n  if (this.calloutLabel && this.calloutLabel.label) {\n    this.hideLabel(this.calloutLabel.label);\n  }\n\n  if (this.areaLabel && this.areaLabel.label) {\n    this.hideLabel(this.areaLabel.label);\n  }\n\n  if (this.arcLabel && this.arcLabel.label) {\n    this.hideLabel(this.arcLabel.label);\n  }\n\n  this.clearSelectionAreas();\n\n  this.segments = [];\n  this.dashedLines = [];\n\n  this.viewer.impl.clearOverlay(this.overlayName);\n  MeasureCommon.createCommonOverlay(this.viewer, this.overlayName);\n};\n\nproto.hideClick = function (pickNumber) {\n\n  Indicator.prototype.hideClick.call(this, pickNumber);\n\n  for (var name in this.lines) {\n    if (this.lines.hasOwnProperty(name)) {\n      var item = this.lines[name];\n      if (item.line) {\n        item.line.visible = false;\n        item.visible = false;\n\n        item.tips && item.tips.forEach(function (tip) {\n          tip.visible = false;\n        });\n      }\n      if (item.label) {\n        this.hideLabel(item.label);\n        item.label.style.opacity = 0;\n      }\n    }\n  }\n\n  if (this.angleLabel && this.angleLabel.label) {\n    this.hideLabel(this.angleLabel.label);\n  }\n\n  if (this.areaLabel && this.areaLabel.label) {\n    this.hideLabel(this.areaLabel.label);\n  }\n\n  if (this.arcLabel && this.arcLabel.label) {\n    this.hideLabel(this.arcLabel.label);\n  }\n\n  this.enableSelectionAreas(item.selectionArea, false);\n};\n\nproto.destroy = function () {\n  var name;\n\n  Indicator.prototype.destroy.call(this);\n\n  for (name in this.lines) {\n    if (this.lines.hasOwnProperty(name)) {\n      var item = this.lines[name];\n      if (item.line) {\n        this.viewer.impl.clearOverlay(self.overlayName);\n        item.material = item.line = item.geometry = null;\n      }\n\n      if (item.label) {\n        if (name === 'xyz') {\n          item.label.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n          item.label.removeEventListener('click', this.onSelectionAreaClickedBinded);\n        }\n\n        item.label.parentNode.removeChild(item.label);\n        item.label = null;\n      }\n      item.material = item.line = item.geometry = item.label = item.p1 = item.p2 = null;\n    }\n  }\n\n  this.clearAngleMeshes();\n\n  if (this.angleLabel && this.angleLabel.label) {\n    this.angleLabel.label.parentNode.removeChild(this.angleLabel.label);\n    this.angleLabel.label.removeEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    this.angleLabel.label.removeEventListener('click', this.onSelectionAreaClickedBinded);\n    this.angleLabel.label = this.angleLabel.p1 = this.angleLabel.p2 = null;\n  }\n\n\n  this.clearArcMeshes();\n\n  if (this.arcLabel && this.arcLabel.label) {\n    this.arcLabel.label.parentNode.removeChild(this.arcLabel.label);\n    this.arcLabel.label.removeEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    this.arcLabel.label.removeEventListener('click', this.onSelectionAreaClickedBinded);\n    this.arcLabel.label = this.arcLabel.midPoint = null;\n  }\n\n\n  if (this.locationLabel && this.locationLabel.label) {\n    this.locationLabel.label.parentNode.removeChild(this.locationLabel.label);\n    this.locationLabel.label.removeEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    //this.locationLabel.label.removeEventListener('click', this.onSelectionAreaClickedBinded);\n    this.locationLabel.label = this.locationLabel.p = null;\n  }\n\n\n  if (this.calloutLabel && this.calloutLabel.label) {\n    this.calloutLabel.label.parentNode.removeChild(this.calloutLabel.label);\n    this.calloutLabel.label.removeEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    //this.calloutLabel.label.removeEventListener('click', this.onSelectionAreaClickedBinded);\n    this.calloutLabel.label = this.calloutLabel.p = null;\n  }\n\n\n  if (this.areaLabel && this.areaLabel.label) {\n    this.areaLabel.label.parentNode.removeChild(this.areaLabel.label);\n    this.areaLabel.label.removeEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    this.areaLabel.label.removeEventListener('click', this.onSelectionAreaClickedBinded);\n    this.areaLabel.label = this.areaLabel.p1 = this.areaLabel.p2 = null;\n  }\n\n\n\n  if (this.viewer.impl.overlayScenes[this.overlayName]) {\n    this.viewer.impl.removeOverlayScene(this.overlayName);\n  }\n\n  this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n  this.removeWindowEventListener('mouseup', this.handleButtonUpBinded);\n};\n\nproto.clearXYZLine = function () {\n  this.viewer.impl.removeOverlay(this.overlayName, this.lines.xyz.line);\n\n  this.lines.xyz.tips && this.lines.xyz.tips.forEach(function (tip) {\n    this.viewer.impl.removeOverlay(this.overlayName, tip);\n  }.bind(this));\n};\n\n// Update scale for vertex, edge, line and extension dash line\nproto.updateScale = function () {var _this2 = this;\n  var name;\n\n  this.angleOutline.forEach(function (cylinderMesh) {return _this2.setCylinderScale(cylinderMesh);});\n\n  this.arcOutline.forEach(function (cylinderMesh) {return _this2.setCylinderScale(cylinderMesh);});\n\n  for (name in this.lines) {\n    if (this.lines.hasOwnProperty(name)) {\n      var item = this.lines[name];\n      if (item.line && item !== this.lines.xyz) {\n        this.setCylinderScale(item.line, item.p1, item.p2);\n      }\n    }\n  }\n\n  for (name in this.segments) {\n    if (this.segments.hasOwnProperty(name)) {\n      var segment = this.segments[name];\n      if (segment.line) {\n        this.setCylinderScale(segment.line, segment.p1, segment.p2);\n      }\n    }\n  }\n\n  if (this.measurement.measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE) {\n    if (this.measurement.isComplete()) {\n      this.clearXYZLine();\n      this.drawXYZLine(this.lines.xyz);\n    }\n  }\n\n  if (this.measurement.measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_ARC) {\n    this.arcTip.forEach(function (cylinderMesh)\n    {\n      var scale = _this2.setScale(cylinderMesh.position);\n      if (cylinderMesh.hasOwnProperty(\"lmv_line_width\")) {\n        var scaleXZ = scale * cylinderMesh.lmv_line_width;\n        cylinderMesh.scale.x = scaleXZ;\n        cylinderMesh.scale.z = scaleXZ;\n      }\n      var scaleY = scale * (2 * _tipHeight);\n      cylinderMesh.scale.y = scaleY;\n    });\n  }\n};\n\nproto.setNoTopology = function () {\n  this.topologyStatus = TOPOLOGY_NOT_AVAILABLE;\n  if (this.lines.xyz.label) {\n    setVisibilityMeasurementLabelSpinner(this.lines.xyz.label, false, this.topologyStatus);\n    this.lines.xyz.label.classList.remove('fetching-topology');\n  }\n};\nproto.setFetchingTopology = function () {\n  this.topologyStatus = TOPOLOGY_FETCHING;\n  if (this.lines.xyz.label) {\n    setVisibilityMeasurementLabelSpinner(this.lines.xyz.label, true, this.topologyStatus);\n    this.lines.xyz.label.classList.add('fetching-topology');\n  }\n};\nproto.setTopologyAvailable = function () {\n  this.topologyStatus = TOPOLOGY_AVAILABLE;\n  if (this.lines.xyz.label) {\n    setVisibilityMeasurementLabelSpinner(this.lines.xyz.label, false, this.topologyStatus);\n    this.lines.xyz.label.classList.remove('fetching-topology');\n  }\n};\n\nproto.createMeasurementLabel = function () {\n\n  var _document = this.getDocument();\n\n  var label = _document.createElement('div');\n  label.className = 'measure-length';\n\n  var spinner = _document.createElement('div');\n  spinner.className = 'measure-fetching-topology';\n  spinner.style.display = 'none';\n  label.appendChild(spinner);\n\n  var text = _document.createElement('div');\n  text.className = 'measure-length-text';\n  label.appendChild(text);\n\n  var delta = _document.createElement('div');\n  delta.className = 'measure-delta-text';\n  label.appendChild(delta);\n\n  label.causeStacking = true;\n\n  if (!av.isMobileDevice()) {\n    MeasureCommon.safeToggle(label, 'enable-hover', true);\n  }\n\n  return label;\n};\n\n// Receives an object created with createMeasurementLabel()\nfunction setVisibilityMeasurementLabelText(label, isVisible) {\n  var div = label.querySelector('.measure-length-text');\n  div && (div.style.display = isVisible ? '' : 'none');\n}\n\n// Receives an object created with createMeasurementLabel()\nfunction setValueMeasurementLabelText(label, strValue) {\n  if (!label) return;\n  var div = label.querySelector('.measure-length-text');\n  div && (div.textContent = strValue);\n}\n\n// Escape special characters in HTML and convert \\n to <br>\nfunction escapeHtml(str) {\n  return str.\n  replace(/&/g, \"&amp;\").\n  replace(/</g, \"&lt;\").\n  replace(/>/g, \"&gt;\").\n  replace(/\"/g, \"&quot;\").\n  replace(/'/g, \"&#039;\").\n  replace(/\\n/g, '<br>');\n}\n\n// Create a space with formatting from format\nfunction createSpan(format) {\n  // If format is a string, no formatting - just return the escaped string\n  if (typeof format === 'string')\n  return escapeHtml(format);\n\n  // Build the style parameters for font-size and font-weight\n  var space = '';\n  var fontSize = format.fontSize;\n  if (format.fontSize !== undefined && format.fontSize !== 10) {\n    // Base the fontSize on 10 === 100% which is ADRs default\n    // LMV uses 12 as the default.\n    fontSize = \"font-size: \".concat(0 | fontSize * 10, \"%;\");\n    space = ' '; // Put a space between font-size and bold\n  } else\n  fontSize = '';\n  var bold = format.bold;\n  if (bold !== undefined)\n  bold = \"\".concat(space, \"font-weight: \").concat(bold ? 'bold' : 'normal', \";\");else\n\n  bold = '';\n  // Escape the string.\n  var str = escapeHtml(format.text);\n  // Include bold and fontSize styles if present.\n  if (bold || fontSize)\n  return \"<span style=\\\"\".concat(fontSize).concat(bold, \"\\\">\").concat(str, \"</span>\");\n  // return escaped string if no formatting\n  return str;\n}\n\nfunction setValueMeasurementLabelCallout(label, calloutValue) {\n  // If the calloutValue is just a string, then set it as text.\n  if (typeof calloutValue === 'string') {\n    setValueMeasurementLabelText(label, calloutValue);\n    return;\n  }\n\n  var div = label.querySelector('.measure-length-text');\n  if (div) {\n    // construct and set the html for the callout.\n    if (!Array.isArray(calloutValue))\n    div.innerHTML = createSpan(calloutValue);else\n\n    div.innerHTML = calloutValue.map(createSpan).join('');\n  }\n}\n\n// Receives an object created with createMeasurementLabel()\nfunction setDeltaMeasurementLabelText(label, strValue) {\n  if (!label) return;\n  var div = label.querySelector('.measure-delta-text');\n  div && (div.textContent = strValue);\n}\n\n// Receives an object created with createMeasurementLabel()\nfunction setVisibilityMeasurementLabelSpinner(label, isVisible, topologyStatus) {\n  if (!label) return;\n  var div = label.querySelector('.measure-fetching-topology');\n  div && (div.style.display =\n  isVisible && topologyStatus === TOPOLOGY_FETCHING ? 'inline-block' : 'none');\n}\n\n/**\n   * Helper function that creates the label used for (1) and (2),\n   * which are the 2 mouse clicks for the measurement.\n   */\nproto.createSnapResultLabel = function (pointNumber) {\n  var _document = this.getDocument();\n\n  var label = _document.createElement('div');\n  label.className = 'measure-label';\n\n  var label_icon = _document.createElement('div');\n  label_icon.className = 'measure-label-icon';\n  label.appendChild(label_icon);\n\n  if (av.isTouchDevice()) {\n    this.initLabelMobileGestures(label, pointNumber, this.measureTool);\n    var hitArea = _document.createElement('div');\n    hitArea.className = 'measure-label-hit-area';\n    label.appendChild(hitArea);\n  }\n\n  if (!av.isMobileDevice()) {\n    this.initMouseEvent(label, pointNumber);\n\n    label.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    MeasureCommon.safeToggle(label, 'enable-hover', true);\n  }\n\n\n  label.causeStacking = false;\n\n  return label;\n};\n\nproto.showAngleLabel = function (midPoint) {\n\n  var label = this.angleLabel.label;\n\n  if (!label) {\n    label = this.angleLabel.label = this.createMeasurementLabel();\n    this.viewer.container.appendChild(label);\n    label.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    label.addEventListener('click', this.onSelectionAreaClickedBinded);\n  }\n\n  this.updateAngle();\n  this.showLabel(label);\n\n  this.angleLabel.p1 = midPoint.clone();\n  this.angleLabel.p2 = midPoint.clone();\n\n};\n\nproto.showArcLabel = function (midPoint) {\n\n  var label = this.arcLabel.label;\n\n  if (!label) {\n    this.arcLabel.label = label = this.createArcLabel();\n  } else\n  {\n    this.hideLabel(label);\n  }\n  this.updateArcLength();\n  this.showLabel(label);\n\n  this.arcLabel.p1 = midPoint.clone();\n  this.arcLabel.p2 = midPoint.clone();\n\n};\n\nproto.showLocationLabel = function (p) {\n\n  var label = this.locationLabel.label;\n\n  if (!label) {\n    label = this.locationLabel.label = this.createMeasurementLabel();\n    label.style.whiteSpace = 'pre-line';\n    label.style.height = 'auto';\n    label.style.textAlign = 'start';\n    label.querySelector('.measure-delta-text').style.display = 'none';\n    this.viewer.container.appendChild(label);\n    label.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    //label.addEventListener('click', this.onSelectionAreaClickedBinded);\n  }\n\n  this.updateLocation();\n  this.showLabel(label);\n\n  this.locationLabel.p = p.clone();\n\n};\n\nproto.showCalloutLabel = function (p) {\n\n  var label = this.calloutLabel.label;\n\n  if (!label) {\n    label = this.calloutLabel.label = this.createMeasurementLabel();\n    label.style.whiteSpace = 'pre-line';\n    label.style.height = 'auto';\n    label.style.textAlign = 'start';\n    if (this.measurement.options && this.measurement.options.width)\n    label.style.width = this.measurement.options.width + 'px';\n    label.querySelector('.measure-delta-text').style.display = 'none';\n    this.viewer.container.appendChild(label);\n    label.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    //label.addEventListener('click', this.onSelectionAreaClickedBinded);\n  }\n\n  this.updateCallout();\n  this.showLabel(label);\n\n  this.calloutLabel.p = p.clone();\n\n};\n\nproto.showAreaLabel = function (midPoint) {\n\n  var label = this.areaLabel.label;\n\n  if (!label) {\n    label = this.areaLabel.label = this.createMeasurementLabel();\n    this.viewer.container.appendChild(label);\n    label.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n    label.addEventListener('click', this.onSelectionAreaClickedBinded);\n  }\n\n  this.updateArea();\n  this.showLabel(label);\n\n  this.areaLabel.p1 = midPoint;\n  this.areaLabel.p2 = midPoint;\n\n};\n\nproto.onSelectionAreaClicked = function () {\n  this.measureTool.selectMeasurementById(this.measurement.id);\n};\n\nproto.createSelectionArea = function () {\n  var _document = this.getDocument();\n  var selectionArea = _document.createElement('div');\n  selectionArea.id = 'measurement-selection-area-' + this.measurement.id;\n  this.viewer.container.appendChild(selectionArea);\n  selectionArea.className = 'measure-selection-area';\n  selectionArea.style.display = 'none';\n  selectionArea.addEventListener('mousewheel', this.viewer.toolController.mousewheel);\n  selectionArea.addEventListener('click', this.onSelectionAreaClickedBinded);\n  return selectionArea;\n};\n\nproto.updateSelectionArea = function () {\n\n  this.segments.forEach(function (item)\n  {\n    if (item.p1 && item.p2) {\n      var p1 = MeasureCommon.project(item.p1, this.viewer);\n      var p2 = MeasureCommon.project(item.p2, this.viewer);\n\n      if (!item.selectionArea) {\n        item.selectionArea = this.createSelectionArea();\n      }\n\n      var selectionArea = item.selectionArea;\n\n      var v = new THREE.Vector2();\n\n      selectionArea.style.top = p1.y - _selectorAreaSize / 2 + 'px';\n      selectionArea.style.left = p1.x + 'px';\n      selectionArea.style.width = v.subVectors(p1, p2).length() + 'px';\n      selectionArea.style.height = _selectorAreaSize + 'px';\n\n      var angle = null;\n      var deltaX = p1.x - p2.x;\n      var deltaY = p1.y - p2.y;\n\n      angle = Math.atan2(-deltaY, -deltaX) * 180 / Math.PI;\n\n      selectionArea.style.transform = 'rotate(' + angle + 'deg)';\n      selectionArea.style.transformOrigin = '0px ' + _selectorAreaSize / 2 + 'px';\n    }\n  }.bind(this));\n\n  if (this.measureTool.areAllPicksSet()) {\n    this.enableSelectionAreas(true);\n  }\n};\n\nproto.clearSelectionAreas = function () {\n  var _document = this.getDocument();\n  this.segments.forEach(function (item)\n  {\n    if (item.selectionArea) {\n      item.selectionArea.removeEventListener('mousewheel', this.viewer.toolController.mousewheel);\n      item.selectionArea.removeEventListener('click', this.onSelectionAreaClickedBinded);\n      var element = _document.getElementById('measurement-selection-area-' + this.measurement.id);\n      if (element) {\n        element.parentNode.removeChild(element);\n      }\n      item.selectionArea = null;\n    }\n  }.bind(this));\n};\n\nproto.enableSelectionAreas = function (enable) {\n  this.segments.forEach(function (item)\n  {\n    if (item.selectionArea) {\n      if (enable) {\n        item.selectionArea.style.display = 'block';\n      } else\n      {\n        item.selectionArea.style.display = 'none';\n      }\n    }\n  }.bind(this));\n};\n\nproto.render = function (picks, showMeasureResult) {\n  Indicator.prototype.render.call(this, picks, showMeasureResult);\n\n  this.updateSelectionArea();\n};\n\nproto.renderFromPoints = function (pointData, showMeasureResult) {\n  Indicator.prototype.renderFromPoints.call(this, pointData, showMeasureResult);\n\n  this.updateSelectionArea();\n};\n\nproto.onCameraChange = function () {\n  this.redrawDashedLines();\n  this.updateSelectionArea();\n  this.hideLabelsOutsideOfView();\n  this.updateLabelsPosition();\n};\n\nproto.handleResize = function () {\n  this.redrawDashedLines();\n  this.updateSelectionArea();\n  this.updateLabelsPosition();\n};","\nvar av = Autodesk.Viewing;\nvar avu = Autodesk.Viewing.UI;\nvar avp = Autodesk.Viewing.Private;\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon;\n\n// /** @constructor */\nexport function MeasureToolbar(measureExtension)\n{\n  this.measureExtension = measureExtension;\n  this.measureTool = this.measureExtension.measureTool;\n  this.viewer = this.measureExtension.viewer;\n  this.setGlobalManager(this.viewer.globalManager);\n  this.visible = false;\n  this.buttonsList = [];\n}\n\nvar proto = MeasureToolbar.prototype;\nav.GlobalManagerMixin.call(MeasureToolbar.prototype);\n\nproto.init = function () {\n  var self = this;\n\n  var _document = this.getDocument();\n\n  // Add Measure tool toolbar to main toolbar\n  var toolbar = this.viewer.getToolbar();\n  var navigationBar = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);\n  var toolbarOptions = {};\n  toolbarOptions.index = toolbar.indexOf(navigationBar) + 1;\n  this.measureToolbar = new avu.ControlGroup(Autodesk.Viewing.TOOLBAR.MEASURETOOLSID);\n  this.measureToolbar.setGlobalManager(this.globalManager);\n  toolbar.addControl(this.measureToolbar, toolbarOptions);\n\n\n  // Create a button for the measure simple distance.\n  this.measureSimpleDistanceBtn = new avu.Button(\"toolbar-measureTool-simple-distance\");\n  this.measureSimpleDistanceBtn.setGlobalManager(this.globalManager);\n  this.measureSimpleDistanceBtn.setToolTip(\"Distance\");\n  this.measureSimpleDistanceBtn.setIcon(\"adsk-icon-measure-distance-new\");\n  this.measureSimpleDistanceBtn.onClick = function () {\n    var enable = self.measureSimpleDistanceBtn.getState() !== avu.Button.State.ACTIVE;\n    if (enable) {\n      self.measureExtension.activate('distance');\n    } else {\n      self.measureTool.deselectAllMeasurements();\n    }\n  };\n\n  this.measureToolbar.addControl(this.measureSimpleDistanceBtn);\n  this.buttonsList[MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE] = this.measureSimpleDistanceBtn;\n\n\n  // Create a button for the measure Angle.\n  this.measureAngleBtn = new avu.Button(\"toolbar-measureTool-angle\");\n  this.measureAngleBtn.setGlobalManager(this.globalManager);\n  this.measureAngleBtn.setToolTip(\"Angle\");\n  this.measureAngleBtn.setIcon(\"adsk-icon-measure-angle-new\");\n  this.measureAngleBtn.onClick = function () {\n    var enable = self.measureAngleBtn.getState() !== avu.Button.State.ACTIVE;\n    if (enable) {\n      self.measureExtension.activate('angle');\n    } else {\n      self.measureTool.deselectAllMeasurements();\n    }\n  };\n  this.measureToolbar.addControl(this.measureAngleBtn);\n  this.buttonsList[MeasureCommon.MeasurementTypes.MEASUREMENT_ANGLE] = this.measureAngleBtn;\n\n  if (this.viewer.model && this.viewer.model.is2d()) {\n    // Create a button for the measure distance.\n    this.measureAreaBtn = new avu.Button(\"toolbar-measureTool-area\");\n    this.measureAreaBtn.setGlobalManager(this.globalManager);\n    this.measureAreaBtn.setToolTip(\"Area\");\n    this.measureAreaBtn.setIcon(\"adsk-icon-measure-area-new\");\n    this.measureAreaBtn.onClick = function () {\n      var enable = self.measureAreaBtn.getState() !== avu.Button.State.ACTIVE;\n      if (enable) {\n        self.measureExtension.activate('area');\n      } else {\n        self.measureTool.deselectAllMeasurements();\n      }\n    };\n\n    this.measureToolbar.addControl(this.measureAreaBtn);\n    this.buttonsList[MeasureCommon.MeasurementTypes.MEASUREMENT_AREA] = this.measureAreaBtn;\n  }\n\n  if (this.viewer.model && this.viewer.model.is2d()) {\n    // Create a button for the arc measurement.\n    this.measureArcBtn = new avu.Button(\"toolbar-measureTool-arc\");\n    this.measureArcBtn.setGlobalManager(this.globalManager);\n    this.measureArcBtn.setToolTip(\"Arc\");\n    this.measureArcBtn.setIcon(\"adsk-icon-measure-arc-new\");\n    this.measureArcBtn.onClick = function () {\n      var enable = self.measureArcBtn.getState() !== avu.Button.State.ACTIVE;\n      if (enable) {\n        self.measureExtension.activate('arc');\n      } else {\n        self.measureTool.deselectAllMeasurements();\n      }\n    };\n\n    this.measureToolbar.addControl(this.measureArcBtn);\n    this.buttonsList[MeasureCommon.MeasurementTypes.MEASUREMENT_ARC] = this.measureArcBtn;\n  }\n\n  // Create a button for the Calibration tool.\n  this.calibrationToolBtn = new avu.Button(\"toolbar-calibrationTool\");\n  this.calibrationToolBtn.setGlobalManager(this.globalManager);\n  this.calibrationToolBtn.setToolTip(\"Calibrate\");\n  this.calibrationToolBtn.setIcon(\"adsk-icon-measure-calibration\");\n  this.calibrationToolBtn.onClick = function (e) {\n    var enable = self.calibrationToolBtn.getState() !== avu.Button.State.ACTIVE;\n    if (enable) {\n      self.measureExtension.activate('calibrate');\n    } else {\n      self.measureExtension.enableCalibrationTool(false);\n    }\n  };\n\n  this.measureToolbar.addControl(this.calibrationToolBtn);\n  this.buttonsList[MeasureCommon.MeasurementTypes.CALIBRATION] = this.calibrationToolBtn;\n\n  var separator = _document.createElement('div');\n  separator.className = 'measure-toolbar-seperator';\n\n  this.measureToolbar.container.appendChild(separator);\n\n\n  // Create a button for the Trash.\n  this.deleteBtn = new avu.Button(\"toolbar-delete\");\n  this.deleteBtn.setGlobalManager(this.globalManager);\n  this.deleteBtn.setToolTip(\"Delete measurement\");\n  this.deleteBtn.setIcon(\"adsk-icon-measure-trash\");\n  this.deleteBtn.onClick = function () {\n    self.measureExtension.deleteCurrentMeasurement();\n  };\n\n  this.measureToolbar.addControl(this.deleteBtn);\n\n  // Create a button for the Settings panel.\n  this.settingsBtn = new avu.Button(\"toolbar-settings\");\n  this.settingsBtn.setGlobalManager(this.globalManager);\n  this.settingsBtn.setToolTip(\"Measure settings\");\n  this.settingsBtn.setIcon(\"adsk-icon-measure-settings\");\n\n  this.settingsControlPanel = _document.createElement('div');\n  this.settingsControlPanel.classList.add('docking-panel');\n  this.settingsControlPanel.classList.add('docking-panel-container-solid-color-b');\n  this.settingsControlPanel.classList.add('measure-settings-popup');\n  this.settingsControlPanel.classList.add('hide');\n\n  this.settingsBtn.onClick = function (event) {\n    if (this.settingsControlPanel.classList.contains('hide')) {\n      this.settingsControlPanel.classList.remove('hide');\n      this.setButtonActive(this.settingsBtn);\n    } else\n    {\n      this.settingsControlPanel.classList.add('hide');\n      this.setButtonInactive(this.settingsBtn);\n    }\n  }.bind(this);\n\n  this.measureToolbar.container.appendChild(this.settingsControlPanel);\n  this.settingsControlPanel.root = this.settingsBtn;\n  this.measureToolbar.addControl(this.settingsBtn);\n\n\n  // Settings Panel\n  this.table = _document.createElement(\"table\");\n  this.table.classList.add(\"adsk-lmv-tftable\");\n  this.table.classList.add(\"calibration-table\");\n\n  this.tbody = _document.createElement(\"tbody\");\n  this.table.appendChild(this.tbody);\n  this.settingsControlPanel.appendChild(this.table);\n\n  this.units = [\n  { name: 'Unknown', units: '', matches: [''] }, // localized in OptionDropDown() call below\n  { name: 'Decimal feet', units: 'decimal-ft', matches: ['ft', 'decimal-ft'] }, // localized in OptionDropDown() call below\n  { name: 'Feet and fractional inches', units: 'ft-and-fractional-in', matches: ['ft-and-fractional-in'] }, // localized in OptionDropDown() call below\n  { name: 'Feet and decimal inches', units: 'ft-and-decimal-in', matches: ['ft-and-decimal-in'] }, // localized in OptionDropDown() call below\n  { name: 'Decimal inches', units: 'decimal-in', matches: ['in', 'decimal-in'] }, // localized in OptionDropDown() call below\n  { name: 'Fractional inches', units: 'fractional-in', matches: ['fractional-in'] }, // localized in OptionDropDown() call below\n  { name: 'Meters', units: 'm', matches: ['m'] }, // localized in OptionDropDown() call below\n  { name: 'Centimeters', units: 'cm', matches: ['cm'] }, // localized in OptionDropDown() call below\n  { name: 'Millimeters', units: 'mm', matches: ['mm'] }, // localized in OptionDropDown() call below\n  { name: 'Meters and centimeters', units: 'm-and-cm', matches: ['m-and-cm'] }, // localized in OptionDropDown() call below\n  { name: 'Points', units: 'pt', matches: ['pt'] } // localized in OptionDropDown() call below\n  ];\n\n  var initialIndex = this.findUnits(),\n  unitNames = [];\n\n  // It is not possible to hide elements in Safari.\n  if (av.isSafari() && this.viewer.model.getDisplayUnit()) {\n    // We will remove the 'Unknown' unit from the units array.\n    this.units.shift();\n  }\n\n  for (var i = 0; i < this.units.length; ++i) {\n    unitNames.push(this.units[i].name);\n  }\n\n  this.unitList = new avp.OptionDropDown(\"Unit type\", this.tbody, unitNames, initialIndex, null, { paddingLeft: 0, paddingRight: 15 });\n  this.unitList.setGlobalManager(this.globalManager);\n  this.unitList.addEventListener(\"change\", function (e) {\n    var index = self.unitList.selectedIndex;\n    var toUnits = self.units[index].units;\n    self.measureTool.setUnits(toUnits);\n    self.setupPrecision();\n    avp.logger.track({ category: 'pref_changed', name: 'measure/units', value: toUnits });\n  });\n\n  this.precisionList = new avp.OptionDropDown(\"Precision\", this.tbody, [], -1, null, { paddingLeft: 0, paddingRight: 15 });\n  this.precisionList.setGlobalManager(this.globalManager);\n  this.precisionList.addEventListener(\"change\", function (e) {\n    var index = self.precisionList.selectedIndex;\n    self.measureTool.setPrecision(index);\n    avp.logger.track({ category: 'pref_changed', name: 'measure/precision', value: index });\n  });\n\n  this.isolate = new avp.OptionCheckbox(\"Isolate measurement\", this.tbody, false);\n  this.isolate.setGlobalManager(this.globalManager);\n  this.isolate.addEventListener(\"change\", function (e) {\n    var enable = self.isolate.checked;\n    self.measureTool.setIsolateMeasure(enable);\n    if (enable) {\n      self.measureTool.isolateMeasurement();\n    } else\n    {\n      self.measureTool.clearIsolate();\n    }\n    avp.logger.track({ category: 'pref_changed', name: 'measure/isolate', value: enable });\n  });\n\n  this.freeMeasure = new avp.OptionCheckbox(\"Enable free measure\", this.tbody, this.measureExtension.isFreeMeasureMode());\n  this.freeMeasure.setGlobalManager(this.globalManager);\n  this.freeMeasure.addEventListener(\"change\", function (e) {\n    var enable = self.freeMeasure.checked;\n    self.measureExtension.setFreeMeasureMode(enable);\n    avp.logger.track({ category: 'pref_changed', name: 'measure/freeMeasure', value: enable });\n  });\n\n  this.setupPrecision();\n\n  this.updateSettingsPanel();\n\n  if (this.viewer.model && this.viewer.model.is2d()) {\n    this.isolate.setVisibility(false);\n  }\n\n  if (!this.measureExtension.sharedMeasureConfig.units) {\n    this.disableUnitOption();\n  }\n  // Only disable option if the browser is not Safari\n  else if (!Autodesk.Viewing.isSafari()) {\n      this.disableUnitOption(0); // disable \"Unknown\" option when the model has units\n    }\n\n\n  // Create a button for 'Done'.\n  this.measureDoneBtn = new avu.Button(\"toolbar-measureTool-done\");\n  this.measureDoneBtn.setGlobalManager(this.globalManager);\n  var doneText = Autodesk.Viewing.i18n.translate('Done');\n  this.measureDoneBtn.setToolTip(doneText);\n  var cancelLabel = _document.createElement('label');\n  cancelLabel.textContent = doneText;\n  var btnContainer = this.measureDoneBtn.container;\n  btnContainer.appendChild(cancelLabel);\n  btnContainer.classList.add('adsk-label-button');\n  var iconEle = btnContainer.getElementsByClassName('adsk-button-icon');\n  iconEle && iconEle[0] && (iconEle[0].style.display = 'none');\n\n  this.measureDoneBtn.onClick = function () {\n    this.measureExtension.exitMeasurementMode();\n  }.bind(this);\n  this.measureToolbar.addControl(this.measureDoneBtn);\n\n  // this.settingsControlPanel.style.width = this.measureToolbar.container.getBoundingClientRect().width + 'px';\n  this.measureToolbar.setVisible(false);\n\n};\n\nproto.destroy = function () {\n\n  // If toolbar was open, close it first. Otherwise, we leave ModelTools toolbar in a broken state.\n  if (this.visible) {\n    this.closeToolbar();\n  }\n\n  if (this.measureToolbar) {\n    this.measureToolbar.removeFromParent();\n    this.measureToolbar = null;\n  }\n};\n\nproto.closeToolbar = function () {\n\n  this.measureExtension.enableMeasureTool(false);\n  this.measureExtension.enableCalibrationTool(false);\n  this.toggleVisible();\n\n  var toolbar = this.viewer.getToolbar();\n  var viewerToolbarContainer = toolbar.container;\n  var viewerContainerChildrenCount = viewerToolbarContainer.children.length;\n\n  for (var i = 0; i < viewerContainerChildrenCount; ++i) {\n    viewerToolbarContainer.children[i].style.display = \"\";\n  }\n\n  var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);\n  modelTools.addControl(this.measureExtension.measurementToolbarButton, { index: this.measureExtension.measurementToolbarButton.index });\n};\n\nproto.toggleVisible = function () {\n  this.visible = !this.visible;\n  this.measureToolbar.setVisible(this.visible);\n  if (!this.visible) {\n    this.settingsControlPanel.classList.add('hide');\n    this.setButtonInactive(this.settingsBtn);\n  }\n};\n\nproto.setButtonActive = function (button) {\n  button.setState(avu.Button.State.ACTIVE);\n};\n\nproto.setButtonInactive = function (button) {\n  button.setState(avu.Button.State.INACTIVE);\n};\n\nproto.deactivateAllButtons = function () {\n  for (var key in this.buttonsList) {\n    if (this.buttonsList.hasOwnProperty(key)) {\n      var button = this.buttonsList[key];\n      this.setButtonInactive(button);\n    }\n  }\n};\n\nproto.activateButtonByType = function (measurementType) {\n  // Check that toolbar button exists - some measurement types don't have UI\n  this.buttonsList[measurementType] && this.setButtonActive(this.buttonsList[measurementType]);\n};\n\nproto.setupPrecision = function () {\n  var _document = this.getDocument();\n  while (this.precisionList.dropdownElement.lastChild) {\n    this.precisionList.dropdownElement.removeChild(this.precisionList.dropdownElement.lastChild);\n  }\n\n  var selectedUnits = this.measureTool.getUnits(),\n  precisions;\n\n  if (selectedUnits === 'ft-and-fractional-in' || selectedUnits === 'fractional-in') {\n    precisions = ['1', '1/2', '1/4', '1/8', '1/16', '1/32', '1/64'];\n  } else {\n    precisions = ['0', '0.1', '0.01', '0.001', '0.0001', '0.00001'];\n  }\n\n  for (var i = 0; i < precisions.length; ++i) {\n    var elem = _document.createElement('option');\n    elem.value = i;\n    elem.textContent = precisions[i];\n    this.precisionList.dropdownElement.appendChild(elem);\n  }\n\n  var selectedIndex = this.measureTool.getPrecision();\n  if (precisions.length <= selectedIndex) {\n    selectedIndex = precisions.length - 1;\n    this.measureTool.setPrecision(selectedIndex);\n  }\n  this.precisionList.dropdownElement.selectedIndex = selectedIndex;\n};\n\nproto.findUnits = function () {\n  var i,\n  j,\n  selectedUnits = this.measureTool.getUnits();\n  for (i = 0; i < this.units.length; ++i) {\n    var matches = this.units[i].matches;\n    if (matches) {\n      for (j = 0; j < matches.length; ++j) {\n        if (matches[j] === selectedUnits) {\n          return i;\n        }\n      }\n    }\n  }\n  return 0;\n};\n\nproto.disableUnitOption = function (index) {\n  if (index != null) {\n    this.unitList.dropdownElement.children[index].style.display = \"none\";\n    if (av.isIE11) {\n      // IE11 can't hide <option> elements...\n      this.unitList.dropdownElement.children[index].disabled = true;\n      this.unitList.dropdownElement.children[index].style.visibility = \"hidden\";\n    }\n  } else {// disable all options\n    this.unitList.dropdownElement.disabled = true;\n  }\n};\n\nproto.updateSettingsPanel = function () {\n  this.unitList.dropdownElement.selectedIndex = this.findUnits();\n  this.precisionList.dropdownElement.selectedIndex = this.measureTool.getPrecision();\n  this.setupPrecision();\n};","\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon; //These come from main lmv bundle.\n\n// /** @constructor */\nexport function MeasurementsManager(viewer)\n{\n  this.viewer = viewer;\n  this.init();\n\n  this.restoredMeasurementData = [];\n}\n\nvar proto = MeasurementsManager.prototype;\n\nproto.getCurrentMeasurement = function () {\n  return this.currentMeasurement;\n};\n\nproto.getRestoredMeasurementData = function () {\n  return this.restoredMeasurementData.slice();\n};\n\nproto.selectMeasurementById = function (id) {\n  var measurement = this.measurementsList[id];\n\n  if (measurement) {\n    this.changeCurrentMeasurement(measurement);\n    return this.currentMeasurement;\n  }\n\n  return false;\n};\n\nproto.createMeasurement = function (measurementType, options) {\n  var id = this.measurementsCounter;\n  var measurement = new MeasureCommon.Measurement(measurementType, id, options);\n  this.measurementsList[id] = measurement;\n  this.measurementsCounter++;\n  this.changeCurrentMeasurement(measurement);\n  return this.currentMeasurement;\n};\n\n// Renders measurements from data.\nproto.createMeasurementFromData = function (measurementData, measurementType, createIndicatorCb, preparePicksCb) {var _this = this;\n  // Convert optional values from DWF to local coordinate\n  var options = measurementData.options;\n  if (options) {\n    // Deep clone options\n    options = JSON.parse(JSON.stringify(options));\n\n    // Convert global world coordinats to LMV coordinates\n    var model =\n    options.hasOwnProperty('modelId') && options.modelId ?\n    this.viewer.impl.findModel(options.modelId) :\n    this.viewer.model;\n    var globalOffset = model && model.getData().globalOffset;\n    if (globalOffset && (globalOffset.x !== 0 || globalOffset.y !== 0 || globalOffset.z !== 0)) {\n      var cvtPts = function cvtPts(points) {\n        if (points) {\n          for (var i = 0; i < points.length; ++i) {\n            // Tricky way to use Vector3 sub on plain objects\n            THREE.Vector3.prototype.sub.call(points[i], globalOffset);\n          }\n        }\n      };\n      cvtPts(options.dimensionOffset);\n      cvtPts(options.dashedLeader);\n      cvtPts(options.arc);\n    }\n  }\n\n  this.createMeasurement(measurementType, options);\n  if (createIndicatorCb instanceof Function) {\n    createIndicatorCb(this.currentMeasurement);\n  }\n\n  this.initPicks(measurementData.picks);\n\n  if (preparePicksCb instanceof Function) {\n    preparePicksCb();\n  }\n\n  if (this.currentMeasurement.measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_AREA) {\n    this.currentMeasurement.closedArea = true;\n  } else if (this.currentMeasurement.measurementType === MeasureCommon.MeasurementTypes.MEASUREMENT_CALLOUT) {\n    this.currentMeasurement.text = measurementData.text;\n  }\n\n  var preparePointData = function preparePointData() {\n    var points = _this.restoredMeasurementData[_this.currentMeasurement.id];\n    var keys = Object.keys(points);\n    var data = [];\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var pointData = points[key];\n      data[key] = {\n        intersection: pointData.intersection,\n        circularArcRadius: pointData.circularArcRadius,\n        circularArcCenter: pointData.circularArcCenter };\n\n    }\n    return data;\n  };\n\n  this.currentMeasurement.indicator.changeAllEndpointsEditableStyle(true);\n  this.currentMeasurement.indicator.enableSelectionAreas(true);\n  this.currentMeasurement.indicator.enableLabelsTouchEvents(true);\n\n  this.activatePicks();\n\n  this.currentMeasurement.computeResult(this.currentMeasurement.picks, this.viewer);\n\n  // This will render the measurements\n  this.currentMeasurement.indicator.renderFromPoints(preparePointData(), true);\n\n  this.currentMeasurement.indicator.changeAllEndpointsEditableStyle(true);\n  this.currentMeasurement.indicator.enableSelectionAreas(true);\n  this.currentMeasurement.indicator.enableLabelsTouchEvents(true);\n\n  this.currentMeasurement.isRestored = true;\n};\n\n// Initializes picks from pick data\nproto.initPicks = function (pickData) {\n  if (!pickData) return;\n  var points = [];\n\n  for (var i = 0; i < pickData.length; i++) {\n    var pick = pickData[i];\n    if (!pick) continue;\n    var key = i + 1;\n\n    var pickPoint = new THREE.Vector3(pick.intersection.x, pick.intersection.y, pick.intersection.z);\n    var model =\n    pick.hasOwnProperty('modelId') && pick.modelId ?\n    this.viewer.impl.findModel(pick.modelId) :\n    this.viewer.model;\n\n    if (model) {\n      var modelData = model.getData();\n      pickPoint =\n      modelData && modelData.hasOwnProperty('globalOffset') ?\n      pickPoint.sub(modelData.globalOffset).clone() :\n      pickPoint.clone();\n    }\n\n    points[key] = {\n      intersection: pickPoint,\n      viewportId: pick.viewportIndex2d,\n      hasTopology: pick.hasTopology,\n      modelId: pick.modelId,\n      snapNode: pick.snapNode,\n      circularArcRadius: pick.circularArcRadius,\n      circularArcCenter: pick.circularArcCenter };\n\n    this.currentMeasurement.getPick(key);\n  }\n\n  this.restoredMeasurementData[this.currentMeasurement.id] = points;\n};\n\n// Stores information from the restored measurement pick data in the current measurement picks\nproto.activatePicks = function () {\n  if (!this.currentMeasurement.picks) return;\n  var keys = Object.keys(this.currentMeasurement.picks);\n\n  var id = this.currentMeasurement.id;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    var pick = this.currentMeasurement.picks[key];\n    var restoredMeasurements = this.getRestoredMeasurementData();\n    var pointInfo = restoredMeasurements[id][key];\n    var p = pointInfo.intersection.clone();\n\n    if (!pick.getGeometry() && pointInfo.intersection) {\n      pick.geomType = MeasureCommon.SnapType.SNAP_VERTEX;\n      pick.geomVertex = p;\n      pick.intersectPoint = p;\n      pick.modelId = pointInfo.modelId;\n      pick.snapNode = pointInfo.snapNode; // the dbid of the pick. This is used for isolation.\n      pick.circularArcCenter = pointInfo.circularArcCenter;\n      pick.circularArcRadius = pointInfo.circularArcRadius;\n\n      // Set the isRestored flag if all of the picks are valid.\n      pick.viewportIndex2d = pointInfo.viewportId;\n    }\n  }\n};\n\nproto.changeCurrentMeasurement = function (measurement) {\n  this.currentMeasurement = measurement;\n  this.viewer.dispatchEvent({ type: MeasureCommon.Events.MEASUREMENT_CHANGED_EVENT, data: { type: measurement.measurementType, id: measurement.id } });\n};\n\nproto.removeCurrentMeasurement = function () {\n  // Remove current measurement from the list\n  if (Object.keys(this.measurementsList).length > 0) {\n    delete this.measurementsList[this.currentMeasurement.id];\n  }\n};\n\nproto.init = function () {\n  this.reset();\n};\n\nproto.destroy = function () {\n  this.reset();\n};\n\nproto.reset = function () {\n  this.currentMeasurement = null;\n  this.measurementsList = {};\n  this.measurementsCounter = 0;\n};","// Centroid of a polygon is the average of its points.\nexport function getCentroidOfPolygon(points) {\n  var centroid = new THREE.Vector3();\n  var n = points.length;\n\n  for (var i = 0; i < n; i++) {\n    centroid.add(points[i]);\n  }\n\n  centroid.multiplyScalar(1 / n);\n  return centroid;\n}\n\n// Algorithm based on https://github.com/mapbox/polylabel\nexport function getPolygonVisualCenter(polygon) {\n  function compareMax(a, b) {\n    return b.max - a.max;\n  }\n\n  function Cell(x, y, h, polygon) {\n    this.x = x; // cell center x\n    this.y = y; // cell center y\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n  }\n\n  // signed distance from point to polygon outline (negative if point is outside)\n  function pointToPolygonDist(x, y, polygon) {\n    var inside = false;\n    var minDistSq = Infinity;\n\n    for (var k = 0; k < polygon.length; k++) {\n      var ring = polygon[k];\n\n      for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n        var a = ring[i];\n        var b = ring[j];\n\n        if (a.y > y !== b.y > y &&\n        x < (b.x - a.x) * (y - a.y) / (b.y - a.y) + a.x) inside = !inside;\n\n        minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n      }\n    }\n\n    return (inside ? 1 : -1) * Math.sqrt(minDistSq);\n  }\n\n  // get polygon centroid\n  function getCentroidCell(polygon) {\n    var area = 0;\n    var x = 0;\n    var y = 0;\n    var points = polygon[0];\n\n    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n      var a = points[i];\n      var b = points[j];\n      var f = a.x * b.y - b.x * a.y;\n      x += (a.x + b.x) * f;\n      y += (a.y + b.y) * f;\n      area += f * 3;\n    }\n    if (area === 0) return new Cell(points[0].x, points[0].y, 0, polygon);\n    return new Cell(x / area, y / area, 0, polygon);\n  }\n\n  // get squared distance from a point to a segment\n  function getSegDistSq(px, py, a, b) {\n\n    var x = a.x;\n    var y = a.y;\n    var dx = b.x - x;\n    var dy = b.y - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n      var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n      if (t > 1) {\n        x = b.x;\n        y = b.y;\n\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n  }\n\n  function TinyQueue(data, compare) {\n\n    function defaultCompare(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n    }\n\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n      for (var i = this.length >> 1; i >= 0; i--) {this._down(i);}\n    }\n  }\n\n  TinyQueue.prototype = {\n\n    push: function push(item) {\n      this.data.push(item);\n      this.length++;\n      this._up(this.length - 1);\n    },\n\n    pop: function pop() {\n      if (this.length === 0) return undefined;\n\n      var top = this.data[0];\n      this.length--;\n\n      if (this.length > 0) {\n        this.data[0] = this.data[this.length];\n        this._down(0);\n      }\n      this.data.pop();\n\n      return top;\n    },\n\n    peek: function peek() {\n      return this.data[0];\n    },\n\n    _up: function _up(pos) {\n      var data = this.data;\n      var compare = this.compare;\n      var item = data[pos];\n\n      while (pos > 0) {\n        var parent = pos - 1 >> 1;\n        var current = data[parent];\n        if (compare(item, current) >= 0) break;\n        data[pos] = current;\n        pos = parent;\n      }\n\n      data[pos] = item;\n    },\n\n    _down: function _down(pos) {\n      var data = this.data;\n      var compare = this.compare;\n      var halfLength = this.length >> 1;\n      var item = data[pos];\n\n      while (pos < halfLength) {\n        var left = (pos << 1) + 1;\n        var right = left + 1;\n        var best = data[left];\n\n        if (right < this.length && compare(data[right], best) < 0) {\n          left = right;\n          best = data[right];\n        }\n        if (compare(best, item) >= 0) break;\n\n        data[pos] = best;\n        pos = left;\n      }\n\n      data[pos] = item;\n    } };\n\n\n  if (polygon.length === 3) {\n    return getCentroidOfPolygon(polygon);\n  }\n\n  var precision = 0.01;\n  polygon = [polygon];\n\n  // find the bounding box of the outer ring\n  var minX, minY, maxX, maxY;\n  for (var i = 0; i < polygon[0].length; i++) {\n    var p = polygon[0][i];\n    if (!i || p.x < minX) minX = p.x;\n    if (!i || p.y < minY) minY = p.y;\n    if (!i || p.x > maxX) maxX = p.x;\n    if (!i || p.y > maxY) maxY = p.y;\n  }\n\n  var width = maxX - minX;\n  var height = maxY - minY;\n  var cellSize = Math.min(width, height);\n  var h = cellSize / 2;\n\n  // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n  var cellQueue = new TinyQueue(null, compareMax);\n\n  if (cellSize === 0) return [minX, minY];\n\n  // cover polygon with initial cells\n  for (var x = minX; x < maxX; x += cellSize) {\n    for (var y = minY; y < maxY; y += cellSize) {\n      cellQueue.push(new Cell(x + h, y + h, h, polygon));\n    }\n  }\n\n  // take centroid as the first best guess\n  var bestCell = getCentroidCell(polygon);\n\n  // special case for rectangular polygons\n  var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n  if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n\n  while (cellQueue.length) {\n    // pick the most promising cell from the queue\n    var cell = cellQueue.pop();\n\n    // update the best cell if we found a better one\n    if (cell.d > bestCell.d) {\n      bestCell = cell;\n    }\n\n    // do not drill down further if there's no chance of a better solution\n    if (cell.max - bestCell.d <= precision) continue;\n\n    // split the cell into four cells\n    h = cell.h / 2;\n    cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n    cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n    cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n    cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n  }\n\n  return { x: bestCell.x, y: bestCell.y };\n};","module.exports = \"\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='10' height='10' viewBox='0 0 10 10'%3E %3Cdefs%3E %3ClinearGradient id='linear-gradient' y1='5' x2='10' y2='5' gradientUnits='userSpaceOnUse'%3E %3Cstop offset='0' stop-color='%23fff' stop-opacity='0'/%3E %3Cstop offset='1' stop-color='%23fff'/%3E %3C/linearGradient%3E %3C/defs%3E %3Ctitle%3EAsset 6%3C/title%3E %3Cg id='Layer_2' data-name='Layer 2'%3E %3Cg id='finals_24px'%3E %3Cpath d='M5,10A5,5,0,0,1,0,5,1.2,1.2,0,0,1,2.3,5,2.7,2.7,0,1,0,5,2.3,1.2,1.2,0,0,1,5,0,5,5,0,0,1,5,10Z' fill='url(%23linear-gradient)'/%3E %3C/g%3E %3C/g%3E %3C/svg%3E\\\"\"","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"@font-face {\\n  font-family: 'calibration-icon';\\n  src: url(\\\"data:application/octet-stream;base64,d09GRgABAAAAAAtYAA8AAAAAE7QAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIwleU9TLzIAAAGUAAAAQgAAAFZWgGFpY21hcAAAAdgAAABOAAABcAGIBM1jdnQgAAACKAAAABMAAAAgBtX/BGZwZ20AAAI8AAAFkAAAC3CKkZBZZ2FzcAAAB8wAAAAIAAAACAAAABBnbHlmAAAH1AAAAOQAAADkZyzZ8WhlYWQAAAi4AAAAMQAAADYL0YfIaGhlYQAACOwAAAAcAAAAJAc7A1VobXR4AAAJCAAAAAgAAAAIBvL//2xvY2EAAAkQAAAABgAAAAYAcgAAbWF4cAAACRgAAAAgAAAAIADpC8puYW1lAAAJOAAAAXcAAALNzJ0cHnBvc3QAAAqwAAAAKgAAADsMvKbDcHJlcAAACtwAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYMpJLMlj4HNx8wlhkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAKVkFSAB4nGNgZK5knMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4MiQyJzEH/sxiimIMYpgGFGUFyAM95CpgAAHicY2BgYGVgYGAGYh0gZmFgYAxhYGQAAT+gKCNYnJmBCyzOwqAEVsMCFk/8/x9OMoJ0gkQZ2RhoDxjpYAclgAdMykB54LCCYkYA4LUHVgAAeJxjYEADEhDIHPQ/C4QBEmwD3QB4nK1WaXfTRhQdeUmchCwlCy1qYcTEabBGJmzBgAlBsmMgXZytlaCLFDvpvvGJ3+Bf82Tac+g3flrvGy8kkLTncJqTo3fnzdXM22USWpLYC+uRlJsvxdTWJo3sPAnphk3LUXwoO3shZYrJ3wVREK2W2rcdh0REIlC1rrBEEPseWZpkfOhRRsu2pFdNyi096S5b40G9Vd9+GjrKsTuhpGYzdGg9siVVGFWiSKY9UtKmZaj6K0krvL/CzFfNUMKITiJpvBnG0EjeG2e0ymg1tuMoimyy3ChSJJrhQRR5lNUS5+SKCQzKB82Q8sqnEeXD/Iis2KOcVrBLttP8vi95p3c5P7Ffb1G25EAfyI7s4Ox0JV+EW1th3LST7ShUEXbXd0Js2exU/2aP8ppGA7crMr3QjGCpfIUQKz+hzP4hWS2cT/mSR6NaspETQetlTuxLPoHW44gpcc0YWdDd0QkR1P2SMwz2mD4e/PHeKZYLEwJ4HMt6RyWcCBMpYXM0SdowcmAlZYsqqfWumDjldVrEW8J+7drRl85o41B3YjxbDx1bOVHJ8WhSp5lMndpJzaMpDaKUdCZ4zK8DKD+iSV5tYzWJlUfTOGbGhEQiAi3cS1NBLDuxpCkEzaMZvbkbprl2LVqkyQP13KP39OZWuLnTU9oO9LNGf1anYjrYC9PpaeQv8Wna5SJF6frpGX5M4kHWAjKRLTbDlIMHb/0O0svXlhyF1wbY7u3zK6h91kTwpAH7G9AeT9UpCUyFmFWIVkBirWtZlsnVrBapyNR3Q5pWvqzTBIpyHBfHvoxx/V8zM5aYEr7fidOzIy49c+1LCNMcfJt1PZrXqcVyAXFmeU6nWZbv6zTH8gOd5lme1+kIS1unoyw/1GmB5Uc6HWN5QQuadN/BkIsw5AIOkDCEpQNDWF6CISwVDGG5CENYFmEIyyUYwvJjGMJyGYawvKxl1dRTSePamVgGbEJgYo4eucxF5WoquVRCu2hUakOeEm6VVBTPqn9loF488oY5sBZIl8iaXzHOlY9G5fjWFS1vGjtXwLHqbx+O9jnxUtaLhT8F/9XWVCW9Ys3Dk6vwG4aebCeqNql4dE2Xz1U9uv5fVFRYC/QbSIVYKMqybHBnIoSPOp2GaqCVQ8xszDy063XLmp/D/TcxQhZQ/fg3FBoL3INOWUlZ7eCs1dfbstw7g3I4EyxJMTfz+lb4IiOz0n6RWcqej3wecAWMSmXYagOtFbzZJzEPmd4kzwRxW1E2SNrYzgSJDRzzgHnznQQmYeqqDeRO4YYN+AVhbsF5J1yieqMsh+5F7PMopPxbp+JE9qhojMCz2Rthr+9Cym9xDCQ0+aV+DFQVoakYNRXQNFJuqAZfxtm6bULGDvQjKnbDsqziw8cW95WSbRmEfKSI1aOjn9Zeok6q3H5mFJfvnb4FwSA1MX9733RxkMq7WskyR20DU7calVPXmkPjVYfq5lH1vePsEzlrmm66Jx56X9Oq28HFXCyw9m0O0lImF9T1YYUNosvFpVDqZTRJ77gHGBYY0O9Qio3/q/rYfJ4rVYXRcSTfTtS30edgDPwP2H9H9QPQ92Pocg0uz/eaE59u9OFsma6iF+un6Dcwa625WboG3NB0A+IhR62OuMoNfKcGcXqkuRzpIeBj3RXiAcAmgMXgE921jOZTAKP5jDk+wOfMYdBkDoMt5jDYZs4awA5zGOwyh8Eecxh8wZx1gC+ZwyBkDoOIOQyeMCcAeMocBl8xh8HXzGHwDXPuA3zLHAYxcxgkzGGwr+nWMMwtXtBdoLZBVaADU09Y3MPiUFNlyP6OF4b9vUHM/sEgpv6o6faQ+hMvDPVng5j6i0FM/VXTnSH1N14Y6u8GMfUPg5j6TL8Yy2UGv4x8lwoHlF1sPufvifcP28VAuQABAAH//wAPAAP///+TAwoDUgAlAC4AMQBJQEYkAQIGBQFHFhUQDwQBRAAHBgAGBwBtCAQCAAMCAgEAAVwKAQYGBVYJAQUFDAZJJyYAADEwKyomLicuACUAJSMkFCQXCwUZKwEVDgEVFBcDIw4BHgE7AQcXPwEhHwE3JzMyNjQmKwEDNjU0Jic1BzIWFAYiJjQ2FxMhAVgoNA7ANAoNAg0KHh4LXEABjUBbDB4eCQ4OCTLADTMoLhMbGyYaGhOw/qEDUm8ORyweHP5EAQ0UDERnLn19LmdEDRQNAbwaICxHDm/CGyYaGiYbzv6qeJxjYGRgYABiNfd3DvH8Nl8ZuJlfAEUYrqQu/A+jgWAy8wvmICCXg4EJJAoAgCEOvwAAAHicY2BkYGAO+p8FJF/8/w8iGYAiKIAJAIvHBZcD6AAAAwr//wAAAAAAcgAAAAEAAAACADIAAwAAAAAAAgAWACYAcwAAAFoLcAAAAAB4nHWQy07CQBSG/5GLCokaTdw6KwMxlksiCxISEgxsdEMMW1NKaUtKh0wHEl7Dd/BhfAmfxZ92MAZim+l855szZ04HwDW+IZA/Txw5C5wxyvkEp+hZLtA/Wy6SXyyXUMWb5TL9u+UKHhBYruIGH6wgiueMFvi0LHAlLi2f4ELcWS7QP1ouknuWS7gVr5bL9J7lCiYitVzFvfgaqNVWR0FoZG1Ql+1mqyOnW6moosSNpbs2odKp7Mu5Sowfx8rx1HLPYz9Yx67eh/t54us0UolsOc29GvmJr13jz3bV003QNmYu51ot5dBmyJVWC98zTmjMqtto/D0PAyissIVGxKsKYSBRo61zbqOJFjqkKTMkM/OsCAlcxDQu1twRZisp4z7HnFFC6zMjJjvw+F0e+TEp4P6YVfTR6mE8Ie3OiDIv2ZfD7g6zRqQky3QzO/vtPcWGp7VpDXftutRZVxLDgxqS97FbW9B49E52K4a2iwbff/7vB+NphE8AeJxjYGKAAC4G7ICJkYmRmUEwOTEnM6kosSQzPy++PCOzJJWBAQBRdwcvAAB4nGPw3sFwIihiIyNjX+QGxp0cDBwMyQUbGVidNjEwMmiBGJu5mBg5ICw+BjCLzWkX0wGgNCeQze60i8EBwmZmcNmowtgRGLHBoSNiI3OKy0Y1EG8XRwMDI4tDR3JIBEhJJBBs5mFi5NHawfi/dQNL70YmBhcADHYj9AAA\\\") format(\\\"woff\\\");\\n  font-weight: normal;\\n  font-style: normal; }\\n\\n[class^=\\\"calibration-icon\\\"], [class*=\\\" calibration-icon\\\"] {\\n  font-family: 'calibration-icon';\\n  font-style: normal;\\n  font-weight: normal;\\n  font-variant: normal;\\n  line-height: 1;\\n  padding-top: 2px;\\n  speak: none;\\n  text-transform: none;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale; }\\n\\n.adsk-viewing-viewer .calibration-icon:before {\\n  content: 'a'; }\\n\\n.adsk-viewing-viewer .calibration-panel {\\n  left: calc(50% - 190px);\\n  top: calc(50% - 145px);\\n  width: 300px;\\n  height: auto;\\n  z-index: 4; }\\n\\n.adsk-viewing-viewer .measure-settings-popup .option-drop-down,\\n.adsk-viewing-viewer .calibration-panel .option-drop-down {\\n  width: 100%;\\n  padding-right: 0px;\\n  box-sizing: border-box; }\\n\\n.adsk-viewing-viewer .measure-settings-popup .adsk-lmv-tftable tr td,\\n.adsk-viewing-viewer .calibration-panel .adsk-lmv-tftable tr td {\\n  width: auto;\\n  padding: 2px 15px 2px 0px; }\\n\\n.adsk-viewing-viewer .calibration-panel .adsk-lmv-tftable tr td input {\\n  margin: 0px;\\n  box-sizing: border-box;\\n  width: 100%; }\\n\\n.adsk-viewing-viewer .measure-settings-popup .switch {\\n  margin-left: 25px; }\\n\\n.adsk-viewing-viewer .measure-settings-popup .switch .slider {\\n  width: 26px; }\\n\\n.adsk-viewing-viewer .calibration-textbox::-webkit-inner-spin-button,\\n.adsk-viewing-viewer .calibration-textbox::-webkit-outer-spin-button {\\n  -webkit-appearance: none;\\n  margin: 0; }\\n\\n.adsk-viewing-viewer .calibration-text {\\n  text-align: left;\\n  padding: 6px 10px 6px 10px;\\n  margin: 20px 20px 14px 20px;\\n  font-size: 14px;\\n  -webkit-font-smoothing: antialiased; }\\n\\n.adsk-viewing-viewer .calibration-button {\\n  margin-top: 15px; }\\n\\n.adsk-viewing-viewer .calibration-button-left {\\n  width: calc(50% - 15px);\\n  margin-right: 5px !important;\\n  display: inline-block; }\\n\\n.adsk-viewing-viewer .calibration-button-right {\\n  width: calc(50% - 15px);\\n  margin-left: 5px !important;\\n  display: inline-block; }\\n\\n.adsk-viewing-viewer .calibration-line {\\n  position: absolute;\\n  display: block;\\n  top: 0;\\n  left: 0;\\n  pointer-events: none;\\n  z-index: 0; }\\n\\n.adsk-viewing-viewer .calibration-label {\\n  display: none;\\n  position: absolute;\\n  pointer-events: none;\\n  text-align: 'center';\\n  vertical-align: middle;\\n  cursor: default;\\n  padding: 2px;\\n  color: #000000;\\n  background: #FFFFFF;\\n  border-radius: 10px;\\n  -webkit-transform-origin: 50%  53%; }\\n\\n.adsk-viewing-viewer .calibration-label-text {\\n  display: inline-block;\\n  pointer-events: none;\\n  text-align: 'center';\\n  vertical-align: middle;\\n  font-size: 12px;\\n  cursor: default;\\n  padding: 2px;\\n  color: #000000;\\n  background: #FFFFFF;\\n  border-bottom: 1px dashed #000000;\\n  text-decoration: none;\\n  text-transform: uppercase;\\n  -webkit-font-smoothing: antialiased; }\\n\\n.adsk-viewing-viewer .calibration-label-text:hover {\\n  color: #039be5;\\n  border-bottom: 1px dashed #039be5; }\\n\\n.adsk-viewing-viewer .calibration-label.visible {\\n  display: block; }\\n\\n.adsk-viewing-viewer .calibration-endpoint:hover.calibration-endpoint.enable-hover,\\n.adsk-viewing-viewer .calibration-endpoint.edit {\\n  background-color: #039be5; }\\n\\n.adsk-viewing-viewer .calibration-endpoint:hover.calibration-endpoint.enable-hover > *,\\n.adsk-viewing-viewer .calibration-endpoint.edit > * {\\n  color: #ffffff; }\\n\\n.adsk-viewing-viewer .calibration-endpoint.editable {\\n  pointer-events: all; }\\n\\n.adsk-viewing-viewer .calibration-endpoint {\\n  display: none;\\n  position: absolute;\\n  cursor: move;\\n  pointer-events: none;\\n  width: 30px;\\n  height: 30px;\\n  background-color: #ffffff;\\n  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.24), 0 0 8px 0 rgba(0, 0, 0, 0.12);\\n  -moz-border-radius: 50px;\\n  -webkit-border-radius: 50px;\\n  border-radius: 50px;\\n  justify-content: center;\\n  align-items: center;\\n  text-align: center; }\\n\\n.adsk-viewing-viewer .calibration-endpoint.visible {\\n  display: block; }\\n\\n.adsk-viewing-viewer .calibration-endpoint-text {\\n  display: inline-block;\\n  font-size: 14px;\\n  vertical-align: middle;\\n  cursor: default;\\n  margin: 5px 5px 5px 5px;\\n  vertical-align: middle;\\n  text-align: center;\\n  color: #039be5;\\n  text-decoration: none;\\n  text-transform: uppercase;\\n  pointer-events: none; }\\n\\n.adsk-viewing-viewer .calibration-buttons-wrapper {\\n  text-align: center; }\\n\", \"\"]);\n\n// exports\n","var escape = require(\"../../node_modules/css-loader/lib/url/escape.js\");\nexports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"/* hover shouldn't work on mobile devices */\\n.adsk-viewing-viewer .measure-length:hover.measure-length.enable-hover {\\n  box-shadow: 0 0 16px 3px rgba(0, 117, 210, 0.7);\\n  -webkit-box-shadow: 0 0 16px 3px rgba(0, 117, 210, 0.7);\\n  -moz-box-shadow: 0 0 16px 3px rgba(0, 117, 210, 0.7); }\\n\\n.adsk-viewing-viewer .measure-length {\\n  display: none;\\n  position: absolute;\\n  height: 19px;\\n  left: 0px;\\n  top: 0px;\\n  padding: 2px 0 2px 0;\\n  background-color: #009bea;\\n  box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.25);\\n  color: #f4f4f4;\\n  font-size: 12px;\\n  text-align: center;\\n  line-height: 1.2;\\n  white-space: nowrap;\\n  border-radius: 8px;\\n  pointer-events: none;\\n  cursor: pointer;\\n  z-index: 2;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\\n\\n.adsk-viewing-viewer .measure-length.visible {\\n  display: block; }\\n\\n.adsk-viewing-viewer .measure-length.fetching-topology {\\n  background-color: rgba(34, 34, 34, 0.8);\\n  box-shadow: 0 0.5px 1.5px 0 rgba(0, 0, 0, 0.3); }\\n\\n.adsk-viewing-viewer .measure-length-text {\\n  display: inline-block;\\n  margin: 0 5px 0 5px;\\n  vertical-align: middle;\\n  font-size: 16px;\\n  pointer-events: none; }\\n\\n.adsk-viewing-viewer .measure-delta-text {\\n  margin: 0 5px 0 5px;\\n  align-self: center;\\n  font-size: 14px;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  height: 16px;\\n  line-height: 16px;\\n  vertical-align: middle;\\n  pointer-events: none; }\\n\\n.adsk-viewing-viewer .measure-length-button {\\n  display: inline-block;\\n  width: 16px;\\n  height: 16px;\\n  font-size: 16px;\\n  float: right;\\n  color: #FFFFFF;\\n  opacity: 0.7; }\\n\\n.adsk-viewing-viewer .measure-length-button:hover {\\n  background-color: rgba(166, 194, 255, 0.7);\\n  -webkit-transition: all 0.2s ease;\\n  -moz-transition: all 0.2s ease;\\n  -ms-transition: all 0.2s ease;\\n  -o-transition: all 0.2s ease;\\n  transition: all 0.2s ease; }\\n\\n/* hover shouldn't work on mobile devices */\\n.adsk-viewing-viewer .measure-label:hover.measure-label.enable-hover,\\n.adsk-viewing-viewer .measure-label.on-edit {\\n  box-shadow: 0 0 4px 4px #0d69ca;\\n  -webkit-box-shadow: 0 0 4px 4px #0d69ca;\\n  -moz-box-shadow: 0 0 4px 4px #0d69ca; }\\n\\n.adsk-viewing-viewer .measure-label.editable {\\n  pointer-events: all; }\\n\\n.adsk-viewing-viewer .measure-label {\\n  display: none;\\n  position: absolute;\\n  width: 7px;\\n  height: 7px;\\n  cursor: move;\\n  pointer-events: none;\\n  border-radius: 100px; }\\n\\n.adsk-viewing-viewer .measure-label-hit-area {\\n  display: inline-block;\\n  position: absolute;\\n  width: 44px;\\n  height: 44px;\\n  left: -22px;\\n  top: -22px;\\n  border-radius: 100px;\\n  z-index: 2; }\\n\\n.adsk-viewing-viewer .measure-label-icon {\\n  display: inline-block;\\n  position: absolute;\\n  width: 7px;\\n  height: 7px;\\n  left: -2px;\\n  top: -2px;\\n  background-color: #009bea;\\n  border-style: solid;\\n  border-width: 2px;\\n  border-color: #FFFFFF;\\n  border-radius: 100px;\\n  box-shadow: 0 2px 5px 0 #182A3D;\\n  z-index: 2; }\\n\\n.adsk-viewing-viewer .measure-label.visible {\\n  display: block; }\\n\\n.adsk-viewing-viewer .measure-label-text {\\n  display: inline-block;\\n  margin: 0px 5px 0px 5px;\\n  vertical-align: middle; }\\n\\n.adsk-viewing-viewer .measure-horizontal-divider {\\n  height: 1px;\\n  border-top: 1px solid rgba(200, 200, 200, 0.8); }\\n\\n.adsk-viewing-viewer .measure-submenu-select {\\n  display: block;\\n  position: relative;\\n  width: calc(100% - 40px);\\n  padding: 10px 20px 0px 20px;\\n  opacity: 0.3; }\\n\\n.adsk-viewing-viewer .option-drop-down:disabled {\\n  opacity: 0.3; }\\n\\n.adsk-viewing-viewer .measure-submenu-selectlabel {\\n  position: relative;\\n  display: inline-block;\\n  padding-right: 20px;\\n  padding-bottom: 4px; }\\n\\n/*.measure-result {*/\\n/*display: inline-block;*/\\n/*padding: 10px 0px  10px 20px;*/\\n/*}*/\\n.adsk-viewing-viewer .measure-results {\\n  position: relative;\\n  display: block;\\n  padding: 5px 0px  10px 30px; }\\n\\n.adsk-viewing-viewer .measure-result-label {\\n  display: inline-block;\\n  padding-right: 10px; }\\n\\n.adsk-viewing-viewer .measure-result-number {\\n  display: inline-block; }\\n\\n.adsk-viewing-viewer .measure-delta-collapse {\\n  position: absolute;\\n  right: 20px;\\n  display: inline-block;\\n  background-color: rgba(255, 255, 255, 0.12);\\n  margin: 0px 4px 0px 4px;\\n  padding: 0px 4px 0px 4px;\\n  cursor: pointer;\\n  text-align: center; }\\n\\n.adsk-viewing-viewer .measure-delta-collapse:hover {\\n  background-color: rgba(166, 194, 255, 0.7);\\n  -webkit-transition: all 0.2s ease;\\n  -moz-transition: all 0.2s ease;\\n  -ms-transition: all 0.2s ease;\\n  -o-transition: all 0.2s ease;\\n  transition: all 0.2s ease; }\\n\\n.adsk-viewing-viewer .measure-selection-repick {\\n  position: absolute;\\n  right: 20px;\\n  display: inline-block;\\n  background-color: rgba(255, 255, 255, 0.12);\\n  margin: 4px 4px 4px 4px;\\n  padding: 4px 4px 4px 4px;\\n  cursor: pointer;\\n  text-align: center; }\\n\\n.adsk-viewing-viewer .measure-selection-repick:hover {\\n  background-color: rgba(166, 194, 255, 0.7);\\n  -webkit-transition: all 0.2s ease;\\n  -moz-transition: all 0.2s ease;\\n  -ms-transition: all 0.2s ease;\\n  -o-transition: all 0.2s ease;\\n  transition: all 0.2s ease; }\\n\\n.adsk-viewing-viewer .measure-restart {\\n  margin: 10px 20px 15px 20px;\\n  padding: 6px 10px 6px 10px;\\n  width: calc(100% - 55px);\\n  cursor: pointer;\\n  text-align: center;\\n  border-style: solid;\\n  border-width: 1px;\\n  border-color: rgba(255, 255, 255, 0.2);\\n  border-radius: 3px; }\\n\\n.adsk-viewing-viewer .docking-panel:hover .measure-restart {\\n  background-color: rgba(255, 255, 255, 0.12); }\\n\\n.adsk-viewing-viewer .docking-panel .measure-restart:hover {\\n  background-color: rgba(166, 194, 255, 0.7);\\n  -webkit-transition: all 0.2s ease;\\n  -moz-transition: all 0.2s ease;\\n  -ms-transition: all 0.2s ease;\\n  -o-transition: all 0.2s ease;\\n  transition: all 0.2s ease; }\\n\\n.adsk-viewing-viewer .measure-panel-title {\\n  padding-top: 0px;\\n  padding-left: 20px;\\n  margin-top: 10px; }\\n\\n.adsk-viewing-viewer .measure-panel-title:hover {\\n  cursor: pointer; }\\n\\n.adsk-viewing-viewer .measure-panel-title.collapsed {\\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkEwMDhBMzY4QTYyODExRTM5REY0Q0MwMTM3MTVFOTMzIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkEwMDhBMzY5QTYyODExRTM5REY0Q0MwMTM3MTVFOTMzIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QTAwOEEzNjZBNjI4MTFFMzlERjRDQzAxMzcxNUU5MzMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QTAwOEEzNjdBNjI4MTFFMzlERjRDQzAxMzcxNUU5MzMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6WHWu4AAAAcElEQVR42mL8//8/AzmAiYFMgEtjGSFDcUmGAfEEIOYix6lWQLwUiGXJ8SNI00IgNiIncPiAeCoQ+5ITqsxQA+CAhQhN34C4AoiPkaLxGRAXAfEdUvx4DohjsGkCA1CSw4LrgZgVhxwYM9I9rQIEGACZNDs01yUXlAAAAABJRU5ErkJggg==);\\n  background-repeat: no-repeat; }\\n\\n.adsk-viewing-viewer .measure-panel-title.expanded {\\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkE3QzFFQUQ1QTYyODExRTM5NzE2RjcyN0QxQjg0QTREIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkE3QzFFQUQ2QTYyODExRTM5NzE2RjcyN0QxQjg0QTREIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QTdDMUVBRDNBNjI4MTFFMzk3MTZGNzI3RDFCODRBNEQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QTdDMUVBRDRBNjI4MTFFMzk3MTZGNzI3RDFCODRBNEQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6XuY60AAAARklEQVR42mL8//8/AzmAiYFMQBeNqSg8kB+JwKlAfAZZjIlIm9JJdSpWTYQ04tSETyNeTbg0EtSETSNRmkCAcegkOYAAAwDGjDZHvY373AAAAABJRU5ErkJggg==);\\n  background-repeat: no-repeat; }\\n\\n.adsk-viewing-viewer .adsk-viewing-viewer .measure-table td {\\n  padding: 10px 0px  10px 20px; }\\n\\n.adsk-viewing-viewer .measure-selection-one-label {\\n  display: inline-block;\\n  margin: 18px 18px 18px 18px;\\n  width: 16px;\\n  height: 16px;\\n  font-size: 16px;\\n  float: left;\\n  padding: 2px;\\n  background-color: #0033FF;\\n  border-radius: 10px;\\n  opacity: 0.6; }\\n\\n.adsk-viewing-viewer .measure-selection-two-label {\\n  display: inline-block;\\n  margin: 18px 18px 18px 18px;\\n  width: 16px;\\n  height: 16px;\\n  font-size: 16px;\\n  float: left;\\n  padding: 2px;\\n  background-color: #0033FF;\\n  border-radius: 10px;\\n  opacity: 0.6; }\\n\\n.adsk-viewing-viewer .measure-repick {\\n  display: inline-block;\\n  cursor: default;\\n  margin: 20px 20px 20px 20px;\\n  width: 16px;\\n  height: 16px;\\n  font-size: 16px;\\n  float: right;\\n  opacity: 0.5; }\\n\\n.adsk-viewing-viewer .measure-repick:hover {\\n  opacity: 1; }\\n\\n.adsk-viewing-viewer .measure-selection-result {\\n  display: inline-block;\\n  margin: 21px 0px 21px 0px; }\\n\\n.adsk-viewing-viewer .measure-distance-icon {\\n  display: inline-block;\\n  margin: 20px 2px 20px 2px;\\n  font-size: 52px;\\n  color: #FF9900;\\n  float: left; }\\n\\n.adsk-viewing-viewer .measure-angle-icon {\\n  display: inline-block;\\n  margin: 20px 2px 20px 2px;\\n  font-size: 52px;\\n  color: #FF9900;\\n  float: left; }\\n\\n.adsk-viewing-viewer .adsk-viewing-viewer .measure-result {\\n  font-size: 20px;\\n  color: #FF9900;\\n  display: inline-block;\\n  margin: 38px 0px 38px 0px; }\\n\\n.adsk-viewing-viewer .measure-initial {\\n  font-size: 20px;\\n  display: inline-block;\\n  margin: 38px 0px 38px 56px; }\\n\\n.adsk-viewing-viewer .measure-settings-button {\\n  cursor: default;\\n  position: relative;\\n  top: 20px;\\n  right: 20px;\\n  width: 16px;\\n  height: 16px;\\n  font-size: 18px;\\n  float: right;\\n  opacity: 0.5; }\\n\\n.adsk-viewing-viewer .measure-settings-button:hover {\\n  opacity: 1; }\\n\\n.adsk-viewing-viewer .measure-delta-button {\\n  position: relative;\\n  top: 56px;\\n  right: 4px;\\n  width: 16px;\\n  height: 16px;\\n  font-size: 16px;\\n  float: right;\\n  opacity: 0.5;\\n  -webkit-transform: rotate(-90deg);\\n  -moz-transform: rotate(-90deg);\\n  -ms-transform: rotate(-90deg);\\n  -o-transform: rotate(-90deg);\\n  transform: rotate(-90deg); }\\n\\n.adsk-viewing-viewer .measure-delta-button.rotated {\\n  -webkit-transform: rotate(90deg);\\n  -moz-transform: rotate(90deg);\\n  -ms-transform: rotate(90deg);\\n  -o-transform: rotate(90deg);\\n  transform: rotate(90deg); }\\n\\n.adsk-viewing-viewer .measure-delta-button:hover {\\n  opacity: 1; }\\n\\n.adsk-viewing-viewer .measure-delta-result {\\n  display: inline-block;\\n  margin: 0px 0px 20px 0px;\\n  padding: 0px 0px 0px 56px; }\\n\\n.adsk-viewing-viewer .measure-label-axis {\\n  display: none;\\n  position: absolute;\\n  width: 16px;\\n  height: 16px;\\n  left: 0px;\\n  top: 0px;\\n  background-color: #f4f4f4;\\n  border-radius: 8px;\\n  pointer-events: none; }\\n\\n.adsk-viewing-viewer .measure-label-axis-icon.X {\\n  background-color: #F12C2C; }\\n\\n.adsk-viewing-viewer .measure-label-axis-icon.Y {\\n  background-color: #0BB80B; }\\n\\n.adsk-viewing-viewer .measure-label-axis-icon.Z {\\n  background-color: #2C2CF1; }\\n\\n.adsk-viewing-viewer .measure-label-axis-icon {\\n  width: 20px;\\n  height: 18px;\\n  color: #f4f4f4;\\n  border-radius: 8px 0 0 8px;\\n  font-size: 12px;\\n  padding-top: 4px;\\n  line-height: 15px;\\n  text-align: center;\\n  margin-left: -2px; }\\n\\n/* hover shouldn't work on mobile devices */\\n.adsk-viewing-viewer .measure-label-axis-delta.enableTransition {\\n  transition: opacity 0.1s linear; }\\n\\n.adsk-viewing-viewer .measure-label-axis-delta {\\n  display: none;\\n  position: absolute;\\n  font-size: 18px;\\n  left: 0px;\\n  top: 0px;\\n  background-color: #ffffff;\\n  pointer-events: none;\\n  opacity: 0;\\n  border-radius: 8px;\\n  box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.25); }\\n\\n.adsk-viewing-viewer .measure-label-axis.visible {\\n  display: block; }\\n\\n.adsk-viewing-viewer .measure-label-axis-delta.visible {\\n  display: flex; }\\n\\n.adsk-viewing-viewer .measure-label-axis-x {\\n  color: #F12C2C; }\\n\\n.adsk-viewing-viewer .measure-label-axis-y {\\n  color: #0BB80B; }\\n\\n.adsk-viewing-viewer .measure-label-axis-z {\\n  color: #2C2CF1; }\\n\\n.adsk-viewing-viewer .magnifying-glass.visible {\\n  display: block; }\\n\\n.adsk-viewing-viewer .magnifying-glass {\\n  position: absolute;\\n  display: none;\\n  -moz-border-radius: 100%;\\n  -webkit-border-radius: 100%;\\n  border-radius: 100%;\\n  background: transparent;\\n  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5), inset 2px 2px 4px rgba(0, 0, 0, 0.5);\\n  -webkit-box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5), inset 2px 2px 4px rgba(0, 0, 0, 0.5);\\n  -moz-box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5), inset 2px 2px 4px rgba(0, 0, 0, 0.5);\\n  z-index: 4; }\\n\\n.adsk-viewing-viewer .measure-fetching-topology {\\n  display: inline-block;\\n  width: 10px;\\n  height: 10px;\\n  background: url(\" + escape(require(\"./res/icon-spinner-sm.svg\")) + \");\\n  margin: 3px 0px -2px 3px;\\n  animation: measure-topology-fetching-anim 1.4s infinite linear;\\n  -webkit-animation: measure-topology-fetching-anim 1.4s infinite linear; }\\n\\n@keyframes measure-topology-fetching-anim {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    transform: rotate(0deg); }\\n  100% {\\n    -webkit-transform: rotate(360deg);\\n    transform: rotate(360deg); } }\\n\\n@-webkit-keyframes measure-topology-fetching-anim {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    transform: rotate(0deg); }\\n  100% {\\n    -webkit-transform: rotate(360deg);\\n    transform: rotate(360deg); } }\\n\\n.adsk-viewing-viewer .docking-panel.measure-settings-popup {\\n  display: flex;\\n  justify-content: center;\\n  flex-direction: column;\\n  bottom: 120%;\\n  box-sizing: border-box;\\n  text-align: left;\\n  position: absolute;\\n  padding-top: 15px;\\n  padding-bottom: 15px; }\\n\\n.adsk-viewing-viewer .adsk-toolbar-vertical .docking-panel.measure-settings-popup {\\n  right: 120%;\\n  bottom: unset;\\n  height: max-content;\\n  width: max-content; }\\n\\n.adsk-viewing-viewer .docking-panel.measure-settings-popup .adsk-lmv-tftable tr.switch-slider-row td {\\n  width: auto;\\n  padding-bottom: 0px;\\n  padding-top: 0px;\\n  vertical-align: inherit; }\\n\\n.adsk-viewing-viewer .docking-panel.measure-settings-popup.hide {\\n  display: none; }\\n\\n.adsk-viewing-viewer .measure-settings-popup tbody {\\n  top: 15px; }\\n\\n.adsk-toolbar .measure-toolbar-seperator {\\n  height: 18px;\\n  width: 1px;\\n  background-color: #999;\\n  float: left;\\n  margin: 16px 5px; }\\n\\n.adsk-toolbar.adsk-toolbar-vertical .measure-toolbar-seperator {\\n  height: 1px;\\n  width: 18px;\\n  margin: 5px 16px; }\\n\\n.adsk-viewing-viewer .measure-selection-area {\\n  display: block;\\n  position: absolute;\\n  cursor: pointer;\\n  z-index: 1;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\\n\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7VA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7wBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnXA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1nBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACl7BA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACthDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvhEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3ZA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtNA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnPA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}