{"version":3,"file":"ViewCubeUi/ViewCubeUi.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/ViewCubeUi/ViewCube.js","webpack://Autodesk.Extensions.[name]/./extensions/ViewCubeUi/ViewCubeUi.css?15c5","webpack://Autodesk.Extensions.[name]/./extensions/ViewCubeUi/ViewCubeUi.js","webpack://Autodesk.Extensions.[name]/./extensions/ViewCubeUi/ViewCubeUi.css","webpack://Autodesk.Extensions.[name]/./node_modules/css-loader/lib/css-base.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/addStyles.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/urls.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/ViewCubeUi/ViewCubeUi.js\");\n","import * as THREE from \"three\";\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\n\nvar DDSLoader = avp.DDSLoader;var\ncreateShaderMaterial = avp.ShaderUtils.createShaderMaterial;\nvar WebGLRenderer = avp.WebGLRenderer;\nvar logger = avp.logger;\nvar isMobileDevice = av.isMobileDevice;var\nerrorCodeString = av.errorCodeString,ErrorCodes = av.ErrorCodes;\nvar endpoint = av.endpoint;\nvar getGlobal = av.getGlobal;\nvar GlobalManagerMixin = av.GlobalManagerMixin;\nvar EPSILON = 0.00001;\n\n/**\n                        * Checks if a number is 1 (or really, really close to 1). Things like 0.9999999999999 still count. This is needed\n                        * because THREE.Vector3.normalize doesn't always create a vector with length exactly 1, sometimes it just gets close.\n                        * For example:\n                        * var t = new THREE.Vector3(0, 0, -0.6873695734180347);\n                        * t.normalize();\n                        * t.z; // -0.9999999999999999\n                        *\n                        * @param {Number} a - Number to check\n                        * @return {boolean} - True if the given number is within 1e-12 of 1\n                        */\nvar equalsOne = function equalsOne(a) {\n  return Math.abs(a - 1) < 1e-12;\n};\n\n/**\n    * Check if a vector is aligned with an axis and has a length of 1\n    *\n    * @param {Vector3} vec3 - The vector to check\n    * @return {boolean} - True if the vector is aligned to an axis and has length 1\n    */\nvar isAxisAlignedUnit = function isAxisAlignedUnit(vec3) {\n  return !(\n  !equalsOne(vec3.length()) ||\n  !equalsOne(Math.abs(vec3.x)) && !equalsOne(Math.abs(vec3.y)) && !equalsOne(Math.abs(vec3.z)));\n\n};\n\nvar COLOR_ARROW = 0xB7B9BC;\n\n// A Triad representing the model's coordinates\nfunction Triad(triadLength) {\n  var offSet = triadLength / 2;\n  var triadThickness = 10;\n  var spriteSize = 50;\n  var triadColors = {\n    x: 0xff0000,\n    y: 0x00ff00,\n    z: 0x0000ff };\n\n  var tempMatrix = new THREE.Matrix4(); // A matrix for temporary calculations\n  var sprites = []; // For tracking things that need to always face the camera\n\n  var spriteGeometry = new THREE.PlaneBufferGeometry(spriteSize, spriteSize);\n  var getTextSprite = function getTextSprite(text, color) {\n    var _document = av.getGlobal().document;\n    var textCanvas = _document.createElement('canvas');\n    textCanvas.width = textCanvas.height = 128;\n    var ctx2d = textCanvas.getContext('2d');\n    ctx2d.font = '128px Arial';\n    ctx2d.fillStyle = \"rgba(255,255,255,1)\";\n    ctx2d.textAlign = 'center';\n    ctx2d.textBaseline = 'middle';\n    ctx2d.fillText(text, textCanvas.width / 2, textCanvas.height / 2);\n\n    var textTexture = new THREE.Texture(textCanvas);\n    textTexture.needsUpdate = true;\n\n    return new THREE.Mesh(\n    spriteGeometry,\n    new THREE.MeshBasicMaterial({\n      map: textTexture,\n      side: THREE.DoubleSide,\n      transparent: true,\n      color: color,\n      depthWrite: false,\n      depthTest: true }));\n\n\n  };\n\n  this.triadScene = new THREE.Scene();\n  this.triadLabelScene = new THREE.Scene();\n\n  // Add the axes.\n  var triadGeom = new THREE.BoxGeometry(triadLength, triadThickness, triadThickness);\n  var xAxis = new THREE.Mesh(triadGeom, new THREE.MeshBasicMaterial(\n  { color: triadColors.x, shading: THREE.SmoothShading }));\n  var yAxis = new THREE.Mesh(triadGeom, new THREE.MeshBasicMaterial(\n  { color: triadColors.y, shading: THREE.SmoothShading }));\n  var zAxis = new THREE.Mesh(triadGeom, new THREE.MeshBasicMaterial(\n  { color: triadColors.z, shading: THREE.SmoothShading }));\n\n  xAxis.applyMatrix(tempMatrix.makeTranslation(triadThickness / 2, -offSet, -offSet));\n  yAxis.applyMatrix(tempMatrix.makeRotationZ(Math.PI / 2));\n  yAxis.applyMatrix(tempMatrix.makeTranslation(-offSet, triadThickness / 2, -offSet));\n  zAxis.applyMatrix(tempMatrix.makeRotationY(Math.PI / 2));\n  zAxis.applyMatrix(tempMatrix.makeTranslation(-offSet, -offSet, triadThickness / 2));\n\n  this.triadScene.add(xAxis);\n  this.triadScene.add(yAxis);\n  this.triadScene.add(zAxis);\n\n  // Add text\n  var xSprite = getTextSprite('X', triadColors.x);\n  var ySprite = getTextSprite('Y', triadColors.y);\n  var zSprite = getTextSprite('Z', triadColors.z);\n\n  // Rotate the text to match the up direction. Only rotate the positions, otherwise orienting them to face the\n  // camera becomes more complicated\n  var positionLabels = function positionLabels(quaternion) {\n    var spriteSecondaryAxisOffSet = -(spriteSize + offSet) / 2 - 20;\n    var spriteMainAxisOffset = offSet + spriteSize;\n    xSprite.position.set(spriteMainAxisOffset, spriteSecondaryAxisOffSet, spriteSecondaryAxisOffSet);\n    ySprite.position.set(spriteSecondaryAxisOffSet, spriteMainAxisOffset, spriteSecondaryAxisOffSet);\n    zSprite.position.set(spriteSecondaryAxisOffSet, spriteSecondaryAxisOffSet, spriteMainAxisOffset);\n\n    if (quaternion) {\n      xSprite.position.applyQuaternion(quaternion);\n      ySprite.position.applyQuaternion(quaternion);\n      zSprite.position.applyQuaternion(quaternion);\n    }\n  };\n  positionLabels();\n\n  // Add them to the list of sprites to keep them oriented correctly\n  sprites.push(xSprite);\n  sprites.push(ySprite);\n  sprites.push(zSprite);\n\n  this.triadLabelScene.add(xSprite);\n  this.triadLabelScene.add(ySprite);\n  this.triadLabelScene.add(zSprite);\n\n  /**\n                                      * Reorients the triad so that the model coordinates are represented correctly. If the resulting orientation of the\n                                      * triad will not be aligned with X/Y/Z, nothing happens.\n                                      *\n                                      * @param {Vector3} sceneUp - The scene up. Expected to be a unit vector.\n                                      * @param {Vector3} sceneFront - The scene front. Expected to be a unit vector.\n                                      */\n  this.orient = function (sceneUp, sceneFront) {\n    if (!isAxisAlignedUnit(sceneUp) || !isAxisAlignedUnit(sceneFront)) {\n      return;\n    }\n\n    // Only reorient if something changed\n    if (this.up && this.front && sceneUp.equals(this.up) && sceneFront.equals(this.front)) {\n      return;\n    }\n\n    this.up = sceneUp.clone();\n    this.front = sceneFront.clone();\n\n    // The triad starts with Y up with each line pointing towards the positive direction of its axis.\n    // Orienting the triad to align with scene up and world front is done in 2 steps\n    // 1. Get the correct axis aligned with vertical (rotate about [1, 1, 1]) and keep it in line with the viewcube\n    // 2. Rotate about scene up to align the correct axis and direction with world front\n    // 3. Rotate about world front to get the correct direction for scene up\n\n    var axes = ['x', 'y', 'z'];\n\n    // Align scene up\n    // secondaryAxis and tertiaryAxis are used to work out which axes to check for aligning the front, simplifying\n    // the if statements a bit\n    var upAxis,secondaryAxis,tertiaryAxis,alignmentAngle = 0,frontAngle = 0,upAngle = 0;\n    if (sceneUp.x) {\n      upAxis = 'x';\n      secondaryAxis = 'y';\n      tertiaryAxis = 'z';\n      alignmentAngle = 2 * Math.PI / 3;\n    } else if (sceneUp.y) {\n      upAxis = 'y';\n      secondaryAxis = 'z';\n      tertiaryAxis = 'x';\n    } else if (sceneUp.z) {\n      upAxis = 'z';\n      secondaryAxis = 'x';\n      tertiaryAxis = 'y';\n      alignmentAngle = -2 * Math.PI / 3;\n    }\n\n    // Align front\n    if (equalsOne(-sceneFront[secondaryAxis])) {\n      // The 'secondaryAxis' is already parallel to the front so we need to decide we need a half rotation\n      frontAngle = Math.PI;\n    } else if (sceneFront[tertiaryAxis]) {\n      // The 'tertiaryAxis' is orthogonal to the front so we need a quarter rotation but have to decide which way\n      // to rotate. Direction is dependent on whether we need front to be + or - as well as whether sceneUp is + or -\n      // since that's the axis we'll be rotating around\n      frontAngle = -sceneFront[tertiaryAxis] * sceneUp[upAxis] * Math.PI / 2;\n    }\n\n    // Correct up direction\n    upAngle = equalsOne(-sceneUp[upAxis]) ? Math.PI : 0;\n\n    var tempQuaternion = new THREE.Quaternion();\n    var rotationQuaternion = new THREE.Quaternion();\n\n    // Step 1\n    var rotationAxis = new THREE.Vector3(1, 1, 1);\n    rotationAxis.normalize();\n    rotationQuaternion.setFromAxisAngle(rotationAxis, alignmentAngle);\n\n    // Step 2\n    tempQuaternion.setFromAxisAngle(sceneUp, frontAngle);\n    rotationQuaternion.multiply(tempQuaternion);\n\n    // Step 3\n    tempQuaternion.setFromAxisAngle(sceneFront, upAngle);\n    rotationQuaternion.multiply(tempQuaternion);\n\n    positionLabels(rotationQuaternion);\n    this.triadScene.setRotationFromQuaternion(rotationQuaternion);\n  };\n\n  this.getSprites = function () {return sprites;};\n}\n\n/* All coordinates in three.js are right handed\n   * when looking at the Front of the Cube in the regular upright position: */\n/**\n                                                                                * This is the view cube class subset of Autocam\n                                                                                * this class renders and provides all functionality for the view cube\n                                                                                * @class\n                                                                                * @param {string} tagId - html tag id where you want the view cube to render - OBSOLETE\n                                                                                * @param {Object} autocam - the autocam controller object\n                                                                                * @param {HTMLDivElement} cubeContainer - the HTML element to contain the view cube\n                                                                                * @param {string} localizeResourcePath - relative path to localized texture images\n                                                                                * @param {Object} [options] - the optional options\n                                                                                * @param {string} [options.showTriad] - whether to show the triad. 'up' is given by autocam's world up\n                                                                                * */\nexport function ViewCube(tagId, autocam, cubeContainer, localizeResourcePath, options) {\n\n  var self = this;\n  GlobalManagerMixin.call(this);\n\n  var cam = autocam;\n  var camera = autocam.camera;\n  autocam.setCube(this);\n\n  var viewDir = cam.center.clone().sub(camera.position).normalize();\n  var sceneRight = cam.sceneFrontDirection.clone().cross(cam.sceneUpDirection);\n  var dotUp = viewDir.dot(cam.sceneUpDirection);\n  var dotFront = viewDir.dot(cam.sceneFrontDirection);\n  var dotRight = viewDir.dot(sceneRight);\n\n  if (1 - Math.abs(dotUp) < EPSILON) {\n    self.currentFace = dotUp > 0 ? \"bottom\" : \"top\";\n  } else if (1 - Math.abs(dotFront) < EPSILON) {\n    self.currentFace = dotFront > 0 ? \"front\" : \"back\";\n  } else if (1 - Math.abs(Math.abs(dotRight)) < EPSILON) {\n    self.currentFace = dotRight > 0 ? \"left\" : \"right\";\n  } else {\n    self.currentFace = \"front\";\n  }\n\n  self.showTriad = options && options.showTriad;\n  self.localizeResourcePath = localizeResourcePath;\n\n  var edgeNames = [\"top,front\", \"top right\", \"top,left\", \"top,back\", \"bottom,front\", \"bottom,right\", \"bottom,left\", \"bottom,back\", \"left,front\", \"front,right\", \"right,back\", \"back,left\"];\n  var cornerNames = [\"front,top,right\", \"back,top,right\", \"front,top,left\", \"back,top,left\", \"front,bottom,right\", \"back,bottom,right\", \"front,bottom,left\", \"back,bottom,left\"];\n\n  /**\n                                                                                                                                                                                    *  A string array which contains the options for the view cube menu. Use null to indicate a section separator\n                                                                                                                                                                                    * @type {Array}\n                                                                                                                                                                                    */\n  var menuOptionList = [\n  \"Go Home\", // localized by call to drawDropdownMenu\n  null,\n  \"Orthographic\", // localized by call to drawDropdownMenu\n  \"Perspective\", // localized by call to drawDropdownMenu\n  \"Perspective with Ortho Faces\", // localized by call to drawDropdownMenu\n  null,\n  \"Set current view as Home\", // localized by call to drawDropdownMenu\n  \"Focus and set as Home\", // localized by call to drawDropdownMenu\n  \"Reset Home\", // localized by call to drawDropdownMenu\n  null,\n  \"Set current view as Front\", // localized by call to drawDropdownMenu\n  \"Set current view as Top\", // localized by call to drawDropdownMenu\n  \"Reset orientation\" // localized by call to drawDropdownMenu\n  /*\n  null,\n  \"Properties...\",\n  null,\n  \"Help...\"\n  */];\n\n  var menuEnableList = [\n  true,\n  null,\n  true,\n  true,\n  true,\n  null,\n  true,\n  true,\n  true,\n  null,\n  true,\n  true,\n  true\n  /*\n       null,\n       \"Properties...\",\n       null,\n       \"Help...\"\n       */];\n\n  var menuStateCallbackList = [\n  null,\n  null,\n  function () {return !cam.orthographicFaces && !camera.isPerspective;},\n  function () {return !cam.orthographicFaces && camera.isPerspective;},\n  function () {return cam.orthographicFaces;},\n  null,\n  null,\n  null,\n  null,\n  null,\n  null,\n  null,\n  null\n  /*\n       null,\n       \"Properties...\",\n       null,\n       \"Help...\"\n       */];\n\n\n  // THREE.js Scenes\n  var shadowScene, cubeScene, gridScene, lineScene, triad, controlScene, compassScene;\n\n  // An array of objects that need to always face the camera\n  var sprites = [];\n\n  var controlCamera;\n  // self.camera = new THREE.PerspectiveCamera( camera.fov, window.innerWidth / window.innerHeight, 1, 10000 );\n  // make two cameras to flip between, depending if perspective or orthographic view is used.\n  // TODO: scale keeps the size of the view cube the same; 45 fov used to be the default FOV. Problem with this\n  // idea is that you also then need to adjust the position (and not below - setting it there does nothing) and this\n  // will change the look of the perspective cube.\n  self.pcam = new THREE.PerspectiveCamera(45, 1.0, 1, 2000); // aspect gets truly set during Init()\n  self.ocam = new THREE.OrthographicCamera(-265, 265, 265, -265, -1000, 1000);\n  self.ocam.fov = self.pcam.fov;\n  self.ocam.aspect = self.pcam.aspect;\n  self.camera = camera.isPerspective ? self.pcam : self.ocam;\n  self.camera.position.copy(camera.position);\n  self.center = new THREE.Vector3(0, 0, 0);\n  self.camera.lookAt(self.center);\n  // var length = camera.position.length();\n\n  // THREE.js Meshes\n  var cube, line, home, shadow, context;\n  var gridMeshes = [];\n  var arrowGroup;\n\n  // Sizes for Three.js renderers\n  //var windowHalfX;\n  //var windowHalfY;\n\n  // Buffers and past INTERSECTS used for mouse picking\n  var arrowBuffer = [];\n  var intersectsFace = [];\n  var controlBuffer = [];\n  var cubeBuffer = [];\n  var INTERSECTED = null;\n  var INTERSECTED_F = null;\n  var INTERSECTED_C = null;\n  var rollLeftOffset, rollRightOffset, rollOffset;\n  var homeOffset, menuOffset;\n\n  // Size of cube in relation to HTML tag\n  var cubeSize = 0;\n\n  // Position of HTML element\n  var position;\n\n  // Used to wait for textures to load before rendering the View Cube\n  var loadedTextureCount = 0;\n\n  // Flags\n  // Whether arrows (orthogonal and roll) are visible (i.e., you're directly facing a cube face).\n  var _orthogonalView = true;\n  var _havePointerLockFeature = false;\n  var _havePointerLock = false;\n  var _pointerLockMoveBugSPK865 = false;\n  var _isChrome = navigator.userAgent.search(\"Chrome\") != -1;\n  var _isWindows = navigator.platform.search(\"Win32\") != -1;\n  var _dragged = false;\n  var _transparent = false;\n\n  // Callback for menu selected item \n  var _onViewTypeChangedCb = null;\n\n  // store all loaded textures here so we are not constantly re-downloading them\n  var changingTextures = [];\n\n  // Height and Width of the renderer\n  // may be referred to as self.width and self.height\n  this.width = 0;\n  this.height = 0;\n\n  // Public changeable values\n  /**\n   * view cube animation speed (not 0 or negative),\n   * specified in time (milliseconds) to complete an animation\n   * @type {Number}\n   */\n  this.animSpeed = 500;\n  /**\n                         * turn on and off animation\n                         * @type {Boolean}\n                         */\n  this.animate = true;\n  /**\n                        * turn on and off ability to drag the view cube\n                        * @type {Boolean}\n                        */\n\n  this.compass = false;\n  this.viewScaleFactorCompass = 1.5;\n  this.viewScale = 1; // Set in Init based on cubeSize\n\n  this.draggable = true;\n\n  /**\n                          * turn on and off the availability of the home button;\n                          * note, this is a \"second\", smaller home button, you probably\n                          * do not want it.\n                          * @type {Boolean}\n                          */\n  this.wantHomeButton = false;\n\n  /**\n                                * turn on and off the availability of the roll arrows\n                                * @type {Boolean}\n                                */\n  this.wantRollArrows = true;\n\n  /**\n                               * turn on and off the availability of the menu icon\n                               * @type {Boolean}\n                               */\n  this.wantContextMenu = true;\n\n  /**\n                                * opacity when inactive (transparency must be enabled)\n                                * @type {Number}\n                                */\n  this.inactiveOpacity = 0.5;\n\n  /** Function to get position of html element on screen\n                               *\n                               * @param element - HTML DOM element to find position of\n                               * @return {Object} - object which specifies x and y screen coordinates of location of input element\n                               */\n  var getPosition = function getPosition(element) {\n    var rect = element.getBoundingClientRect();\n    return { x: rect.left, y: rect.top, w: rect.width, h: rect.height };\n\n    /*\n                                                                         var xPosition = window.pageXOffset;\n                                                                         var yPosition = window.pageYOffset;\n                                                                          while (element) {\n                                                                             xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);\n                                                                             yPosition += (element.offsetTop - element.scrollTop + element.clientTop);\n                                                                             element = element.offsetParent;\n                                                                         }\n                                                                         return { x:xPosition, y:yPosition };\n                                                                         */\n\n  };\n\n  /** Used by pointer lock API\n      *\n      * @param {Object} e - event object\n      */\n  var pointerLockChange = function pointerLockChange(e) {\n    e.preventDefault();\n    e.stopPropagation();\n\n    var _document = self.getDocument();\n    _havePointerLock = _document.pointerLockElement === cubeContainer ||\n    _document.mozPointerLockElement === cubeContainer ||\n    _document.webkitPointerLockElement === cubeContainer;\n  };\n\n  var setControlsPositions = function setControlsPositions() {\n    var rollArrowMargin = 30;\n    if (self.renderCompass) {\n      self.rollMesh.position.set(cubeSize + rollArrowMargin, cubeSize + rollArrowMargin, 0);\n      self.rollLeftMesh.position.set(cubeSize + rollArrowMargin, 1.5 * cubeSize, 0.1);\n      self.rollRightMesh.position.set(1.5 * cubeSize, cubeSize + rollArrowMargin, 0.1);\n      self.contextMesh.position.set(1.6 * cubeSize, -1.6 * cubeSize, 0);\n    } else {\n      self.rollMesh.position.set(cubeSize * 0.5 + 20, cubeSize * 0.5 + 20, 0);\n      self.rollLeftMesh.position.set(cubeSize * 0.5 + 20, cubeSize + 20, 0.1);\n      self.rollRightMesh.position.set(cubeSize + 20, cubeSize * 0.5 + 20, 0.1);\n      self.contextMesh.position.set(cubeSize, -cubeSize, 0);\n    }\n  };\n\n  /** Create ViewCube and set up renderer and camera\n      * sets up all Three.js meshes for the View Cube\n      * and initializes all event handlers such as mousemove\n      * and mousedown and mouseup and pointerlock\n      */\n  var Init = function Init() {\n\n    // parentTag = document.getElementById(tagId);\n\n    // var element = $('#'+tagId); // ?? Is this different than the above?\n    // element.width(300);\n    // element.height(300);\n\n    var bounds = cubeContainer.getBoundingClientRect();\n    self.width = bounds.width;\n    self.height = bounds.height;\n\n    position = getPosition(cubeContainer);\n\n    //windowHalfX = self.width / 2;\n    //windowHalfY = self.height / 2;\n\n    //camera for home and arrow\n    controlCamera = new THREE.PerspectiveCamera(70, self.height / self.width, 1, 10000);\n    controlCamera.position.set(0, 0, 500);\n\n    shadowScene = new THREE.Scene();\n    cubeScene = new THREE.Scene();\n    gridScene = new THREE.Scene();\n    lineScene = new THREE.Scene();\n    controlScene = new THREE.Scene();\n    _orthogonalView = true;\n\n    // This size means that the cube is (cubeSize)x(cubeSize)x(cubeSize) big\n    cubeSize = 160;\n    // This adjusts the camera position in perspective view. Has no effect on orthographic cams\n    self.viewScale = cubeSize * 4;\n\n    /******************************************Create the View Cube***********************************************/\n\n    // Load in the faceMap textures for 6 faces\n    var material = self.refreshTexture();\n\n    var filteringType = THREE.LinearFilter;\n    var getResourceUrl = Autodesk.Viewing.Private.getResourceUrl;\n    var resRoot = 'res/textures/';\n\n    var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize, 4, 4, 4);\n    var cubeLine = new THREE.BoxGeometry(cubeSize + 1, cubeSize + 1, cubeSize + 1, 4, 4, 4);\n\n    // Create a cube object mesh with specified geometry and faceMap materials\n    cube = new THREE.Mesh(cubeGeometry, material);\n    cube.position.set(0.0, 0, 0);\n    cubeScene.add(cube);\n\n    // Set up a line segment for the cube border\n    var borderTexture = loadTexture(getResourceUrl(resRoot + 'VCedge1.png'));\n\n    borderTexture.minFilter = borderTexture.maxFilter = filteringType;\n\n    line = new THREE.Mesh(cubeLine, new THREE.MeshBasicMaterial({ map: borderTexture, overdraw: false, transparent: true, shading: THREE.SmoothShading }));\n    line.position.set(0.0, 0, 0);\n    lineScene.add(line);\n\n    // Set up the triad\n    triad = new Triad(cubeSize + 20);\n    Array.prototype.push.apply(sprites, triad.getSprites());\n\n    /********************************************Set up the controls**********************************************/\n\n    // Orthogonal Arrows\n\n    var arrowDist = cubeSize + 5;\n\n    var arrowGeo = new THREE.Geometry();\n\n    var v1 = new THREE.Vector3(-30, 0, 0);\n    var v2 = new THREE.Vector3(30, 0, 0);\n    var v3 = new THREE.Vector3(0, -30, 0);\n\n    arrowGeo.vertices.push(v1);\n    arrowGeo.vertices.push(v2);\n    arrowGeo.vertices.push(v3);\n\n    arrowGeo.faces.push(new THREE.Face3(1, 0, 2));\n    arrowGeo.computeFaceNormals();\n\n    // Arrows are rendered flat over other mesh, so it's depthTest and depthWrite can be turned off\n    var arrowMaterial1 = new THREE.MeshBasicMaterial({ overdraw: true, color: COLOR_ARROW,\n      depthTest: false, depthWrite: false, transparent: false, opacity: 1, shading: THREE.FlatShading });\n    var arrowMaterial2 = new THREE.MeshBasicMaterial({ overdraw: true, color: COLOR_ARROW,\n      depthTest: false, depthWrite: false, transparent: false, opacity: 1, shading: THREE.FlatShading });\n    var arrowMaterial3 = new THREE.MeshBasicMaterial({ overdraw: true, color: COLOR_ARROW,\n      depthTest: false, depthWrite: false, transparent: false, opacity: 1, shading: THREE.FlatShading });\n    var arrowMaterial4 = new THREE.MeshBasicMaterial({ overdraw: true, color: COLOR_ARROW,\n      depthTest: false, depthWrite: false, transparent: false, opacity: 1, shading: THREE.FlatShading });\n\n    var arrowSelection = new THREE.PlaneBufferGeometry(cubeSize * 0.5, cubeSize * 0.3, 2, 2);\n    var arrowSelectionMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0 });\n\n    var upArrow = new THREE.Mesh(arrowGeo, arrowMaterial1);\n    var upArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);\n    upArrow.position.set(0, arrowDist, 0.0);\n    upArrowSelect.position.set(0, arrowDist * 0.9, 0.1);\n\n    var downArrow = new THREE.Mesh(arrowGeo, arrowMaterial2);\n    var downArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);\n    downArrow.position.set(0, -arrowDist, 0.0);\n    downArrowSelect.position.set(0, -arrowDist * 0.9, 0.1);\n    downArrow.rotation.z += Math.PI;\n    downArrowSelect.rotation.z += Math.PI;\n\n    var rightArrow = new THREE.Mesh(arrowGeo, arrowMaterial3);\n    var rightArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);\n    rightArrow.position.set(arrowDist, 0, 0.0);\n    rightArrowSelect.position.set(arrowDist * 0.9, 0, 0.1);\n    rightArrow.rotation.z -= Math.PI / 2;\n    rightArrowSelect.rotation.z -= Math.PI / 2;\n\n    var leftArrow = new THREE.Mesh(arrowGeo, arrowMaterial4);\n    var leftArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);\n    leftArrow.position.set(-arrowDist, 0, 0.0);\n    leftArrowSelect.position.set(-arrowDist * 0.9, 0, 0.1);\n    leftArrow.rotation.z += Math.PI / 2;\n    leftArrowSelect.rotation.z += Math.PI / 2;\n\n    arrowGroup = new THREE.Object3D();\n    arrowGroup.position.set(0, 0, 0);\n    arrowGroup.add(upArrow);\n    arrowGroup.add(downArrow);\n    arrowGroup.add(rightArrow);\n    arrowGroup.add(leftArrow);\n\n    controlScene.add(upArrowSelect);\n    controlScene.add(downArrowSelect);\n    controlScene.add(rightArrowSelect);\n    controlScene.add(leftArrowSelect);\n    controlScene.add(arrowGroup);\n\n    arrowBuffer.push(upArrowSelect);\n    arrowBuffer.push(downArrowSelect);\n    arrowBuffer.push(rightArrowSelect);\n    arrowBuffer.push(leftArrowSelect);\n\n    // Home icon\n    var homeGeo = new THREE.PlaneBufferGeometry(cubeSize / 3, cubeSize / 3, 2, 2);\n    var homeMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(getResourceUrl(resRoot + 'VChome.png')),\n      transparent: true, shading: THREE.FlatShading });\n    //homeMaterial.needsUpdate = true;\n    home = new THREE.Mesh(homeGeo, homeMaterial);\n    home.position.set(-cubeSize, cubeSize, 0);\n\n    homeOffset = controlBuffer.length;\n    controlScene.add(home);\n    controlBuffer.push(home);\n\n    // Arrows for rolling\n    var rollArrows = new THREE.PlaneBufferGeometry(cubeSize * 1.5, cubeSize * 1.5, 2, 2);\n    var rollMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(getResourceUrl(resRoot + 'VCarrows.png')), shading: THREE.FlatShading, depthTest: false, depthWrite: false, transparent: true });\n    var roll = new THREE.Mesh(rollArrows, rollMaterial);\n    self.rollMesh = roll;\n\n    var rollSelectionLeft = new THREE.PlaneBufferGeometry(cubeSize * 0.6, cubeSize * 0.45, 2, 2);\n    var rollSelectionLeftMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0 });\n    var rollLeft = new THREE.Mesh(rollSelectionLeft, rollSelectionLeftMat);\n    self.rollLeftMesh = rollLeft;\n\n    var rollSelectionRight = new THREE.PlaneBufferGeometry(cubeSize * 0.45, cubeSize * 0.6, 2, 2);\n    var rollSelectionRightMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0 });\n    var rollRight = new THREE.Mesh(rollSelectionRight, rollSelectionRightMat);\n    self.rollRightMesh = rollRight;\n\n    controlScene.add(roll);\n    controlScene.add(rollLeft);\n    controlScene.add(rollRight);\n\n    rollLeftOffset = controlBuffer.length;\n    controlBuffer.push(rollLeft);\n    rollRightOffset = controlBuffer.length;\n    controlBuffer.push(rollRight);\n    rollOffset = controlBuffer.length;\n    controlBuffer.push(roll);\n\n    //Menu Icon\n    var contextGeo = new THREE.PlaneBufferGeometry(cubeSize / 2.3, cubeSize / 2.3, 2, 2);\n    var contextMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(getResourceUrl(resRoot + 'VCcontext.png')),\n      transparent: true, depthTest: false, depthWrite: false, shading: THREE.FlatShading });\n    //homeMaterial.needsUpdate = true;\n    context = new THREE.Mesh(contextGeo, contextMaterial);\n    self.contextMesh = context;\n\n    menuOffset = controlBuffer.length;\n    controlScene.add(context);\n    controlBuffer.push(context);\n\n    // Move the controls to right positions\n    setControlsPositions();\n\n    // Cube Shadow (Plane)\n\n    var shadowGeo = new THREE.Geometry();\n\n    shadowGeo.vertices.push(new THREE.Vector3(0, 0, 0));\n\n    var shadowToCubeDist = Math.floor(cubeSize * 0.20 / 2) || 20;\n    shadowGeo.vertices.push(new THREE.Vector3(-cubeSize / 2, -cubeSize / 2 - shadowToCubeDist, -cubeSize / 2));\n    shadowGeo.vertices.push(new THREE.Vector3(cubeSize / 2, -cubeSize / 2 - shadowToCubeDist, -cubeSize / 2));\n    shadowGeo.vertices.push(new THREE.Vector3(cubeSize / 2, -cubeSize / 2 - shadowToCubeDist, cubeSize / 2));\n    shadowGeo.vertices.push(new THREE.Vector3(-cubeSize / 2, -cubeSize / 2 - shadowToCubeDist, cubeSize / 2));\n\n    shadowGeo.faces.push(new THREE.Face3(4, 3, 2));\n    shadowGeo.faces.push(new THREE.Face3(4, 2, 1));\n\n\n    var shadowMat;\n\n    // if(cam.renderer === 'WEBGL') {\n    //     var vertexShader = \"void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}\";\n    //     var fragmentShader = \"void main() {gl_FragColor = vec4(0, 0, 0, 0.5);}\";\n    //     shadowMat = new THREE.ShaderMaterial({vertexShader: vertexShader, fragmentShader: fragmentShader});\n    // }else{\n    //     shadowMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity: 0.5});\n    // }\n    shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.5 });\n\n    shadow = new THREE.Mesh(shadowGeo, shadowMat);\n    shadowScene.add(shadow);\n\n    createCubeGrid();\n\n    if (cam.renderer.toUpperCase() === 'CANVAS') {\n      self.renderer = new THREE.CanvasRenderer();\n\n    } else if (cam.renderer.toUpperCase() === 'WEBGL') {\n      self.renderer = new WebGLRenderer({ alpha: true, antialias: false });\n\n      // Simplify debugging\n      self.renderer.name = 'ViewCubeRenderer';\n    } else {\n      logger.warn(\"Incorrect use of Autocam.renderer property\");\n      self.renderer = new THREE.CanvasRenderer();\n    }\n\n    self.useTransparency(true);\n    self.setSize(self.width, self.height);\n\n    self.camera.topFov = self.camera.bottomFov = self.camera.fov / 2;\n    self.camera.leftFov = self.camera.rightFov = self.camera.aspect * self.camera.fov / 2;\n    // need to copy to camera templates - half of these statements do nothing, since the camera points at pcam or ocam, but simpler than an if statement.\n    self.pcam.topFov = self.ocam.topFov = self.camera.topFov;\n    self.pcam.bottomFov = self.ocam.bottomFov = self.camera.bottomFov;\n    self.pcam.leftFov = self.ocam.leftFov = self.camera.leftFov;\n    self.pcam.rightFov = self.ocam.rightFov = self.camera.rightFov;\n\n    // Auto clear needed because of multiple scenes\n    self.renderer.autoClear = false;\n    self.renderer.setSize(self.width, self.height);\n    self.renderer.sortObjects = false;\n    cubeContainer.appendChild(self.renderer.domElement);\n\n    // Initialize all event handlers\n    cubeContainer.addEventListener('touchstart', onDocumentMouseDown, false);\n    cubeContainer.addEventListener('mousedown', onDocumentMouseDown, false);\n    cubeContainer.addEventListener('mousemove', onDocumentMouseMove, false);\n\n    /*\n                                                                                     _havePointerLockFeature = 'pointerLockElement' in document ||\n                                                                                                               'mozPointerLockElement' in document ||\n                                                                                                               'webkitPointerLockElement' in document;\n                                                                             */\n    //Disabling this because it causes an intrusive browser pop-up asking\n    //whether I want to allow full screen mode to happen (huh?)\n    _havePointerLockFeature = false;\n\n    if (_havePointerLockFeature) {\n      var _document = self.getDocument();\n      _document.exitPointerLock = _document.exitPointerLock ||\n      _document.mozExitPointerLock ||\n      _document.webkitExitPointerLock;\n\n      cubeContainer.requestPointerLock = cubeContainer.requestPointerLock ||\n      cubeContainer.mozRequestPointerLock ||\n      cubeContainer.webkitRequestPointerLock;\n\n      // Hook pointer lock state change events\n      self.addDocumentEventListener('pointerlockchange', pointerLockChange, false);\n      self.addDocumentEventListener('mozpointerlockchange', pointerLockChange, false);\n      self.addDocumentEventListener('webkitpointerlockchange', pointerLockChange, false);\n    }\n\n    // Changing textures (blue highlighting for home and roll arrows)\n    changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VChomeS.png')));\n    changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCarrowsS0.png')));\n    changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCarrowsS1.png')));\n    changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VChome.png')));\n    changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCarrows.png')));\n    changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCcontext.png')));\n    changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCcontextS.png')));\n  };\n\n  /** Used to make cube visible again when using the transparency option   */\n  var mouseOverCube = function mouseOverCube() {\n    if (cam.navApi.isActionEnabled('orbit')) {\n      cubeContainer.style.opacity = \"1.0\";\n      _transparent = false;\n    }\n    requestAnimationFrame(self.render);\n  };\n\n  /** Used to fade in and out the cube when using the transparency option */\n  var mouseMoveOverCube = function mouseMoveOverCube(event) {\n    if (!_transparent && !cam.viewCubeMenuOpen && cam.navApi.isActionEnabled('orbit')) {\n      var x = Math.max(Math.abs((event.clientX - position.x) / position.w - 0.5) * 4.0 - 1.0, 0);\n      var y = Math.max(Math.abs((event.clientY - position.y) / position.h - 0.5) * 4.0 - 1.0, 0);\n      var d = Math.max(0, Math.min(Math.sqrt(x * x + y * y), 1.0));\n      cubeContainer.style.opacity = 1.0 - d * (1.0 - self.inactiveOpacity);\n    } else\n    if (cam.navApi.isActionEnabled('orbit')) {\n      cubeContainer.style.opacity = 1.0;\n    }\n  };\n\n  /** Used to make cube transparent when using the transparency option */\n  var mouseOutCube = function mouseOutCube() {\n    if (cam.viewCubeMenuOpen) {\n      return;\n    }\n    cubeContainer.style.opacity = self.inactiveOpacity;\n    _transparent = true;\n    requestAnimationFrame(self.render);\n  };\n\n\n  /** Takes in a image url and outputs a THREE.texture to be used\n      * by Three.js materials\n      * @param {string} url - path to the image you want to load as a texture\n      * @return {THREE.Texture}\n      */\n  var loadTexture = function loadTexture(url) {\n    var image = new Image();\n    var _window = self.getWindow();\n    var useCredentials = endpoint.getUseCredentials() && (url.indexOf('://') === -1 || url.indexOf(_window.location.host) !== -1);\n    if (useCredentials) {\n      image.crossOrigin = \"use-credentials\";\n    } else {\n      image.crossOrigin = \"anonymous\";\n    }\n    var texture = new THREE.Texture(image);\n    image.onload = function () {\n      texture.needsUpdate = true;\n      loadedTextureCount++;\n      if (loadedTextureCount >= 11) {\n        // all textures are now loaded\n        requestAnimationFrame(self.render);\n      }\n    };\n\n    image.src = url;\n    return texture;\n  };\n\n  /** Creates the click-able grid around the View Cube\n      *  by running functions to create Three.js meshes\n      */\n  var createCubeGrid = function createCubeGrid() {\n    var currentGridLength;\n    var cubeCorners = [];\n    var cubeEdges = [];\n\n    cubeCorners[0] = buildCubeCorner(0, 0);\n    cubeCorners[1] = buildCubeCorner(0, Math.PI / 2);\n    cubeCorners[2] = buildCubeCorner(0, -Math.PI / 2);\n    cubeCorners[3] = buildCubeCorner(0, Math.PI);\n    cubeCorners[4] = buildCubeCorner(Math.PI / 2, 0);\n    cubeCorners[5] = buildCubeCorner(Math.PI / 2, Math.PI / 2);\n    cubeCorners[6] = buildCubeCorner(Math.PI / 2, -Math.PI / 2);\n    cubeCorners[7] = buildCubeCorner(Math.PI / 2, Math.PI);\n\n    cubeEdges[0] = buildCubeEdge(0, 0, 0);\n    cubeEdges[1] = buildCubeEdge(0, Math.PI / 2, 0);\n    cubeEdges[2] = buildCubeEdge(0, -Math.PI / 2, 0);\n    cubeEdges[3] = buildCubeEdge(0, Math.PI, 0);\n    cubeEdges[4] = buildCubeEdge(Math.PI / 2, 0, 0);\n    cubeEdges[5] = buildCubeEdge(Math.PI / 2, Math.PI / 2, 0);\n    cubeEdges[6] = buildCubeEdge(Math.PI / 2, -Math.PI / 2, 0);\n    cubeEdges[7] = buildCubeEdge(Math.PI / 2, Math.PI, 0);\n    cubeEdges[8] = buildCubeEdge(0, 0, Math.PI / 2);\n    cubeEdges[9] = buildCubeEdge(0, 0, -Math.PI / 2);\n    cubeEdges[10] = buildCubeEdge(-Math.PI / 2, 0, -Math.PI / 2);\n    cubeEdges[11] = buildCubeEdge(-Math.PI, 0, -Math.PI / 2);\n\n    // Draw the front square on the grid\n    gridMeshes.push(buildCubeFace(0, 0));\n    gridMeshes[0].name = 'front';\n    intersectsFace.push(gridMeshes[0]);\n    cubeBuffer.push(gridMeshes[0]);\n    gridScene.add(gridMeshes[0]);\n\n    // Draw the right square on the grid\n    gridMeshes.push(buildCubeFace(0, Math.PI / 2));\n    gridMeshes[1].name = 'right';\n    intersectsFace.push(gridMeshes[1]);\n    cubeBuffer.push(gridMeshes[1]);\n    gridScene.add(gridMeshes[1]);\n\n    // Draw the back square on the grid\n    gridMeshes.push(buildCubeFace(0, Math.PI));\n    gridMeshes[2].name = 'back';\n    intersectsFace.push(gridMeshes[2]);\n    cubeBuffer.push(gridMeshes[2]);\n    gridScene.add(gridMeshes[2]);\n\n    // Draw the left grid\n    gridMeshes.push(buildCubeFace(0, -Math.PI / 2));\n    gridMeshes[3].name = 'left';\n    intersectsFace.push(gridMeshes[3]);\n    cubeBuffer.push(gridMeshes[3]);\n    gridScene.add(gridMeshes[3]);\n\n    // Draw the bottom grid\n    gridMeshes.push(buildCubeFace(Math.PI / 2, 0));\n    gridMeshes[4].name = 'bottom';\n    intersectsFace.push(gridMeshes[4]);\n    cubeBuffer.push(gridMeshes[4]);\n    gridScene.add(gridMeshes[4]);\n\n    // Draw the top grid\n    gridMeshes.push(buildCubeFace(-Math.PI / 2, 0));\n    gridMeshes[5].name = 'top';\n    intersectsFace.push(gridMeshes[5]);\n    cubeBuffer.push(gridMeshes[5]);\n    gridScene.add(gridMeshes[5]);\n\n    currentGridLength = gridMeshes.length;\n\n    var i;\n    for (i = 0; i < cubeCorners.length; i++) {\n      gridMeshes.push(cubeCorners[i]);\n      gridMeshes[currentGridLength + i].name = cornerNames[i];\n      gridScene.add(gridMeshes[currentGridLength + i]);\n      intersectsFace.push(gridMeshes[currentGridLength + i]);\n      cubeBuffer.push(gridMeshes[currentGridLength + i]);\n    }\n\n    currentGridLength = gridMeshes.length;\n\n    for (i = 0; i < cubeEdges.length; i++) {\n      gridMeshes.push(cubeEdges[i]);\n      gridMeshes[currentGridLength + i].name = edgeNames[i];\n      gridScene.add(gridMeshes[currentGridLength + i]);\n      intersectsFace.push(gridMeshes[currentGridLength + i]);\n      cubeBuffer.push(gridMeshes[currentGridLength + i]);\n    }\n  };\n\n\n  /**\n      * Get intersections between a mesh and mouse position (mouse picking)\n      * @param {THREE.Vector3} pickingVector - direction vector to find intersections\n      * @param {THREE.Camera} camera\n      * @param {THREE.Mesh[]} intersectionBuffer - an array of three.js meshes to check for intersections with these specific meshes\n      * @return {Object[]} - objects which were intersected\n      */\n  var findPickingIntersects = function findPickingIntersects(pickingVector, camera, intersectionBuffer) {\n    var raycaster;\n\n    var direction = new THREE.Vector3();\n    if (camera.type === \"PerspectiveCamera\") {\n      direction.copy(pickingVector);\n      // retrieve point on view plane to shoot ray through\n      direction.unproject(camera);\n      // direction is target point minus position\n      raycaster = new THREE.Raycaster(camera.position, direction.sub(camera.position).normalize());\n    } else {\n      // orthographic\n      var target = new THREE.Vector3();\n      target.copy(pickingVector);\n      // retrieve point on view plane to shoot ray through\n      target.unproject(camera);\n\n      // direction is constant, from position to origin.\n      // direction is negative of position\n      direction.copy(camera.position).negate().normalize();\n      raycaster = new THREE.Raycaster(target, direction);\n    }\n\n    return raycaster.intersectObjects(intersectionBuffer);\n\n  };\n\n  var getPickVector = function getPickVector(event, position) {\n    var x = event.clientX - position.x;\n    var y = event.clientY - position.y;\n\n    x = x / position.w * 2.0 - 1.0;\n    y = (position.h - y) / position.h * 2.0 - 1.0;\n\n    return new THREE.Vector3(x, y, 0.5);\n  };\n\n  /* never used\n     function isFullscreen() {\n         return document.fullscreenElement ||\n                document.webkitFullscreenElement ||\n                document.mozFullScreenElement ||\n                document.msFullscreenElement;\n     }\n     */\n\n  function getEventCoords(event, self) {\n    var coords = {};\n\n    if (event.type.indexOf(\"touch\") === 0) {\n      if (event.touches.length > 0) {\n        coords.clientX = event.touches[0].clientX;\n        coords.clientY = event.touches[0].clientY;\n        coords.pageX = event.touches[0].pageX;\n        coords.pageY = event.touches[0].pageY;\n        coords.screenX = event.touches[0].screenX;\n        coords.screenY = event.touches[0].screenY;\n        coords.movementX = coords.screenX - self.prevX;\n        coords.movementY = coords.screenY - self.prevY;\n        coords.which = cam.navApi.getUseLeftHandedInput() ? 3 : 1;\n      } else\n      {\n        coords = self.prevCoords;\n      }\n    } else\n    {\n      coords.clientX = event.clientX;\n      coords.clientY = event.clientY;\n      coords.pageX = event.pageX;\n      coords.pageY = event.pageY;\n      coords.screenX = event.screenX;\n      coords.screenY = event.screenY;\n      coords.which = event.which;\n\n      if (_havePointerLockFeature) {\n        coords.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;\n        coords.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;\n      } else\n      {\n        coords.movementX = coords.screenX - self.prevX;\n        coords.movementY = coords.screenY - self.prevY;\n      }\n    }\n    self.prevX = coords.screenX;\n    self.prevY = coords.screenY;\n    self.prevCoords = coords;\n\n    return coords;\n  }\n\n  /** All functionality regarding cube clicks starts here\n     *\n     * @param {Object} event - event when mouse down occurs\n     */\n  var onDocumentMouseDown = function onDocumentMouseDown(event) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (!cam.navApi.isActionEnabled('orbit'))\n    return;\n\n    if (cam.currentlyAnimating) {return;}\n\n    var coords = getEventCoords(event, self);\n\n    // Make sure our position is up to date...\n    position = getPosition(cubeContainer);\n\n    cubeContainer.removeEventListener('mousemove', onDocumentMouseMove, false);\n    self.addDocumentEventListener('mouseup', onDocumentMouseUp, false);\n    self.addDocumentEventListener('touchend', onDocumentMouseUp, false);\n    // Not needed: document.addEventListener('mousemove', onDocumentMouseMove, false);\n\n    if (!cam.navApi.getUsePivotAlways()) {\n      // If the usePivot option is not on, we pivot around the center of the view:\n      cam.pivot.copy(cam.center);\n      cam.navApi.setPivotPoint(cam.center);\n      // This also clears the pivot set flag:\n      cam.navApi.setPivotSetFlag(false);\n    }\n\n    cam.startInteraction(coords.pageX, coords.pageY);\n\n    // Since this mouse down is for dragging the cube we should not be able do this if the cube is animating already\n    var intersectsWithCube;\n    var pickingVector;\n\n    //If cube is first thing clicked, add the current shot to rewind history\n    //if (cam.rewindParams.history.length == 0) cam.addHistoryElement();\n\n    //If clicking cube from anywhere other then end of timeline update history accordingly\n    //if (!cam.rewindParams.snapped || cam.rewindParams.timelineIndex +1 != cam.rewindParams.history.length) cam.addIntermediateHistoryElement();\n\n    var rightMouse = cam.navApi.getUseLeftHandedInput() ? 1 : 3;\n    if (coords.which === rightMouse) // Right mouse click, handled on mouse up\n      return;\n\n    if (self.animSpeed <= 0) {\n      logger.error(\"animSpeed cannot be 0 or less, use ViewCube.animate flag to turn on and off animation\", errorCodeString(ErrorCodes.VIEWER_INTERNAL_ERROR));\n      return;\n    }\n\n    // get mouse picking intersections\n    pickingVector = getPickVector(coords, position);\n    intersectsWithCube = findPickingIntersects(pickingVector, self.camera, cubeBuffer);\n\n\n    if (intersectsWithCube.length > 0) {\n\n      hideArrows();\n      if (self.draggable) {\n        self.addDocumentEventListener('mousemove', onDocumentMouseMoveCube, false);\n        self.addDocumentEventListener('touchmove', onDocumentMouseMoveCube, false);\n\n        // Check if browser has pointer lock support\n        if (_havePointerLockFeature) {\n          // Ask the browser to lock the pointer\n          cubeContainer.requestPointerLock();\n          _pointerLockMoveBugSPK865 = _isChrome && _isWindows;\n        }\n      }\n    }\n  };\n\n  /** Used for dragging the cube,\n      * @param {Object} event - event when mouse move occurs (contains information about pointer position)\n      */\n  var onDocumentMouseMoveCube = function onDocumentMouseMoveCube(event) {\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    // This is an error if user puts in self.animSpeed = 0 or less\n    if (self.animSpeed <= 0) {\n      self.removeDocumentEventListener(\"mousemove\", onDocumentMouseMoveCube, false);\n      self.removeDocumentEventListener(\"touchmove\", onDocumentMouseMoveCube, false);\n      logger.error(\"animSpeed cannot be 0 or less\", errorCodeString(ErrorCodes.VIEWER_INTERNAL_ERROR));\n      return;\n    }\n\n    if (cam.currentlyAnimating) {\n      return;\n    }\n    var coords = getEventCoords(event, self);\n\n    if (_havePointerLockFeature) {\n      // We skip the first movement event after requesting pointer lock\n      // because Chrome on Windows sends out a bogus motion value.\n      if (_pointerLockMoveBugSPK865) {\n        _pointerLockMoveBugSPK865 = false;\n        coords.movementX = coords.movementY = 0;\n      }\n    }\n\n    if (_havePointerLock) {\n\n      // Ignore erroneous data sent from pointer lock\n      // not sure why erroneous data gets received\n      // could be bug in pointer lock\n      if (coords.movementX > 300 || coords.movementY > 300) {\n        coords.movementX = 0;\n        coords.movementY = 0;\n      }\n    }\n\n    // If the mouse hasn't moved ignore this current movement (not sure why the mouse move event gets called)\n    // Also used for ignoring erroneous data\n    if (coords.movementX === coords.movementY && coords.movementX === 0) {\n      cam.currentlyAnimating = false;\n      return;\n    }\n    _orthogonalView = false;\n    _dragged = true;\n    cam.showPivot(true);\n    cam.currentCursor = new THREE.Vector2(coords.pageX, coords.pageY);\n    cam.orbit(cam.currentCursor, cam.startCursor, new THREE.Vector3(-coords.movementX, coords.movementY, 0), cam.startState);\n\n    self.camera.lookAt(self.center);\n\n    requestAnimationFrame(self.render);\n  };\n\n\n  var endMouseUp = function endMouseUp(stillNeedUp) {\n    if (!stillNeedUp) {\n      self.removeDocumentEventListener('mouseup', onDocumentMouseUp, false);\n      self.removeDocumentEventListener('touchend', onDocumentMouseUp, false);\n    }\n\n    self.removeDocumentEventListener('mousemove', onDocumentMouseMoveCube, false);\n    self.removeDocumentEventListener('touchmove', onDocumentMouseMoveCube, false);\n    cubeContainer.addEventListener('mousemove', onDocumentMouseMove, false);\n\n    if (_havePointerLock) {\n      var _document = self.getDocument();\n      _document.exitPointerLock();\n    }\n\n  };\n\n  this.registerOnViewTypeChangedCb = function (cb) {\n    if (cb instanceof Function) {\n      _onViewTypeChangedCb = cb;\n    }\n  };\n\n  this.setViewType = function (viewType) {\n    switch (viewType) {\n      case avp.VIEW_TYPES.ORTHOGRAPHIC:\n        // change cube appearance\n        self.camera = self.ocam;\n        break;\n      case avp.VIEW_TYPES.PERSPECTIVE:\n        // change cube appearance\n        self.camera = self.pcam;\n        break;\n      case avp.VIEW_TYPES.PERSPECTIVE_ORTHO_FACES:\n        self.camera = _orthogonalView ? self.ocam : self.pcam;\n        break;\n      default:\n        // This viewType is not supported.\n        // We do not want to call the view type callback here\n        return;}\n\n    _onViewTypeChangedCb && _onViewTypeChangedCb(viewType);\n  };\n\n  /** Rotates the cube when a division of the cube grid is clicked,\n      * also provides functionality for home button interaction, orthogonal arrows interaction,\n      * and roll arrows interaction\n      * @param {Object} event - event contains information about mouse position which is used in this function\n      */\n  var onDocumentMouseUp = function onDocumentMouseUp(event) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    var cubeIntersects;\n    var arrowIntersects;\n    var controlIntersects;\n\n    if (cam.currentlyAnimating || _dragged) {\n      cam.endInteraction();\n      cam.showPivot(false);\n      _dragged = false;\n\n      endMouseUp(false);\n      return;\n    }\n    var coords = getEventCoords(event, self);\n\n    if (cam.viewCubeMenuOpen) {\n      var x = coords.clientX - position.x;\n      var y = coords.clientY - position.y;\n\n      //if clicked on the menu\n      if (cam.menuOrigin.x <= x && x <= cam.menuOrigin.x + cam.menuSize.x &&\n      cam.menuOrigin.y <= y && y <= cam.menuOrigin.y + cam.menuSize.y) {\n\n        // HACK!!\n        // TODO: make this a bit more robust. It doesn't take the menu separators\n        // into account and makes a gross assumption about the menu entry size.\n        var menuItemNumber = Math.floor((y - 5 - cam.menuOrigin.y) / 25);\n\n        var log = function log(action) {\n          logger.track({ name: 'navigation/' + action, aggregate: 'count' });\n        };\n\n        switch (menuItemNumber) {\n          case 0: //home\n            log('home');\n            cam.goHome();\n            break;\n          case 1: //orthographic\n            log('setortho');\n          case 2: //perspective\n            log('setpersp');\n          case 3: //perspective with ortho faces\n            self.setViewType(menuItemNumber);\n            break;\n          case 4: //set current view as home\n            log('sethome');\n            cam.setCurrentViewAsHome(false);\n            break;\n          case 5: //focus and set current view as home\n            log('focushome');\n            cam.setCurrentViewAsHome(true);\n            break;\n          case 6: //reset home\n            log('resethome');\n            cam.resetHome();\n            break;\n          case 7: //set current view as front\n            log('setfront');\n            cam.setCurrentViewAsFront();\n            break;\n          case 8: //set current view as top\n            log('settop');\n            cam.setCurrentViewAsTop();\n            break;\n          case 9: //reset orientation\n            cam.resetOrientation();\n            break;}\n\n      }\n\n      cam.viewCubeMenuOpen = false;\n      cam.removeDropdownMenu(cubeContainer);\n\n      //if clicked off the cube canvas\n      if (coords.clientX < position.x || coords.clientX > position.w + position.x ||\n      coords.clientY < position.y || coords.clientY > position.h + position.y) {\n        mouseOutCube();\n      }\n\n      // In case something needs a highlight change:\n      if (self.mouseMoveSave)\n      self.processMouseMove(self.mouseMoveSave);\n\n      // LMV-1876 and LMV-1986 - re-enable hotkeys, essentially\n      cam.endInteraction();\n\n      // remove event listeners\n      endMouseUp(false);\n      return;\n    }\n    var rightMouse = cam.navApi.getUseLeftHandedInput() ? 1 : 3;\n    if (coords.which === rightMouse) {\n      cam.viewCubeMenuOpen = true;\n      cam.drawDropdownMenu(menuOptionList, menuEnableList, menuStateCallbackList, coords.clientX, coords.clientY, cubeContainer, position);\n      endMouseUp(true);\n      return;\n    }\n    var pickingVector = getPickVector(coords, position);\n    cubeIntersects = findPickingIntersects(pickingVector, self.camera, cubeBuffer);\n    arrowIntersects = findPickingIntersects(pickingVector, controlCamera, arrowBuffer);\n    controlIntersects = findPickingIntersects(pickingVector, controlCamera, controlBuffer);\n\n    // Apply logic for clicking on arrows\n    if (arrowIntersects.length > 0 && _orthogonalView) {\n\n      var FACES = [\"top\", \"bottom\", \"right\", \"left\", \"front\", \"back\"];\n\n      var FACE_MAPPING = {\n        front: {\n          up: [0, 1, 2, 3],\n          right: [2, 3, 1, 0],\n          down: [1, 0, 3, 2],\n          left: [3, 2, 0, 1] },\n\n        right: {\n          up: [0, 1, 5, 4],\n          right: [5, 4, 1, 0],\n          down: [1, 0, 4, 5],\n          left: [4, 5, 0, 1] },\n\n        left: {\n          up: [0, 1, 4, 5],\n          right: [4, 5, 1, 0],\n          down: [1, 0, 5, 4],\n          left: [5, 4, 0, 1] },\n\n        back: {\n          up: [0, 1, 3, 2],\n          right: [3, 2, 1, 0],\n          down: [1, 0, 2, 3],\n          left: [2, 3, 0, 1] },\n\n        top: {\n          up: [5, 4, 2, 3],\n          right: [2, 3, 4, 5],\n          down: [4, 5, 3, 2],\n          left: [3, 2, 5, 4] },\n\n        bottom: {\n          up: [4, 5, 2, 3],\n          right: [2, 3, 5, 4],\n          down: [5, 4, 3, 2],\n          left: [3, 2, 4, 5] } };\n\n\n\n      var orientation = cam.getOrientation();\n      var order = FACE_MAPPING[self.currentFace][orientation];\n\n      var face;\n      for (var f = 0; f < 4; f++) {\n        if (arrowIntersects[0].object === arrowBuffer[f]) {\n          face = FACES[order[f]];\n          break;\n        }\n      }\n\n      cam.calculateCubeTransform(face);\n      self.currentFace = face;\n\n      cam.elapsedTime = 0;\n      cam.sphericallyInterpolateTransition();\n    }\n\n    if (controlIntersects.length > 0) {\n      cam.elapsedTime = 0;\n\n      if (self.wantHomeButton && controlIntersects[0].object === controlBuffer[homeOffset]) {\n        cam.goHome();\n        endMouseUp(false);\n        return;\n      }\n      if (self.wantContextMenu && controlIntersects[0].object === controlBuffer[menuOffset]) {\n        cam.viewCubeMenuOpen = true;\n        cam.drawDropdownMenu(menuOptionList, menuEnableList, menuStateCallbackList, coords.clientX, coords.clientY, cubeContainer, position);\n        endMouseUp(true);\n        return;\n      }\n      if (self.wantRollArrows && _orthogonalView && (controlIntersects[0].object === controlBuffer[rollLeftOffset] || controlIntersects[0].object === controlBuffer[rollRightOffset])) {\n        //TODO: when panning, dir changes -> position\n        var clockwise = controlIntersects[0].object === controlBuffer[rollRightOffset];\n        var destination = {\n          center: cam.center.clone(),\n          position: camera.position.clone(),\n          pivot: camera.pivot.clone(),\n          fov: camera.fov,\n          worldUp: cam.sceneUpDirection.clone(),\n          isOrtho: camera.isPerspective === false };\n\n        var dir = cam.center.clone().sub(camera.position).normalize();\n\n        if (clockwise) {\n          destination.up = camera.up.clone().cross(dir);\n        } else {\n          destination.up = camera.up.clone().multiplyScalar(-1);\n          destination.up.cross(dir);\n        }\n        destination.up.normalize();\n\n        cam.goToView(destination);\n      }\n    }\n    if (cubeIntersects.length > 0) {\n      var face = cubeIntersects[0].object.name;\n      self.mouseMoveSave = event;\n      self.cubeRotateTo(face);\n    }\n    endMouseUp(false);\n  };\n\n  this.cubeRotateTo = function (face) {\n    self.currentFace = face;\n\n    // If ortho faces is on and the target is not another face,\n    // switch to perspective mode:\n    if (cam.orthographicFaces && self.currentFace.indexOf(',') !== -1) {\n      cam.setCameraOrtho(false);\n    }\n    cam.calculateCubeTransform(self.currentFace);\n\n    cam.elapsedTime = 0;\n\n    // After interpolating to the new target we may have to simulate\n    // a mouse move event at the final location so that the appropriate\n    // part of the cube is highlighted:\n    cam.sphericallyInterpolateTransition(function () {\n      if (self.mouseMoveSave)\n      self.processMouseMove(self.mouseMoveSave);\n    });\n  };\n\n  /** Used to highlight cube grid divisions/arrows/home\n      * @param {Object} event - event contains information about mouse position which is used in this function\n      */\n  this.processMouseMove = function (event) {\n    var intersectsFaces;\n    var arrowIntersects;\n    var controlIntersects;\n\n    if (cam.viewCubeMenuOpen || cam.currentlyAnimating) {\n      self.mouseMoveSave = event;\n      return;\n    }\n    self.mouseMoveSave = null;\n\n    var coords = getEventCoords(event, self);\n\n    var pickingVector = getPickVector(coords, position);\n\n    intersectsFaces = findPickingIntersects(pickingVector, self.camera, intersectsFace);\n    arrowIntersects = findPickingIntersects(pickingVector, controlCamera, arrowBuffer);\n    controlIntersects = findPickingIntersects(pickingVector, controlCamera, controlBuffer);\n\n    /**********Highlight arrows when hovered over************/\n\n    if (INTERSECTED && !_dragged) {\n      INTERSECTED.material.color.setHex(COLOR_ARROW);\n      INTERSECTED = null;\n      requestAnimationFrame(self.render);\n    }\n\n    if (arrowIntersects.length > 0 && !_dragged) {\n      INTERSECTED = arrowIntersects[0].object;\n      for (var i = arrowGroup.children.length; --i >= 0;) {\n        if (INTERSECTED === arrowBuffer[i]) {\n          INTERSECTED = arrowGroup.children[i];\n          INTERSECTED.material.color.setHex(0x00afff);\n          break;\n        }\n      }\n      requestAnimationFrame(self.render);\n    }\n\n    /**************Highlight faces on cube******************/\n\n    if (INTERSECTED_F && !_dragged) {\n      // Make the previously selected face opacity: 0.0\n      INTERSECTED_F.material.opacity = 0.0;\n      INTERSECTED_F = null;\n      requestAnimationFrame(self.render);\n    }\n\n    if (intersectsFaces.length > 0 && !_dragged) {\n      // Make the currently selected face opacity: 0.3\n      INTERSECTED_F = intersectsFaces[0].object;\n      INTERSECTED_F.material.opacity = 0.3;\n      requestAnimationFrame(self.render);\n    }\n\n    if (controlIntersects.length > 0 && !_dragged) {\n      if (INTERSECTED_C !== controlIntersects[0].object) {\n        // home mouse over\n        if (self.wantHomeButton && controlIntersects[0].object === controlBuffer[homeOffset]) {\n          INTERSECTED_C = controlIntersects[0].object;\n          controlBuffer[homeOffset].material.map = changingTextures[0];\n        }\n\n        // Left roll arrow mouse over\n        else if (self.wantRollArrows && controlIntersects[0].object === controlBuffer[rollLeftOffset]) {\n            INTERSECTED_C = controlIntersects[0].object;\n            controlBuffer[rollOffset].material.map = changingTextures[1];\n          }\n\n          // Right roll arrow mouse over\n          else if (self.wantRollArrows && controlIntersects[0].object === controlBuffer[rollRightOffset]) {\n              INTERSECTED_C = controlIntersects[0].object;\n              controlBuffer[rollOffset].material.map = changingTextures[2];\n            }\n\n            // Menu Icon\n            else if (self.wantContextMenu && controlIntersects[0].object === controlBuffer[menuOffset]) {\n                INTERSECTED_C = controlIntersects[0].object;\n                controlBuffer[menuOffset].material.map = changingTextures[6];\n              } else\n\n              {\n                // home mouse over\n                if (self.wantHomeButton && INTERSECTED_C === controlBuffer[homeOffset]) {\n                  INTERSECTED_C = null;\n                  controlBuffer[homeOffset].material.map = changingTextures[3];\n                }\n\n                // Left roll and Right roll arrow\n                else if (self.wantRollArrows && (INTERSECTED_C === controlBuffer[rollLeftOffset] ||\n                  INTERSECTED_C === controlBuffer[rollRightOffset] || INTERSECTED_C === controlBuffer[rollOffset])) {\n                    INTERSECTED_C = null;\n                    controlBuffer[rollOffset].material.map = changingTextures[4];\n                  }\n\n                  // menu icon\n                  else if (self.wantContextMenu && INTERSECTED_C === controlBuffer[menuOffset]) {\n                      INTERSECTED_C = null;\n                      controlBuffer[menuOffset].material.map = changingTextures[5];\n                    }\n              }\n        requestAnimationFrame(self.render);\n      }\n    } else if (INTERSECTED_C !== null && !_dragged) {\n      // home mouse over\n      if (self.wantHomeButton && INTERSECTED_C === controlBuffer[homeOffset]) {\n        INTERSECTED_C = null;\n        controlBuffer[homeOffset].material.map = changingTextures[3];\n      }\n\n      // Left roll and Right roll arrow\n      else if (self.wantRollArrows && (INTERSECTED_C === controlBuffer[rollLeftOffset] ||\n        INTERSECTED_C === controlBuffer[rollRightOffset] || INTERSECTED_C === controlBuffer[rollOffset])) {\n          INTERSECTED_C = null;\n          controlBuffer[rollOffset].material.map = changingTextures[4];\n        }\n\n        // menu icon\n        else if (self.wantContextMenu && INTERSECTED_C === controlBuffer[menuOffset]) {\n            INTERSECTED_C = null;\n            controlBuffer[menuOffset].material.map = changingTextures[5];\n          }\n\n      requestAnimationFrame(self.render);\n    }\n  };\n\n  var onDocumentMouseMove = function onDocumentMouseMove(event) {\n    if (cam.navApi.isActionEnabled('orbit'))\n    self.processMouseMove(event);\n  };\n\n  /** Refreshes values so that renderer is correct size (in pixels) **/\n  var onWindowResize = function onWindowResize() {\n    position = getPosition(cubeContainer);\n\n    // cubeContainer.style.width = self.width.toString() + \"px\";\n    // cubeContainer.style.height = \"inherit\";\n\n    self.width = cubeContainer.offsetWidth;\n    self.height = cubeContainer.offsetHeight;\n\n    //windowHalfX = self.width / 2;\n    //windowHalfY = self.height / 2;\n\n    //self.camera.aspect = self.width / self.height; - one of the two cameras has this aspect, so setting it there sets it here.\n    self.pcam.aspect = self.ocam.aspect = self.width / self.height;\n    //self.camera.updateProjectionMatrix(); - done by the two calls below:\n    self.pcam.updateProjectionMatrix();\n    self.ocam.updateProjectionMatrix();\n\n    // PHB added. See Autocam.js windowResize\n    self.camera.topFov = self.camera.bottomFov = self.camera.fov / 2;\n    self.camera.leftFov = self.camera.rightFov = self.camera.aspect * self.camera.fov / 2;\n    // need to copy to camera templates - half of these statements do nothing, since the camera points at pcam or ocam, but simpler than an if statement.\n    self.pcam.aspect = self.ocam.aspect = self.camera.aspect;\n    self.pcam.topFov = self.ocam.topFov = self.camera.topFov;\n    self.pcam.bottomFov = self.ocam.bottomFov = self.camera.bottomFov;\n    self.pcam.leftFov = self.ocam.leftFov = self.camera.leftFov;\n    self.pcam.rightFov = self.ocam.rightFov = self.camera.rightFov;\n\n    self.renderer.setSize(self.width, self.height);\n    requestAnimationFrame(self.render);\n  };\n\n  /** Builds one square mesh of the grid (located on each face of the cube)\n      *\n      * @param {Number} rotationX - rotate shape by this amount in X\n      * @param {Number} rotationY - rotate shape by this amount in Y\n      * @return {THREE.Mesh} - mesh of the cube face (square part) rotated by params\n      */\n  var buildCubeFace = function buildCubeFace(rotationX, rotationY) {\n\n    // These sizes may be changed if cube size is changed\n    var material;\n    var edge = Math.floor(cubeSize * 0.45 / 2) || 45;\n    var square = Math.floor(cubeSize * 0.60 / 2) || 60;\n    var masterCubeSize = edge + square;\n\n    var geo = new THREE.Geometry();\n\n    // Center of the cube\n    var v0 = new THREE.Vector3(0, 0, 0);\n\n    /******************FRONT OF CUBE********************/\n    var v1 = new THREE.Vector3(square, -square, masterCubeSize);\n    var v2 = new THREE.Vector3(square, square, masterCubeSize);\n    var v3 = new THREE.Vector3(-square, square, masterCubeSize);\n    var v4 = new THREE.Vector3(-square, -square, masterCubeSize);\n\n    geo.vertices.push(v0);\n\n    geo.vertices.push(v1);\n    geo.vertices.push(v2);\n    geo.vertices.push(v3);\n    geo.vertices.push(v4);\n\n    /******************FRONT FACE********************/\n\n    // Front square\n    geo.faces.push(new THREE.Face3(1, 2, 3));\n    geo.faces.push(new THREE.Face3(1, 3, 4));\n\n\n    // Apply matrix rotations for sides which are not the front\n    geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));\n    geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));\n\n    geo.computeFaceNormals();\n    geo.computeVertexNormals();\n\n    material = new THREE.MeshBasicMaterial({ overdraw: true, opacity: 0.0, color: 0x00afff, transparent: true });\n    return new THREE.Mesh(geo, material);\n  };\n\n  /** Builds one edge mesh of the grid\n      *\n      * @param rotationX - rotate shape by this amount X\n      * @param rotationY - rotate shape by this amount Y\n      * @param rotationZ - rotate shape by this amount Z\n      * @return {THREE.Mesh} - mesh of the cube edge rotated by params\n      */\n  var buildCubeEdge = function buildCubeEdge(rotationX, rotationY, rotationZ) {\n    var material;\n    var edge = Math.floor(cubeSize * 0.45 / 2) || 45;\n    var square = Math.floor(cubeSize * 0.60 / 2) || 60;\n    var masterCubeSize = edge + square;\n    var meshReturn;\n\n    var geo = new THREE.Geometry();\n\n    var e0 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);\n    var e1 = new THREE.Vector3(-square, masterCubeSize, masterCubeSize);\n    var e2 = new THREE.Vector3(-square, square, masterCubeSize);\n    var e3 = new THREE.Vector3(square, square, masterCubeSize);\n\n    var e4 = new THREE.Vector3(square, masterCubeSize, square);\n    var e5 = new THREE.Vector3(-square, masterCubeSize, square);\n    var e6 = new THREE.Vector3(-square, masterCubeSize, masterCubeSize);\n    var e7 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);\n\n    geo.vertices.push(e0);\n    geo.vertices.push(e1);\n    geo.vertices.push(e2);\n    geo.vertices.push(e3);\n\n    geo.vertices.push(e4);\n    geo.vertices.push(e5);\n    geo.vertices.push(e6);\n    geo.vertices.push(e7);\n\n    geo.faces.push(new THREE.Face3(0, 1, 2));\n    geo.faces.push(new THREE.Face3(0, 2, 3));\n\n    geo.faces.push(new THREE.Face3(4, 5, 6));\n    geo.faces.push(new THREE.Face3(4, 6, 7));\n\n\n    geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));\n    geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));\n    geo.applyMatrix(new THREE.Matrix4().makeRotationZ(rotationZ));\n\n    geo.computeFaceNormals();\n    geo.computeVertexNormals();\n\n    material = new THREE.MeshBasicMaterial({ overdraw: true, opacity: 0.0, color: 0x00afff, transparent: true });\n    meshReturn = new THREE.Mesh(geo, material);\n    return meshReturn;\n  };\n\n  /** Builds one corner mesh of the grid\n      *\n      * @param {Number} rotationX - rotate shape by this amount in X\n      * @param {Number} rotationY - rotate shape by this amount in Y\n      * @return {THREE.Mesh} - the cube corner mesh rotated by params\n      */\n  var buildCubeCorner = function buildCubeCorner(rotationX, rotationY) {\n    var material;\n    var edge = Math.floor(cubeSize * 0.45 / 2) || 45;\n    var square = Math.floor(cubeSize * 0.60 / 2) || 60;\n    var masterCubeSize = edge + square;\n    var meshReturn;\n\n    var geo = new THREE.Geometry();\n\n    var c0 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);\n    var c1 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);\n    var c2 = new THREE.Vector3(square, square, masterCubeSize);\n    var c3 = new THREE.Vector3(masterCubeSize, square, masterCubeSize);\n\n    var c4 = new THREE.Vector3(masterCubeSize, masterCubeSize, square);\n    var c5 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);\n    var c6 = new THREE.Vector3(masterCubeSize, square, masterCubeSize);\n    var c7 = new THREE.Vector3(masterCubeSize, square, square);\n\n    var c8 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);\n    var c9 = new THREE.Vector3(masterCubeSize, masterCubeSize, square);\n    var c10 = new THREE.Vector3(square, masterCubeSize, square);\n    var c11 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);\n\n    geo.vertices.push(c0);\n    geo.vertices.push(c1);\n    geo.vertices.push(c2);\n    geo.vertices.push(c3);\n\n    geo.vertices.push(c4);\n    geo.vertices.push(c5);\n    geo.vertices.push(c6);\n    geo.vertices.push(c7);\n\n    geo.vertices.push(c8);\n    geo.vertices.push(c9);\n    geo.vertices.push(c10);\n    geo.vertices.push(c11);\n\n    geo.faces.push(new THREE.Face3(0, 1, 2));\n    geo.faces.push(new THREE.Face3(0, 2, 3));\n\n    geo.faces.push(new THREE.Face3(4, 5, 6));\n    geo.faces.push(new THREE.Face3(4, 6, 7));\n\n    geo.faces.push(new THREE.Face3(8, 9, 10));\n    geo.faces.push(new THREE.Face3(8, 10, 11));\n\n\n    geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));\n    geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));\n\n    geo.computeFaceNormals();\n    geo.computeVertexNormals();\n\n    material = new THREE.MeshBasicMaterial({ overdraw: true, opacity: 0.0, color: 0x00afff, transparent: true });\n    meshReturn = new THREE.Mesh(geo, material);\n    return meshReturn;\n  };\n\n  var changeBasisWorldToStandard = function changeBasisWorldToStandard(V) {\n    var worldD = cam.cubeFront.clone();\n    var worldU = cam.sceneUpDirection.clone();\n    var worldR = worldD.clone().cross(worldU);\n    worldU.copy(worldR).cross(worldD);\n\n    worldD.normalize();\n    worldU.normalize();\n    worldR.normalize();\n\n    var answer = new THREE.Vector3(worldD.x, worldU.x, worldR.x).multiplyScalar(V.x);\n    answer.add(new THREE.Vector3(worldD.y, worldU.y, worldR.y).multiplyScalar(V.y));\n    answer.add(new THREE.Vector3(worldD.z, worldU.z, worldR.z).multiplyScalar(V.z));\n\n    return answer;\n  };\n\n  /** Render the View Cube scenes and perform checks for control visibility **/\n  this.render = function () {\n    // switch view cube to match whatever camera.isPerspective says to use.\n    self.camera = camera.isPerspective ? self.pcam : self.ocam;\n\n    var scale = self.compass ? self.viewScaleFactorCompass * self.viewScale : self.viewScale;\n    var viewDir = cam.center.clone().sub(camera.position).normalize();\n    var upDir = camera.up.normalize();\n    var spriteRotationMatrix = new THREE.Matrix4();\n\n    viewDir = changeBasisWorldToStandard(viewDir);\n    upDir = changeBasisWorldToStandard(upDir);\n\n    self.camera.position.copy(viewDir);\n    self.camera.position.multiplyScalar(-scale / self.camera.position.length());\n    self.camera.up = upDir.normalize();\n    self.camera.lookAt(self.center);\n\n    checkControlVisibility();\n\n    // Only render triad if enabled and up/front are axis aligned. Otherwise it looks weird\n    var renderTriad = self.renderTriad &&\n    isAxisAlignedUnit(cam.sceneUpDirection) &&\n    isAxisAlignedUnit(cam.sceneFrontDirection);\n\n    var renderer = self.renderer;\n    if (renderer) {\n      // Orient any sprites to face the camera\n      for (var i = 0; i < sprites.length; i++) {\n        spriteRotationMatrix.lookAt(self.camera.position, sprites[i].position, self.camera.up);\n        sprites[i].setRotationFromMatrix(spriteRotationMatrix);\n      }\n\n      renderer.clear();\n      // There are 3 scenes: the first is the shadow, then the cube with textures, then the grid is on top\n      renderer.render(shadowScene, self.camera);\n      renderer.render(cubeScene, self.camera);\n      renderer.render(lineScene, self.camera);\n\n      if (renderTriad) {\n        // Reorient in case up/front changed. Weirdly the scene front direction is backwards so we have to\n        // multiply by -1\n        triad.orient(cam.sceneUpDirection, cam.sceneFrontDirection.clone().multiplyScalar(-1));\n        renderer.render(triad.triadScene, self.camera);\n        renderer.render(triad.triadLabelScene, self.camera);\n      }\n      renderer.render(gridScene, self.camera);\n      // render the compass after the cube. If we do it before, the cube will be hidden\n      if (self.renderCompass) {\n        renderer.render(compassScene, self.camera);\n      }\n\n      // Different camera since these shouldn't move with the View Cube\n      renderer.render(controlScene, controlCamera);\n    }\n  };\n\n  /**\n      * Returns a promise that resolves with an image/png Blob.\n      *\n      * @returns {Promise}\n      */\n  this.getScreenShot = function (options) {\n    return new Promise(function (resolve, reject) {\n\n      var renderer = self.renderer;\n      if (!renderer)\n      return reject('No renderer');\n\n      // Add background\n      var _document = self.getDocument();\n      var canvas = _document.createElement('canvas');\n      canvas.width = self.width;\n      canvas.height = self.height;\n      var ctx = canvas.getContext('2d');\n      ctx.fillStyle = '#FFFFFF';\n      ctx.fillRect(0, 0, self.width, self.height);\n\n      renderer.domElement.toBlob(onViewCubeBlob, 'image/png');\n\n      function onViewCubeBlob(vcBlob) {\n        var img = new Image();\n        var _window = self.getWindow();\n        img.src = _window.URL.createObjectURL(vcBlob);\n        img.onload = function () {\n          ctx.drawImage(img, 0, 0, self.width, self.height);\n          _window.URL.revokeObjectURL(img.src);\n          canvas.toBlob(function (blob) {resolve(blob);}, 'image/png');\n        };\n      }\n    });\n  };\n\n  /**\n      * checks whether arrows (orthogonal and roll), drop down menus, and home button should be visible or not at\n      * this current time\n      */\n  var checkControlVisibility = function checkControlVisibility() {\n    // Arrow Visibility\n\n    _orthogonalView = cam.isFaceView();\n\n    _orthogonalView && !_transparent && !cam.currentlyAnimating ? showArrows() : hideArrows();\n\n    // Menu Visibility\n    _transparent ? hideContext() : showContext();\n\n    // Home Visibility\n    _transparent ? hideHome() : showHome();\n  };\n\n  /** Hide View Cube Arrows **/\n  var hideArrows = function hideArrows() {\n    controlScene.remove(arrowGroup);\n\n    controlBuffer[rollOffset].material.opacity = 0.0;\n    controlBuffer[menuOffset].material.opacity = 0.0;\n  };\n\n  /** Show View Cube Arrows **/\n  var showArrows = function showArrows() {\n    controlScene.add(arrowGroup);\n\n    var opacity = self.wantRollArrows ? 1.0 : 0.0;\n    controlBuffer[rollOffset].material.opacity = opacity;\n    controlBuffer[menuOffset].material.opacity = opacity;\n  };\n\n  /** Hide the view cube menu button **/\n  var hideContext = function hideContext() {\n    context.material.opacity = isMobileDevice() ? 1.0 : 0.0;\n  };\n\n  /** Show the view cube menu button **/\n  var showContext = function showContext() {\n    context.material.opacity = self.wantContextMenu ? 1.0 : 0.0;\n  };\n\n  /** Hide the home button **/\n  var hideHome = function hideHome() {\n    home.material.opacity = 0.0;\n  };\n\n  /** Show the home button **/\n  var showHome = function showHome() {\n    home.material.opacity = self.wantHomeButton ? 1.0 : 0.0;\n  };\n\n  /* Public Methods */\n  /** Update the View Cube camera to a new camera view\n                        * @public\n                        * @this ViewCube\n                        * @param {int[]} eye - client provided camera position (in their world coordinates)\n                        * @param {int[]} centre - client provided pivot point or centre (where the camera is looking at in their world coordinates)\n                        * @param {int[]} upVector - client provided up vector\n                        */\n\n  /** Refresh height and width renderer sizes\n                            * @public\n                            * @this ViewCube\n                            */\n  this.refreshCube = function () {\n    onWindowResize();\n  };\n\n  /** Set the size of the View Cube\n      * @public\n      * @this ViewCube\n      * @param {int} width - in pixels\n      * @param {int} height - in pixels\n      */\n  this.setSize = function (width, height) {\n    self.width = width;\n    self.height = height;\n\n    if (cubeContainer.children.length > 1) {\n      for (var i = 1; i < cubeContainer.children.length; i++) {\n        cubeContainer.children[i].style.bottom = (self.height / 5).toString() + \"px\";}\n    }\n\n    onWindowResize();\n  };\n\n  /** Option to turn on and off transparency on mouse out for the view cube\n      * @public\n      * @this ViewCube\n      * @param {boolean} transparent - true to use transparency, false to turn it off\n      */\n  this.useTransparency = function (transparent) {\n    _transparent = transparent;\n    if (transparent) {\n      cubeContainer.onmouseover = mouseOverCube;\n      cubeContainer.onmousemove = mouseMoveOverCube;\n      cubeContainer.onmouseout = mouseOutCube;\n      mouseOutCube();\n    } else\n    {\n      cubeContainer.onmouseover = null;\n      cubeContainer.onmouseout = null;\n      cubeContainer.onmousemove = null;\n      cubeContainer.style.opacity = \"1.0\";\n    }\n  };\n\n  this.showTriad = function (show) {\n    if (show !== self.renderTriad) {\n      self.renderTriad = show;\n      requestAnimationFrame(self.render);\n    }\n  };\n\n  this.showCompass = function () {var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.initCompass();\n\n\n    if (self.renderCompass !== show) {\n      self.prevRenderCompass = self.renderCompass; // prevRenderCompass is used for \"Reset Orientation\" option\n      self.renderCompass = show;\n      // Move the controls to right positions\n      setControlsPositions();\n      requestAnimationFrame(self.render);\n    }\n  };\n\n  // North angle is the angle to viewcube's back face normal vector\n  this.setCompassRotation = function () {var newNorthAngle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.initCompass();\n\n    var toRotate = newNorthAngle - self.northAngle;\n\n    if (toRotate === 0) {\n      return;\n    }\n\n    self.northAngle = newNorthAngle;\n\n    // rotate about world Y which is the same as object Z\n    self.compassPointerMeshUp.rotateZ(toRotate);\n    self.compassPointerMeshDown.rotateZ(toRotate);\n\n    requestAnimationFrame(self.render);\n  };\n\n  this.initCompass = function () {\n    if (self.hasCompass) {\n      return; // already initialized\n    }\n\n    self.hasCompass = true;\n    self.northAngle = 0; // Angle of north in radians wrt front\n\n    var resRoot = 'res/textures/';\n    var getResourceUrl = Autodesk.Viewing.Private.getResourceUrl;\n    // create the mesh for compass and add it to compass scene\n    compassScene = new THREE.Scene();\n\n    // geometry and material\n    var planeSize = cubeSize * 2.9;\n    var compassGeom = new THREE.PlaneBufferGeometry(planeSize, planeSize, 2, 2);\n    var compassPointerMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide, map: loadTexture(getResourceUrl(resRoot + 'VCcompass-pointer-b.png')), shading: THREE.FlatShading, transparent: true });\n    var compassBaseMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide, map: loadTexture(getResourceUrl(resRoot + 'VCcompass-base.png')), shading: THREE.FlatShading, transparent: true });\n\n    // mesh\n    // We create two meshes for the pointer one on each side of the base mesh, because it causes flicker with transparency set\n    var compassPointerMeshUp = new THREE.Mesh(compassGeom, compassPointerMaterial);\n    var compassPointerMeshDown = new THREE.Mesh(compassGeom, compassPointerMaterial);\n    var compassBaseMesh = new THREE.Mesh(compassGeom, compassBaseMaterial);\n    self.compassPointerMeshUp = compassPointerMeshUp;\n    self.compassPointerMeshDown = compassPointerMeshDown;\n\n    var xRot = -Math.PI / 2;\n    compassBaseMesh.rotateX(xRot);\n    compassPointerMeshUp.rotateX(xRot);\n    compassPointerMeshDown.rotateX(xRot);\n\n    // Translate by world Y, which is object's Z after the rotation above\n    var yTran = -cubeSize * 0.5 - (Math.floor(cubeSize * 0.25 / 2) || 25);\n    compassBaseMesh.translateZ(yTran);\n    compassPointerMeshUp.translateZ(yTran + 0.1);\n    compassPointerMeshDown.translateZ(yTran - 0.1);\n\n    compassScene.add(compassBaseMesh);\n    compassScene.add(compassPointerMeshUp);\n    compassScene.add(compassPointerMeshDown);\n\n    requestAnimationFrame(self.render);\n  };\n\n  /**\n      * Emulates a mouseOver event (when `show=true`) to display the context menu\n      * affordance and make the viewcube render fully opaque. Invoking the method with \n      * `show=false` will emulate a mouseOut event, hiding the context menu affordance\n      * and making the cube transparent.\n      *\n      * @param {boolean} show - true to emulate a mouseOver event, false to emulate a mouseOut event.\n      */\n  this.showControls = function (show) {\n    if (show || show === undefined)\n    mouseOverCube();else\n\n    mouseOutCube();\n  };\n\n  this.dtor = function () {\n    this.renderer = null;\n    _onViewTypeChangedCb = null;\n  };\n\n  this.refreshTexture = function (onTextureReady) {\n\n    // The face names texture is localized:\n    // Load in the faceMap textures for 6 faces\n    var getResourceUrl = Autodesk.Viewing.Private.getResourceUrl;\n    var locTexPath = this.localizeResourcePath || 'res/textures/';\n\n    var texture = new DDSLoader().load(getResourceUrl(locTexPath + 'VCcrossRGBA8small.dds'), onTextureReady);\n    texture.minFilter = texture.maxFilter = THREE.LinearFilter;\n\n    this.texture && this.texture.dispose();\n    this.texture = texture;\n\n    var material = this.material;\n    if (!material) {\n      var shader = THREE.ShaderLib[\"cube\"];\n      material = createShaderMaterial(shader);\n      material.depthWrite = false;\n      this.material = material;\n    }\n\n    material.uniforms[\"tCube\"].value = texture;\n    return material;\n  };\n\n  this.localize = function () {var _this = this;\n    var global = getGlobal();\n    this.localizeResourcePath = global.LOCALIZATION_REL_PATH;\n    this.refreshTexture(function () {\n      // Must delay a frame for the case when the texture is cached by the browser.\n      requestAnimationFrame(_this.render);\n    });\n  };\n\n  /* Build the cube */\n  Init();\n};\n\navp.ViewCube = ViewCube;","\nvar content = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./ViewCubeUi.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./ViewCubeUi.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./ViewCubeUi.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","'use strict';\n\nimport { ViewCube } from './ViewCube';\nimport './ViewCubeUi.css';\n\nvar av = Autodesk.Viewing;\nvar avp = Autodesk.Viewing.Private;\nvar global = av.getGlobal();\n\n\n/**\n                              * Create the UI for the view cube.\n                              * \n                              * The extension id is: `Autodesk.ViewCubeUi`\n                              * \n                              * @example\n                              *    viewer.loadExtension('Autodesk.ViewCubeUi');\n                              * \n                              * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                              * @memberof Autodesk.Viewing.Extensions\n                              * @alias Autodesk.Viewing.Extensions.ViewCubeUi\n                              * @class\n                              * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance.\n                              * @param {object} options - Not used.\n                              */\nexport function ViewCubeUi(viewer, options) {\n  av.Extension.call(this, viewer, options);\n  // Keep the constructor LEAN\n  // The actual initialization happens in create()\n  this.container = null;\n  this.cube = null; // Autocam.ViewCube\n  this.viewcube = null;\n  this.homeViewContainer = null;\n  this._created = false;\n  this._initTriadVisibility = false;\n  this.refreshCube = this.refreshCube.bind(this);\n  this.displayViewCube = this.displayViewCube.bind(this);\n  this.setViewType = this.setViewType.bind(this);\n  this._updateView = this._updateView.bind(this);\n  this._onModelAdded = this._onModelAdded.bind(this);\n}\n\nViewCubeUi.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nViewCubeUi.prototype.constructor = ViewCubeUi;\n\nObject.assign(ViewCubeUi.prototype, {\n  /**\n                                       * @private\n                                       */\n  load: function load() {var _this = this;\n    this.create();\n\n    this._displayViewCube(this.viewer.impl.is2d);\n\n    this.localize();\n\n    // Dispatch a view cube created event\n    this.viewer.dispatchEvent({ type: av.VIEW_CUBE_CREATED_EVENT });\n\n    // Refresh the cube when resizing\n    this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this.refreshCube);\n\n    // Register the displayViewCube function as the callback for the viewCube preference.\n    this.viewer.prefs.addListeners(avp.Prefs3D.VIEW_CUBE, this.displayViewCube);\n\n    // Change the view when the VIEW_TYPE preference is set.\n    this.viewer.prefs.addListeners(avp.Prefs3D.VIEW_TYPE, this.setViewType);\n\n    if (this.viewer.model) {\n      // Add first model according to the current mode (2D or 3D)\n      var models = this.viewer.getVisibleModels().filter(function (model) {return !!_this.viewer.impl.is2d === model.is2d();});\n      this._onModelAdded({ model: models[0] });\n    }\n\n    // Register an event handler to update the view cube (not just once for model unloading/loading use cases)\n    this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._onModelAdded);\n\n    // This needs to be called to ensure that the preference callback is called.\n    // By the time the viewer.setProfile function is called in the viewer (which will set the preferences), this extension is not loaded.\n    this._setDefaultView();\n\n    return true;\n  },\n\n  /**\n      * Destroy the view cube.\n      *\n      * @private\n      */\n  unload: function unload() {\n    this.viewer.prefs.removeListeners(avp.Prefs3D.VIEW_CUBE, this.displayViewCube);\n    this.viewer.prefs.removeListeners(avp.Prefs3D.VIEW_TYPE, this.setViewType);\n    this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.refreshCube);\n    this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._onModelAdded);\n\n    if (this.container) {\n      this.viewer.container.removeChild(this.container);\n      this.viewcube = null;\n    }\n\n    if (this.cube) {\n      this.cube.dtor();\n      this.cube = null;\n    }\n\n    this.homeViewContainer = null;\n    this.hideHomeViewMenu = null;\n    this.viewer = null;\n    return true;\n  },\n\n  /**\n      * Initialize the view cube and the home button.\n      * This method is called when the extension is loaded.\n      */\n  create: function create() {\n    if (this._created)\n    return;\n    this.initContainer();\n    this.initHomeButton();\n    this._created = true;\n  },\n\n  /**\n      * @private\n      */\n  initContainer: function initContainer() {\n    var _document = this.getDocument();\n    this.container = _document.createElement('div');\n    this.container.className = \"viewcubeWrapper\";\n    this.viewer.container.appendChild(this.container);\n  },\n\n  /**\n      * @private\n      */\n  initHomeButton: function initHomeButton() {\n    if (this.homeViewContainer) {\n      return;\n    }\n\n    var _document = this.getDocument();\n    var homeViewContainer = _document.createElement('div');\n    homeViewContainer.className = \"homeViewWrapper\";\n\n    this.container.appendChild(homeViewContainer);\n    this.homeViewContainer = homeViewContainer;\n\n    var self = this;\n    homeViewContainer.addEventListener(\"click\", function () {\n      self.viewer.navigation.setRequestHomeView(true);\n    });\n  },\n\n  /**\n      * Show or hide the view cube element. This also applies to the home button.\n      *\n      * @param {boolean} show - If set to false, the view cube and the home button will become invisible.\n      * @alias Autodesk.Viewing.Extensions.ViewCubeUi#setVisible\n      */\n  setVisible: function setVisible(show) {\n    this.container.style.display = show ? 'block' : 'none';\n  },\n\n  /**\n      * Update the VIEW_TYPE preference's default value.\n      *\n      * @private\n      */\n  _setDefaultView: function _setDefaultView() {\n    if (this.viewer.impl.is2d) return;\n\n    if (this.viewer.impl.getModelCamera(this.viewer.model)) {\n      return;\n    }\n\n    this.viewer.prefs.dispatchEvent(avp.Prefs3D.VIEW_TYPE);\n  },\n\n  /**\n      * Set the viewType for the VIEW_TYPE preference\n      *\n      * @param {number} viewType - view index. \n      * @private\n      */\n  _updateView: function _updateView(viewType) {\n    if (this.viewer.impl.is2d) return;\n\n    if (!this.viewer.prefs.set(avp.Prefs3D.VIEW_TYPE, viewType)) {\n      // If the value was not changed, check with autocam as well, in case it was changed programmatically\n      var autocamViewType = this.viewer.autocam.getViewType();\n      if (viewType !== autocamViewType) {\n        this.viewer.prefs.dispatchEvent(avp.Prefs3D.VIEW_TYPE);\n      }\n    }\n  },\n\n  /**\n      * Set the viewCube view type. \n      *\n      * @param {string} viewType - 1 for orthographic, 2 for perspective, 3 for orthoFaces\n      */\n  setViewType: function setViewType(viewType) {\n    if (this.viewer.impl.is2d || !this.cube) return;\n    this.cube.setViewType(viewType);\n  },\n\n  /**\n      * Show the x,y,z axes of the view cube.\n      *\n      * @param {boolean} show - if set to true, the view cube axes will be shown.\n      * @alias Autodesk.Viewing.Extensions.ViewCubeUi#showTriad\n      */\n  showTriad: function showTriad(show) {\n    if (this.cube)\n    this.cube.showTriad(show);else\n\n    this._initTriadVisibility = show;\n  },\n\n  /**\n      * Set the face of ViewCube and apply camera transformation according to it.\n      *\n      * @param {string} face - The face name of ViewCube. The name can contain multiple face names,\n      * the format should be `\"[front/back], [top/bottom], [left/right]\"`.\n      *\n      * @example\n      *    viewer.setViewCube('front top right');\n      *    viewer.setViewCube('bottom left');\n      *    viewer.setViewCube('back');\n      * \n      * @alias Autodesk.Viewing.Extensions.ViewCubeUi#setViewCube\n      */\n  setViewCube: function setViewCube(face) {\n    if (this.cube) {\n      this.cube.cubeRotateTo(face);\n    }\n  },\n\n  /**\n      * Hides the Home button next to the ViewCube.\n      *\n      * @param {boolean} show\n      * @alias Autodesk.Viewing.Extensions.ViewCubeUi#displayHomeButton\n      */\n  displayHomeButton: function displayHomeButton(show) {// show/hide home button.\n    if (this.homeViewContainer)\n    this.homeViewContainer.style.display = show ? '' : 'none';\n  },\n\n  /**\n      * Display the view cube. This will not effect the home button.\n      *\n      * @param {boolean} display - if set to false the view cube element will be invisible\n      * @param {boolean} updatePrefs - update the view cube preference\n      * @alias Autodesk.Viewing.Extensions.ViewCubeUi#displayViewCube\n      */\n  displayViewCube: function displayViewCube(display, updatePrefs) {\n    if (updatePrefs)\n    this.viewer.prefs.set(avp.Prefs3D.VIEW_CUBE, display);\n\n    if (display && !this.cube && !this.viewer.impl.is2d) {\n      var _document = this.getDocument();\n      this.viewcube = _document.createElement(\"div\");\n      this.viewcube.className = \"viewcube\";\n      this.container.appendChild(this.viewcube);\n      this.cube = new ViewCube(\"cube\", this.viewer.autocam, this.viewcube, global.LOCALIZATION_REL_PATH);\n      this.cube.registerOnViewTypeChangedCb(this._updateView);\n      this.cube.setGlobalManager(this.globalManager);\n\n      // Move sibling on top of the viewcube.\n      this.container.appendChild(this.homeViewContainer);\n\n      if (this._initTriadVisibility) {\n        this.showTriad(true);\n      }\n      delete this._initTriadVisibility;\n    } else\n    if (!this.cube) {\n      this._positionHomeButton();\n      return; //view cube is not existent and we want it off? Just do nothing.\n    }\n\n    this.viewcube.style.display = display ? \"block\" : \"none\";\n\n    this._positionHomeButton();\n\n    if (display) {\n      this.viewer.autocam.refresh();\n    }\n  },\n\n  /**\n      * Localize the view cube\n      *\n      * @alias Autodesk.Viewing.Extensions.ViewCubeUi#localize\n      */\n  localize: function localize() {\n    this.cube && this.cube.localize();\n  },\n\n  /**\n      * @param {boolean} [show=true] show the compass\n      */\n  showCompass: function showCompass() {var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.cube && this.cube.showCompass(show);\n  },\n\n  /**\n      * \n      * @param {number} [radians=0] // Angle of north in radians wrt front\n      */\n  setCompassRotation: function setCompassRotation() {var radians = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.cube && this.cube.setCompassRotation(radians);\n  },\n\n  /**\n      * @param model\n      * @private\n      */\n  _initCompass: function _initCompass(model) {var _data$loadOptions;\n\n    // calculate the north orientation angle\n    var data = model && model.getData();\n    var metadata = data && data.metadata;\n    var projectNorthVector = metadata && metadata['world north vector'];\n    projectNorthVector = projectNorthVector && projectNorthVector.XYZ;\n    projectNorthVector = projectNorthVector && new THREE.Vector3(projectNorthVector[0], projectNorthVector[1], projectNorthVector[2]);\n\n    // Skip initialization if the model doesn't have the north vector\n    if (!projectNorthVector) {\n      return;\n    }\n\n    // Calculate the N orientation\n\n    //       Front Direction (usually same as project or world north)\n    //             ^    \n    //             | \n    //             |\n    //  left <---- o  ----> Right\n    //           /    \n    //          /  \n    //         /   \n    //True North   \n\n    // frontDirection is the direction looking into the front face of the cube\n    var frontDirection = this.viewer.autocam.sceneFrontDirection.clone();\n    var upVector = this.viewer.autocam.sceneUpDirection.clone();\n    var cross = new THREE.Vector3();\n    cross.crossVectors(frontDirection, projectNorthVector);\n    var projectNorthAngle = projectNorthVector.angleTo(frontDirection) * (cross.dot(upVector) < 0 ? -1 : 1);\n    var customValues = metadata['custom values'];\n    var trueNorthAngle = customValues && customValues.angleToTrueNorth || 0;\n    trueNorthAngle = trueNorthAngle * (Math.PI / 180);\n\n    // Project North + True North will give us the final angle to point the north\n    // Do not rotate the compass in aggregated view which sets applyRefPoint\n    var radians = (data === null || data === void 0 ? void 0 : (_data$loadOptions = data.loadOptions) === null || _data$loadOptions === void 0 ? void 0 : _data$loadOptions.applyRefPoint) ? 0 : projectNorthAngle + trueNorthAngle;\n    this.cube.initCompass();\n    this.setCompassRotation(radians);\n\n    // Only show compass if preference is set\n    this.showCompass(!!this.viewer.prefs.get(avp.Prefs3D.VIEW_CUBE_COMPASS));\n  },\n\n  /**\n      * @param is2d\n      * @private\n      */\n  _displayViewCube: function _displayViewCube(is2d) {\n    // Do not display the ViewCube for 2d models\n    var display = is2d ? false : this.viewer.prefs.get(avp.Prefs3D.VIEW_CUBE);\n    this.displayViewCube(display);\n  },\n\n  /**\n      * @param event\n      * @private\n      */\n  _onModelAdded: function _onModelAdded(event) {\n    // As soon as we enter 2D mode, hide the viewcube\n    this._displayViewCube(this.viewer.impl.is2d);\n\n    if (this.cube && !this.cube.hasCompass && !this.viewer.impl.is2d) {\n      this._initCompass(event.model);\n    }\n  },\n\n  /**\n      * @private\n      */\n  _positionHomeButton: function _positionHomeButton() {\n    if (this.homeViewContainer) {\n      var viewCubeVisible = this.cube && this.viewcube && this.viewcube.style.display === 'block';\n      if (viewCubeVisible) {\n        this.homeViewContainer.classList.remove('no-viewcube');\n      } else {\n        this.homeViewContainer.classList.add('no-viewcube');\n      }\n    }\n  },\n\n  /**\n      * Refresh the view cube\n      *\n      * @alias Autodesk.Viewing.Extensions.ViewCubeUi#refreshCube\n      */\n  refreshCube: function refreshCube() {\n    this.cube && this.cube.refreshCube();\n  } });\n\n\n\n/**\n         * Register the extension with the extension manager.\n         */\nav.theExtensionManager.registerExtension('Autodesk.ViewCubeUi', ViewCubeUi);","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"/***\\n * view cube\\n */\\n.viewcube, .viewcubeWrapper {\\n  display: block;\\n  position: absolute;\\n  outline: none;\\n  width: 170px;\\n  height: 170px;\\n  right: -1px;\\n  top: -1px;\\n  opacity: 0.7;\\n  margin: 0;\\n  -webkit-transition: opacity 0.2s ease;\\n  -moz-transition: opacity 0.2s ease;\\n  -ms-transition: opacity 0.2s ease;\\n  -o-transition: opacity 0.2s ease;\\n  transition: opacity 0.2s ease; }\\n\\n.viewcubeWrapper {\\n  pointer-events: none; }\\n\\n.viewcube {\\n  pointer-events: auto; }\\n\\n.rewindFrame {\\n  background-color: #FFFFFF;\\n  position: absolute;\\n  height: 56px;\\n  width: 56px;\\n  z-index: 1002; }\\n\\n.dropDownMenu {\\n  position: absolute;\\n  min-width: 220px;\\n  margin: 0;\\n  z-index: 1001;\\n  background-color: #FFFFFF;\\n  font-family: sans-serif;\\n  font-size: 14px;\\n  list-style-type: none;\\n  border: solid;\\n  border-width: 1px;\\n  border-color: #979797; }\\n\\n.dropDownMenuItem {\\n  position: relative;\\n  width: calc(100% - 24px);\\n  height: 21px;\\n  padding-left: 24px;\\n  /* Pad room for checkboxes */\\n  padding-top: 4px;\\n  background-color: #FFFFFF;\\n  cursor: pointer; }\\n\\n.dropDownMenuCheckbox {\\n  position: relative;\\n  width: calc(100% - 4px);\\n  padding-top: 4px;\\n  height: 21px;\\n  margin-left: 4px;\\n  background-color: #FFFFFF;\\n  cursor: pointer; }\\n\\n.dropDownMenuCheck {\\n  padding-top: 2px;\\n  cursor: pointer; }\\n\\n.dropDownMenuCheckText {\\n  position: relative;\\n  padding-left: 2px;\\n  margin: 0;\\n  cursor: pointer; }\\n\\n.dropDownMenuItemDisabled {\\n  color: #999999;\\n  position: relative;\\n  width: calc(100% - 5px);\\n  height: 23px;\\n  background-color: #FFFFFF;\\n  cursor: pointer; }\\n\\n.dropDownMenuItem:hover {\\n  background-color: #E7EEF6; }\\n\\n.dropDownMenuCheckbox:hover {\\n  background-color: #E7EEF6; }\\n\\n.textBox {\\n  font-size: 15px;\\n  background-color: #000;\\n  opacity: 0.6;\\n  padding: 2px 10px;\\n  border-radius: 2px;\\n  position: fixed;\\n  display: none;\\n  font-family: Monospace;\\n  color: #fff;\\n  z-index: 1000; }\\n\\n#colorCode {\\n  position: absolute;\\n  left: 0px;\\n  top: 0px; }\\n\\n#text, #steeringWheel {\\n  position: absolute;\\n  left: 0px;\\n  top: 0px;\\n  z-index: 900; }\\n\\n.homeViewWrapper {\\n  display: block;\\n  outline: none;\\n  margin: 18px 0px 0px -20px;\\n  opacity: 0.7;\\n  width: 24px;\\n  height: 24px;\\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAYtJREFUeNrslTFrwkAUx98Vh0DOTfwC+QYuZiihVOmQJZi5LiltJic/gkuWujhdoaHQzu1WaCUdnHQxkP2+gZtBRaGvSwLXcDHaYgulDx5cjnf/3733cncEEeGQdgQHtoMDSumAEFIU2wKARjIOAOAJAKCwxIgIO/TBtixrGIbhIgzDhWVZQwCwxfV5vgvANk3zJYqiJeccOecYRdEyhRQBSkU7bzabl57nGaqqKumkqqpKr9c73mw274QQQMTHwh7kiff7/RNRXIR4nmes1+utEJKWJ9Nk2zCMi8FgcEopVbalGMfxqtPpvI1Go1sZRAawdV13GGONInER4rpuMB6P/Swkew5a+4oDAFBKFcZYQ9d1hxDSysvArNVqru/7Z+VyWfnKoZrP5yvHcV6n0ylDxOcs4HoymVxVKhUqW6xp2oP4zTk/l8XNZrO4Xq/fIGI3W6Jqnrhg7cRzLdGoyn7TQNO0rbsrMiHLQAa4S/z+O5cbIrb/1nX9c++BrNnZ+T1jPh+0/x78GuBjAFsN4U22Zd1EAAAAAElFTkSuQmCC);\\n  cursor: pointer;\\n  pointer-events: auto; }\\n\\n.homeViewWrapper:hover {\\n  opacity: 1; }\\n\\n.homeViewWrapper.no-viewcube {\\n  position: absolute;\\n  right: 12px;\\n  top: 10px;\\n  margin: 0; }\\n\\n.homeViewMenu {\\n  display: none;\\n  position: absolute;\\n  right: 10px;\\n  top: 28px;\\n  background-color: #FFFFFF;\\n  border: 1px solid #979797;\\n  z-index: 1; }\\n\\n.homeViewMenuItem {\\n  padding: 5px 20px;\\n  font-family: sans-serif;\\n  font-size: 14px;\\n  cursor: pointer;\\n  z-index: 2; }\\n\\n.homeViewMenuItem:hover {\\n  background-color: #E7EEF6; }\\n\\n.homeViewWrapper .homeViewMenuHandle {\\n  display: none;\\n  position: relative;\\n  left: 18px;\\n  top: 18px; }\\n\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpoEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;A","sourceRoot":""}